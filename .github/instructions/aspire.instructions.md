<SYSTEM>This is the full developer documentation for Aspire</SYSTEM>

# Aspire

> Your stack, streamlined. <p>Orchestrate front ends, APIs, containers, and databases effortlessly—no rewrites, no limits. Extend Aspire to power any project.</p>

##### Free and open source

Aspire is a developer-first, always-free, open-source platform. Join a thriving community and help shape the future of modern development.

## Why developers choose Aspire

[Section titled “Why developers choose Aspire”](#why-developers-choose-aspire)

### [Code-centric control](#define-your-stack-in-code)

Define your stack in code—type-safe and readable. Run locally, deploy anywhere without architectural changes.

### [Modular and extensible](#explore-integrations)

Orchestrate front ends, APIs, containers, and databases with zero rewrites. Extend Aspire to fit your stack—deploy anywhere.

### [Observability from the start](#opentelemetry-developer-dashboard)

Built-in OpenTelemetry delivers logs, traces, and health checks automatically—debug faster with zero setup.

### [Flexible deployments](#local-first-production-ready)

Deploy anywhere—Kubernetes, cloud, or on-prem. Aspire adapts to your environment for consistent deployments without rewrites.

## Define your stack in code

[Section titled “Define your stack in code”](#define-your-stack-in-code)

Aspire is modular, composable, and extensible. Configure relationships, deployment options, and dev-time flags in one place. [Learn more about the `AppHost`](/get-started/app-host/).

### Build your AppHost

Toggle different features on/off to see how Aspire defines different parts of your stack.

Front end   Database   API service   Container   Deployment options

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// This would be a rather boring AppHost ☹️...
// Toggle the options above to see what an AppHost might look like.
// For example, select "Front end" to add a frontend service.


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT");


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT");


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT");


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT");


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj");


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj");


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres);


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres);


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

<!-- Non-frontend variants -->

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj");


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj");


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata");


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres);


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add frontend service
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .PublishAsAzureContainerApp();


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api)
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .PublishAsAzureContainerApp();


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api)
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres)
    .WaitFor(postgres)
    .PublishAsAzureContainerApp();


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api)
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres)
    .WaitFor(postgres)
    .PublishAsAzureContainerApp();


// Add frontend service and reference the API
var frontend = builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api)
    .WithNpmPackageInstallation()
    .PublishAsDockerFile();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

<!-- Non-frontend deployment variants -->

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .PublishAsAzureContainerApp();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add API service
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .PublishAsAzureContainerApp();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres)
    .WaitFor(postgres)
    .PublishAsAzureContainerApp();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database
var postgres = builder.AddAzurePostgresFlexibleServer("db")
    .AddDatabase("appdata")
    .WithDataVolume()
    .RunAsContainer();


// Add API service and reference the database
var api = builder.AddProject("api", "../api/ApiService.csproj")
    .WithReference(postgres)
    .WaitFor(postgres)
    .PublishAsAzureContainerApp();


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add custom container
var customContainer = builder.AddContainer("mycustomcontainer", "myregistry/myapp", "latest")
    .WithHttpEndpoint(targetPort: 8080)
    .PublishAsKubernetes();


builder.Build().Run();
```

## Polyglot, multilanguage support

[Section titled “Polyglot, multilanguage support”](#polyglot-multilanguage-support)

**Built for your stack**, Aspire orchestrates apps in C#, Java, Python, JavaScript, TypeScript, Go, and more—use the languages you prefer. [Explore how to model your apps](/get-started/resources/).

[![](/_astro/go.Bxxui8tm_1dalL.svg) Go ](</integrations/gallery/?search=golang gofeature> "Explore Go integrations")[![](/_astro/python.HT_z5JOp_1dalL.svg) Python ](/integrations/gallery/?search=python "Explore Python integrations")[![](/_astro/javascript.BtpOR5m6_1dalL.svg) JavaScript ](</integrations/gallery/?search=javascript nodejs> "Explore JavaScript integrations")[![](/_astro/typescript.C9-blvjE_1dalL.svg) TypeScript ](</integrations/gallery/?search=javascript nodejs> "Explore TypeScript integrations")[![](/_astro/java.B9Whfg8T_1dalL.svg) Java ](/integrations/gallery/?search=java "Explore Java integrations")[![](/_astro/csharp.bEYMnWDV_1dalL.svg) C# ](/integrations/gallery/?search= "Explore C# integrations")[ And more...](/integrations/gallery/?search= "Explore more integrations integrations")

## Local-first, production-ready

[Section titled “Local-first, production-ready”](#local-first-production-ready)

**Built for local development**, Aspire mirrors production environments on your machine, eliminating “works on my machine” issues for smooth deployments. [Learn about pipelines and app topology](/get-started/pipelines/).

Local  Test  Prod

Local development with containerized services

Spin up and tear down complete staging environments for testing

Production cloud services—zero code changes

```bash
aspire run
```

```bash
aspire deploy -e test
```

```bash
aspire deploy
```

Redis

AWS ElastiCache

Redis

Shortlived container

Redis

Local container

PostgreSQL

Azure Database for PostgreSQL

PostgreSQL

Staged DB

PostgreSQL

Local container

Frontend

Azure Static Web Apps

Frontend

Dev tunnel

Frontend

Local process

API

Azure Container Apps

API

Staging environment

API

Local process

## Same model, different environments

[Section titled “Same model, different environments”](#same-model-different-environments)

Use Aspire’s CLI to spin everything up locally or create deployment artifacts during your CI/CD. [Dive in, and build your first Aspire app](/get-started/first-app/).

[ Local development](/reference/cli/commands/aspire-run/)

```bash
aspire run
```

[* Runs with your local container runtime* Dashboard available on `localhost`* Uses dev secrets, volumes, dev-time config](/reference/cli/commands/aspire-run/)

[ Production deployment](/reference/cli/commands/aspire-deploy/)

```bash
aspire deploy
```

[* Same app structure, deployed where you want* Use managed cloud services or your own infra* Integrates with CI/CD pipelines seamlessly](/reference/cli/commands/aspire-deploy/)

## OpenTelemetry developer dashboard

[Section titled “OpenTelemetry developer dashboard”](#opentelemetry-developer-dashboard)

**Monitor logs, metrics, and traces** in real time with the ready-to-use OpenTelemetry dashboard, integrated directly into your workflow. [Explore the Aspire dashboard](/dashboard/overview/).

[]()   Pause video

## Explore integrations

[Section titled “Explore integrations”](#explore-integrations)

**Multi-cloud, limitless integrations** — Connect Aspire to Azure, AWS, or your own infrastructure. Tap into a vast ecosystem of integrations to power any stack, anywhere. [Explore the integration gallery](/integrations/gallery/).

<!-- Row 1: Right to Left -->

[![Dapr](/_astro/dapr-icon.MGF9MsE6_2aVLdq.webp) ![Dapr](/_astro/dapr-light-icon.ELr6tnVg_ZwcAPp.webp) ](/integrations/gallery/?search=dapr "Explore Dapr integrations")[![Azure Key Vault](/_astro/azure-keyvault-icon.1ZBAx6bH_Z2oCTia.webp) ](/integrations/gallery/?search=keyvault "Explore Azure Key Vault integrations")[![Ollama](/_astro/ollama-icon.4z_rvyfm_iRpLi.webp) ](/integrations/gallery/?search=ollama "Explore Ollama integrations")[![Azure App Services](/_astro/azure-app-services.B0FFn4fq_Z16Po59.svg) ](/integrations/gallery/?search=appservice "Explore Azure App Services integrations")[![Seq Log Server](/_astro/seq-icon.DTfU7WN9_ZNOCXN.webp) ](/integrations/gallery/?search=seq "Explore Seq Log Server integrations")[![JavaScript](/_astro/javascript.BtpOR5m6_ZqVd3r.svg) ](/integrations/gallery/?search=javascript "Explore JavaScript integrations")[![MCP Inspector](/_astro/mcp-inspector-icon.DQeLMEV7_FY77a.webp) ![MCP Inspector](/_astro/mcp-inspector-light-icon.rjkjwwTI_2pwQ59.webp) ](/integrations/gallery/?search=mcpinspector "Explore MCP Inspector integrations")[![Node.js](/_astro/nodejs-icon.KKaryUxz_2sOSGC.webp) ![Node.js](/_astro/nodejs-light-icon.CKqeM1Fh_Z1OWBE8.webp) ](/integrations/gallery/?search=nodejs "Explore Node.js integrations")[![RavenDB](/_astro/ravendb-icon.BflXREOW_ZVux2J.webp) ![RavenDB](/_astro/ravendb-light-icon.DbGb21sS_n3za8.webp) ](/integrations/gallery/?search=ravendb "Explore RavenDB integrations")[![Azure Database for PostgreSQL](/_astro/azure-postgresql-icon.BMlm1jYK_ZqHmBn.webp) ](/integrations/gallery/?search=postgresql "Explore Azure Database for PostgreSQL integrations")[![Azure Table Storage](/_astro/azure-table-icon.pXm7NAMI_1v9Mbf.webp) ](/integrations/gallery/?search=table "Explore Azure Table Storage integrations")[![Azure OpenAI](/_astro/azure-openai-icon.DONb5yBE_2mf48d.webp) ](/integrations/gallery/?search=openai "Explore Azure OpenAI integrations")[![Azure Blob/Page Storage](/_astro/azure-blobpagestorage-icon.tYa7DQ3n_Z1AvfXW.webp) ](/integrations/gallery/?search=blob "Explore Azure Blob\&#x2F;Page Storage integrations")[![Azure Function Apps](/_astro/azure-functionapps-icon.C0faWE2U_kkmkD.webp) ](/integrations/gallery/?search=functions "Explore Azure Function Apps integrations")[![React](/_astro/react-icon.BghDNlos_Z1cy2hv.svg) ](/integrations/gallery/?search=nodejs "Explore React integrations")[![Qdrant Vector Database](/_astro/qdrant-icon.wEc8LmZK_ZDK0v.svg) ](/integrations/gallery/?search=qdrant "Explore Qdrant Vector Database integrations")[![PowerShell](/_astro/powershell-icon.B0QrE_7N_ZSTkKe.webp) ](/integrations/gallery/?search=powershell "Explore PowerShell integrations")[![Milvus Vector Database](/_astro/milvus-icon.QcNRKvVY_2pt2fz.webp) ](/integrations/gallery/?search=milvus "Explore Milvus Vector Database integrations")[![Data API Builder](/_astro/data-api-builder-icon.DhVUjYqn_Z1Y8zUC.webp) ](/integrations/gallery/?search=dataapibuilder "Explore Data API Builder integrations")[![Bun](/_astro/bun-icon.DvKtlocW_Z2r7PJF.webp) ](/integrations/gallery/?search=bun "Explore Bun integrations")[![Azure Cognitive Search](/_astro/azure-search-icon.DfNUAH0j_3AIS9.webp) ](/integrations/gallery/?search=search "Explore Azure Cognitive Search integrations")[![Azure Cosmos DB](/_astro/azure-cosmosdb-icon.4tqzZo4Z_3Ja9d.webp) ](/integrations/gallery/?search=cosmos "Explore Azure Cosmos DB integrations")[![k6](/_astro/k6-icon.DPd0lzLv_Z1E9CxU.svg) ](/integrations/gallery/?search=k6 "Explore k6 integrations")[![AWS](/_astro/aws-icon.CvC2PfNY_IFCNU.webp) ![AWS](/_astro/aws-light-icon.U6rA_yMZ_HSKeq.webp) ](/integrations/gallery/?search=aws "Explore AWS integrations")[![Meilisearch](/_astro/meilisearch-icon.CR2umVYU_2jz77T.webp) ](/integrations/gallery/?search=meilisearch "Explore Meilisearch integrations")[![Oracle](/_astro/oracle-icon.CmqMr237_1Qbvgq.svg) ](/integrations/gallery/?search=oracle "Explore Oracle integrations")[![Azure AI Foundry](/_astro/azure-ai-foundry-icon.0G-oiuDs_ZxdwjP.webp) ](/integrations/gallery/?search=aifoundry "Explore Azure AI Foundry integrations")[![Dapr](/_astro/dapr-icon.MGF9MsE6_2aVLdq.webp) ![Dapr](/_astro/dapr-light-icon.ELr6tnVg_ZwcAPp.webp) ](/integrations/gallery/?search=dapr "Explore Dapr integrations")[![Azure Key Vault](/_astro/azure-keyvault-icon.1ZBAx6bH_Z2oCTia.webp) ](/integrations/gallery/?search=keyvault "Explore Azure Key Vault integrations")[![Ollama](/_astro/ollama-icon.4z_rvyfm_iRpLi.webp) ](/integrations/gallery/?search=ollama "Explore Ollama integrations")[![Azure App Services](/_astro/azure-app-services.B0FFn4fq_Z16Po59.svg) ](/integrations/gallery/?search=appservice "Explore Azure App Services integrations")[![Seq Log Server](/_astro/seq-icon.DTfU7WN9_ZNOCXN.webp) ](/integrations/gallery/?search=seq "Explore Seq Log Server integrations")[![JavaScript](/_astro/javascript.BtpOR5m6_ZqVd3r.svg) ](/integrations/gallery/?search=javascript "Explore JavaScript integrations")[![MCP Inspector](/_astro/mcp-inspector-icon.DQeLMEV7_FY77a.webp) ![MCP Inspector](/_astro/mcp-inspector-light-icon.rjkjwwTI_2pwQ59.webp) ](/integrations/gallery/?search=mcpinspector "Explore MCP Inspector integrations")[![Node.js](/_astro/nodejs-icon.KKaryUxz_2sOSGC.webp) ![Node.js](/_astro/nodejs-light-icon.CKqeM1Fh_Z1OWBE8.webp) ](/integrations/gallery/?search=nodejs "Explore Node.js integrations")[![RavenDB](/_astro/ravendb-icon.BflXREOW_ZVux2J.webp) ![RavenDB](/_astro/ravendb-light-icon.DbGb21sS_n3za8.webp) ](/integrations/gallery/?search=ravendb "Explore RavenDB integrations")[![Azure Database for PostgreSQL](/_astro/azure-postgresql-icon.BMlm1jYK_ZqHmBn.webp) ](/integrations/gallery/?search=postgresql "Explore Azure Database for PostgreSQL integrations")[![Azure Table Storage](/_astro/azure-table-icon.pXm7NAMI_1v9Mbf.webp) ](/integrations/gallery/?search=table "Explore Azure Table Storage integrations")[![Azure OpenAI](/_astro/azure-openai-icon.DONb5yBE_2mf48d.webp) ](/integrations/gallery/?search=openai "Explore Azure OpenAI integrations")[![Azure Blob/Page Storage](/_astro/azure-blobpagestorage-icon.tYa7DQ3n_Z1AvfXW.webp) ](/integrations/gallery/?search=blob "Explore Azure Blob\&#x2F;Page Storage integrations")[![Azure Function Apps](/_astro/azure-functionapps-icon.C0faWE2U_kkmkD.webp) ](/integrations/gallery/?search=functions "Explore Azure Function Apps integrations")[![React](/_astro/react-icon.BghDNlos_Z1cy2hv.svg) ](/integrations/gallery/?search=nodejs "Explore React integrations")[![Qdrant Vector Database](/_astro/qdrant-icon.wEc8LmZK_ZDK0v.svg) ](/integrations/gallery/?search=qdrant "Explore Qdrant Vector Database integrations")[![PowerShell](/_astro/powershell-icon.B0QrE_7N_ZSTkKe.webp) ](/integrations/gallery/?search=powershell "Explore PowerShell integrations")[![Milvus Vector Database](/_astro/milvus-icon.QcNRKvVY_2pt2fz.webp) ](/integrations/gallery/?search=milvus "Explore Milvus Vector Database integrations")[![Data API Builder](/_astro/data-api-builder-icon.DhVUjYqn_Z1Y8zUC.webp) ](/integrations/gallery/?search=dataapibuilder "Explore Data API Builder integrations")[![Bun](/_astro/bun-icon.DvKtlocW_Z2r7PJF.webp) ](/integrations/gallery/?search=bun "Explore Bun integrations")[![Azure Cognitive Search](/_astro/azure-search-icon.DfNUAH0j_3AIS9.webp) ](/integrations/gallery/?search=search "Explore Azure Cognitive Search integrations")[![Azure Cosmos DB](/_astro/azure-cosmosdb-icon.4tqzZo4Z_3Ja9d.webp) ](/integrations/gallery/?search=cosmos "Explore Azure Cosmos DB integrations")[![k6](/_astro/k6-icon.DPd0lzLv_Z1E9CxU.svg) ](/integrations/gallery/?search=k6 "Explore k6 integrations")[![AWS](/_astro/aws-icon.CvC2PfNY_IFCNU.webp) ![AWS](/_astro/aws-light-icon.U6rA_yMZ_HSKeq.webp) ](/integrations/gallery/?search=aws "Explore AWS integrations")[![Meilisearch](/_astro/meilisearch-icon.CR2umVYU_2jz77T.webp) ](/integrations/gallery/?search=meilisearch "Explore Meilisearch integrations")[![Oracle](/_astro/oracle-icon.CmqMr237_1Qbvgq.svg) ](/integrations/gallery/?search=oracle "Explore Oracle integrations")[![Azure AI Foundry](/_astro/azure-ai-foundry-icon.0G-oiuDs_ZxdwjP.webp)](/integrations/gallery/?search=aifoundry "Explore Azure AI Foundry integrations")

<!-- Row 2: Left to Right -->

[![Kubernetes](/_astro/kubernetes.C_WJle_s_2gX2jT.svg) ](/integrations/gallery/?search=kubernetes "Explore Kubernetes integrations")[![MongoDB](/_astro/mongodb-icon.KisFuM9l_Z1rFLEy.webp) ](/integrations/gallery/?search=mongodb "Explore MongoDB integrations")[![.NET MAUI](/_astro/maui-icon.oIIgefok_ZfsSNl.webp) ](/integrations/gallery/?search=maui "Explore .NET MAUI integrations")[![GitHub](/_astro/github-icon.Byy9PfGk_Z1WQGSj.webp) ![GitHub](/_astro/github-light-icon.7mgvdsQN_ZQFdqH.webp) ](/integrations/gallery/?search=github "Explore GitHub integrations")[![Azure SignalR](/_astro/azure-signalr-icon.D9MOb89K_Z1OQfuz.webp) ](/integrations/gallery/?search=signalr "Explore Azure SignalR integrations")[![Keycloak](/_astro/keycloak-icon.DX4K8To8_N1GSw.svg) ](/integrations/gallery/?search=keycloak "Explore Keycloak integrations")[![Papercut](/_astro/papercut-icon.B8rcj8wM_1iIkd9.webp) ![Papercut](/_astro/papercut-light-icon.Bf8JCLde_Ky021.webp) ](/integrations/gallery/?search=papercut "Explore Papercut integrations")[![FastAPI](/_astro/fastapi-icon.D8bDqXMx_Z2vFsTt.svg) ](/integrations/gallery/?search=python "Explore FastAPI integrations")[![Azure Service Bus](/_astro/azure-servicebus-icon.DHL-Rg8b_bGWk2.webp) ](/integrations/gallery/?search=servicebus "Explore Azure Service Bus integrations")[![Azure Storage Queue](/_astro/azure-storagequeue-icon.CaHewY1O_Z1Fx0A6.webp) ](/integrations/gallery/?search=queue "Explore Azure Storage Queue integrations")[![DbGate](/_astro/dbgate-icon.BYOhW4_J_1fPTS5.svg) ![DbGate](/_astro/dbgate-light-icon.D-DLXL4p_1fPTS5.svg) ](/integrations/gallery/?search=dbgate "Explore DbGate integrations")[![Uv](/_astro/uv-icon.DHB-AWwX_1BQasg.svg) ](/integrations/gallery/?search=python "Explore Uv integrations")[![Garnet](/_astro/garnet-icon.C0u592g4_2sHaMr.webp) ](/integrations/gallery/?search=garnet "Explore Garnet integrations")[![MinIO](/_astro/minio-icon.AQf9ocD3_15R9tp.webp) ](/integrations/gallery/?search=minio "Explore MinIO integrations")[![Azure Cache for Redis](/_astro/azure-cacheredis-icon.BPM2--yb_Y1u2e.webp) ](/integrations/gallery/?search=redis "Explore Azure Cache for Redis integrations")[![OpenAI](/_astro/openai-icon.gefPjpNr_ZbKiuN.webp) ![OpenAI](/_astro/openai-light-icon.DDa3Da58_Z1raq4r.webp) ](/integrations/gallery/?search=openai "Explore OpenAI integrations")[![LavinMQ](/_astro/lavinmq-icon.D9qf9hFl_6QF57.webp) ](/integrations/gallery/?search=lavinmq "Explore LavinMQ integrations")[![ngrok](/_astro/ngrok-icon.BOnAsKMX_18Ugza.webp) ![ngrok](/_astro/ngrok-light-icon.DmpiVpvN_Z1lGpSV.webp) ](/integrations/gallery/?search=ngrok "Explore ngrok integrations")[![SQLite](/_astro/sqlite-icon.5bKv4aj0_djhLH.webp) ](/integrations/gallery/?search=sqlite "Explore SQLite integrations")[![RabbitMQ](/_astro/rabbitmq-icon.D4S9ajGZ_Z1ufcBS.svg) ](/integrations/gallery/?search=rabbitmq "Explore RabbitMQ integrations")[![TypeScript](/_astro/typescript.C9-blvjE_ZqVd3r.svg) ](/integrations/gallery/?search=typescript "Explore TypeScript integrations")[![Java](/_astro/java-icon.R5ekku_P_Z2vbJkh.webp) ](/integrations/gallery/?search=java "Explore Java integrations")[![Azure SQL Server](/_astro/azure-sqlserver-icon.Cqcoy_ug_2ja87h.webp) ](/integrations/gallery/?search=sql "Explore Azure SQL Server integrations")[![Azure Storage Container](/_astro/azure-storagecontainer-icon.BHpAHDcw_Z2kkxgS.webp) ](/integrations/gallery/?search=storage "Explore Azure Storage Container integrations")[![Dev Tunnels](/_astro/dev-tunnels-icon.Bn_RqgUr_Z1zSK6o.svg) ](/integrations/gallery/?search=devtunnels "Explore Dev Tunnels integrations")[![SurrealDB](/_astro/surrealdb-icon.CLbq5g3b_ZPznj5.webp) ![SurrealDB](/_astro/surrealdb-light-icon.MWAgJ8-j_Z2nuKgP.webp) ](/integrations/gallery/?search=surrealdb "Explore SurrealDB integrations")[![MySQL Connector](/_astro/mysqlconnector-icon.De_epwTX_ZoFn7k.webp) ](/integrations/gallery/?search=mysql "Explore MySQL Connector integrations")[![Kubernetes](/_astro/kubernetes.C_WJle_s_2gX2jT.svg) ](/integrations/gallery/?search=kubernetes "Explore Kubernetes integrations")[![MongoDB](/_astro/mongodb-icon.KisFuM9l_Z1rFLEy.webp) ](/integrations/gallery/?search=mongodb "Explore MongoDB integrations")[![.NET MAUI](/_astro/maui-icon.oIIgefok_ZfsSNl.webp) ](/integrations/gallery/?search=maui "Explore .NET MAUI integrations")[![GitHub](/_astro/github-icon.Byy9PfGk_Z1WQGSj.webp) ![GitHub](/_astro/github-light-icon.7mgvdsQN_ZQFdqH.webp) ](/integrations/gallery/?search=github "Explore GitHub integrations")[![Azure SignalR](/_astro/azure-signalr-icon.D9MOb89K_Z1OQfuz.webp) ](/integrations/gallery/?search=signalr "Explore Azure SignalR integrations")[![Keycloak](/_astro/keycloak-icon.DX4K8To8_N1GSw.svg) ](/integrations/gallery/?search=keycloak "Explore Keycloak integrations")[![Papercut](/_astro/papercut-icon.B8rcj8wM_1iIkd9.webp) ![Papercut](/_astro/papercut-light-icon.Bf8JCLde_Ky021.webp) ](/integrations/gallery/?search=papercut "Explore Papercut integrations")[![FastAPI](/_astro/fastapi-icon.D8bDqXMx_Z2vFsTt.svg) ](/integrations/gallery/?search=python "Explore FastAPI integrations")[![Azure Service Bus](/_astro/azure-servicebus-icon.DHL-Rg8b_bGWk2.webp) ](/integrations/gallery/?search=servicebus "Explore Azure Service Bus integrations")[![Azure Storage Queue](/_astro/azure-storagequeue-icon.CaHewY1O_Z1Fx0A6.webp) ](/integrations/gallery/?search=queue "Explore Azure Storage Queue integrations")[![DbGate](/_astro/dbgate-icon.BYOhW4_J_1fPTS5.svg) ![DbGate](/_astro/dbgate-light-icon.D-DLXL4p_1fPTS5.svg) ](/integrations/gallery/?search=dbgate "Explore DbGate integrations")[![Uv](/_astro/uv-icon.DHB-AWwX_1BQasg.svg) ](/integrations/gallery/?search=python "Explore Uv integrations")[![Garnet](/_astro/garnet-icon.C0u592g4_2sHaMr.webp) ](/integrations/gallery/?search=garnet "Explore Garnet integrations")[![MinIO](/_astro/minio-icon.AQf9ocD3_15R9tp.webp) ](/integrations/gallery/?search=minio "Explore MinIO integrations")[![Azure Cache for Redis](/_astro/azure-cacheredis-icon.BPM2--yb_Y1u2e.webp) ](/integrations/gallery/?search=redis "Explore Azure Cache for Redis integrations")[![OpenAI](/_astro/openai-icon.gefPjpNr_ZbKiuN.webp) ![OpenAI](/_astro/openai-light-icon.DDa3Da58_Z1raq4r.webp) ](/integrations/gallery/?search=openai "Explore OpenAI integrations")[![LavinMQ](/_astro/lavinmq-icon.D9qf9hFl_6QF57.webp) ](/integrations/gallery/?search=lavinmq "Explore LavinMQ integrations")[![ngrok](/_astro/ngrok-icon.BOnAsKMX_18Ugza.webp) ![ngrok](/_astro/ngrok-light-icon.DmpiVpvN_Z1lGpSV.webp) ](/integrations/gallery/?search=ngrok "Explore ngrok integrations")[![SQLite](/_astro/sqlite-icon.5bKv4aj0_djhLH.webp) ](/integrations/gallery/?search=sqlite "Explore SQLite integrations")[![RabbitMQ](/_astro/rabbitmq-icon.D4S9ajGZ_Z1ufcBS.svg) ](/integrations/gallery/?search=rabbitmq "Explore RabbitMQ integrations")[![TypeScript](/_astro/typescript.C9-blvjE_ZqVd3r.svg) ](/integrations/gallery/?search=typescript "Explore TypeScript integrations")[![Java](/_astro/java-icon.R5ekku_P_Z2vbJkh.webp) ](/integrations/gallery/?search=java "Explore Java integrations")[![Azure SQL Server](/_astro/azure-sqlserver-icon.Cqcoy_ug_2ja87h.webp) ](/integrations/gallery/?search=sql "Explore Azure SQL Server integrations")[![Azure Storage Container](/_astro/azure-storagecontainer-icon.BHpAHDcw_Z2kkxgS.webp) ](/integrations/gallery/?search=storage "Explore Azure Storage Container integrations")[![Dev Tunnels](/_astro/dev-tunnels-icon.Bn_RqgUr_Z1zSK6o.svg) ](/integrations/gallery/?search=devtunnels "Explore Dev Tunnels integrations")[![SurrealDB](/_astro/surrealdb-icon.CLbq5g3b_ZPznj5.webp) ![SurrealDB](/_astro/surrealdb-light-icon.MWAgJ8-j_Z2nuKgP.webp) ](/integrations/gallery/?search=surrealdb "Explore SurrealDB integrations")[![MySQL Connector](/_astro/mysqlconnector-icon.De_epwTX_ZoFn7k.webp)](/integrations/gallery/?search=mysql "Explore MySQL Connector integrations")

<!-- Row 3: Right to Left -->

[![KurrentDB](/_astro/kurrent-icon.DqAKa12N_2a6rl4.webp) ![KurrentDB](/_astro/kurrent-light-icon.D13VPSBq_rcOdM.webp) ](/integrations/gallery/?search=kurrentdb "Explore KurrentDB integrations")[![Azure Web PubSub](/_astro/azure-webpubsub-icon.BXTJxxmO_1bcwh0.webp) ](/integrations/gallery/?search=pubsub "Explore Azure Web PubSub integrations")[![Docker](/_astro/docker.CnL-arqo_4GkmT.svg) ](/integrations/gallery/?search=docker "Explore Docker integrations")[![Azure Event Hubs](/_astro/azure-eventhubs-icon.8SLmUE2W_Z2eS2ng.webp) ](/integrations/gallery/?search=eventhubs "Explore Azure Event Hubs integrations")[![Azure Log Analytics](/_astro/azure-loganalytics-icon.B3ZB_iQQ_2azs7d.webp) ](/integrations/gallery/?search=operationalinsights "Explore Azure Log Analytics integrations")[![Microsoft Azure](/_astro/azure-icon.Be9vXxEg_2qTdxK.webp) ](/integrations/gallery/?search=azure "Explore Microsoft Azure integrations")[![Go](/_astro/go-icon.BtjqguRP_Z2uHijN.webp) ![Go](/_astro/go-light-icon.CrPrQ3fH_Z1yeRD5.webp) ](/integrations/gallery/?search=golang%20gofeature "Explore Go integrations")[![NATS Messaging](/_astro/nats-icon.D9qyPulo_ZhlBbT.webp) ](/integrations/gallery/?search=nats "Explore NATS Messaging integrations")[![Azure App Configuration](/_astro/azure-appconfig-icon.CzIz3ORB_Semkp.webp) ](/integrations/gallery/?search=appconfig "Explore Azure App Configuration integrations")[![flagd](/_astro/flagd-icon.BEqgEdwX_1yRKim.svg) ![flagd](/_astro/flagd-light-icon.Dix_nwxQ_1yRKim.svg) ](/integrations/gallery/?search=flagd "Explore flagd integrations")[![PostgreSQL](/_astro/postgresql-icon.DTORe-rE_Z13dczk.webp) ](/integrations/gallery/?search=postgresql "Explore PostgreSQL integrations")[![Elasticsearch](/_astro/elastic-icon.C7IAv20j_MNO57.webp) ](/integrations/gallery/?search=elasticsearch "Explore Elasticsearch integrations")[![SQL Database Projects](/_astro/sql-database-projects-icon.XFCfircj_7gM8X.webp) ](/integrations/gallery/?search=sqlprojects "Explore SQL Database Projects integrations")[![Adminer](/_astro/adminer-icon.2oEl7n76_1PItH2.webp) ](/integrations/gallery/?search=adminer "Explore Adminer integrations")[![Redis](/_astro/redis-icon.CxKuuAy2_201wWE.webp) ](/integrations/gallery/?search=redis "Explore Redis integrations")[![SQL Database](/_astro/sql-icon.CyVgV5Qd_Z143gof.webp) ](/integrations/gallery/?search=sql "Explore SQL Database integrations")[![Python](/_astro/python.HT_z5JOp_ZqVd3r.svg) ](/integrations/gallery/?search=python "Explore Python integrations")[![ActiveMQ](/_astro/activemq-icon.BAGN0GK8_OwWjv.webp) ![ActiveMQ](/_astro/activemq-light-icon.BOyxsb5v_Z29wngD.webp) ](/integrations/gallery/?search=activemq "Explore ActiveMQ integrations")[![Rust](/_astro/rust-icon.Dbc7QCHB_pxFKP.webp) ](/integrations/gallery/?search=rust "Explore Rust integrations")[![Azure Application Insights](/_astro/azure-appinsights-icon.zXXLd062_Zoouc6.webp) ](/integrations/gallery/?search=applicationinsights "Explore Azure Application Insights integrations")[![Deno](/_astro/deno-icon.BlzooUTA_Z2mOBgz.webp) ![Deno](/_astro/deno-light-icon.BCKIGHbu_ZK019o.webp) ](/integrations/gallery/?search=deno "Explore Deno integrations")[![Azure Container Apps Environments](/_astro/azure-container-apps-environments.Cxfx93EZ_Z16Po59.svg) ](/integrations/gallery/?search=container%20apps "Explore Azure Container Apps Environments integrations")[![GO Feature Flag](/_astro/go-feature-flag.UXez91CJ_Z1yIab7.webp) ](/integrations/gallery/?search=golang%20feature-flags "Explore GO Feature Flag integrations")[![Mailpit](/_astro/mailpit-icon.DNy-ogcL_1KbSOR.svg) ![Mailpit](/_astro/mailpit-light-icon.iFb6G2JZ_1KbSOR.svg) ](/integrations/gallery/?search=mailpit "Explore Mailpit integrations")[![Valkey](/_astro/valkey-icon.BdkvDMZ6_1hw2RV.webp) ](/integrations/gallery/?search=valkey "Explore Valkey integrations")[![KurrentDB](/_astro/kurrent-icon.DqAKa12N_2a6rl4.webp) ![KurrentDB](/_astro/kurrent-light-icon.D13VPSBq_rcOdM.webp) ](/integrations/gallery/?search=kurrentdb "Explore KurrentDB integrations")[![Azure Web PubSub](/_astro/azure-webpubsub-icon.BXTJxxmO_1bcwh0.webp) ](/integrations/gallery/?search=pubsub "Explore Azure Web PubSub integrations")[![Docker](/_astro/docker.CnL-arqo_4GkmT.svg) ](/integrations/gallery/?search=docker "Explore Docker integrations")[![Azure Event Hubs](/_astro/azure-eventhubs-icon.8SLmUE2W_Z2eS2ng.webp) ](/integrations/gallery/?search=eventhubs "Explore Azure Event Hubs integrations")[![Azure Log Analytics](/_astro/azure-loganalytics-icon.B3ZB_iQQ_2azs7d.webp) ](/integrations/gallery/?search=operationalinsights "Explore Azure Log Analytics integrations")[![Microsoft Azure](/_astro/azure-icon.Be9vXxEg_2qTdxK.webp) ](/integrations/gallery/?search=azure "Explore Microsoft Azure integrations")[![Go](/_astro/go-icon.BtjqguRP_Z2uHijN.webp) ![Go](/_astro/go-light-icon.CrPrQ3fH_Z1yeRD5.webp) ](/integrations/gallery/?search=golang%20gofeature "Explore Go integrations")[![NATS Messaging](/_astro/nats-icon.D9qyPulo_ZhlBbT.webp) ](/integrations/gallery/?search=nats "Explore NATS Messaging integrations")[![Azure App Configuration](/_astro/azure-appconfig-icon.CzIz3ORB_Semkp.webp) ](/integrations/gallery/?search=appconfig "Explore Azure App Configuration integrations")[![flagd](/_astro/flagd-icon.BEqgEdwX_1yRKim.svg) ![flagd](/_astro/flagd-light-icon.Dix_nwxQ_1yRKim.svg) ](/integrations/gallery/?search=flagd "Explore flagd integrations")[![PostgreSQL](/_astro/postgresql-icon.DTORe-rE_Z13dczk.webp) ](/integrations/gallery/?search=postgresql "Explore PostgreSQL integrations")[![Elasticsearch](/_astro/elastic-icon.C7IAv20j_MNO57.webp) ](/integrations/gallery/?search=elasticsearch "Explore Elasticsearch integrations")[![SQL Database Projects](/_astro/sql-database-projects-icon.XFCfircj_7gM8X.webp) ](/integrations/gallery/?search=sqlprojects "Explore SQL Database Projects integrations")[![Adminer](/_astro/adminer-icon.2oEl7n76_1PItH2.webp) ](/integrations/gallery/?search=adminer "Explore Adminer integrations")[![Redis](/_astro/redis-icon.CxKuuAy2_201wWE.webp) ](/integrations/gallery/?search=redis "Explore Redis integrations")[![SQL Database](/_astro/sql-icon.CyVgV5Qd_Z143gof.webp) ](/integrations/gallery/?search=sql "Explore SQL Database integrations")[![Python](/_astro/python.HT_z5JOp_ZqVd3r.svg) ](/integrations/gallery/?search=python "Explore Python integrations")[![ActiveMQ](/_astro/activemq-icon.BAGN0GK8_OwWjv.webp) ![ActiveMQ](/_astro/activemq-light-icon.BOyxsb5v_Z29wngD.webp) ](/integrations/gallery/?search=activemq "Explore ActiveMQ integrations")[![Rust](/_astro/rust-icon.Dbc7QCHB_pxFKP.webp) ](/integrations/gallery/?search=rust "Explore Rust integrations")[![Azure Application Insights](/_astro/azure-appinsights-icon.zXXLd062_Zoouc6.webp) ](/integrations/gallery/?search=applicationinsights "Explore Azure Application Insights integrations")[![Deno](/_astro/deno-icon.BlzooUTA_Z2mOBgz.webp) ![Deno](/_astro/deno-light-icon.BCKIGHbu_ZK019o.webp) ](/integrations/gallery/?search=deno "Explore Deno integrations")[![Azure Container Apps Environments](/_astro/azure-container-apps-environments.Cxfx93EZ_Z16Po59.svg) ](/integrations/gallery/?search=container%20apps "Explore Azure Container Apps Environments integrations")[![GO Feature Flag](/_astro/go-feature-flag.UXez91CJ_Z1yIab7.webp) ](/integrations/gallery/?search=golang%20feature-flags "Explore GO Feature Flag integrations")[![Mailpit](/_astro/mailpit-icon.DNy-ogcL_1KbSOR.svg) ![Mailpit](/_astro/mailpit-light-icon.iFb6G2JZ_1KbSOR.svg) ](/integrations/gallery/?search=mailpit "Explore Mailpit integrations")[![Valkey](/_astro/valkey-icon.BdkvDMZ6_1hw2RV.webp)](/integrations/gallery/?search=valkey "Explore Valkey integrations")

## User testimonials

[Section titled “User testimonials”](#user-testimonials)

**Don’t just take our word for it!** From indie hackers to enterprises, developers like you are building faster and shipping with confidence using Aspire. [Explore the community building Aspire](/community/contributors/).

SP

![Steven Price](/_astro/steven-price.DWQ6ydsD_ZYpPqf.webp "Steven Price (Software Engineering Manager, Iceland Foods)")

Aspire lets developers be developers again.

[Steven Price (Software Engineering Manager, Iceland Foods)](https://www.linkedin.com/in/steve-m-price/)

RH

![Russ Harding](/_astro/russ-harding.U2FjyOyA_Z11Tw12.webp "Russ Harding (VP Engineering, EQengineered)")

I had someone start on a Monday morning and they were contributing code by lunch.

[Russ Harding (VP Engineering, EQengineered)](https://www.linkedin.com/in/russharding1/)

NC

![Nick Chapsas](/_astro/nick-chapsas.CcXIHFNc_9KrlQ.webp "Nick Chapsas (Founder & Author, Dometrain)")

The best thing that happened in .NET since it went open source in 2014!

[Nick Chapsas (Founder & Author, Dometrain)](https://dometrain.com/author/nick-chapsas/)

MJ

![Milan Jovanović](/_astro/milan-jovanovic.Czwrk8nx_ZCojUF.webp "Milan Jovanović (Educator & Content Creator, MJ Tech)")

I was surprised by how quickly Aspire got me from idea to running services.

[Milan Jovanović (Educator & Content Creator, MJ Tech)](https://www.milanjovanovic.tech)

NU

![Nk54 (Reddit User)](/_astro/nk54.B9ILi8AF_NhmaA.webp "Nk54 (Reddit User)")

I've never wanted to commit to a Microsoft technology this much.

[Nk54 (Reddit User)](https://www.reddit.com/user/Nk54)

CT

![Craig Taylor](/_astro/craig-taylor.BVQgR7jU_Z1bSkA8.webp "Craig Taylor (Principal Architect, Xbox Live)")

Hit F5 to begin — skip the setup boss fight, ship code faster.

[Craig Taylor (Principal Architect, Xbox Live)](https://www.linkedin.com/in/craig-taylor-2594895/)

SK

![Sean Killeen](/_astro/sean-killeen.DnR5W1LG_Z11Cy71.webp "Sean Killeen (VP Innovation, SCT Software)")

Aspire was easy to integrate with our existing container orchestration.

[Sean Killeen (VP Innovation, SCT Software)](https://www.linkedin.com/in/seankilleen/)

DC

![Dan Clarke](/_astro/dan-clarke.BBqMB07W_ZejoUz.webp "Dan Clarke (Developer & Podcaster, Everstack)")

OpenTelemetry out-of-the-box in the Aspire dashboard is a game changer for observability!

[Dan Clarke (Developer & Podcaster, Everstack)](https://bsky.app/profile/danclarke.com)

## Ready for liftoff?

[Section titled “Ready for liftoff?”](#ready-for-liftoff)

Get started with Aspire by installing the CLI, then dive into the Docs to learn how to model, run, and deploy your applications.

[Get Aspire ](/get-started/install-cli/)Install Aspire and streamline your workflow.

[Explore docs ](/docs/)Learn how to model, run, and deploy apps with Aspire.

# 404

> — This page doesn't exist—or at least, not anymore. Perhaps the route was deprecated...or maybe it never existed at all?

[Go Back](/)

[Go Home](/)

# Certificate configuration

> Learn how to configure HTTPS endpoints and certificate trust for resources in Aspire to enable secure communication.

Aspire provides two complementary sets of certificate APIs:

1. **HTTPS endpoint APIs**: Configure the certificates that resources use for their own HTTPS endpoints (server authentication)
2. **Certificate trust APIs**: Configure which certificates resources trust when making outbound HTTPS connections (client authentication)

Both sets of APIs work together to enable secure HTTPS communication during local development. For example, a Vite frontend might use `WithHttpsDeveloperCertificate` to serve HTTPS traffic, while also using `WithDeveloperCertificateTrust` to trust the dashboard’s OTLP endpoint certificate.

Caution

Certificate customization only applies at run time. Custom certificates aren’t included in publish or deployment artifacts.

### Why HTTPS matters

[Section titled “Why HTTPS matters”](#why-https-matters)

HTTPS is essential for protecting the security and privacy of data transmitted between services. It encrypts traffic to prevent eavesdropping, tampering, and man-in-the-middle attacks. For production environments, HTTPS is a fundamental security requirement.

However, enabling HTTPS during local development to match the production configuration presents unique challenges. Development environments typically use self-signed certificates that browsers and applications don’t trust by default. Managing these certificates across multiple services, containers, and different language runtimes can be complex and time-consuming, often creating friction in the development workflow.

Aspire simplifies HTTPS configuration for local development by providing APIs to:

* Configure HTTPS endpoints with appropriate certificates for server authentication
* Manage certificate trust so resources can communicate with services using self-signed certificates
* Automatically handle the .NET provided ASP.NET Core development certificate (a per-user self-signed certificate valid only for local domains) across different resource types

## HTTPS endpoint configuration

[Section titled “HTTPS endpoint configuration”](#https-endpoint-configuration)

HTTPS endpoint configuration determines which certificate a resource presents when serving HTTPS traffic. This is server-side certificate configuration for resources that host HTTPS/TLS endpoints.

### Default behavior

[Section titled “Default behavior”](#default-behavior)

For resources that have a certificate configuration defined with `WithHttpsCertificateConfiguration`, Aspire attempts to configure it to use the ASP.NET Core development certificate if available. This automatic configuration works for many common resource types including YARP, Redis, and Keycloak containers; Vite based JavaScript apps; and Python apps using Uvicorn.

You can control this behavior using the HTTPS endpoint APIs described below.

### Use the development certificate

[Section titled “Use the development certificate”](#use-the-development-certificate)

To explicitly configure a resource to use the ASP.NET Core development certificate for its HTTPS endpoints:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Explicitly use the developer certificate
var nodeApp = builder.AddViteApp("frontend", "../frontend")
    .WithHttpsDeveloperCertificate();


// Use developer certificate with an encrypted private key
var certPassword = builder.AddParameter("cert-password", secret: true);
var pythonApp = builder.AddUvicornApp("api", "../api", "app:main")
    .WithHttpsDeveloperCertificate(certPassword);


builder.Build().Run();
```

The `WithHttpsDeveloperCertificate` method:

* Configures the resource to use the ASP.NET Core development certificate
* Only applies in run mode (local development)
* Optionally accepts a password parameter for encrypted certificate private keys
* Works with containers, Node.js, Python, and other resource types

### Use a custom certificate

[Section titled “Use a custom certificate”](#use-a-custom-certificate)

To configure a resource to use a specific X.509 certificate for HTTPS endpoints:

AppHost.cs

```csharp
using System.Security.Cryptography.X509Certificates;


var builder = DistributedApplication.CreateBuilder(args);


// Load your certificate
var certificate = new X509Certificate2("path/to/certificate.pfx", "password");


// Use the certificate for HTTPS endpoints
builder.AddContainer("api", "my-api:latest")
    .WithHttpsCertificate(certificate);


// Use certificate with a password parameter
var certPassword = builder.AddParameter("cert-password", secret: true);
builder.AddNpmApp("frontend", "../frontend")
    .WithHttpsCertificate(certificate, certPassword);


builder.Build().Run();
```

The certificate must:

* Include a private key
* Be a valid X.509 certificate
* Be appropriate for server authentication

### Disable HTTPS certificate configuration

[Section titled “Disable HTTPS certificate configuration”](#disable-https-certificate-configuration)

To prevent Aspire from configuring any HTTPS certificate for a resource:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Disable automatic HTTPS certificate configuration
var redis = builder.AddRedis("cache")
    .WithoutHttpsCertificate();


builder.Build().Run();
```

Use `WithoutHttpsCertificate` when:

* The resource doesn’t support HTTPS
* You want to manually configure certificates
* The resource has its own certificate management

### Customize certificate configuration

[Section titled “Customize certificate configuration”](#customize-certificate-configuration)

For resources that need custom certificate configuration logic, use `WithHttpsCertificateConfiguration` to specify how certificate files should be passed to the resource:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("api", "my-api:latest")
    .WithHttpsCertificateConfiguration(ctx =>
    {
        // Pass certificate paths as command line arguments
        ctx.Arguments.Add("--tls-cert");
        ctx.Arguments.Add(ctx.CertificatePath);
        ctx.Arguments.Add("--tls-key");
        ctx.Arguments.Add(ctx.KeyPath);


        // Or set environment variables
        ctx.EnvironmentVariables["TLS_CERT_FILE"] = ctx.CertificatePath;
        ctx.EnvironmentVariables["TLS_KEY_FILE"] = ctx.KeyPath;


        // Use PFX format if the resource requires it
        ctx.EnvironmentVariables["TLS_PFX_FILE"] = ctx.PfxPath;


        // Include password if needed
        if (ctx.Password is not null)
        {
            ctx.EnvironmentVariables["TLS_KEY_PASSWORD"] = ctx.Password;
        }


        return Task.CompletedTask;
    });


builder.Build().Run();
```

The callback receives an `HttpsCertificateConfigurationCallbackAnnotationContext` that provides:

* `CertificatePath`: Path to the certificate file in PEM format
* `KeyPath`: Path to the private key file in PEM format
* `PfxPath`: Path to the certificate in PFX/PKCS#12 format
* `Password`: The password for the private key, if configured
* `Arguments`: Command line arguments list to modify
* `EnvironmentVariables`: Environment variables dictionary to modify
* `ExecutionContext`: The current execution context
* `Resource`: The resource being configured

## Certificate trust configuration

[Section titled “Certificate trust configuration”](#certificate-trust-configuration)

Certificate trust configuration determines which certificates a resource trusts when making outbound HTTPS connections. This is client-side certificate configuration.

### When to use certificate trust

[Section titled “When to use certificate trust”](#when-to-use-certificate-trust)

Certificate trust customization is valuable when:

* Resources need to trust the ASP.NET Core development certificate for local HTTPS communication
* Containerized services must communicate with the dashboard over HTTPS
* Python or Node.js applications need to trust custom certificate authorities
* You’re working with services that have specific certificate trust requirements
* Resources need to establish secure telemetry connections to the Aspire dashboard

### Development certificate trust

[Section titled “Development certificate trust”](#development-certificate-trust)

By default, Aspire attempts to add trust for the ASP.NET Core development certificate to resources that wouldn’t otherwise trust it. This enables resources to communicate with the dashboard OTLP collector endpoint over HTTPS and any other HTTPS endpoints secured by the development certificate.

You can control this behavior per resource using the `WithDeveloperCertificateTrust` API or through AppHost configuration settings.

#### Configure development certificate trust per resource

[Section titled “Configure development certificate trust per resource”](#configure-development-certificate-trust-per-resource)

To explicitly enable or disable development certificate trust for a specific resource:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Explicitly enable development certificate trust
var nodeApp = builder.AddNpmApp("frontend", "../frontend")
    .WithDeveloperCertificateTrust(trust: true);


// Disable development certificate trust
var pythonApp = builder.AddPythonApp("api", "../api", "main.py")
    .WithDeveloperCertificateTrust(trust: false);


builder.Build().Run();
```

### Certificate authority collections

[Section titled “Certificate authority collections”](#certificate-authority-collections)

Certificate authority collections allow you to bundle custom certificates and make them available to resources. You create a collection using the `AddCertificateAuthorityCollection` method and then reference it from resources that need to trust those certificates.

#### Create and use a certificate authority collection

[Section titled “Create and use a certificate authority collection”](#create-and-use-a-certificate-authority-collection)

AppHost.cs

```csharp
using System.Security.Cryptography.X509Certificates;


var builder = DistributedApplication.CreateBuilder(args);


// Load your custom certificates
var certificates = new X509Certificate2Collection();
certificates.ImportFromPemFile("path/to/certificate.pem");


// Create a certificate authority collection
var certBundle = builder.AddCertificateAuthorityCollection("my-bundle")
    .WithCertificates(certificates);


// Apply the certificate bundle to resources
builder.AddNpmApp("my-project", "../myapp")
    .WithCertificateAuthorityCollection(certBundle);


builder.Build().Run();
```

In the preceding example, the certificate bundle is created with custom certificates and then applied to a Node.js application, enabling it to trust those certificates.

### Certificate trust scopes

[Section titled “Certificate trust scopes”](#certificate-trust-scopes)

Certificate trust scopes control how custom certificates interact with a resource’s default trusted certificates. Different scopes provide flexibility in managing certificate trust based on your application’s requirements.

The `WithCertificateTrustScope` API accepts a `CertificateTrustScope` value to specify the trust behavior.

#### Available trust scopes

[Section titled “Available trust scopes”](#available-trust-scopes)

Aspire supports the following certificate trust scopes:

* **Append**: Appends custom certificates to the default trusted certificates
* **Override**: Replaces the default trusted certificates with only the configured certificates
* **System**: Combines custom certificates with system root certificates and uses them to override the defaults
* **None**: Disables all custom certificate trust configuration

#### Append mode

[Section titled “Append mode”](#append-mode)

Attempts to append the configured certificates to the default trusted certificates for a given resource. This mode is useful when you want to add trust for additional certificates while maintaining trust for the system’s default certificates.

This is the default scope for most resources. For Python resources, only OTEL trust configuration will be applied in this mode.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddNodeApp("api", "../api")
    .WithCertificateTrustScope(CertificateTrustScope.Append);


builder.Build().Run();
```

Note

Not all languages and runtimes support Append mode. For example, Python doesn’t natively support appending certificates to the default trust store.

#### Override mode

[Section titled “Override mode”](#override-mode)

Attempts to override a resource to only trust the configured certificates, replacing the default trusted certificates entirely. This mode is useful when you need strict control over which certificates are trusted.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var certBundle = builder.AddCertificateAuthorityCollection("custom-certs")
    .WithCertificates(myCertificates);


builder.AddPythonModule("api", "./api", "uvicorn")
    .WithCertificateAuthorityCollection(certBundle)
    .WithCertificateTrustScope(CertificateTrustScope.Override);


builder.Build().Run();
```

#### System mode

[Section titled “System mode”](#system-mode)

Attempts to combine the configured certificates with the default system root certificates and use them to override the default trusted certificates for a resource. This mode is intended to support Python or other languages that don’t work well with Append mode.

This is the default scope for Python projects because Python only has mechanisms to fully override certificate trust.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddPythonApp("worker", "../worker", "main.py")
    .WithCertificateTrustScope(CertificateTrustScope.System);


builder.Build().Run();
```

#### None mode

[Section titled “None mode”](#none-mode)

Disables all custom certificate trust for the resource, causing it to rely solely on its default certificate trust behavior.

This is the default scope for .NET projects on Windows, as there’s no way to automatically change the default system store source.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("service", "myimage")
    .WithCertificateTrustScope(CertificateTrustScope.None);


builder.Build().Run();
```

### Custom certificate trust configuration

[Section titled “Custom certificate trust configuration”](#custom-certificate-trust-configuration)

For advanced scenarios, you can specify custom certificate trust behavior using a callback API. This callback allows you to customize the command line arguments and environment variables required to configure certificate trust for different resource types.

#### Configure certificate trust with a callback

[Section titled “Configure certificate trust with a callback”](#configure-certificate-trust-with-a-callback)

Use `WithCertificateTrustConfiguration` to customize how certificate trust is configured for a resource:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("api", "myimage")
    .WithCertificateTrustConfiguration(ctx =>
    {
        // Add a command line argument
        ctx.Arguments.Add("--use-system-ca");


        // Set environment variables with certificate paths
        // CertificateBundlePath resolves to the path of the custom certificate bundle file
        ctx.EnvironmentVariables["MY_CUSTOM_CERT_VAR"] = ctx.CertificateBundlePath;


        // CertificateDirectoriesPath resolves to paths containing individual certificates
        ctx.EnvironmentVariables["CERTS_DIR"] = ctx.CertificateDirectoriesPath;


        return Task.CompletedTask;
    });


builder.Build().Run();
```

The callback receives a `CertificateTrustConfigurationCallbackAnnotationContext` that provides:

* `Scope`: The `CertificateTrustScope` for the resource.
* `Arguments`: Command line arguments for the resource. Values can be strings or path providers like `CertificateBundlePath` or `CertificateDirectoriesPath`.
* `EnvironmentVariables`: Environment variables for configuring certificate trust. The dictionary key is the environment variable name; values can be strings or path providers. By default, includes `SSL_CERT_DIR` and may include `SSL_CERT_FILE` if Override or System scope is configured.
* `CertificateBundlePath`: A value provider that resolves to the path of a custom certificate bundle file.
* `CertificateDirectoriesPath`: A value provider that resolves to paths containing individual certificates.

Default implementations are provided for Node.js, Python, and container resources. Container resources rely on standard OpenSSL configuration options, with default values that support the majority of common Linux distributions.

#### Configure container certificate paths

[Section titled “Configure container certificate paths”](#configure-container-certificate-paths)

For container resources, you can customize where certificates are stored and accessed using `WithContainerCertificatePaths`:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("api", "myimage")
    .WithContainerCertificatePaths(
        customCertificatesDestination: "/custom/certs/path",
        defaultCertificateBundlePaths: ["/etc/ssl/certs/ca-certificates.crt"],
        defaultCertificateDirectoryPaths: ["/etc/ssl/certs"]);


builder.Build().Run();
```

The `WithContainerCertificatePaths` API accepts three optional parameters:

* `customCertificatesDestination`: Overrides the base path in the container where custom certificate files are placed. If not set or set to `null`, the default path of `/usr/lib/ssl/aspire` is used.
* `defaultCertificateBundlePaths`: Overrides the path(s) in the container where a default certificate authority bundle file is located. When the `CertificateTrustScope` is Override or System, the custom certificate bundle is additionally written to these paths. If not set or set to `null`, a set of default certificate paths for common Linux distributions is used.
* `defaultCertificateDirectoryPaths`: Overrides the path(s) in the container where individual trusted certificate files are found. When the `CertificateTrustScope` is Append, these paths are concatenated with the path to the uploaded certificate artifacts. If not set or set to `null`, a set of default certificate paths for common Linux distributions is used.

Note

All desired paths must be configured in a single call to `WithContainerCertificatePaths` as only the most recent call to the API is honored.

## Common scenarios

[Section titled “Common scenarios”](#common-scenarios)

This section demonstrates common patterns for configuring HTTPS endpoints and certificate trust together.

### Configure a service with HTTPS and enable dashboard telemetry

[Section titled “Configure a service with HTTPS and enable dashboard telemetry”](#configure-a-service-with-https-and-enable-dashboard-telemetry)

A typical scenario is configuring a Node.js service to serve HTTPS traffic while also enabling it to send telemetry to the dashboard:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Configure the service to use developer certificate for HTTPS endpoints
// and trust the developer certificate for outbound connections (like dashboard telemetry)
var frontend = builder.AddNpmApp("frontend", "../frontend")
    .WithHttpsDeveloperCertificate()      // Server cert for HTTPS endpoints
    .WithDeveloperCertificateTrust(true); // Client trust for dashboard


builder.Build().Run();
```

### Enable HTTPS with custom certificates

[Section titled “Enable HTTPS with custom certificates”](#enable-https-with-custom-certificates)

When working with corporate or custom CA certificates, you can configure both server and client certificates:

AppHost.cs

```csharp
using System.Security.Cryptography.X509Certificates;


var builder = DistributedApplication.CreateBuilder(args);


// Load custom certificates
var serverCert = new X509Certificate2("server-cert.pfx", "password");
var customCA = new X509Certificate2Collection();
customCA.Import("corporate-ca.pem");


var caBundle = builder.AddCertificateAuthorityCollection("corporate-certs")
    .WithCertificates(customCA);


// Configure service with custom server cert and CA trust
builder.AddContainer("api", "my-api:latest")
    .WithHttpsCertificate(serverCert)           // Server cert for HTTPS
    .WithCertificateAuthorityCollection(caBundle); // Trust corporate CA


builder.Build().Run();
```

### Configure Redis with TLS

[Section titled “Configure Redis with TLS”](#configure-redis-with-tls)

Redis resources can be configured to use HTTPS (TLS) for secure connections:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Configure Redis to use the developer certificate for TLS
var redis = builder.AddRedis("cache")
    .WithHttpsDeveloperCertificate();


// Or disable TLS entirely
var redisNoTls = builder.AddRedis("cache-notls")
    .WithoutHttpsCertificate();


builder.Build().Run();
```

### Disable certificate configuration for specific resources

[Section titled “Disable certificate configuration for specific resources”](#disable-certificate-configuration-for-specific-resources)

To disable both HTTPS endpoint configuration and certificate trust for a resource that manages its own certificates:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Disable all automatic certificate configuration
builder.AddPythonModule("api", "./api", "uvicorn")
    .WithoutHttpsCertificate()                    // No server cert config
    .WithCertificateTrustScope(CertificateTrustScope.None); // No client trust config


builder.Build().Run();
```

## Limitations

[Section titled “Limitations”](#limitations)

Certificate configuration has the following limitations:

* Currently supported only in run mode, not in publish mode
* Not all languages and runtimes support all trust scope modes
* Python applications don’t natively support Append mode for certificate trust
* Custom certificate configuration requires appropriate runtime support within the resource
* HTTPS endpoint APIs are marked as experimental (`ASPIRECERTIFICATES001`)

# AppHost configuration

> Learn about the Aspire AppHost configuration options.

The AppHost project configures and starts your distributed application. When a `DistributedApplication` runs it reads configuration from the AppHost. Configuration is loaded from environment variables that are set on the AppHost and `DistributedApplicationOptions`. Configuration includes:

* Settings for hosting the resource service, such as the address and authentication options.
* Settings used to start the [Aspire dashboard](/dashboard/overview/), such the dashboard’s frontend and OpenTelemetry Protocol (OTLP) addresses.
* Internal settings that Aspire uses to run the AppHost. These are set internally but can be accessed by integrations that extend Aspire.

AppHost configuration is provided by the AppHost launch profile. The AppHost has a launch settings file call *launchSettings.json* which has a list of launch profiles. Each launch profile is a collection of related options which defines how you would like `dotnet` to start your application.

launchSettings.json

```json
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:17134;http://localhost:15170",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21030",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22057"
      }
    }
  }
}
```

The preceding launch settings file:

* Has one launch profile named `https`.

* Configures an Aspire AppHost project:

  * The `applicationUrl` property configures the dashboard launch address (`ASPNETCORE_URLS`).
  * Environment variables such as `ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL` and `ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL` are set on the AppHost.

For more information, see [Launch profiles](/fundamentals/launch-profiles/).

Note

Configuration described on this page is for the Aspire AppHost project. To configure the standalone dashboard, see [dashboard configuration](/dashboard/configuration/).

## Common configuration

[Section titled “Common configuration”](#common-configuration)

| Option                             | Default value | Description                                                                                                                                                                                                      |
| ---------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ASPIRE_ALLOW_UNSECURED_TRANSPORT` | `false`       | Allows communication with the AppHost without https. `ASPNETCORE_URLS` (dashboard address) and `ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL` (AppHost resource service address) must be secured with HTTPS unless true. |
| `ASPIRE_CONTAINER_RUNTIME`         | `docker`      | Allows the user of alternative container runtimes for resources backed by containers. Possible values are `docker` (default) or `podman`.                                                                        |
| `ASPIRE_VERSION_CHECK_DISABLED`    | `false`       | When set to `true`, Aspire doesn’t check for newer versions on startup.                                                                                                                                          |

## Version update notifications

[Section titled “Version update notifications”](#version-update-notifications)

When an Aspire app starts, it checks if a newer version of Aspire is available on NuGet. If a new version is found, a notification appears in the dashboard with the latest version number, [a link to upgrade instructions](https://aka.ms/dotnet/aspire/update-latest), and button to ignore that version in the future.

![Screenshot of dashboard showing a version update notification with upgrade options.](/_astro/dashboard-update-notification.CbuDufvf_Z2mm2cn.webp)

The version check runs only when:

* The dashboard is enabled (interaction service is available).
* At least 2 days have passed since the last check.
* The check hasn’t been disabled via the `ASPIRE_VERSION_CHECK_DISABLED` configuration setting.
* The app is not running in publish mode.

Updates are manual. You need to edit your project file to upgrade the Aspire SDK and package versions.

## Resource service

[Section titled “Resource service”](#resource-service)

A resource service is hosted by the AppHost. The resource service is used by the dashboard to fetch information about resources which are being orchestrated by Aspire.

| Option                                    | Default value                                  | Description                                                                                                                                                                                                                                                                            |
| ----------------------------------------- | ---------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL`    | `null`                                         | Configures the address of the resource service hosted by the AppHost. Automatically generated with *launchSettings.json* to have a random port on localhost. For example, `https://localhost:17037`.                                                                                   |
| `ASPIRE_DASHBOARD_RESOURCESERVICE_APIKEY` | Automatically generated 128-bit entropy token. | The API key used to authenticate requests made to the AppHost’s resource service. The API key is required if the AppHost is in run mode, the dashboard isn’t disabled, and the dashboard isn’t configured to allow anonymous access with `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS`. |

## Dashboard

[Section titled “Dashboard”](#dashboard)

By default, the dashboard is automatically started by the AppHost. The dashboard supports [its own set of configuration](/dashboard/configuration/), and some settings can be configured from the AppHost.

| Option                                      | Default value                                               | Description                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ASPNETCORE_URLS`                           | `null`                                                      | Dashboard address. Must be `https` unless `ASPIRE_ALLOW_UNSECURED_TRANSPORT` or `DistributedApplicationOptions.AllowUnsecuredTransport` is true. Automatically generated with *launchSettings.json* to have a random port on localhost. The value in launch settings is set on the `applicationUrls` property. |
| `ASPNETCORE_ENVIRONMENT`                    | `Production`                                                | Configures the environment the dashboard runs as. For more information, see [Use multiple environments in ASP.NET Core](https://learn.microsoft.com/aspnet/core/fundamentals/environments).                                                                                                                    |
| `ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL`        | `http://localhost:18889` if no gRPC endpoint is configured. | Configures the dashboard OTLP gRPC address. Used by the dashboard to receive telemetry over OTLP. Set on resources as the `OTEL_EXPORTER_OTLP_ENDPOINT` env var. The `OTEL_EXPORTER_OTLP_PROTOCOL` env var is `grpc`. Automatically generated with *launchSettings.json* to have a random port on localhost.   |
| `ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL`   | `null`                                                      | Configures the dashboard OTLP HTTP address. Used by the dashboard to receive telemetry over OTLP. If only `ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL` is configured then it is set on resources as the `OTEL_EXPORTER_OTLP_ENDPOINT` env var. The `OTEL_EXPORTER_OTLP_PROTOCOL` env var is `http/protobuf`.      |
| `ASPIRE_DASHBOARD_CORS_ALLOWED_ORIGINS`     | `null`                                                      | Overrides the CORS allowed origins configured in the dashboard. This setting replaces the default behavior of calculating allowed origins based on resource endpoints.                                                                                                                                         |
| `ASPIRE_DASHBOARD_FRONTEND_BROWSERTOKEN`    | Automatically generated 128-bit entropy token.              | Configures the frontend browser token. This is the value that must be entered to access the dashboard when the auth mode is BrowserToken. If no browser token is specified then a new token is generated each time the AppHost is launched.                                                                    |
| `ASPIRE_DASHBOARD_TELEMETRY_OPTOUT`         | `false`                                                     | Configures the dashboard to never send [usage telemetry](/dashboard/microsoft-collected-dashboard-telemetry/).                                                                                                                                                                                                 |
| `ASPIRE_DASHBOARD_AI_DISABLED`              | `false`                                                     | [GitHub Copilot in the dashboard](/dashboard/copilot/) is available when the AppHost is launched by a supported IDE. When set to `true` Copilot is disabled in the dashboard and no Copilot UI is visible.                                                                                                     |
| `ASPIRE_DASHBOARD_FORWARDEDHEADERS_ENABLED` | `false`                                                     | Enables the Forwarded headers middleware that replaces the scheme and host values on the Request context with the values coming from the `X-Forwarded-Proto` and `X-Forwarded-Host` headers.                                                                                                                   |

## Internal

[Section titled “Internal”](#internal)

Internal settings are used by the AppHost and integrations. Internal settings aren’t designed to be configured directly.

| Option                             | Default value                                                                                                           | Description                                                                                                                                                                                                                                                                                                                                                                              |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `AppHost:Directory`                | The content root if there’s no project.                                                                                 | Directory of the project where the AppHost is located. Accessible from the `IDistributedApplicationBuilder.AppHostDirectory`.                                                                                                                                                                                                                                                            |
| `AppHost:Path`                     | The directory combined with the application name.                                                                       | The path to the AppHost. It combines the directory with the application name.                                                                                                                                                                                                                                                                                                            |
| `AppHost:Sha256`                   | It is created from the AppHost name when the AppHost is in publish mode. Otherwise it is created from the AppHost path. | Hex encoded hash for the current application. The hash is based on the location of the app on the current machine so it is stable between launches of the AppHost.                                                                                                                                                                                                                       |
| `AppHost:OtlpApiKey`               | Automatically generated 128-bit entropy token.                                                                          | The API key used to authenticate requests sent to the dashboard OTLP service. The value is present if needed: the AppHost is in run mode, the dashboard isn’t disabled, and the dashboard isn’t configured to allow anonymous access with `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS`.                                                                                                  |
| `AppHost:BrowserToken`             | Automatically generated 128-bit entropy token.                                                                          | The browser token used to authenticate browsing to the dashboard when it is launched by the AppHost. The browser token can be set by `ASPIRE_DASHBOARD_FRONTEND_BROWSERTOKEN`. The value is present if needed: the AppHost is in run mode, the dashboard isn’t disabled, and the dashboard isn’t configured to allow anonymous access with `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS`. |
| `AppHost:ResourceService:AuthMode` | `ApiKey`. If `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS` is true then the value is `Unsecured`.                        | The authentication mode used to access the resource service. The value is present if needed: the AppHost is in run mode and the dashboard isn’t disabled.                                                                                                                                                                                                                                |
| `AppHost:ResourceService:ApiKey`   | Automatically generated 128-bit entropy token.                                                                          | The API key used to authenticate requests made to the AppHost’s resource service. The API key can be set by `ASPIRE_DASHBOARD_RESOURCESERVICE_APIKEY`. The value is present if needed: the AppHost is in run mode, the dashboard isn’t disabled, and the dashboard isn’t configured to allow anonymous access with `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS`.                         |

## Advanced orchestration properties

[Section titled “Advanced orchestration properties”](#advanced-orchestration-properties)

Caution

The following MSBuild properties and command-line arguments are intended for internal use by the Aspire SDK and tooling. You should not need to set these manually under normal circumstances. Incorrectly configuring these values can break your AppHost.

### DcpCliPath

[Section titled “DcpCliPath”](#dcpclipath)

The `DcpCliPath` property specifies the path to the **Developer Control Plane (DCP)** executable. The DCP is the core orchestration engine that Aspire uses to run and manage distributed application resources locally during development.

#### How it works

[Section titled “How it works”](#how-it-works)

When you use the [Aspire SDK](/get-started/aspire-sdk/), the build system automatically:

1. Imports the platform-specific `Aspire.Hosting.Orchestration` NuGet package (for example, `Aspire.Hosting.Orchestration.win-x64`).
2. Sets `DcpCliPath` to point to the `dcp` executable within that package.
3. Embeds this path as assembly metadata in your compiled AppHost.

At runtime, the AppHost reads this metadata to locate and start the DCP process, which then orchestrates your application’s resources.

#### Override options

[Section titled “Override options”](#override-options)

In rare cases, you may need to override the default DCP path:

| Method                | Example                                       |
| --------------------- | --------------------------------------------- |
| MSBuild property      | `<DcpCliPath>C:\path\to\dcp.exe</DcpCliPath>` |
| Command-line argument | `--dcp-cli-path /path/to/dcp`                 |
| Configuration         | `DcpPublisher:CliPath`                        |

#### When to use

[Section titled “When to use”](#when-to-use)

You might override `DcpCliPath` in these scenarios:

* **Aspire contributors**: Testing with a custom or debug build of DCP when developing Aspire itself.
* **CI/CD pipelines**: Non-standard SDK layouts where automatic discovery doesn’t work.
* **Troubleshooting**: Temporarily pointing to a specific DCP version to diagnose issues.

Tip

If your AppHost fails to start with an error about missing DCP or orchestration dependencies, ensure you have the [Aspire SDK](/get-started/aspire-sdk/) properly configured rather than manually setting `DcpCliPath`.

# Docker Compose to Aspire AppHost

> Quick reference for converting Docker Compose YAML syntax to Aspire C# API calls.

This reference provides systematic mappings from Docker Compose YAML syntax to equivalent Aspire C# API calls. Use these tables as a quick reference when converting your existing Docker Compose files to Aspire application host configurations.

## Service definitions

[Section titled “Service definitions”](#service-definitions)

| Docker Compose  | Aspire                                                     | Notes                                                               |
| --------------- | ---------------------------------------------------------- | ------------------------------------------------------------------- |
| `services:`     | `var builder = DistributedApplication.CreateBuilder(args)` | Root application builder used for adding and representing resources |
| `service_name:` | `builder.Add*("service_name")`                             | Service name becomes resource name                                  |

Learn more about [Docker Compose services](https://docs.docker.com/compose/compose-file/05-services/).

## Images and builds

[Section titled “Images and builds”](#images-and-builds)

| Docker Compose                        | Aspire                                                     | Notes                    |
| ------------------------------------- | ---------------------------------------------------------- | ------------------------ |
| `image: nginx:latest`                 | `builder.AddContainer("name", "nginx", "latest")`          | Direct image reference   |
| `build: .`                            | `builder.AddDockerfile("name", ".")`                       | Build from Dockerfile    |
| `build: ./path`                       | `builder.AddDockerfile("name", "./path")`                  | Build from specific path |
| `build.context: ./app`                | `builder.AddDockerfile("name", "./app")`                   | Build context            |
| `build.dockerfile: Custom.dockerfile` | `builder.Add*("name").WithDockerfile("Custom.dockerfile")` | Custom Dockerfile name   |

Learn more about [Docker Compose build reference](https://docs.docker.com/compose/compose-file/build/) and [WithDockerfile](/app-host/withdockerfile/).

## .NET projects

[Section titled “.NET projects”](#net-projects)

| Docker Compose              | Aspire                                        | Notes                         |
| --------------------------- | --------------------------------------------- | ----------------------------- |
| `build: ./MyApi` (for .NET) | `builder.AddProject<Projects.MyApi>("myapi")` | Direct .NET project reference |

Learn more about [adding .NET projects](/get-started/app-host/).

## Port mappings

[Section titled “Port mappings”](#port-mappings)

| Docker Compose       | Aspire                                           | Notes                                                                         |
| -------------------- | ------------------------------------------------ | ----------------------------------------------------------------------------- |
| `ports: ["8080:80"]` | `.WithHttpEndpoint(port: 8080, targetPort: 80)`  | HTTP endpoint mapping. Ports are optional; dynamic ports are used if omitted  |
| `ports: ["443:443"]` | `.WithHttpsEndpoint(port: 443, targetPort: 443)` | HTTPS endpoint mapping. Ports are optional; dynamic ports are used if omitted |
| `expose: ["8080"]`   | `.WithEndpoint(port: 8080)`                      | Internal port exposure. Ports are optional; dynamic ports are used if omitted |

Learn more about [Docker Compose ports](https://docs.docker.com/compose/compose-file/05-services/#ports) and [endpoint configuration](/fundamentals/networking-overview/).

## Environment variables

[Section titled “Environment variables”](#environment-variables)

| Docker Compose                 | Aspire / Notes                                                                                                          |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| `environment: KEY=value`       | `.WithEnvironment("KEY", "value")` Static environment variable                                                          |
| `environment: KEY=${HOST_VAR}` | `.WithEnvironment(context => context.EnvironmentVariables["KEY"] = hostVar)` Environment variable with callback context |
| `env_file: .env`               | `.ConfigureEnvFile(env => { ... })` Environment file generation (available in 13.1+)                                    |

Learn more about [Docker Compose environment](https://docs.docker.com/compose/compose-file/05-services/#environment) and [external parameters](/fundamentals/external-parameters/).

## Volumes and storage

[Section titled “Volumes and storage”](#volumes-and-storage)

| Docker Compose                   | Aspire                                                 | Notes                |
| -------------------------------- | ------------------------------------------------------ | -------------------- |
| `volumes: ["data:/app/data"]`    | `.WithVolume("data", "/app/data")`                     | Named volume         |
| `volumes: ["./host:/container"]` | `.WithBindMount("./host", "/container")`               | Bind mount           |
| `volumes: ["./config:/app:ro"]`  | `.WithBindMount("./config", "/app", isReadOnly: true)` | Read-only bind mount |

Learn more about [Docker Compose volumes](https://docs.docker.com/compose/compose-file/05-services/#volumes) and [persist container data](/fundamentals/persist-data-volumes/).

## Dependencies and ordering

[Section titled “Dependencies and ordering”](#dependencies-and-ordering)

| Docker Compose                               | Aspire                   | Notes                                               |
| -------------------------------------------- | ------------------------ | --------------------------------------------------- |
| `depends_on: [db]`                           | `.WithReference(db)`     | Service dependency with connection string injection |
| `depends_on: db: condition: service_started` | `.WaitFor(db)`           | Wait for service start                              |
| `depends_on: db: condition: service_healthy` | `.WaitForCompletion(db)` | Wait for health check to pass                       |

Learn more about [Docker Compose depends\_on](https://docs.docker.com/compose/compose-file/05-services/#depends_on) and [launch profiles](/fundamentals/launch-profiles/).

## Networks

[Section titled “Networks”](#networks)

| Docker Compose        | Aspire     | Notes                                                 |
| --------------------- | ---------- | ----------------------------------------------------- |
| `networks: [backend]` | Automatic  | Aspire handles networking automatically               |
| Custom networks       | Not needed | Service discovery handles inter-service communication |

Learn more about [Docker Compose networks](https://docs.docker.com/compose/compose-file/05-services/#networks) and [service discovery](/fundamentals/service-discovery/).

## Resource limits

[Section titled “Resource limits”](#resource-limits)

| Docker Compose                         | Aspire        | Notes                                      |
| -------------------------------------- | ------------- | ------------------------------------------ |
| `deploy.resources.limits.memory: 512m` | Not supported | Resource limits aren’t supported in Aspire |
| `deploy.resources.limits.cpus: 0.5`    | Not supported | Resource limits aren’t supported in Aspire |

Learn more about [Docker Compose deploy reference](https://docs.docker.com/compose/compose-file/deploy/).

## Health checks

[Section titled “Health checks”](#health-checks)

| Docker Compose                                                 | Aspire                      | Notes                                              |
| -------------------------------------------------------------- | --------------------------- | -------------------------------------------------- |
| `healthcheck.test: ["CMD", "curl", "http://localhost/health"]` | Built-in for integrations   | Aspire integrations include health checks          |
| `healthcheck.interval: 30s`                                    | Configurable in integration | Health check configuration varies by resource type |

Learn more about [Docker Compose healthcheck](https://docs.docker.com/compose/compose-file/05-services/#healthcheck) and [health checks](/fundamentals/health-checks/).

## Restart policies

[Section titled “Restart policies”](#restart-policies)

| Docker Compose            | Aspire        | Notes                                       |
| ------------------------- | ------------- | ------------------------------------------- |
| `restart: unless-stopped` | Not supported | Restart policies aren’t supported in Aspire |
| `restart: always`         | Not supported | Restart policies aren’t supported in Aspire |
| `restart: no`             | Default       | No restart policy                           |

Learn more about [Docker Compose restart](https://docs.docker.com/compose/compose-file/05-services/#restart).

## Logging

[Section titled “Logging”](#logging)

| Docker Compose                  | Aspire                  | Notes                              |
| ------------------------------- | ----------------------- | ---------------------------------- |
| `logging.driver: json-file`     | Built-in                | Aspire provides integrated logging |
| `logging.options.max-size: 10m` | Dashboard configuration | Managed through Aspire dashboard   |

Learn more about [Docker Compose logging](https://docs.docker.com/compose/compose-file/05-services/#logging) and [telemetry](/fundamentals/telemetry/).

## Database services

[Section titled “Database services”](#database-services)

| Docker Compose        | Aspire                        | Notes                                   |
| --------------------- | ----------------------------- | --------------------------------------- |
| `image: postgres:15`  | `builder.AddPostgres("name")` | PostgreSQL with automatic configuration |
| `image: mysql:8`      | `builder.AddMySql("name")`    | MySQL with automatic configuration      |
| `image: redis:7`      | `builder.AddRedis("name")`    | Redis with automatic configuration      |
| `image: mongo:latest` | `builder.AddMongoDB("name")`  | MongoDB with automatic configuration    |

Learn more about [Docker Compose services](https://docs.docker.com/compose/compose-file/05-services/) and [database integrations](/integrations/gallery/?search=database).

## See also

[Section titled “See also”](#see-also)

* [Migrate from Docker Compose to Aspire](/app-host/migrate-from-docker-compose/)
* [AppHost overview](/get-started/app-host/)
* [WithDockerfile](/app-host/withdockerfile/)

# AppHost eventing APIs

> Learn how to use the Aspire AppHost eventing features.

In Aspire, eventing allows you to publish and subscribe to events during various AppHost life cycles. Eventing is more flexible than life cycle events. Both let you run arbitrary code during event callbacks, but eventing offers finer control of event timing, publishing, and provides supports for custom events.

The eventing mechanisms in Aspire are part of the [📦 Aspire.Hosting](https://www.nuget.org/packages/Aspire.Hosting) NuGet package. This package provides a set of interfaces and classes in the `Aspire.Hosting.Eventing` namespace that you use to publish and subscribe to events in your Aspire AppHost project. Eventing is scoped to the AppHost itself and the resources within.

In this article, you learn how to use the eventing features in Aspire.

## AppHost eventing

[Section titled “AppHost eventing”](#apphost-eventing)

The following events are available in the AppHost and occur in the following order:

1. `BeforeStartEvent`: This event is raised before the AppHost starts.
2. `ResourceEndpointsAllocatedEvent`: This event is raised per resource after its endpoints are allocated.
3. `AfterResourcesCreatedEvent`: This event is raised after the AppHost created resources.

### Subscribe to AppHost events

[Section titled “Subscribe to AppHost events”](#subscribe-to-apphost-events)

To subscribe to the built-in AppHost events, use the eventing API. After you have a distributed application builder instance, walk up to the `IDistributedApplicationBuilder.Eventing` property and call the `Subscribe` API. Consider the following sample AppHost *AppHost.cs* file:

AppHost.cs

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;


var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice");


builder.AddProject<Projects.AspireApp_Web>("webfrontend")
    .WithExternalHttpEndpoints()
    .WithReference(cache)
    .WaitFor(cache)
    .WithReference(apiService)
    .WaitFor(apiService);


builder.Eventing.Subscribe<ResourceEndpointsAllocatedEvent>(
    static (@event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("2. \"{ResourceName}\" ResourceEndpointsAllocatedEvent", @event.Resource.Name);
        return Task.CompletedTask;
    });


builder.Eventing.Subscribe<BeforeStartEvent>(
    static (@event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("1. BeforeStartEvent");


        return Task.CompletedTask;
    });


builder.Eventing.Subscribe<AfterResourcesCreatedEvent>(
    static (@event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("3. AfterResourcesCreatedEvent");


        return Task.CompletedTask;
    });


builder.Build().Run();
```

The preceding code is based on the starter template with the addition of the calls to the `Subscribe` API. The `Subscribe<T>` API returns a `DistributedApplicationEventSubscription` instance that you can use to unsubscribe from the event. It’s common to discard the returned subscriptions, as you don’t usually need to unsubscribe from events as the entire app is torn down when the AppHost is shut down.

When the AppHost is run, by the time the Aspire dashboard is displayed, you should see the following log output in the console:

```plaintext
info: Program[0]
      1. BeforeStartEvent
info: Aspire.Hosting.DistributedApplication[0]
      Aspire version: 13.1.0
info: Aspire.Hosting.DistributedApplication[0]
      Distributed application starting.
info: Aspire.Hosting.DistributedApplication[0]
      Application host directory is: ../AspireApp/AspireApp.AppHost
info: Program[0]
      2. "cache" ResourceEndpointsAllocatedEvent
info: Program[0]
      2. "apiservice" ResourceEndpointsAllocatedEvent
info: Program[0]
      2. "webfrontend" ResourceEndpointsAllocatedEvent
info: Program[0]
      2. "aspire-dashboard" ResourceEndpointsAllocatedEvent
info: Aspire.Hosting.DistributedApplication[0]
      Now listening on: https://localhost:17178
info: Aspire.Hosting.DistributedApplication[0]
      Login to the dashboard at https://localhost:17178/login?t=<YOUR_TOKEN>
info: Program[0]
      3. AfterResourcesCreatedEvent
info: Aspire.Hosting.DistributedApplication[0]
      Distributed application started. Press Ctrl+C to shut down.
```

The log output confirms that event handlers are executed in the order of the AppHost life cycle events. The subscription order doesn’t affect execution order. The `BeforeStartEvent` is triggered first, followed by each resource’s `ResourceEndpointsAllocatedEvent`, and finally `AfterResourcesCreatedEvent`.

## Resource eventing

[Section titled “Resource eventing”](#resource-eventing)

In addition to the AppHost events, you can also subscribe to resource events. Resource events are raised specific to an individual resource. Resource events are defined as implementations of the `IDistributedApplicationResourceEvent` interface. The following resource events are available in the listed order:

1. `InitializeResourceEvent`: Raised by orchestrators to signal to resources that they should initialize themselves.
2. `ResourceEndpointsAllocatedEvent`: Raised when the orchestrator allocates endpoints for a resource.
3. `ConnectionStringAvailableEvent`: Raised when a connection string becomes available for a resource.
4. `BeforeResourceStartedEvent`: Raised before the orchestrator starts a new resource.
5. `ResourceReadyEvent`: Raised when a resource initially transitions to a ready state.

### Subscribe to resource events

[Section titled “Subscribe to resource events”](#subscribe-to-resource-events)

To subscribe to resource events, use the convenience-based extension methods—`On*`. After you have a distributed application builder instance, and a resource builder, walk up to the instance and chain a call to the desired `On*` event API. Consider the following sample *AppHost.cs* file:

AppHost.cs

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;


var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


cache.OnResourceReady(static (resource, @event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("5. OnResourceReady");


        return Task.CompletedTask;
    });


cache.OnInitializeResource(
    static (resource, @event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("1. OnInitializeResource");


        return Task.CompletedTask;
    });


cache.OnBeforeResourceStarted(
    static (resource, @event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("4. OnBeforeResourceStarted");




        return Task.CompletedTask;
    });


cache.OnResourceEndpointsAllocated(
    static (resource, @event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("2. OnResourceEndpointsAllocated");


        return Task.CompletedTask;
    });


cache.OnConnectionStringAvailable(
    static (resource, @event, cancellationToken) =>
    {
        var logger = @event.Services.GetRequiredService<ILogger<Program>>();
        logger.LogInformation("3. OnConnectionStringAvailable");


        return Task.CompletedTask;
    });


var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice");


builder.AddProject<Projects.AspireApp_Web>("webfrontend")
    .WithExternalHttpEndpoints()
    .WithReference(cache)
    .WaitFor(cache)
    .WithReference(apiService)
    .WaitFor(apiService);


builder.Build().Run();
```

The preceding code subscribes to the `InitializeResourceEvent`, `ResourceReadyEvent`, `ResourceEndpointsAllocatedEvent`, `ConnectionStringAvailableEvent`, and `BeforeResourceStartedEvent` events on the `cache` resource. When `AddRedis` is called, it returns an `IResourceBuilder<T>` where `T` is a `RedisResource`. Chain calls to the `On*` methods to subscribe to the events. The `On*` methods return the same `IResourceBuilder<T>` instance, so you can chain multiple calls:

* `OnInitializeResource`: Subscribes to the `InitializeResourceEvent`.
* `OnResourceEndpointsAllocated`: Subscribes to the `ResourceEndpointsAllocatedEvent` event.
* `OnConnectionStringAvailable`: Subscribes to the `ConnectionStringAvailableEvent` event.
* `OnBeforeResourceStarted`: Subscribes to the `BeforeResourceStartedEvent` event.
* `OnResourceReady`: Subscribes to the `ResourceReadyEvent` event.

When the AppHost is run, by the time the Aspire dashboard is displayed, you should see the following log output in the console:

```plaintext
info: Aspire.Hosting.DistributedApplication[0]
      Aspire version: 13.1.0
info: Aspire.Hosting.DistributedApplication[0]
      Distributed application starting.
info: Aspire.Hosting.DistributedApplication[0]
      Application host directory is: ../AspireApp/AspireApp.AppHost
info: Program[0]
      1. OnInitializeResource
info: Program[0]
      2. OnResourceEndpointsAllocated
info: Program[0]
      3. OnConnectionStringAvailable
info: Program[0]
      4. OnBeforeResourceStarted
info: Aspire.Hosting.DistributedApplication[0]
      Now listening on: https://localhost:17222
info: Aspire.Hosting.DistributedApplication[0]
      Login to the dashboard at https://localhost:17222/login?t=<YOUR_TOKEN>
info: Program[0]
      5. OnResourceReady
info: Aspire.Hosting.DistributedApplication[0]
      Distributed application started. Press Ctrl+C to shut down.
```

Note

Some events block execution. For example, when the `BeforeResourceStartedEvent` is published, the resource startup blocks until all subscriptions for that event on a given resource finish executing. Whether an event blocks or not depends on how you publish it (see the following section).

## Publish events

[Section titled “Publish events”](#publish-events)

When subscribing to any of the built-in events, you don’t need to publish the event yourself as the AppHost orchestrator manages to publish built-in events on your behalf. However, you can publish custom events with the eventing API. To publish an event, you have to first define an event as an implementation of either the `IDistributedApplicationEvent` or `IDistributedApplicationResourceEvent` interface. You need to determine which interface to implement based on whether the event is a global AppHost event or a resource-specific event.

Then, you can subscribe and publish the event by calling the either of the following APIs:

* `PublishAsync<T>(T, CancellationToken)`: Publishes an event to all subscribes of the specific event type.
* `PublishAsync<T>(T, EventDispatchBehavior, CancellationToken)`: Publishes an event to all subscribes of the specific event type with a specified dispatch behavior.

### Provide an `EventDispatchBehavior`

[Section titled “Provide an EventDispatchBehavior”](#provide-an-eventdispatchbehavior)

When events are dispatched, you can control how the events are dispatched to subscribers. The event dispatch behavior is specified with the `EventDispatchBehavior` enum. The following behaviors are available:

* `EventDispatchBehavior.BlockingSequential`: Fires events sequentially and blocks until they’re all processed.
* `EventDispatchBehavior.BlockingConcurrent`: Fires events concurrently and blocks until they’re all processed.
* `EventDispatchBehavior.NonBlockingSequential`: Fires events sequentially but doesn’t block.
* `EventDispatchBehavior.NonBlockingConcurrent`: Fires events concurrently but doesn’t block.

The default behavior is `EventDispatchBehavior.BlockingSequential`. To override this behavior, when calling a publishing API such as `PublishAsync`, provide the desired behavior as an argument.

## Eventing subscribers

[Section titled “Eventing subscribers”](#eventing-subscribers)

In some cases, such as extension libraries, you may need to access lifecycle events from a service rather than directly from the Aspire application model. You can implement `IDistributedApplicationEventingSubscriber` and register the service with `AddEventingSubscriber` (or `TryAddEventingSubscriber` if you want to avoid duplicate registrations).

AppHost.cs

```csharp
using Aspire.Hosting.Eventing;
using Aspire.Hosting.Lifecycle;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;


var builder = DistributedApplication.CreateBuilder(args);


builder.Services.AddEventingSubscriber<LifecycleLoggerSubscriber>();


builder.Build().Run();


internal sealed class LifecycleLoggerSubscriber(ILogger<LifecycleLoggerSubscriber> logger)
    : IDistributedApplicationEventingSubscriber
{
    public Task SubscribeAsync(
        IDistributedApplicationEventing eventing,
        DistributedApplicationExecutionContext executionContext,
        CancellationToken cancellationToken)
    {
        eventing.Subscribe<BeforeStartEvent>((@event, ct) =>
        {
            logger.LogInformation("1. BeforeStartEvent");
            return Task.CompletedTask;
        });


        eventing.Subscribe<ResourceEndpointsAllocatedEvent>((@event, ct) =>
        {
            logger.LogInformation("2. {Resource} ResourceEndpointsAllocatedEvent", @event.Resource.Name);
            return Task.CompletedTask;
        });


        eventing.Subscribe<AfterResourcesCreatedEvent>((@event, ct) =>
        {
            logger.LogInformation("3. AfterResourcesCreatedEvent");
            return Task.CompletedTask;
        });


        return Task.CompletedTask;
    }
}
```

The subscriber approach keeps builder code minimal while still letting you respond to the same lifecycle moments as inline subscriptions:

* `AddEventingSubscriber<T>()` (or `TryAddEventingSubscriber()`) ensures the subscriber participates whenever the AppHost starts.
* `SubscribeAsync` is called once per AppHost execution, giving you access to `IDistributedApplicationEventing` and the `DistributedApplicationExecutionContext` should you need model- or environment-specific data.
* You can register handlers for any built-in event (AppHost or resource) or for your own custom `IDistributedApplicationEvent` types.

Use this pattern whenever you previously relied on `IDistributedApplicationLifecycleHook`. The lifecycle hook APIs remain only for backward compatibility and will be removed in a future release.

# Host external executables in Aspire

> Learn how to use ExecutableResource and AddExecutable to host external executable applications in your Aspire AppHost.

In Aspire, you can host external executable applications alongside your projects using the `AddExecutable` method. This capability is useful when you need to integrate executable applications or tools into your distributed application, such as Node.js applications, Python scripts, or specialized CLI tools.

## When to use executable resources

[Section titled “When to use executable resources”](#when-to-use-executable-resources)

Use executable resources when you need to:

* Host non-.NET applications that don’t have containerized equivalents.
* Integrate command-line tools or utilities into your application.
* Run external processes that other resources depend on.
* Develop with tools that provide local development servers.

Common examples include:

* **Frontend development servers**: Tools like [Vercel CLI](https://vercel.com/docs/cli) or webpack dev server.
* **Language-specific applications**: Node.js apps, Python scripts, or Go applications.
* **Database tools**: Migration utilities or database seeders.
* **Build tools**: Asset processors or code generators.

## Basic usage

[Section titled “Basic usage”](#basic-usage)

The `AddExecutable` method requires a resource name, the executable path, and optionally command-line arguments and a working directory:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Basic executable without arguments
var nodeApp = builder.AddExecutable("frontend", "node", ".", "server.js");


// Executable with command-line arguments
var pythonApp = builder.AddExecutable(
        "api", "python", ".", "-m", "uvicorn", "main:app", "--reload", "--host", "0.0.0.0", "--port", "8000");


builder.Build().Run();
```

This code demonstrates setting up a basic executable resource. The first example runs a Node.js server script, while the second starts a Python application using Uvicorn with specific configuration options passed as arguments directly to the `AddExecutable` method.

## Resource dependencies and environment configuration

[Section titled “Resource dependencies and environment configuration”](#resource-dependencies-and-environment-configuration)

You can provide command-line arguments directly in the `AddExecutable` call and configure environment variables for resource dependencies. Executable resources can reference other resources and access their connection information.

### Arguments in the AddExecutable call

[Section titled “Arguments in the AddExecutable call”](#arguments-in-the-addexecutable-call)

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Arguments provided directly in AddExecutable
var app = builder.AddExecutable(
    "vercel-dev", "vercel", ".", "dev", "--listen", "3000");
```

### Resource dependencies with environment variables

[Section titled “Resource dependencies with environment variables”](#resource-dependencies-with-environment-variables)

For arguments that depend on other resources, use environment variables:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis("cache");
var postgres = builder.AddPostgres("postgres").AddDatabase("appdb");


var app = builder.AddExecutable("worker", "python", ".", "worker.py")
    .WithReference(redis)      // Provides ConnectionStrings__cache
    .WithReference(postgres);  // Provides ConnectionStrings__appdb
```

When one resource depends on another, `WithReference` passes along environment variables containing the dependent resource’s connection details. For example, the `worker` executable’s reference to `redis` and `postgres` provides it with the `ConnectionStrings__cache` and `ConnectionStrings__appdb` environment variables, which contain connection strings to these resources.

### Access specific endpoint information

[Section titled “Access specific endpoint information”](#access-specific-endpoint-information)

For more control over how connection information is passed to your executable:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis("cache");


var app = builder.AddExecutable("app", "node", ".", "app.js")
    .WithReference(redis)
    .WithEnvironment(context =>
    {
        // Provide individual connection details
        context.EnvironmentVariables["REDIS_HOST"] = redis.Resource.PrimaryEndpoint.Property(EndpointProperty.Host);
        context.EnvironmentVariables["REDIS_PORT"] = redis.Resource.PrimaryEndpoint.Property(EndpointProperty.Port);
    });
```

## Practical example: Vercel CLI

[Section titled “Practical example: Vercel CLI”](#practical-example-vercel-cli)

Here’s a complete example using the [Vercel CLI](https://vercel.com/docs/cli) to host a frontend application with a backend API:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Backend API
var api = builder.AddProject<Projects.Api>("api")
    .WithExternalHttpEndpoints();


// Frontend with Vercel CLI
var frontend = builder.AddExecutable(
        "vercel-dev", "vercel", ".", "dev", "--listen", "3000")
    .WithEnvironment("API_URL", api.GetEndpoint("http"))
    .WithHttpEndpoint(port: 3000, name: "http");


builder.Build().Run();
```

## Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Executable resources can expose HTTP endpoints that other resources can reference:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var frontend = builder.AddExecutable(
        "webpack-dev", "npx", ".", "webpack", "serve", "--port", "8080", "--host", "0.0.0.0")
    .WithHttpEndpoint(port: 8080, name: "http");


// Another service can reference the frontend
var e2eTests = builder.AddExecutable("playwright", "npx", ".", "playwright", "test")
    .WithEnvironment("BASE_URL", frontend.GetEndpoint("http"));
```

## Environment configuration

[Section titled “Environment configuration”](#environment-configuration)

Configure environment variables for your executable:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddExecutable(
        "api", "uvicorn", ".", "main:app", "--reload", "--host", "0.0.0.0")
    .WithEnvironment("DEBUG", "true")
    .WithEnvironment("LOG_LEVEL", "info")
    .WithEnvironment(context =>
    {
        // Dynamic environment variables
        context.EnvironmentVariables["START_TIME"] = DateTimeOffset.UtcNow.ToString();
    });
```

## Publishing with PublishAsDockerfile

[Section titled “Publishing with PublishAsDockerfile”](#publishing-with-publishasdockerfile)

For production deployment, executable resources need to be containerized. Use the `PublishAsDockerfile` method to specify how the executable should be packaged:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddExecutable(
        "frontend", "npm", ".", "start", "--port", "3000")
    .PublishAsDockerfile();
```

When you call `PublishAsDockerfile()`, Aspire generates a Dockerfile during the publish process. You can customize this by providing your own Dockerfile:

### Custom Dockerfile for publishing

[Section titled “Custom Dockerfile for publishing”](#custom-dockerfile-for-publishing)

Create a `Dockerfile` in your executable’s working directory:

Dockerfile

```dockerfile
FROM node:22-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

Then reference it in your AppHost:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddExecutable("frontend", "npm", ".", "start")
    .PublishAsDockerfile([new DockerfileBuildArg("NODE_ENV", "production")]);
```

## Best practices

[Section titled “Best practices”](#best-practices)

When working with executable resources:

1. **Use explicit paths**: For better reliability, use full paths to executables when possible.
2. **Handle dependencies**: Use `WithReference` to establish proper dependency relationships.
3. **Configure explicit start**: Use `WithExplicitStart()` for executables that shouldn’t start automatically.
4. **Prepare for deployment**: Always use `PublishAsDockerfile()` for production scenarios.
5. **Environment isolation**: Use environment variables rather than command-line arguments for sensitive configuration.
6. **Resource naming**: Use descriptive names that clearly identify the executable’s purpose.

# Migrate from Docker Compose to Aspire

> Learn how to migrate your Docker Compose applications to Aspire and understand the key conceptual differences.

This guide helps you understand how to migrate applications from Docker Compose to Aspire, highlighting the key conceptual differences and providing accurate, practical examples for common migration scenarios.

## Understand the differences

[Section titled “Understand the differences”](#understand-the-differences)

While Docker Compose and Aspire might seem similar at first glance, they serve different purposes and operate at different levels of abstraction.

### Docker Compose vs Aspire

[Section titled “Docker Compose vs Aspire”](#docker-compose-vs-aspire)

|                            | Docker Compose                | Aspire                                                      |
| -------------------------- | ----------------------------- | ----------------------------------------------------------- |
| **Primary purpose**        | Container orchestration       | Development-time orchestration and app composition          |
| **Scope**                  | Container-focused             | Multi-resource (containers, .NET projects, cloud resources) |
| **Configuration**          | YAML-based                    | C#-based, strongly typed                                    |
| **Target environment**     | Any Docker runtime            | Development and cloud deployment                            |
| **Service discovery**      | DNS-based container discovery | Built-in service discovery with environment variables       |
| **Development experience** | Manual container management   | Integrated tooling, dashboard, and telemetry                |

### Key conceptual shifts

[Section titled “Key conceptual shifts”](#key-conceptual-shifts)

When migrating from Docker Compose to Aspire, consider these conceptual differences:

* **From YAML to C#** — Configuration moves from declarative YAML to imperative, strongly-typed C# code
* **From containers to resources** — Aspire manages not just containers, but .NET projects, executables, parameters, and cloud resources
* **From manual networking to service discovery** — Aspire automatically configures service discovery and connection strings
* **From development gaps to integrated experience** — Aspire provides dashboard, telemetry, and debugging integration
* **Startup orchestration differs** — Docker Compose `depends_on` controls startup order, while Aspire `WithReference` only configures service discovery; use `WaitFor` for startup ordering

For detailed API mappings, see [Docker Compose to Aspire AppHost API reference](/app-host/docker-compose-to-apphost-reference/).

## Common migration patterns

[Section titled “Common migration patterns”](#common-migration-patterns)

This section demonstrates practical migration scenarios you’ll likely encounter when moving from Docker Compose to Aspire. Each pattern shows a complete Docker Compose example alongside its accurate Aspire equivalent.

### Multi-service web application

[Section titled “Multi-service web application”](#multi-service-web-application)

This example shows a typical three-tier application with frontend, API, and database.

**Docker Compose example:**

compose.yaml

```yaml
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      api:
        condition: service_healthy
    environment:
      - API_URL=http://api:5000


  api:
    build: ./api
    ports:
      - "5000:5000"
    depends_on:
      database:
        condition: service_healthy
    environment:
      - ConnectionStrings__DefaultConnection=Host=database;Database=myapp;Username=postgres;Password=secret
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 10s
      timeout: 3s
      retries: 3


  database:
    image: postgres:15
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=secret
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 3s
      retries: 3


volumes:
  postgres_data:
```

**Aspire equivalent:**

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add the database with explicit configuration
var database = builder.AddPostgres("postgres")
    .WithImageTag("15")
    .WithEnvironment("POSTGRES_USER", "postgres")
    .WithEnvironment("POSTGRES_PASSWORD", "secret")
    .WithDataVolume()  // Adds persistent volume
    .AddDatabase("myapp");


// Add the API project with proper dependencies
var api = builder.AddProject<Projects.MyApp_Api>("api")
    .WithHttpEndpoint(port: 5000)
    .WithHttpHealthCheck("/health")
    .WithReference(database)
    .WaitFor(database);  // Ensures database is ready before starting


// Add the frontend project with dependencies
var frontend = builder.AddProject<Projects.MyApp_Frontend>("frontend")
    .WithHttpEndpoint(port: 3000)
    .WithReference(api)
    .WithEnvironment("API_URL", api.GetEndpoint("http"))
    .WaitFor(api);  // Ensures API is ready before starting


builder.Build().Run();
```

**Key differences explained:**

* **Ports** — Both examples explicitly map ports (3000 and 5000)
* **Startup order** — Docker Compose uses `depends_on` with health conditions; Aspire uses `WaitFor()` with health checks
* **Service discovery** — `WithReference()` configures service discovery but doesn’t control startup order
* **Environment variables** — Connection strings are automatically generated by `WithReference(database)`, providing `ConnectionStrings__myapp`
* **Volumes** — `WithDataVolume()` explicitly creates and manages persistent storage
* **Image versions** — Aspire uses `WithImageTag()` to specify PostgreSQL 15

### Container-based services

[Section titled “Container-based services”](#container-based-services)

This example shows existing container images being orchestrated.

**Docker Compose example:**

compose.yaml

```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      redis:
        condition: service_started
      postgres:
        condition: service_healthy
    environment:
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://postgres:secret@postgres:5432/main


  redis:
    image: redis:7
    ports:
      - "6379:6379"


  postgres:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready"]
      interval: 10s


volumes:
  postgres_data:
```

**Aspire equivalent:**

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add backing services with explicit versions
var redis = builder.AddRedis("redis")
    .WithImageTag("7")
    .WithHostPort(6379);  // Static port mapping


var postgres = builder.AddPostgres("postgres")
    .WithImageTag("15")
    .WithEnvironment("POSTGRES_PASSWORD", "secret")
    .WithDataVolume()  // Persistent storage
    .AddDatabase("main");


// Add the containerized web application
var web = builder.AddContainer("web", "myapp", "latest")
    .WithHttpEndpoint(port: 8080, targetPort: 8080)
    .WithReference(redis)
    .WithReference(postgres)
    .WaitFor(redis)     // Wait for dependencies
    .WaitFor(postgres);


builder.Build().Run();
```

**Key differences explained:**

* **Image versions** — Explicitly specified with `WithImageTag()` to match Docker Compose
* **Ports** — Redis uses `WithHostPort()` for static port mapping
* **Volumes** — `WithDataVolume()` explicitly adds persistent storage
* **Container source** — `AddContainer()` uses existing built image
* **Startup ordering** — `WaitFor()` ensures services start in correct order
* **Connection strings** — Automatically generated in Aspire’s format, not matching Docker Compose URLs exactly

### Environment variables and configuration

[Section titled “Environment variables and configuration”](#environment-variables-and-configuration)

This example shows different approaches to configuration management.

**Docker Compose approach:**

compose.yaml

```yaml
services:
  app:
    image: myapp:latest
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/myapp
      - REDIS_URL=redis://cache:6379
      - API_KEY=${API_KEY}
      - LOG_LEVEL=info
```

**Aspire approach:**

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add external parameter for secrets
var apiKey = builder.AddParameter("apiKey", secret: true);


var database = builder.AddPostgres("db")
    .WithEnvironment("POSTGRES_USER", "user")
    .WithEnvironment("POSTGRES_PASSWORD", "pass")
    .AddDatabase("myapp");


var cache = builder.AddRedis("cache");


var app = builder.AddContainer("app", "myapp", "latest")
    .WithReference(database)      // Sets ConnectionStrings__myapp
    .WithReference(cache)         // Sets ConnectionStrings__cache
    .WithEnvironment("API_KEY", apiKey)
    .WithEnvironment("LOG_LEVEL", "info");


builder.Build().Run();
```

**Important differences:**

Caution

Aspire generates connection strings in .NET format, which differs from Docker Compose URLs:

* Docker Compose: `postgresql://user:pass@db:5432/myapp`
* Aspire: `ConnectionStrings__myapp=Host=localhost;Port=12345;Username=postgres;Password=abc...;Database=myapp`

If your application expects specific URL formats, you’ll need to manually construct and pass them using `WithEnvironment()`.

### Custom volumes and bind mounts

[Section titled “Custom volumes and bind mounts”](#custom-volumes-and-bind-mounts)

**Docker Compose example:**

compose.yaml

```yaml
version: '3.8'
services:
  app:
    image: myapp:latest
    volumes:
      - app_data:/data
      - ./config:/app/config:ro


  worker:
    image: myworker:latest
    volumes:
      - app_data:/shared


volumes:
  app_data:
```

**Aspire equivalent:**

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Create a named volume for sharing data
var appData = builder.AddVolume("app-data");


var app = builder.AddContainer("app", "myapp", "latest")
    .WithVolume(appData, "/data")
    .WithBindMount("./config", "/app/config", isReadOnly: true);


var worker = builder.AddContainer("worker", "myworker", "latest")
    .WithVolume(appData, "/shared");


builder.Build().Run();
```

**Key differences:**

* **Named volumes** — Created with `AddVolume()` and shared between containers
* **Bind mounts** — Use `WithBindMount()` for host directory access
* **Networking** — Aspire automatically handles container networking; custom networks aren’t needed for most scenarios

## Migration strategy

[Section titled “Migration strategy”](#migration-strategy)

Successfully migrating from Docker Compose to Aspire requires a systematic approach.

1. ### Assess your current setup

   [Section titled “Assess your current setup”](#assess-your-current-setup)

   Before migrating, inventory your Docker Compose setup:

   * **Services** — Identify all services including databases, caches, APIs, and web applications
   * **Dependencies** — Map out service dependencies from `depends_on` declarations
   * **Data persistence** — Catalog all volumes and bind mounts used for data storage
   * **Environment variables** — List all configuration variables and secrets
   * **Health checks** — Document any custom health check commands
   * **Image versions** — Note specific versions used in production

2. ### Create the Aspire AppHost

   [Section titled “Create the Aspire AppHost”](#create-the-aspire-apphost)

   Start by creating a new Aspire project:

   ```bash
   aspire new aspire-starter -o MyApp
   ```

3. ### Migrate services incrementally

   [Section titled “Migrate services incrementally”](#migrate-services-incrementally)

   Migrate services one by one, starting with backing services:

   * **Add backing services** like PostgreSQL, Redis with specific versions using `WithImageTag()`
   * **Add persistent storage** using `WithDataVolume()` where needed
   * **Convert .NET applications** to project references for better integration
   * **Convert other containers** using `AddContainer()` for existing Docker images
   * **Configure dependencies** with `WithReference()` for service discovery
   * **Add startup ordering** with `WaitFor()` to match `depends_on` behavior
   * **Set up environment variables** — Note that connection string formats will differ
   * **Migrate health checks** — Use `WithHttpHealthCheck()` or `WithHealthCheck()` for custom checks

4. ### Handle data migration

   [Section titled “Handle data migration”](#handle-data-migration)

   For persistent data:

   * Use `WithDataVolume()` for automatic volume management with integrations
   * Use `WithVolume()` for named volumes that need to persist data
   * Use `WithBindMount()` for host directory mounts when you need direct access to host files

5. ### Test and validate

   [Section titled “Test and validate”](#test-and-validate)

   * Start the Aspire AppHost and verify all services start correctly
   * Check the dashboard to confirm service health and connectivity status
   * Validate that inter-service communication works as expected
   * **Verify connection strings** — If your app expects specific URL formats, you may need to adjust environment variables

## Migration troubleshooting

[Section titled “Migration troubleshooting”](#migration-troubleshooting)

### Common issues and solutions

[Section titled “Common issues and solutions”](#common-issues-and-solutions)

**Connection string format mismatch**

Aspire generates .NET-style connection strings (`ConnectionStrings__*`) rather than URL formats like `postgresql://` or `redis://`.

**Solution**: If your application expects specific URL formats, construct them manually:

AppHost.cs

```csharp
var postgres = builder.AddPostgres("db", password: "secret")
    .WithImageTag("15")
    .AddDatabase("myapp");


var app = builder.AddContainer("app", "myapp", "latest")
    .WithReference(postgres)  // Still provides service discovery
    .WithEnvironment("DATABASE_URL", $"postgresql://postgres:secret@{{db.GetEndpoint(\"tcp\").Host}}:{{db.GetEndpoint(\"tcp\").Port}}/myapp");
```

**Service startup order issues**

`WithReference()` only configures service discovery, not startup ordering.

**Solution**: Use `WaitFor()` to ensure dependencies are ready:

AppHost.cs

```csharp
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(database)  // Service discovery
    .WaitFor(database);       // Startup ordering
```

**Volume mounting issues**

* Use absolute paths for bind mounts to avoid path resolution issues
* Ensure the host directory exists and has proper permissions
* Use `WithDataVolume()` for database integrations for automatic configuration

**Port conflicts**

Aspire automatically assigns random ports by default.

**Solution**: Use `WithHostPort()` or `WithHttpEndpoint(port:)` for static port mapping:

AppHost.cs

```csharp
var redis = builder.AddRedis("cache")
    .WithHostPort(6379);  // Static port
```

**Health check migration**

Docker Compose health checks use shell commands.

**Solution**: For HTTP health checks, use `WithHttpHealthCheck()`:

AppHost.cs

```csharp
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpHealthCheck("/health");
```

For custom container health checks:

AppHost.cs

```csharp
var rabbit = builder.AddContainer("rabbitmq", "rabbitmq", "4.1.4-management-alpine")
    .WithHealthCheck("rabbitmqctl", ["ping"],
        interval: TimeSpan.FromSeconds(30),
        timeout: TimeSpan.FromSeconds(10),
        startPeriod: TimeSpan.FromSeconds(10));
```

## Next steps

[Section titled “Next steps”](#next-steps)

After migrating to Aspire:

* Explore [Aspire integrations](/integrations/overview/) to replace custom container configurations
* Set up [health checks](/fundamentals/health-checks/) for better monitoring
* Learn about [deployment options](/deployment/overview/) for production environments
* Consider [testing](/testing/overview/) your distributed application
* Review [telemetry configuration](/fundamentals/telemetry/) for observability

# Persistent container lifetimes

> Learn how to configure containers to persist and be re-used between Aspire AppHost runs.

In Aspire, containers follow a typical lifecycle where they’re created when the AppHost starts and destroyed when it stops. However, you can specify that you want to use **persistent containers**, which deviate from this standard lifecycle. Persistent containers are created and started by the Aspire orchestrator but aren’t destroyed when the AppHost stops, allowing them to persist between runs.

This feature is particularly beneficial for containers that have long startup times, such as databases, as it eliminates the need to wait for these services to initialize on every AppHost restart.

## Configure a persistent container

[Section titled “Configure a persistent container”](#configure-a-persistent-container)

To configure a container resource with a persistent lifetime, use the `WithLifetime` method and pass `ContainerLifetime.Persistent`:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithLifetime(ContainerLifetime.Persistent);


var db = postgres.AddDatabase("inventorydb");


builder.AddProject<Projects.InventoryService>("inventory")
       .WithReference(db);


builder.Build().Run();
```

In the preceding example, the PostgreSQL container is configured to persist between AppHost runs, while the `inventory` project references the database as normal.

## Dashboard visualization

[Section titled “Dashboard visualization”](#dashboard-visualization)

The Aspire dashboard shows persistent containers with a distinctive pin icon (📌) to help you identify them:

![Screenshot of the Aspire dashboard showing a persistent container with a pin icon.](/_astro/persistent-container.B3qvqKn7_ZNmkFU.webp)

After the AppHost stops, persistent containers continue running and can be seen in your container runtime (such as Docker Desktop):

![Screenshot of Docker Desktop showing a persistent RabbitMQ container still running after the AppHost stopped.](/_astro/persistent-container-docker-desktop.fBhTDXpR_MFVaN.webp)

## Configuration change detection

[Section titled “Configuration change detection”](#configuration-change-detection)

Persistent containers are automatically recreated when the AppHost detects meaningful configuration changes. Aspire tracks a hash of the configuration used to create each container and compares it to the current configuration on subsequent runs. If the configuration differs, the container is recreated with the new settings.

This mechanism ensures that persistent containers stay synchronized with your AppHost configuration without requiring manual intervention.

## Container naming and uniqueness

[Section titled “Container naming and uniqueness”](#container-naming-and-uniqueness)

By default, persistent containers use a naming pattern that combines:

* The service name you specify in your AppHost.
* A postfix based on a hash of the AppHost project path.

This naming scheme ensures that persistent containers are unique to each AppHost project, preventing conflicts when multiple Aspire projects use the same service names.

For example, if you have a service named `"postgres"` in an AppHost project located at `/path/to/MyApp.AppHost`, the container name might be `postgres-abc123def` where `abc123def` is derived from the project path hash.

### Custom container names

[Section titled “Custom container names”](#custom-container-names)

For advanced scenarios, you can set a custom container name using the `WithContainerName` method:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithLifetime(ContainerLifetime.Persistent)
                      .WithContainerName("my-shared-postgres");


builder.Build().Run();
```

When you specify a custom container name, Aspire first checks if a container with that name already exists. If a container with that name exists and was previously created by Aspire, it follows the normal persistent container behavior and can be automatically recreated if the configuration changes. If a container with that name exists but wasn’t created by Aspire, it won’t be managed or recreated by the AppHost. If no container with the custom name exists, Aspire creates a new one.

## Manual cleanup

[Section titled “Manual cleanup”](#manual-cleanup)

Caution

Persistent containers aren’t automatically removed when you stop the AppHost. To delete these containers, you must manually stop and remove them using your container runtime.

You can clean up persistent containers using Docker CLI commands:

```bash
# Stop the container
docker stop my-container-name


# Remove the container
docker rm my-container-name
```

Alternatively, you can use Docker Desktop or your preferred container management tool to stop and remove persistent containers.

## Use cases and benefits

[Section titled “Use cases and benefits”](#use-cases-and-benefits)

Persistent containers are ideal for:

* **Database services**: PostgreSQL, SQL Server, MySQL, and other databases that take time to initialize and load data.
* **Message brokers**: RabbitMQ, Redis, and similar services that benefit from maintaining state between runs.
* **Development data**: Containers with test data or configurations that you want to preserve during development iterations.
* **Shared services**: Services that multiple AppHosts or development team members can share.

# Add Dockerfiles to your app model

> Learn how to add Dockerfiles to your app model.

With Aspire it’s possible to specify a *Dockerfile* to build when the [AppHost](/get-started/app-host/) is started using either the `AddDockerfile` or `WithDockerfile` extension methods.

These two methods serve different purposes:

* **`AddDockerfile`**: Creates a new container resource from an existing Dockerfile. Use this when you want to add a custom containerized service to your app model.
* **`WithDockerfile`**: Customizes an existing container resource (like a database or cache) to use a different Dockerfile. Use this when you want to modify the default container image for an Aspire component.

Both methods expect an existing Dockerfile in the specified context path—neither method creates a Dockerfile for you.

## When to use AddDockerfile vs WithDockerfile

[Section titled “When to use AddDockerfile vs WithDockerfile”](#when-to-use-adddockerfile-vs-withdockerfile)

Choose the appropriate method based on your scenario:

**Use `AddDockerfile` when:**

* You want to add a custom containerized service to your app model.
* You have an existing Dockerfile for a custom application or service.
* You need to create a new container resource that isn’t provided by Aspire components.

**Use `WithDockerfile` when:**

* You want to customize an existing Aspire component (like PostgreSQL, Redis, etc.).
* You need to replace the default container image with a custom one.
* You want to maintain the strongly typed resource builder and its extension methods.
* You have specific requirements that the default container image doesn’t meet.

## Add a Dockerfile to the app model

[Section titled “Add a Dockerfile to the app model”](#add-a-dockerfile-to-the-app-model)

In the following example the `AddDockerfile` extension method is used to specify a container by referencing the context path for the container build.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var container = builder.AddDockerfile(
    "mycontainer", "relative/context/path");
```

Unless the context path argument is a rooted path the context path is interpreted as being relative to the AppHost projects directory (where the AppHost `*.csproj` folder is located).

By default the name of the *Dockerfile* which is used is `Dockerfile` and is expected to be within the context path directory. It’s possible to explicitly specify the *Dockerfile* name either as an absolute path or a relative path to the context path.

This is useful if you wish to modify the specific *Dockerfile* being used when running locally or when the AppHost is deploying.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var container = builder.ExecutionContext.IsRunMode
    ? builder.AddDockerfile(
          "mycontainer", "relative/context/path", "Dockerfile.debug")
    : builder.AddDockerfile(
          "mycontainer", "relative/context/path", "Dockerfile.release");
```

## Customize existing container resources

[Section titled “Customize existing container resources”](#customize-existing-container-resources)

When using `AddDockerfile` the return value is an `IResourceBuilder<ContainerResource>`. Aspire includes many custom resource types that are derived from `ContainerResource`.

Using the `WithDockerfile` extension method it’s possible to take an existing Aspire component (like PostgreSQL, Redis, or SQL Server) and replace its default container image with a custom one built from your own Dockerfile. This allows you to continue using the strongly typed resource types and their specific extension methods while customizing the underlying container.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// This replaces the default PostgreSQL container image with a custom one
// built from your Dockerfile, while keeping PostgreSQL-specific functionality
var pgsql = builder.AddPostgres("pgsql")
    .WithDockerfile("path/to/context")
    .WithPgAdmin(); // Still works because it's still a PostgreSQL resource
```

## Pass build arguments

[Section titled “Pass build arguments”](#pass-build-arguments)

The `WithBuildArg` method can be used to pass arguments into the container image build.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var container = builder.AddDockerfile("mygoapp", "relative/context/path")
    .WithBuildArg("GO_VERSION", "1.22");
```

The value parameter on the `WithBuildArg` method can be a literal value (`boolean`, `string`, `int`) or it can be a resource builder for a [parameter resource](/fundamentals/external-parameters/). The following code replaces the `GO_VERSION` with a parameter value that can be specified at deployment time.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var goVersion = builder.AddParameter("goversion");


var container = builder.AddDockerfile("mygoapp", "relative/context/path")
    .WithBuildArg("GO_VERSION", goVersion);
```

Build arguments correspond to the [`ARG` command](https://docs.docker.com/build/guide/build-args/) in *Dockerfiles*. Expanding the preceding example, this is a multi-stage *Dockerfile* which specifies specific container image version to use as a parameter.

Dockerfile

```dockerfile
# Stage 1: Build the Go program
ARG GO_VERSION=1.22
FROM golang:${GO_VERSION} AS builder
WORKDIR /build
COPY . .
RUN go build mygoapp.go


# Stage 2: Run the Go program
FROM mcr.microsoft.com/cbl-mariner/base/core:2.0
WORKDIR /app
COPY --from=builder /build/mygoapp .
CMD ["./mygoapp"]
```

Note

Instead of hardcoding values into the container image, it’s recommended to use environment variables for values that frequently change. This avoids the need to rebuild the container image whenever a change is required.

## Pass build secrets

[Section titled “Pass build secrets”](#pass-build-secrets)

In addition to build arguments it’s possible to specify build secrets using `WithBuildSecret` which are made selectively available to individual commands in the *Dockerfile* using the `--mount=type=secret` syntax on `RUN` commands.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var accessToken = builder.AddParameter("accesstoken", secret: true);


var container = builder.AddDockerfile("myapp", "relative/context/path")
    .WithBuildSecret("ACCESS_TOKEN", accessToken);
```

For example, consider the `RUN` command in a *Dockerfile* which exposes the specified secret to the specific command:

Dockerfile

```dockerfile
# The helloworld command can read the secret from /run/secrets/ACCESS_TOKEN
RUN --mount=type=secret,id=ACCESS_TOKEN helloworld
```

Caution

Caution should be exercised when passing secrets in build environments. This is often done when using a token to retrieve dependencies from private repositories or feeds before a build. It is important to ensure that the injected secrets are not copied into the final or intermediate images.

# Glossary

> A glossary of key terms and concepts in Aspire.

| API Terms             | Description                                       |
| --------------------- | ------------------------------------------------- |
| `IResourceAnnotation` | Typed metadata object attached to resources.      |
| `WithAnnotation()`    | Fluent method to attach typed annotations.        |
| `ReferenceExpression` | Structured formatter preserving value references. |

| Term                          | Definition                                         |
| ----------------------------- | -------------------------------------------------- |
| Resource                      | Service or infrastructure element in your app.     |
| Annotation                    | Metadata attached to a resource.                   |
| DAG                           | Directed acyclic graph.                            |
| Heterogeneous DAG             | DAG containing varied resource types.              |
| Publisher                     | Emits deployment artifacts from the model.         |
| Hoisting                      | Leaving a value unresolved for later substitution. |
| Deferred evaluation           | Computing a value only when needed.                |
| `ResourceNotificationService` | Publishes observable state updates.                |
| Lifecycle events              | Time-based signals for resource transitions.       |

# Aspire architecture

> Learn about the overall architecture of Aspire, including its integrations, orchestration, and networking capabilities.

Aspire brings together a powerful suite of tools and libraries, designed to deliver a seamless and intuitive experience for developers. Its modular and extensible architecture empowers you to define your application model with precision, orchestrating intricate systems composed of services, containers, and executables. Whether your components span different programming languages, platforms, stacks, or operating systems, Aspire ensures they work harmoniously, simplifying the complexity of modern cloud-native app development.

## App model architecture

[Section titled “App model architecture”](#app-model-architecture)

Resources are the building blocks of your app model. They’re used to represent abstract concepts like services, containers, executables, and external integrations. Specific resources enable developers to define dependencies on concrete implementations of these concepts. For example, a `Redis` resource can be used to represent a Redis cache, while a `Postgres` resource can represent a PostgreSQL database.

While the app model is often synonymous with a collection of resources, it’s also a high level representation of your entire application topology. This is important, as it’s architected for lowering. In this way, Aspire can be thought of as a compiler for application topology.

### Lowering the model

[Section titled “Lowering the model”](#lowering-the-model)

In a traditional compiler, the process of “lowering” involves translating a high-level programming language into progressively simpler representations:

* **Intermediate Representation (IR):** The first step abstracts away language-specific features, creating a platform-neutral representation.
* **Machine Code:** The IR is then transformed into machine-specific instructions tailored to a specific CPU architecture.

Similarly, Aspire applies this concept to applications, treating the app model as the high-level language:

* **Intermediate constructs:** The app model is first lowered into intermediate constructs, such as cloud development kit (CDK)-style object graphs. These constructs might be platform-agnostic or partially tailored to specific targets.
* **Target runtime representation:** Finally, a publisher generates the deployment-ready artifacts—YAML, HCL, JSON, or other formats—required by the target platform.

This layered approach unlocks several key benefits:

* **Validation and enrichment:** Models can be validated and enriched during the transformation process, ensuring correctness and completeness.
* **Multi-target support:** Aspire supports multiple deployment targets, enabling flexibility across diverse environments.
* **Customizable workflow:** Developers can hook into each phase of the process to customize behavior, tailoring the output to specific needs.
* **Clean and portable models:** The high-level app model remains expressive, portable, and free from platform-specific concerns.

Most importantly, the translation process itself is highly extensible. You can define custom transformations, enrichments, and output formats, allowing Aspire to seamlessly adapt to your unique infrastructure and deployment requirements. This extensibility ensures that Aspire remains a powerful and versatile tool, capable of evolving alongside your application’s needs.

### Modality and extensibility

[Section titled “Modality and extensibility”](#modality-and-extensibility)

Aspire operates in two primary modes, each tailored to streamline your specific needs—detailed in the following section. Both modes use a robust set of familiar APIs and a rich ecosystem of [integrations](/integrations/gallery/). Each integration simplifies working with a common service, framework, or platform, such as Redis, PostgreSQL, Azure services, or Orleans, for example. These integrations work together like puzzle pieces, enabling you to define resources, express dependencies, and configure behavior effortlessly—whether you’re running locally or deploying to production.

Why is modality important when it comes to the AppHost’s execution context? This is because it allows you to define your app model once and with the appropriate APIs, specify how resources operate in each mode. Consider the following collection of resources:

* Database: PostgreSQL
* Cache: Redis
* AI service: Ollama or OpenAI
* Back end: ASP.NET Core minimal API
* Front end: React app

Depending on the mode, the AppHost might treat these resources differently. For example, in run mode, the AppHost might use a local PostgreSQL database and Redis cache—using containers, while in publish mode, it might generate deployment artifacts for Azure PostgreSQL and Redis Cache.

#### Run mode

[Section titled “Run mode”](#run-mode)

The default mode is run mode, which is ideal for local development and testing. In this mode, the Aspire AppHost orchestrates your application model, including processes, containers, and cloud emulators, to facilitate fast and iterative development. Resources behave like real runtime entities with lifecycles that mirror production. With a simple `F5`, the AppHost launches everything in your app model—storage, databases, caches, messaging, jobs, APIs, front ends—all fully configured and ready to debug locally. Let’s considering the app model from the previous section—where AppHost would orchestrate the following resources locally:

![Local app topology for dev-time orchestration](/_astro/local-app-topology.B_sGoIdM.svg)

For more information on how run mode works, see [Dev-time orchestration](#dev-time-orchestration).

#### Publish mode

[Section titled “Publish mode”](#publish-mode)

The publish mode generates deployment-ready artifacts tailored to your target environment. The Aspire AppHost compiles your app model into outputs like Kubernetes manifests, Terraform configs, Bicep/ARM templates, Docker Compose files, or CDK constructs—ready for integration into any deployment pipeline. The output format depends on the chosen publisher, giving you flexibility across deployment scenarios. When you consider the app model from the previous section, the AppHost doesn’t orchestrate anything—instead, it emits publish artifacts that can be used to deploy your application to a cloud provider. For example, let’s assume you want to deploy to Azure—the AppHost would emit Bicep templates that define the following resources:

![Published app topology](/_astro/publish-app-topology.MEx6uFC3.svg)

## Dev-time orchestration

[Section titled “Dev-time orchestration”](#dev-time-orchestration)

In run mode, [the AppHost orchestrates](/get-started/app-host/) all resources defined in your app model. But how does it achieve this?

Caution

The AppHost isn’t a production runtime. It’s a development-time orchestration tool that simplifies the process of running and debugging your application locally.

In this section, several key questions are answered to help you understand how the AppHost orchestrates your app model:

* **What powers the orchestration?**

  Orchestration is delegated to the [Microsoft Developer Control Plane](#developer-control-plane) (DCP), which manages resource lifecycles, startup order, dependencies, and network configurations across your app topology.

* **How is the app model used?**

  The app model defines all resources via implementations of `IResource`, including containers, processes, databases, and external services—forming the blueprint for orchestration.

* **What role does the AppHost play?**

  The AppHost provides a high-level declaration of the desired application state. It delegates execution to DCP, which interprets the app model and performs orchestration accordingly.

* **What resources are monitored?**

  All declared resources—including containers, executables, and integrations—are monitored to ensure correct behavior and to support a fast and reliable development workflow.

* **How are containers and executables managed?**

  Containers and processes are initialized with their configurations and launched concurrently, respecting the dependency graph defined in the app model. DCP ensures their readiness and connectivity during orchestration, starting resources as quickly as possible while maintaining the correct order dictated by their dependencies.

* **How are resource dependencies handled?**

  Dependencies are defined in the app model and evaluated by DCP to determine correct startup sequencing, ensuring resources are available before dependents start.

* **How is networking configured?**

  Networking—such as port bindings—is autoconfigured unless explicitly defined. DCP resolves conflicts and ensures availability, enabling seamless communication between services.

The orchestration process follows a layered architecture. At its core, the AppHost represents the developer’s desired view of the distributed application’s resources. DCP ensures that this desired state is realized by orchestrating the resources and maintaining consistency.

The [app model](/get-started/app-host/) serves as a blueprint for DCP to orchestrate your application. Under the hood, the AppHost is a .NET console application powered by the [`📦 Aspire.Hosting.AppHost`](https://www.nuget.org/packages/Aspire.Hosting.AppHost) NuGet package. This package includes build targets that register orchestration dependencies, enabling seamless dev-time orchestration.

DCP is a Kubernetes-compatible API server, meaning it uses the same network protocols and conventions as Kubernetes. This compatibility allows the Aspire AppHost to leverage existing Kubernetes libraries for communication. Specifically, the AppHost contains an implementation of the `k8s.KubernetesClient` (from the [📦 KubernetesClient](https://www.nuget.org/packages/KubernetesClient) NuGet package), which is a .NET client for Kubernetes. This client is used to communicate with the DCP API server, enabling the AppHost to delegate orchestration tasks to DCP.

When you run the AppHost, it performs the first step of “lowering” by translating the general-purpose Aspire app model into a DCP-specific model tailored for local execution in run mode. This DCP model is then handed off to DCP, which evaluates it and orchestrates the resources accordingly. This separation ensures that the AppHost focuses on adapting the Aspire app model for local execution, while DCP specializes in executing the tailored model. The following diagram helps to visualize this orchestration process:

![Flow diagram showing AppHost delegating to DCP](/_astro/app-host-dcp-flow.BZQuKk3r.svg)

### Developer control plane

[Section titled “Developer control plane”](#developer-control-plane)

DCP is at the core of the Aspire AppHost orchestration functionality. It’s responsible for orchestrating all resources defined in your app model, starting the developer dashboard, ensuring that everything is set up correctly for local development and testing. DCP manages the lifecycle of resources, applies network configurations, and resolves dependencies.

DCP is written in Go, aligning with Kubernetes and its ecosystem, which are also Go-based. This choice enables deep, native integration with Kubernetes APIs, efficient concurrency, and access to mature tooling like Kubebuilder. DCP is delivered as two executables:

* `dcp.exe`: API server that exposes a Kubernetes-like API endpoint for the AppHost to communicate with. Additionally, it exposes log streaming to the AppHost, which ultimately streams logs to the developer dashboard.
* `dcpctrl.exe`: Controller that monitors the API server for new objects and changes, ensuring that the real-world environment matches the specified model.

Note

DCP operates on the principle of “eventual consistency,” meaning that changes to the model and the real-world environment are applied asynchronously. While this approach may introduce noticeable delays, DCP is designed to diligently synchronize both states. Unlike a “strongly consistent” system that might fail immediately on encountering issues, DCP persistently retries until the desired state is achieved or an error is conclusively determined, often resulting in a more robust alignment between the model and the real world.

When the AppHost runs, it uses Kubernetes client libraries to communicate with DCP. It translates the app model into a format DCP can process by converting the model’s resources into specifications. Specifically, this involves generating Kubernetes Custom Resource Definitions (CRDs) that represent the application’s desired state.

DCP performs the following tasks:

* Prepares the resources for execution:

  * Configures service endpoints.
    * Assigns names and ports dynamically, unless explicitly set (DCP ensures that the ports are available and not in use by other processes).
  * Initializes container networks.
  * Pulls container images based on their applied `ImagePullPolicy`.
  * Creates and starts containers.
  * Runs executables with the required arguments and environment variables.

* Monitors resources:
  * Provides change notifications about objects managed within DCP, including process IDs, running status, and exit codes (the AppHost subscribes to these changes to manage the [application’s lifecycle](/app-host/eventing/) effectively).

* Starts the developer dashboard.

Continuing from the diagram in the previous section, consider the following diagram that helps to visualize the responsibilities of DCP:

![Architecture diagram showing DCP components](/_astro/dcp-arch.9Tyj5BPk.svg)

DCP logs are streamed back to the AppHost, which then forwards them to the developer dashboard. While the developer dashboard exposes commands such as start, stop, and restart, these commands are not part of DCP itself. Instead, they are implemented by the app model runtime, specifically within its “dashboard service” component. These commands operate by manipulating DCP objects—creating new ones, deleting old ones, or updating their properties. For example, restarting a .NET project involves stopping and deleting the existing `ExecutableResource` representing the project and creating a new one with the same specifications.

## Developer dashboard

[Section titled “Developer dashboard”](#developer-dashboard)

The Aspire developer dashboard is a powerful tool designed to simplify local development and resource management. It also supports a standalone mode and integrates seamlessly when publishing to Azure Container Apps. With its intuitive interface, the dashboard empowers developers to monitor, manage, and interact with application resources effortlessly.

### Monitor and manage resources

[Section titled “Monitor and manage resources”](#monitor-and-manage-resources)

The dashboard provides a user-friendly interface for inspecting resource states, viewing logs, and executing commands. Whether you’re debugging locally or deploying to the cloud, the dashboard ensures you have full visibility into your application’s behavior.

### Built-in and custom commands

[Section titled “Built-in and custom commands”](#built-in-and-custom-commands)

The dashboard provides a set of commands for managing resources, such as start, stop, and restart. While commands appear as intuitive actions in the dashboard UI, under the hood, they operate by manipulating DCP objects. For more information, see *Stop or Start a resource*.

In addition to these built-in commands, you can define custom commands tailored to your application’s needs. These custom commands are registered in the app model and seamlessly integrated into the dashboard, providing enhanced flexibility and control.

### Real-time log streaming

[Section titled “Real-time log streaming”](#real-time-log-streaming)

Stay informed with the dashboard’s real-time log streaming feature. Logs from all resources in your app model are streamed from DCP to the AppHost and displayed in the dashboard. With advanced filtering options—by resource type, severity, and more—you can quickly pinpoint relevant information and troubleshoot effectively.

The developer dashboard is more than just a tool—it’s your command center for building, debugging, and managing Aspire applications with confidence and ease.

# Resource API Patterns

> Discover common API resource patterns in Aspire, including how to add and configure resources, use annotations, and implement custom value objects.

Aspire’s resource model allows you to define and configure resources in a structured way, enabling seamless integration and management of your application’s components. This guide provides details the common patterns for adding and configuring resources in Aspire.

## API patterns

[Section titled “API patterns”](#api-patterns)

Aspire separates **resource data models** from **behavior** using **fluent extension methods**.

* **Resource classes** define only constructors and properties.
* **Extension methods** implement resource creation, configuration, and runtime wiring.

This guide describes each pattern and shows a **verbatim Redis example** at the end. It also covers how to publish manifests via custom resources.

## Adding resources with `AddX(...)`

[Section titled “Adding resources with AddX(...)”](#adding-resources-with-addx)

An `AddX(...)` method executes:

1. **Validate inputs** (`builder`, `name`, required arguments).
2. **Instantiate** the data-only resource (`new TResource(...)`).
3. **Register** it with `builder.AddResource(resource)`.
4. **Optional wiring** of endpoints, health checks, container settings, environment variables, command-line arguments, and event subscriptions.

### Signature pattern

[Section titled “Signature pattern”](#signature-pattern)

```csharp
public static IResourceBuilder<TResource> AddX(
    this IDistributedApplicationBuilder builder,
    [ResourceName] string name,
    /* optional parameters */)
{
    // 1. Validate inputs
    // 2. Instantiate resource
    // 3. builder.AddResource(resource)
    // 4. Optional wiring:
    //    .WithEndpoint(...)
    //    .WithHealthCheck(...)
    //    .WithImage(...)
    //    .WithEnvironment(...)
    //    .WithArgs(...)
    //    Eventing.Subscribe<...>(...)
}
```

### Optional wiring examples

[Section titled “Optional wiring examples”](#optional-wiring-examples)

**Endpoints**:

```csharp
.WithEndpoint(port: hostPort, targetPort: containerPort, name: endpointName)
```

**Health checks**:

```csharp
.WithHealthCheck(healthCheckKey)
```

**Container images / registries**:

```csharp
.WithImage(imageName, imageTag)
.WithImageRegistry(registryUrl)
```

**Entrypoint and args**:

```csharp
.WithEntrypoint("/bin/sh")
.WithArgs(context => { /* build args */ return Task.CompletedTask; })
```

**Environment variables**:

```csharp
.WithEnvironment(context => new("ENV_VAR", valueProvider))
```

**Event subscriptions**:

```csharp
builder.Eventing.Subscribe<EventType>(resource, handler);
```

### Summary table

[Section titled “Summary table”](#summary-table)

| Step            | Call/Method                                                                                                                | Purpose                                                |
| --------------- | -------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |
| Validate        | `ArgumentNullException.ThrowIfNull(...)`                                                                                   | Ensure non-null builder, name, and args                |
| Instantiate     | `new TResource(name, …)`                                                                                                   | Create data-only instance                              |
| Register        | `builder.AddResource(resource)`                                                                                            | Add resource to the application model                  |
| Optional wiring | `.WithEndpoint(…)`, `.WithHealthCheck(…)`, `.WithImage(…)`, `.WithEnvironment(…)`, `.WithArgs(…)`, `Eventing.Subscribe(…)` | Configure container details, wiring, and runtime hooks |

## Configuring resources with `WithX(...)`

[Section titled “Configuring resources with WithX(...)”](#configuring-resources-with-withx)

`WithX(...)` methods **attach annotations** to resource builders.

### Signature pattern

[Section titled “Signature pattern”](#signature-pattern-1)

```csharp
public static IResourceBuilder<TResource> WithX(
    this IResourceBuilder<TResource> builder,
    FooOptions options) =>
    builder.WithAnnotation(new FooAnnotation(options));
```

* **Target**: `IResourceBuilder<TResource>`.
* **Action**: `WithAnnotation(...)`.
* **Returns**: `IResourceBuilder<TResource>`.

### Summary table

[Section titled “Summary table”](#summary-table-1)

| Method       | Target                        | Action                                                 |
| ------------ | ----------------------------- | ------------------------------------------------------ |
| `WithX(...)` | `IResourceBuilder<TResource>` | Attaches `XAnnotation` using the `WithAnnotation` API. |
| Returns      | `IResourceBuilder<TResource>` | Enables fluent chaining .                              |

## Annotations

[Section titled “Annotations”](#annotations)

Annotations are **public** metadata types implementing `IResourceAnnotation`. They can be added or removed dynamically at runtime via hooks or events. Consumers can query annotations using `TryGetLastAnnotation<T>()` when necessary.

### Definition and attachment

[Section titled “Definition and attachment”](#definition-and-attachment)

```csharp
public sealed record PersistenceAnnotation(
    TimeSpan? Interval,
    int KeysChangedThreshold) : IResourceAnnotation;


builder.WithAnnotation(new PersistenceAnnotation(
    TimeSpan.FromSeconds(60),
    100));
```

### Summary table

[Section titled “Summary table”](#summary-table-2)

| Concept         | Pattern                                                 | Notes                                    |
| --------------- | ------------------------------------------------------- | ---------------------------------------- |
| Annotation Type | `public record XAnnotation(...) : IResourceAnnotation`  | Public to support dynamic runtime use.   |
| Attach          | `builder.WithAnnotation(new XAnnotation(...))`          | Adds metadata to resource builder.       |
| Query           | `resource.TryGetLastAnnotation<XAnnotation>(out var a)` | Consumers inspect annotations as needed. |

## Custom value objects

[Section titled “Custom value objects”](#custom-value-objects)

Custom value objects defer evaluation and allow the framework to discover dependencies between resources.

### Core interfaces

[Section titled “Core interfaces”](#core-interfaces)

| Interface                       | Member                                                | Mode             | Purpose                                  |
| ------------------------------- | ----------------------------------------------------- | ---------------- | ---------------------------------------- |
| `IValueProvider`                | `ValueTask<string?> GetValueAsync(CancellationToken)` | Run              | Resolve live values at runtime           |
| `IManifestExpressionProvider`   | `string ValueExpression { get; }`                     | Publish          | Emit structured expressions in manifests |
| `IValueWithReferences` *(opt.)* | `IEnumerable<object> References { get; }`             | Both (if needed) | Declare dependencies on other resources  |

* **Implement** `IValueProvider` and `IManifestExpressionProvider` on all structured value types.
* **Implement** `IValueWithReferences` only when your type holds resource references.

### Attaching to resources

[Section titled “Attaching to resources”](#attaching-to-resources)

```csharp
builder.WithEnvironment(context =>
    new("REDIS_CONNECTION_STRING", redis.GetConnectionStringAsync));
```

Example: BicepOutputReference

```csharp
public sealed partial class BicepOutputReference :
    IManifestExpressionProvider,
    IValueProvider,
    IValueWithReferences
{
    public string ValueExpression { get; }
    public ValueTask<string?> GetValueAsync(CancellationToken cancellationToken = default);
    IEnumerable<object> IValueWithReferences.References { get; }
}
```

```csharp
public static IResourceBuilder<T> WithEnvironment<T>(
    this IResourceBuilder<T> builder,
    string name,
    BicepOutputReference bicepOutputReference)
    where T : IResourceWithEnvironment
{
    return builder.WithAnnotation(
      new EnvironmentVariableAnnotation(name, bicepOutputReference));
}
```

### Summary table

[Section titled “Summary table”](#summary-table-3)

| Concept                         | Pattern                      | Purpose                              |
| ------------------------------- | ---------------------------- | ------------------------------------ |
| `IValueProvider`                | `GetValueAsync(...)`         | Deferred runtime resolution          |
| `IManifestExpressionProvider`   | `ValueExpression`            | Structured publish-time expression   |
| `IValueWithReferences` *(opt.)* | `References`                 | Declare resource dependencies        |
| `WithEnvironment(...)`          | `new("NAME", valueProvider)` | Attach structured values unflattened |

# Examples

> Explore complete, runnable examples demonstrating key concepts in Aspire.

Aspire provides a flexible resource model that allows you to define and configure resources in a structured way. This guide explores common patterns for adding and configuring resources, including examples of custom resources and how to implement them.

### Example: Derived Container Resource (Redis)

[Section titled “Example: Derived Container Resource (Redis)”](#example-derived-container-resource-redis)

This example shows how to create a custom resource (`RedisResource`) that derives from `ContainerResource` and implements `IResourceWithConnectionString`. It demonstrates:

* Defining a data-only resource class.
* Implementing `IResourceWithConnectionString` with deferred evaluation using `ReferenceExpression`.
* Creating an `AddRedis` extension method that handles parameter validation, password management, event subscription, health checks, and container configuration using fluent APIs.

C# — RedisResourceExtensions.cs

```csharp
public static class RedisResourceExtensions
{
    // This extension method provides a convenient way to add a Redis resource to the Aspire application model.
    public static IResourceBuilder<RedisResource> AddRedis(
        this IDistributedApplicationBuilder builder, // Extends the main application builder interface.
        [ResourceName] string name,                   // The unique name for this Redis resource.
        int? port = null,                             // Optional host port mapping.
        IResourceBuilder<ParameterResource>? password = null) // Optional parameter resource for the password.
    {
        // 1. Validate inputs before any side effects
        // Ensure the builder and name are not null to prevent downstream errors.
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(name);


        // 2. Preserve or generate the password ParameterResource (deferred evaluation)
        // If a password parameter is provided, use it. Otherwise, create a default one.
        // ParameterResource allows the actual password value to be resolved later (e.g., from secrets).
        var passwordParameter = password?.Resource
            ?? ParameterResourceBuilderExtensions.CreateDefaultPasswordParameter(
                builder, $"{name}-password", special: false); // Creates a default password parameter if none is supplied.


        // 3. Instantiate the data-only RedisResource with its password parameter
        // Create the RedisResource instance, passing the name and the (potentially deferred) password parameter.
        var redis = new RedisResource(name, passwordParameter);


        // Variable to hold the resolved connection string at runtime.
        string? connectionString = null;


        // 4. Subscribe to ConnectionStringAvailableEvent to capture the connection string at runtime
        // This event hook allows capturing the connection string *after* it has been resolved
        // by the Aspire runtime, including potentially allocated ports and resolved parameter values.
        builder.Eventing.Subscribe<ConnectionStringAvailableEvent>(redis, async (@event, ct) =>
        {
            // Resolve the connection string using the resource's method.
            connectionString = await redis.GetConnectionStringAsync(ct).ConfigureAwait(false);
            // Ensure the connection string was actually resolved.
            if (connectionString == null)
            {
                throw new DistributedApplicationException(
                    $"Connection string for '{redis.Name}' was unexpectedly null.");
            }
        });


        // 5. Register a health check that uses the connection string once it becomes available
        // Define a unique key for the health check.
        var healthCheckKey = $"{name}_check";
        // Add a Redis-specific health check to the application's health check services.
        // The lambda `_ => connectionString ?? ...` ensures the health check uses the
        // connection string *after* it has been resolved by the event handler above.
        builder.Services
            .AddHealthChecks()
            .AddRedis(_ => connectionString
                                ?? throw new InvalidOperationException("Connection string is unavailable"), // Throw if accessed too early.
                        name: healthCheckKey); // Name the health check for identification.


        // 6. Add & configure container using the fluent builder pattern
        // Add the RedisResource instance to the application model.
        return builder.AddResource(redis)
                    // 6.a Expose the Redis TCP endpoint
                    // Map the host port (if provided) to the container's default Redis port (6379).
                    // Name the endpoint "tcp" for reference.
                    .WithEndpoint(
                        port: port,                             // Optional host port.
                        targetPort: 6379,                       // Default Redis port inside the container.
                        name: RedisResource.PrimaryEndpointName) // Use the constant defined in RedisResource.
                    // 6.b Specify container image and tag
                    // Define the Docker image to use for the Redis container.
                    .WithImage(RedisContainerImageTags.Image, RedisContainerImageTags.Tag)
                    // 6.c Configure container registry if needed
                    // Specify a container registry if the image is not on Docker Hub.
                    .WithImageRegistry(RedisContainerImageTags.Registry)
                    // 6.d Wire the health check into the resource
                    // Associate the previously defined health check with this resource.
                    // Aspire uses this for dashboard status and orchestration.
                    .WithHealthCheck(healthCheckKey)
                    // 6.e Define the container's entrypoint
                    // Override the default container entrypoint if necessary. Here, it's set to use shell.
                    .WithEntrypoint("/bin/sh")
                    // 6.f Pass the password ParameterResource into an environment variable
                    // Set environment variables for the container. This uses a callback to access
                    // the resource instance (`redis`) and its properties.
                    .WithEnvironment(context =>
                    {
                        // If a password parameter exists, expose it as the REDIS_PASSWORD environment variable.
                        // The actual value resolution happens later via the ParameterResource.
                        if (redis.PasswordParameter is { } pwd)
                        {
                            context.EnvironmentVariables["REDIS_PASSWORD"] = pwd;
                        }
                    })
                    // 6.g Build the container arguments lazily, preserving annotations
                    // Define the command-line arguments for the container. This also uses a callback
                    // to allow dynamic argument construction based on resource state or annotations.
                    .WithArgs(context =>
                    {
                        // Start with the basic command to run the Redis server.
                        var cmd = new List<string> { "redis-server" };


                        // If a password parameter is set, add the necessary Redis CLI arguments.
                        // Note: It uses the environment variable name set earlier ($REDIS_PASSWORD).
                        if (redis.PasswordParameter is not null)
                        {
                            cmd.Add("--requirepass");
                            cmd.Add("$REDIS_PASSWORD"); // Reference the environment variable.
                        }


                        // Check if a PersistenceAnnotation has been added to the resource.
                        // Annotations allow adding optional configuration or behavior.
                        if (redis.TryGetLastAnnotation<PersistenceAnnotation>(out var pa))
                        {
                            // If persistence is configured, add the corresponding Redis CLI arguments.
                            var interval = (pa.Interval ?? TimeSpan.FromSeconds(60))
                                .TotalSeconds
                                .ToString(CultureInfo.InvariantCulture);
                            cmd.Add("--save");
                            cmd.Add(interval); // Save interval in seconds.
                            cmd.Add(pa.KeysChangedThreshold.ToString(CultureInfo.InvariantCulture)); // Number of key changes threshold.
                        }


                        // Finalize the arguments for the shell entrypoint.
                        context.Args.Add("-c"); // Argument for /bin/sh to execute a command string.
                        context.Args.Add(string.Join(' ', cmd)); // Join all parts into a single command string.
                        return Task.CompletedTask; // Return a completed task as the callback is synchronous.
                    });
    }
}
```

C# — RedisResource.cs

```csharp
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.


namespace Aspire.Hosting.ApplicationModel;


// Data-only Redis resource derived from ContainerResource.
// It implements IResourceWithConnectionString to provide connection details.
public class RedisResource(string name)
    // Inherits common container properties and behaviors from ContainerResource.
    : ContainerResource(name),
    // Implements this interface to indicate it can provide a connection string.
    IResourceWithConnectionString
{
    // Constant for the primary endpoint name, used for consistency.
    internal const string PrimaryEndpointName = "tcp";


    // Backing field for the lazy-initialized primary endpoint reference.
    private EndpointReference? _primaryEndpoint;


    // Public property to get the EndpointReference for the primary "tcp" endpoint.
    // EndpointReference allows deferred access to endpoint details (host, port, URL).
    // It's lazy-initialized on first access.
    public EndpointReference PrimaryEndpoint
        => _primaryEndpoint ??= new(this, PrimaryEndpointName);


    // Property to hold the ParameterResource representing the Redis password.
    // ParameterResource allows the password value to be resolved later (e.g., from secrets).
    public ParameterResource? PasswordParameter { get; private set; }


    // Constructor that accepts a password ParameterResource.
    public RedisResource(string name, ParameterResource password)
        : this(name) // Call the base constructor.
    {
        PasswordParameter = password; // Store the provided password parameter.
    }


    // Helper method to build the ReferenceExpression for the connection string.
    // ReferenceExpression captures the structure of the connection string, including
    // references to endpoints and parameters, allowing deferred resolution.
    private ReferenceExpression BuildConnectionString()
    {
        // Use a builder to construct the expression piece by piece.
        var builder = new ReferenceExpressionBuilder();
        // Append the host and port part, referencing the PrimaryEndpoint properties.
        // .Property() ensures deferred resolution suitable for both run and publish modes.
        builder.Append($"{PrimaryEndpoint.Property(EndpointProperty.HostAndPort)}");
        // If a password parameter exists, append it to the connection string format.
        if (PasswordParameter is not null)
        {
            // Append the password parameter directly; ReferenceExpression handles its deferred resolution.
            builder.Append($",password={PasswordParameter}");
        }
        // Build and return the final ReferenceExpression.
        return builder.Build();
    }


    // Implementation of IResourceWithConnectionString.ConnectionStringExpression.
    // Provides the connection string as a ReferenceExpression, suitable for publish mode
    // where concrete values aren't available yet.
    public ReferenceExpression ConnectionStringExpression =>
        BuildConnectionString();
}
```

### Example: Custom Resource - Talking Clock

[Section titled “Example: Custom Resource - Talking Clock”](#example-custom-resource---talking-clock)

This example demonstrates creating a completely custom resource (`TalkingClockResource`) that doesn’t derive from built-in types. It shows:

* Defining a simple resource class.
* Implementing a custom lifecycle hook (`TalkingClockLifecycleHook`) to manage the resource’s behavior (starting, logging, state updates).
* Using `ResourceLoggerService` for per-resource logging.
* Using `ResourceNotificationService` to publish state updates.
* Creating an `AddTalkingClock` extension method to register the resource and its lifecycle hook.

C# — TalkingClockResource.cs

```csharp
// Define the custom resource type. It inherits from the base Aspire 'Resource' class.
// This class is primarily a data container; Aspire behavior is added via lifecycle hooks and extension methods.
public sealed class TalkingClockResource(string name) : Resource(name);
```

C# — TalkingClockLifecycleHook.cs

```csharp
// Define an Aspire lifecycle hook that implements the behavior for the TalkingClockResource.
// Lifecycle hooks allow plugging into the application's startup and shutdown sequences.
public sealed class TalkingClockLifecycleHook(
    // Aspire service for publishing resource state updates (e.g., Running, Starting).
    ResourceNotificationService notification,
    // Aspire service for publishing and subscribing to application-wide events.
    IDistributedApplicationEventing eventing,
    // Aspire service for getting a logger scoped to a specific resource.
    ResourceLoggerService loggerSvc,
    // General service provider for dependency injection if needed.
    IServiceProvider services) : IDistributedApplicationLifecycleHook // Implement the Aspire hook interface.
{
    // This method is called by Aspire after all resources have been initially added to the application model.
    public Task AfterResourcesCreatedAsync(
        DistributedApplicationModel model, // The Aspire application model containing all resources.
        CancellationToken token)           // Cancellation token for graceful shutdown.
    {
        // Find all instances of TalkingClockResource in the Aspire application model.
        foreach (var clock in model.Resources.OfType<TalkingClockResource>())
        {
            // Get an Aspire logger specifically for this clock instance. Logs will be associated with this resource in the dashboard.
            var log = loggerSvc.GetLogger(clock);


            // Start a background task to manage the clock's lifecycle and behavior.
            _ = Task.Run(async () =>
            {
                // Publish an Aspire event indicating that this resource is about to start.
                // Other components could subscribe to this event for pre-start actions.
                await eventing.PublishAsync(
                    new BeforeResourceStartedEvent(clock, services), token);


                // Log an informational message associated with the resource.
                log.LogInformation("Starting Talking Clock...");


                // Publish an initial state update to the Aspire notification service.
                // This sets the resource's state to 'Running' and records the start time.
                // The Aspire dashboard and other orchestrators observe these state updates.
                await notification.PublishUpdateAsync(clock, s => s with
                {
                    StartTimeStamp = DateTime.UtcNow,
                    State          = KnownResourceStates.Running // Use an Aspire well-known state.
                });


                // Enter the main loop that runs as long as cancellation is not requested.
                while (!token.IsCancellationRequested)
                {
                    // Log the current time, associated with the resource.
                    log.LogInformation("The time is {time}", DateTime.UtcNow);


                    // Publish a custom state update "Tick" using Aspire's ResourceStateSnapshot.
                    // This demonstrates using custom state strings and styles in the Aspire dashboard.
                    await notification.PublishUpdateAsync(clock,
                        s => s with { State = new ResourceStateSnapshot("Tick", KnownResourceStateStyles.Info) });


                    await Task.Delay(1000, token);


                    // Publish another custom state update "Tock" using Aspire's ResourceStateSnapshot.
                    await notification.PublishUpdateAsync(clock,
                        s => s with { State = new ResourceStateSnapshot("Tock", KnownResourceStateStyles.Success) });


                    await Task.Delay(1000, token);
                }
            }, token);
        }


        // Indicate that this hook's work (starting the background tasks) is complete for now.
        return Task.CompletedTask;
    }
    // Other Aspire lifecycle hook methods (e.g., BeforeStartAsync, AfterEndpointsAllocatedAsync) could be implemented here if needed.
}
```

C# — TalkingClockExtensions.cs

```csharp
// Define Aspire extension methods for adding the TalkingClockResource to the application builder.
// This provides a fluent API for users to add the custom resource.
public static class TalkingClockExtensions
{
    // The main Aspire extension method to add a TalkingClockResource.
    public static IResourceBuilder<TalkingClockResource> AddTalkingClock(
        this IDistributedApplicationBuilder builder, // Extends the Aspire application builder.
        string name)                                  // The name for this resource instance.
    {
        // Register the TalkingClockLifecycleHook with the DI container using Aspire's helper method.
        // The Aspire hosting infrastructure will automatically discover and run registered lifecycle hooks.
        builder.Services.TryAddLifecycleHook<TalkingClockLifecycleHook>();


        // Create a new instance of the TalkingClockResource.
        var clockResource = new TalkingClockResource(name);


        // Add the resource instance to the Aspire application builder and configure it using fluent APIs.
        return builder.AddResource(clockResource)
            // Use Aspire's ExcludeFromManifest to prevent this resource from being included in deployment manifests.
            .ExcludeFromManifest()
            // Use Aspire's WithInitialState to set an initial state snapshot for the resource.
            // This provides initial metadata visible in the Aspire dashboard.
            .WithInitialState(new CustomResourceSnapshot // Aspire type for custom resource state.
            {
                ResourceType      = "TalkingClock", // A string identifying the type of resource for Aspire.
                CreationTimeStamp = DateTime.UtcNow,
                State             = KnownResourceStates.NotStarted, // Use an Aspire well-known state.
                // Add custom properties displayed in the Aspire dashboard's resource details.
                Properties =
                [
                    // Use Aspire's known property key for source information.
                    new(CustomResourceKnownProperties.Source, "Talking Clock")
                ],
                // Add URLs associated with the resource, displayed as links in the Aspire dashboard.
                Urls =
                [
                    // Define a URL using Aspire's UrlSnapshot type.
                    new("Speaking Clock", "https://www.speaking-clock.com/", isInternal: false)
                ]
            });
    }
}
```

# Resource Hierarchies

> Learn how Aspire manages resources and their dependencies in your application.

Aspire supports modeling **parent-child relationships** between resources to express ownership, containment, and grouping.

Parent-child relationships serve two purposes:

* **Lifecycle Containment**: The child’s execution is tied to the parent’s — starting, stopping, and failures cascade from parent to child automatically.
* **Dashboard Visualization**: The child appears **nested beneath** the parent in dashboards and visualizations, improving readability.

### Lifecycle containment

[Section titled “Lifecycle containment”](#lifecycle-containment)

When a resource implements the `IResourceWithParent` interface, it declares **true containment** — meaning its lifecycle is controlled by its parent:

* **Startup**: The child resource will only start after its parent starts (though readiness is independent).
* **Shutdown**: If the parent is stopped or removed, the child is also stopped automatically.
* **Failure Propagation**: If a parent enters a terminal failure state (`FailedToStart`, etc.), dependent children are stopped.

Note

A logging sidecar container is tied to the lifecycle of a main application container — if the main app stops, the logging sidecar is also terminated.

### Visual grouping (without lifecycle impact)

[Section titled “Visual grouping (without lifecycle impact)”](#visual-grouping-without-lifecycle-impact)

Aspire also supports **visual-only parent-child relationships** using the `WithParentRelationship()` method during resource construction.

Visual relationships:

* Affect **only the dashboard layout**.
* **Do not affect lifecycle** — the resources are independent operationally.
* Improve **clarity** by logically grouping related components.

Tip

A Redis database container and a Redis Commander admin UI container can be grouped visually, even though they start independently.

### Manual Relationships — No Inference

[Section titled “Manual Relationships — No Inference”](#manual-relationships--no-inference)

Aspire **does not infer** parent-child relationships automatically based on names, dependencies, or network links.

You must **explicitly declare** relationships by either:

* **Implementing `IResourceWithParent`**: Creates lifecycle dependency and visual nesting.
* **Using `.WithParentRelationship()`**: Creates visual nesting only.

This explicitness ensures developers have full control over resource containment and presentation.

### Real-world scenarios

[Section titled “Real-world scenarios”](#real-world-scenarios)

The following scenarios illustrate how Aspire models parent-child relationships:

| Scenario                                        | Parent             | Child                  |
| ----------------------------------------------- | ------------------ | ---------------------- |
| Main application container with logging sidecar | App container      | Fluentd container      |
| Database with admin dashboard                   | Database container | Admin UI container     |
| Microservice with associated health monitor     | API container      | Health probe container |

## Values and references

[Section titled “Values and references”](#values-and-references)

In Aspire, configuration, connectivity details, and dependencies between distributed resources are modeled using **structured values**. These values capture relationships explicitly—not just as simple strings—making the application graph **portable, inspectable, and evolvable**.

Aspire represents these relationships through a **heterogeneous Directed Acyclic Graph (DAG)**. This graph tracks not only dependency ordering but also how **structured values** are passed between resources at multiple abstraction levels: configuration, connection, and runtime behavior.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddPostgres("pg");
var api = builder.AddProject("api").WithReference(db);
var web = builder.AddNpmApp("web").WithReference(api);


builder.Build().Run();
```

```
architecture-beta

  service db(logos:postgresql)[pg]
  service epr(iconoir:server-connection)[Endpoint Reference]
  service api(logos:dotnet)[api]
  service ctr(iconoir:server-connection)[Connection String Reference]
  service frontend(logos:react)[web]

  db:L <-- R:ctr
  ctr:L <-- R:api
  api:L <-- R:epr
  epr:L <-- R:frontend
```

### Special case: Endpoints

[Section titled “Special case: Endpoints”](#special-case-endpoints)

Normally, resource references form an acyclic graph — **no cycles allowed**. However, **endpoint references are treated specially** and **may form cycles** intentionally.

Endpoints are modeled as **external entities**:

* They are **not edges** in the resource dependency graph.

* They enable realistic mutual references like:

  * A frontend app and an OIDC server mutually referencing each other’s URLs (redirects, login callbacks).
  * A backend exposing CORS settings that reference the frontend URL.

Tip

Endpoints are managed separately from strict dependency edges to allow flexible, real-world service wiring.

### How the DAG forms

[Section titled “How the DAG forms”](#how-the-dag-forms)

Resources connect to each other through:

* **`WithReference()` calls**: Direct resource-to-resource dependencies.
* **Environment variables and CLI arguments**: Configuration values containing structured references.
* **Other configuration sources**: Settings populated with structured value references.

Each reference **adds an edge** to the graph, allowing Aspire to:

* Track dependency ordering.
* Propagate structured values cleanly between services.
* Validate application integrity before execution.

Note

Aspire **never infers references automatically** — all value flows must be explicitly authored by developers.

### Structured vs literal values

[Section titled “Structured vs literal values”](#structured-vs-literal-values)

Aspire distinguishes between **structured values** and **literal values**.

* **Structured values** preserve meaning (e.g., “this is a service URL” vs. “this is a raw string”).
* **Literal values** are inert — they are carried unchanged across modes.

At publish time and run time:

* Structured values are either **resolved** (if possible) or **translated into target artifacts** (e.g., environment variables, argument values, etc.).
* Literal values are simply copied.

Caution

**Flattening values too early destroys portability, environment substitution, and cross-platform compatibility.** Aspire delays flattening as long as possible to maintain graph fidelity.

### Value providers and deferred evaluation

[Section titled “Value providers and deferred evaluation”](#value-providers-and-deferred-evaluation)

Every structured value type in Aspire implements two fundamental interfaces:

| Interface                     | When Used    | Purpose                                                                           |
| ----------------------------- | ------------ | --------------------------------------------------------------------------------- |
| `IValueProvider`              | Run mode     | Resolves live values when the application starts.                                 |
| `IManifestExpressionProvider` | Publish mode | Emits structured expressions (like `{pg.outputs.url}`) into deployment artifacts. |

This dual-interface model enables **deferred evaluation**:

* During **publish**, structured placeholders are emitted — no runtime values are resolved yet.
* During **run**, structured references are resolved to live values like URLs, ports, or connection strings.

Internally, value providers are attached to environment variables, CLI arguments, configuration fields, and other structured outputs during application graph construction.

Note

Deferred evaluation guarantees that Aspire applications can be **published safely**, **deployed flexibly**, and **run consistently** across environments.

### Core value types (expanded)

[Section titled “Core value types (expanded)”](#core-value-types-expanded)

| Type                          | Represents                                            | Run Mode                                | Publish Mode                                               |
| ----------------------------- | ----------------------------------------------------- | --------------------------------------- | ---------------------------------------------------------- |
| `string`                      | A literal string value.                               | Same literal.                           | Same literal.                                              |
| `EndpointReference`           | A link to a named endpoint on another resource.       | Concrete URL (`http://localhost:5000`). | Target-specific endpoint translation (DNS, ingress, etc.). |
| `EndpointReferenceExpression` | A property of an endpoint (`Host`, `Port`, `Scheme`). | Concrete value.                         | Platform-specific translation.                             |
| `ConnectionStringReference`   | A symbolic pointer to a resource’s connection string. | Concrete string.                        | Token or externalized secret.                              |
| `ParameterResource`           | An external input, secret, or setting.                | Local dev value or environment lookup.  | Placeholder `${PARAM}` for substitution.                   |
| `ReferenceExpression`         | A composite string with embedded references.          | Concrete formatted string.              | Format string preserved for substitution.                  |

## `ReferenceExpression`

[Section titled “ReferenceExpression”](#referenceexpression)

`ReferenceExpression` preserves **structured value objects**—endpoints, parameters, connection strings, etc.—inside an interpolated string and defers evaluation until it is safe.

Aspire evaluates the model in **two distinct modes**:

| Phase       | `ReferenceExpression` yields                                            |
| ----------- | ----------------------------------------------------------------------- |
| **Publish** | Publisher-specific placeholder text (e.g., `{api.bindings.http.host}`). |
| **Run**     | Concrete value such as `localhost`.                                     |

**Example — Using `ReferenceExpression`:**

C# — AppHost.cs

```csharp
var ep = api.GetEndpoint("http");


builder.WithEnvironment("HEALTH_URL",
    ReferenceExpression.Create(
        $"https://{ep.Property(EndpointProperty.Host)}:{ep.Property(EndpointProperty.Port)}/health"
    )
);
```

*Publish manifest excerpt:*

```ini
HEALTH_URL=https://{api.bindings.http.host}:{api.bindings.http.port}/health
```

*Run-time value:*

```ini
HEALTH_URL=https://localhost:5000/health
```

Tip

**Avoid resolving values directly** — build the string inside `ReferenceExpression.Create()` to preserve structure.

### Alternate pattern using `ExecutionContext`

[Section titled “Alternate pattern using ExecutionContext”](#alternate-pattern-using-executioncontext)

C# — AppHost.cs

```csharp
var ep = api.GetEndpoint("http");


if (builder.ExecutionContext.IsRunMode)
{
    builder.WithEnvironment("HEALTH_URL",
        $"{ep.Url}/health"); // concrete
}
else
{
    builder.WithEnvironment("HEALTH_URL",
        ReferenceExpression.Create($"{ep}/health")); // structured
}
```

### Pattern used by `IResourceWithConnectionString`

[Section titled “Pattern used by IResourceWithConnectionString”](#pattern-used-by-iresourcewithconnectionstring)

A common implementation builds the connection string with `ReferenceExpression`, mixing any value objects (endpoint properties, parameters, other references):

```csharp
private static ReferenceExpression BuildConnectionString(
    EndpointReference endpoint,
    ParameterResource  passwordParameter)
{
    var host = endpoint.Property(EndpointProperty.IPV4Host);
    var port = endpoint.Property(EndpointProperty.Port);
    var pwd  = passwordParameter;


    return ReferenceExpression.Create(
        $"Server={host},{port};User ID=sa;Password={pwd};TrustServerCertificate=true");
}
```

### Common errors

[Section titled “Common errors”](#common-errors)

The following patterns are common mistakes when using `ReferenceExpression`:

| Error                                  | Correct approach                                        |
| -------------------------------------- | ------------------------------------------------------- |
| Build the string first, wrap later.    | Build **inside** `ReferenceExpression.Create(...)`.     |
| Access `Endpoint.Url` during publish.  | Use `Endpoint.Property(...)` in the expression.         |
| Mix resolved strings and placeholders. | Keep the entire value inside one `ReferenceExpression`. |

## Endpoint primitives

[Section titled “Endpoint primitives”](#endpoint-primitives)

The `EndpointReference` is the fundamental type used to interact with another resource’s endpoint. It provides properties such as:

* `Url`: The full URL of the endpoint, e.g., `http://localhost:6379`.
* `Host`: The hostname or IP address of the endpoint.
* `Port`: The port number of the endpoint.

These properties are dynamically resolved during the application’s startup sequence. Accessing them before the endpoints are allocated results in an exception.

### `IResourceWithEndpoints`

[Section titled “IResourceWithEndpoints”](#iresourcewithendpoints)

Resources supporting endpoints should implement `IResourceWithEndpoints`, enabling the use of `GetEndpoint(name)` to retrieve an `EndpointReference`. This is implemented on the built-in `ProjectResource`, `ContainerResource` and `ExecutableResource`. It allows endpoints to be programmatically accessed and passed between resources.

Example — Endpoint Access and Resolution

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddContainer("redis", "redis")
                   .WithEndpoint(name: "tcp", targetPort: 6379);


// Get a reference to the "tcp" endpoint by name
var endpoint = redis.GetEndpoint("tcp");


builder.Build().Run();
```

### What does “allocated” mean?

[Section titled “What does “allocated” mean?”](#what-does-allocated-mean)

An endpoint is **allocated** when Aspire resolves its runtime values (e.g., `Host`, `Port`, `Url`) during **run mode**. Allocation happens as part of the **startup sequence**, ensuring endpoints are ready for use in local development.

In **publish mode**, endpoints are not allocated with concrete values. Instead, their values are represented as **manifest expressions** or bindings (e.g., `{redis.bindings.tcp.host}:{redis.bindings.tcp.port}`) that are resolved by the deployment infrastructure.

#### Comparison: Run Mode vs Publish Mode

[Section titled “Comparison: Run Mode vs Publish Mode”](#comparison-run-mode-vs-publish-mode)

| **Context**         | **Run Mode**                             | **Publish Mode**                                                  |
| ------------------- | ---------------------------------------- | ----------------------------------------------------------------- |
| **Endpoint Values** | Fully resolved (`tcp://localhost:6379`). | Represented by manifest expressions (`{redis.bindings.tcp.url}`). |
| **Use Case**        | Local development and debugging.         | Deployed environments (e.g., Kubernetes, Azure, AWS, etc.).       |
| **Behavior**        | Endpoints are allocated dynamically.     | Endpoint placeholders resolve at runtime.                         |

Use the `IsAllocated` property on an `EndpointReference` to check whether an endpoint has been allocated before accessing its runtime values.

### Accessing Allocated Endpoints Safely

[Section titled “Accessing Allocated Endpoints Safely”](#accessing-allocated-endpoints-safely)

Endpoint resolution happens during the startup sequence of the `DistributedApplication`. To safely access endpoint values (e.g., `Url`, `Host`, `Port`), you must wait until endpoints are allocated. Aspire provides eventing APIs, such as `AfterEndpointsAllocatedEvent`, to access endpoints after allocation. These APIs ensure code executes only when endpoints are ready.

Example — Checking Allocation and Using Eventing

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a Redis container with a TCP endpoint
var redis = builder.AddContainer("redis", "redis")
                   .WithEndpoint(name: "tcp", targetPort: 6379);


// Retrieve the EndpointReference
var endpoint = redis.GetEndpoint("tcp");


// Check allocation status and access Url
Console.WriteLine($"IsAllocated: {endpoint.IsAllocated}");


try
{
    Console.WriteLine($"Url: {endpoint.Url}");
}
catch (Exception ex)
{
    Console.WriteLine($"Error accessing Url: {ex.Message}");
}


// Subscribe to AfterEndpointsAllocatedEvent for resolved properties
builder.Eventing.Subscribe<AfterEndpointsAllocatedEvent>(
    (@event, cancellationToken) =>
    {
        Console.WriteLine($"Endpoint allocated: {endpoint.IsAllocated}");
        Console.WriteLine($"Resolved Url: {endpoint.Url}");
        return Task.CompletedTask;
    });


// Start the application
builder.Build().Run();
```

The preceding code will output different results depending on whether the application is running in **run mode** or **publish mode**:

**Run Mode**:

Run Mode — Console Output

```bash
IsAllocated: True
Resolved Url: http://localhost:6379
```

**Publish Mode**:

Publish Mode — Console Output

```bash
IsAllocated: False
Error accessing Url: Endpoint has not been allocated.
```

Tip

The overloads of `WithEnvironment` that take a callback run after endpoints have been allocated.

## Referencing Endpoints from Other Resources

[Section titled “Referencing Endpoints from Other Resources”](#referencing-endpoints-from-other-resources)

This section covers how to reference endpoints from other resources in Aspire, allowing you to wire up dependencies and configurations effectively.

### Using `WithReference`

[Section titled “Using WithReference”](#using-withreference)

The `WithReference` API allows you to pass an endpoint reference directly to a target resource.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddContainer("redis", "redis")
                   .WithEndpoint(name: "tcp", targetPort: 6379);


builder.AddProject<Projects.Worker>("worker")
       .WithReference(redis.GetEndpoint("tcp"));


builder.Build().Run();
```

`WithReference` is optimized for applications that use service discovery.

### Using `WithEnvironment`

[Section titled “Using WithEnvironment”](#using-withenvironment)

The `WithEnvironment` API exposes endpoint details as environment variables, enabling runtime configuration.

Example — Passing Redis Endpoint as Environment Variable

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddContainer("redis", "redis")
                   .WithEndpoint(name: "tcp", targetPort: 6379);


builder.AddProject<Worker>("worker")
       .WithEnvironment("RedisUrl", redis.GetEndpoint("tcp"));


builder.Build().Run();
```

`WithEnvironment` gives full control over the configuration names injected into the target resource.

## `EndpointReferenceExpression` — Accessing Endpoint Parts

[Section titled “EndpointReferenceExpression — Accessing Endpoint Parts”](#endpointreferenceexpression--accessing-endpoint-parts)

`EndpointReferenceExpression` represents **one field** of an endpoint (`Host`, `Port`, `Scheme`, etc.). Call `endpoint.Property(...)` to get that field; the result is still a structured value and stays deferred until publish/run time.

| Need                                    | Pattern                                                |
| --------------------------------------- | ------------------------------------------------------ |
| Only one part (e.g., host)              | `endpoint.Property(EndpointProperty.Host)`             |
| Compose multiple parts into one setting | Build a `ReferenceExpression` (see dedicated section). |

Example — Expose Redis Host and Port

```csharp
var redis = builder.AddContainer("redis", "redis")
                   .WithEndpoint("tcp", 6379);


builder.AddProject("worker")
       .WithEnvironment(ctx =>
       {
           var ep = redis.GetEndpoint("tcp");
           ctx.EnvironmentVariables["REDIS_HOST"] = ep.Property(EndpointProperty.Host);
           ctx.EnvironmentVariables["REDIS_PORT"] = ep.Property(EndpointProperty.Port);
       });
```

In this pattern, `ep.Property(...)` returns an `EndpointReferenceExpression`, which is a structured value that will be resolved at runtime.

Example — Build a Full Redis URL

```csharp
var ep = redis.GetEndpoint("tcp");


builder.WithEnvironment("REDIS_URL",
    ReferenceExpression.Create(
        $"redis://{ep.Property(EndpointProperty.HostAndPort)}"
    )
);
```

This pattern avoids resolving endpoint values prematurely and works in both publish and run modes.

### `EndpointProperty` API Surface

[Section titled “EndpointProperty API Surface”](#endpointproperty-api-surface)

| Property               | Meaning                                          |
| ---------------------- | ------------------------------------------------ |
| `Url`                  | Fully qualified URL (`scheme://host:port`).      |
| `Host` or `IPV4Host`   | Host name or IPv4 literal.                       |
| `Port` or `TargetPort` | Allocated host port vs. container-internal port. |
| `Scheme`               | `http`, `tcp`, etc.                              |
| `HostAndPort`          | Convenience composite (`host:port`).             |

The `EndpointReference` type exposes live or placeholder values for an endpoint and provides `.Property(...)` to create an `EndpointReferenceExpression`.

Key members:

| Member                                                   | Description                                            |
| -------------------------------------------------------- | ------------------------------------------------------ |
| `Url`, `Host`, `Port`, `Scheme`, `TargetPort`            | Concrete in run mode; undefined in publish mode.       |
| `bool IsAllocated`                                       | Indicates if concrete values are available (run mode). |
| `EndpointReferenceExpression Property(EndpointProperty)` | Creates a deferred expression for one field.           |

`EndpointReferenceExpression` implements the same `IManifestExpressionProvider` / `IValueProvider` pair, so it can be embedded in a `ReferenceExpression` or resolved directly with `GetValueAsync()`.

## Context-based endpoint resolution

[Section titled “Context-based endpoint resolution”](#context-based-endpoint-resolution)

Aspire resolves endpoints differently based on the relationship between the source and target resources. This ensures proper communication across all environments.

### Resolution Rules

[Section titled “Resolution Rules”](#resolution-rules)

| **Source**           | **Target**           | **Resolution**                              | **Example URL**             |
| -------------------- | -------------------- | ------------------------------------------- | --------------------------- |
| Container            | Container            | Container network (`resource name:port`).   | `redis:6379`                |
| Executable / Project | Container            | Host network (`localhost:port`).            | `localhost:6379`            |
| Container            | Executable / Project | Host network (`host.docker.internal:port`). | `host.docker.internal:5000` |

#### Advanced Scenario: Dynamic Endpoint Resolution Across Contexts

[Section titled “Advanced Scenario: Dynamic Endpoint Resolution Across Contexts”](#advanced-scenario-dynamic-endpoint-resolution-across-contexts)

Aspire resolves endpoints differently based on the execution context (e.g., run mode vs. publish mode, container vs. executable). Sometimes you want to override that resolution behavior.

Consider the following scenario, where the example shows a project that is going to setup up grafana and keycloak. We need to give the project the address for container-to-container communication between grafana and keycloak even though the target resource is a project. The project isn’t directly talking to keycloak or grafana, it’s a mediator that is just setting URLs in the appropriate configuration of each container.

### Cross-Context Communication Example

[Section titled “Cross-Context Communication Example”](#cross-context-communication-example)

The following code demonstrates how to set environment variables for a project that needs to communicate with other resources like Grafana and Keycloak. It ensures that the URLs are correctly resolved based on the execution context (run mode vs. publish mode).

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keycloak = builder.AddKeycloak("keycloak", 8080);
var grafana = builder.AddContainer("grafana", "grafana/grafana");


var api = builder.AddProject<Projects.Api>("api")
    .WithEnvironment(ctx =>
    {
        var keyCloakEndpoint = keycloak.GetEndpoint("http");
        var grafanaEndpoint = grafana.GetEndpoint("http");


        ctx.EnvironmentVariables["Grafana__Url"] = grafanaEndpoint;


        if (ctx.ExecutionContext.IsRunMode)
        {
            // The project needs to get the URL for keycloak in the context
            // of the container network, but since this is a project, it'll
            // resolve the url in the context of the host network. We get
            // the runtime url and change the host and port to match the
            // container network pattern (host = resource name, port = target port ?? port)
            var keycloakUrl = new UriBuilder(keyCloakEndpoint.Url)
            {
                Host = keycloak.Resource.Name,
                Port = keyCloakEndpoint.TargetPort ?? keyCloakEndpoint.Port,
            };


            ctx.EnvironmentVariables["Keycloak__AuthServerUrl"] = keycloakUrl.ToString();
        }
        else
        {
            // In publish mode let the endpoint resolver handle the URL
            ctx.EnvironmentVariables["Keycloak__AuthServerUrl"] = keyCloakEndpoint;
        }
    });


builder.Build().Run();
```

# Resource Model

> Learn how Aspire's resource model simplifies the development and management of distributed applications.

Aspire’s AppHost represents a collection of resources, known as the “resource model”. This model allows developers to define and manage the various components and services that make up their applications, providing a unified way to interact with these resources throughout the development lifecycle.

The resource model is a **directed acyclic graph (DAG)**, where resources are nodes and dependencies are edges. This structure allows Aspire to manage complex relationships between resources, ensuring that they can be started, stopped, and monitored in a predictable manner.

## Basic example

[Section titled “Basic example”](#basic-example)

A quick example that shows the basic usage:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddPostgres("pg").AddDatabase("appdata");
var api = builder.AddProject<Projects.Api>("api").WithReference(db);
var web = builder.AddNpmApp("web", "../web").WithReference(api);


builder.Build().Run();
```

The preceding `AppHost` code defines an architecture with three resources:

```
architecture-beta

  service db(logos:postgresql)[pq]
  service api(logos:dotnet)[api]
  service frontend(logos:react)[web]

  api:R --> L:db
  frontend:R --> L:api
```

1. Use `.AddXyz(...)` helper methods to add and declare resources (e.g., `.AddPostgres(...)`, `.AddProject(...)`).

2. Use `.WithReference(...)` (or similar) to represent explicit dependencies between resources.

3. Call `Build().Run()` - Aspire builds the application model (graph) and executes it handling:

   * Port allocation
   * Environment variables
   * Startup order

## Resource basics

[Section titled “Resource basics”](#resource-basics)

In Aspire, a **resource** is the fundamental unit for modeling your distributed applications. Resources represent services, infrastructure elements, or supporting components that together compose a distributed system.

Resources in Aspire implement the `IResource` interface, with most built-in resources deriving from the base `Resource` class.

* Resources are **inert by default** — they are **pure data objects** that describe capabilities, configuration, and relationships. They **do not manage their own lifecycle** (e.g., starting, stopping, checking health). Resource lifecycle is coordinated externally by orchestrators and lifecycle hooks.
* Resources are identified by a **unique name** within the application graph. This name forms the basis for referencing, wiring, and visualizing resources.

### Annotations

[Section titled “Annotations”](#annotations)

Resource metadata is expressed through **annotations**, which are strongly-typed objects implementing the `IResourceAnnotation` interface.

Annotations allow attaching additional structured information to a resource without modifying its core class. They are the **primary extensibility mechanism** in Aspire, enabling:

* Core system behaviors (e.g., service discovery, connection strings, health probes).
* Custom extensions and third-party integrations.
* Layering of optional capabilities without inheritance or tight coupling.

Tip

Resources might have annotations for environment variables, endpoint information, or service discovery metadata that other resources require.

For additional information on annotations, see [Resource API Patterns: Annotations](/architecture/resource-api-patterns/#annotations).

### Fluent extension methods

[Section titled “Fluent extension methods”](#fluent-extension-methods)

Resources are typically added using fluent **extension methods** such as `.AddRedis(...)`, `.AddProject(...)`, or `.AddPostgres(...)`. Extension methods encapsulate:

* **Construction** of the resource object.
* **Attachment of annotations** that describe defaults, discovery hints, or runtime behavior.
* **Relationships** like wiring up dependencies (e.g., via `.WithReference(...)`).

This pattern improves the developer experience by:

* Setting **sane defaults** automatically.
* Making **required configuration obvious and discoverable**.
* Providing a **product-like feel** to adding infrastructure.

Note

Without extension methods, adding a resource manually would require constructing it directly, setting annotations manually, and remembering to wire relationships by hand.

### Adding resources and wiring dependencies

[Section titled “Adding resources and wiring dependencies”](#adding-resources-and-wiring-dependencies)

To continue from the previous example, here’s how you can add resources and wire them together in the `AppHost`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddPostgres("pg").AddDatabase("appdata");
var api = builder.AddProject<Projects.Api>("api").WithReference(db);
var web = builder.AddNpmApp("web", "../web").WithReference(api);


builder.Build().Run();
```

The preceding example:

* A PostgreSQL server (`pg`) is created and configured with a database named `appdata`.
* A backend service (`api`) is created and connected to the database.
* A frontend app (`web`) is created and reverse-proxies traffic to the backend.

Each resource participates in the application graph passively, with dependencies expressed through references.

### Key takeaways

[Section titled “Key takeaways”](#key-takeaways)

Resources **describe** capabilities rather than controlling them directly. **Annotations** provide a rich, extensible metadata system for resources, while **fluent extension methods** guide developers toward correct and complete configurations. **Names** serve as the identity anchors for wiring and dependency resolution throughout the application graph.

## Built-in resources and lifecycle

[Section titled “Built-in resources and lifecycle”](#built-in-resources-and-lifecycle)

In Aspire, many common infrastructure and application patterns are available as **built-in resource types**. Built-in resources simplify modeling real-world systems by providing ready-made building blocks that automatically integrate with the Aspire runtime, lifecycle management, health tracking, and dashboard visualization.

Built-in resources:

* Handle **lifecycle transitions** automatically.
* Raise **lifecycle events** (like startup and readiness signals).
* Push **status updates** to the system for real-time orchestration and monitoring.
* Expose **endpoints, environment variables, and metadata** needed for dependent resources.

They help developers express distributed applications **consistently** without needing to manually orchestrate startup, shutdown, and dependency wiring.

### Known resource states

[Section titled “Known resource states”](#known-resource-states)

All resources in Aspire begin in an `Unknown` state when added to the application graph. This ensures that the **resource graph can be fully constructed** before any execution, dependency resolution, or publishing occurs.

| State              | Meaning                                                                                              |
| ------------------ | ---------------------------------------------------------------------------------------------------- |
| `Exited`           | Completed execution (typically for short-lived jobs, migrations, one-shot tasks).                    |
| `FailedToStart`    | Failed during startup initialization.                                                                |
| `Finished`         | Ran to successful completion (used for batch workloads or scripts).                                  |
| `Hidden`           | Present in the model but intentionally hidden from dashboard UI (e.g., infrastructure helpers).      |
| `NotStarted`       | Defined but not yet scheduled to start.                                                              |
| `Running`          | Successfully started; may have separate application-level health probing.                            |
| `RuntimeUnhealthy` | The container or host runtime environment (e.g., Docker daemon) is unavailable, preventing start-up. |
| `Starting`         | Actively starting; readiness not yet confirmed.                                                      |
| `Stopping`         | Resource is shutting down gracefully.                                                                |
| `Unknown`          | Default state when first added to the graph. No execution planned yet.                               |
| `TerminalStates`   | List of terminal states (e.g., `Finished`, `Exited`, `FailedToStart`).                               |
| `Waiting`          | Awaiting dependencies to become ready (e.g., using `.WaitFor(...)`).                                 |

Resource states drive:

* **Readiness checks** to unblock dependent resources.
* **Dashboard visualization** and state coloring.
* **Orchestration sequencing** for startup and shutdown.
* **Health monitoring** at runtime.

### Built-in types

[Section titled “Built-in types”](#built-in-types)

Aspire provides a set of fundamental built-in resource types that serve as the foundation for modeling execution units:

| Type                 | Purpose                                                 |
| -------------------- | ------------------------------------------------------- |
| `ContainerResource`  | Runs Docker containers as resources.                    |
| `ExecutableResource` | Launches arbitrary executables or scripts as resources. |
| `ProjectResource`    | Runs a .NET project directly (build + launch workflow). |
| `ParameterResource`  | Represents a parameter or configuration value.          |

These types are **infrastructure-oriented primitives**. They model how code and applications are packaged and executed.

Note

Specialized services like Redis, Postgres, or RabbitMQ are **not** true “built-in” resource types in Aspire core — they are typically provided through external packages or extensions that build on `ContainerResource` or custom resource types.

Built-in types:

* Automatically participate in resource orchestration.
* Raise standard lifecycle events without manual intervention.
* Report health and readiness status.
* Expose connection endpoints for dependent services.

Custom resources must **opt-in manually** to these behaviors.

### Well-known lifecycle events

[Section titled “Well-known lifecycle events”](#well-known-lifecycle-events)

Aspire defines standard events to orchestrate resource lifecycles, in the following order:

1. `InitializeResourceEvent`: Fired when a resource is first created to kick off the resource’s lifecycle.
2. `ConnectionStringAvailableEvent`: Fired when a connection string is ready, enabling dependent resources to wire themselves dynamically based on the resource’s outputs.
3. `ResourceEndpointsAllocatedEvent`: Fired when endpoints have been allocated and can be evaluated successfully.
4. `BeforeResourceStartedEvent`: Fired just before the resource starts executing as a last-chance dynamic setup or validation point.
5. `ResourceReadyEvent`: Fired when the resource is considered “ready,” unblocking any dependents waiting for the resource.

Lifecycle events allow:

* Dynamic reconfiguration just before startup.
* Dependent resource activation based on readiness.
* Wiring services together based on runtime-generated outputs.

Caution

Event publishing is **synchronous and blocking** — event handlers can delay further execution.

### Status reporting

[Section titled “Status reporting”](#status-reporting)

Beyond events, Aspire uses **asynchronous state snapshots** to report resource status continuously.

* `ResourceNotificationService` handles snapshot updates.

* Status updates involve:

  1. Receiving the previous immutable snapshot.
  2. Mutating to a new snapshot representing the updated state.
  3. Publishing the new snapshot to the dashboard and orchestrators.

Snapshots:

* Always reflect the **latest known status**.
* Are **non-blocking** and do not delay orchestration.
* Drive **dashboard visualization** and orchestration decisions.

Note

Events represent **moment-in-time actions**. Snapshots represent **ongoing state**.

### Resource health

[Section titled “Resource health”](#resource-health)

Aspire integrates with .NET health checks to monitor the status of resources after they have started. The health check mechanism is tied into the resource lifecycle:

1. When a resource transitions to the `Running` state, Aspire checks if it has any associated health check annotations (typically added via `.WithHealthCheck(...)`).
2. **If health checks are configured:** Aspire begins executing these checks periodically. The resource is considered fully “ready” only after its health checks pass successfully. Once healthy, Aspire automatically publishes the `ResourceReadyEvent`.
3. **If no health checks are configured:** The resource is considered “ready” as soon as it enters the `Running` state. Aspire automatically publishes the `ResourceReadyEvent` immediately in this case.

This automatic handling ensures that dependent resources (using mechanisms like `.WaitFor(...)`) only proceed when the target resource is truly ready, either by simply running or by passing its defined health checks.

Danger

Developers should **not** manually publish the `ResourceReadyEvent`. Aspire manages the transition to the ready state based on the presence and outcome of health checks. Manually firing this event can interfere with the orchestration logic.

### Resource logging

[Section titled “Resource logging”](#resource-logging)

Aspire supports logging output on a per-resource basis, which is displayed in the console window and can be surfaced in the dashboard. This log stream is especially useful for monitoring what a resource is doing in real time.

For built-in resources, Aspire captures and forwards output from:

* `stdout` and `stderr` of containers (e.g., Docker).
* Process output from executables or .NET projects.

For custom resources, developers can write directly to a resource’s log using the `ResourceLoggerService`.

This service provides an `ILogger` scoped to the individual resource instance, enabling human-readable, contextual logging.

```csharp
var logger = resourceLoggerService.GetLogger(myResource);
logger.LogInformation("Starting provisioning…");
```

Note

A full example demonstrating custom resource logging with the Talking Clock resource can be found in the [Full Examples](/architecture/resource-examples/) section.

#### Common resource logging APIs

[Section titled “Common resource logging APIs”](#common-resource-logging-apis)

The following APIs are likely to be used when working with resource logging:

| API                                          | Description                 |
| -------------------------------------------- | --------------------------- |
| `ResourceLoggerService.GetLogger(IResource)` | Returns a scoped `ILogger`. |
| `ResourceLoggerService.WatchAsync`           | Stream log lines.           |

Resource logs are designed to be human-readable and provide insights into the resource’s behavior, state changes, and any issues encountered during execution. Use the `ResourceNotificationService` to publish structured state changes.

## Standard interfaces

[Section titled “Standard interfaces”](#standard-interfaces)

Aspire defines a set of **optional standard interfaces** that allow resources to declare their capabilities in a structured, discoverable way. Implementing these interfaces enables **dynamic wiring, publishing, service discovery, and orchestration** without hardcoded type knowledge.

These interfaces are the foundation for Aspire’s polymorphic behaviors — enabling tools, publishers, and the runtime to treat resources uniformly based on what they can do, rather than what they are.

### Benefits of standard interfaces

[Section titled “Benefits of standard interfaces”](#benefits-of-standard-interfaces)

* **Dynamic discovery:** Tooling and runtime systems can automatically adapt based on resource capabilities.
* **Loose coupling:** Behaviors (like environment wiring, service discovery, or connection sharing) are opt-in.
* **Extensibility:** New resource types can integrate seamlessly into the Aspire ecosystem by implementing one or more interfaces.

### Common interfaces

[Section titled “Common interfaces”](#common-interfaces)

| Interface                       | Purpose                                                                       |
| ------------------------------- | ----------------------------------------------------------------------------- |
| `IResourceWithArgs`             | Supplies additional CLI arguments when launching a project or executable.     |
| `IResourceWithConnectionString` | Provides a connection string output for consumers to connect to the resource. |
| `IResourceWithEndpoints`        | Exposes ports, URLs, or connection points that other resources can consume.   |
| `IResourceWithEnvironment`      | Supports setting environment variables for the resource.                      |
| `IResourceWithServiceDiscovery` | Registers a service hostname and metadata for discovery by other resources.   |
| `IResourceWithWaitSupport`      | This resource can wait for other resources.                                   |
| `IResourceWithWithoutLifetime`  | This resource does not have a lifecycle. (e.g. connection string, parameter)  |

### Examples per interface

[Section titled “Examples per interface”](#examples-per-interface)

**`IResourceWithEnvironment`**

```csharp
builder.WithEnvironment("MY_SETTING", "value");
```

Allows setting environment variables that are passed to the resource when it starts.

**`IResourceWithServiceDiscovery`**

```csharp
builder.WithReference(myResourceWithDiscovery);
```

Exposes the resource via DNS-style service discovery. Downstream resources can refer to it by logical name.

**`IResourceWithEndpoints`**

```csharp
builder.GetEndpoint("http");
```

When a resource implements `IResourceWithEndpoints`, it allows referencing specific endpoints (e.g., `http`, `tcp`) for reverse proxies or connection targets.

**`IResourceWithConnectionString`**

```csharp
builder.WithReference(myDatabaseResource);
```

Allows wiring a database connection string into environment variables, configurations, or CLI arguments.

**`IResourceWithArgs`**

```csharp
builder.WithArgs("2", "--url", endpoint);
```

Allows setting command-line arguments on the resource.

**`IResourceWithWaitSupport`**

```csharp
builder.WaitFor(otherResource)
```

This resource can wait on other resources. A `ParameterResource` is an example of resources that cannot wait.

Note

These APIs and behaviors are defined in the [📦 Aspire.Hosting](https://www.nuget.org/packages/Aspire.Hosting) package.

### Importance of polymorphism

[Section titled “Importance of polymorphism”](#importance-of-polymorphism)

By modeling behaviors through interfaces rather than concrete types, Aspire enables:

* **Tooling flexibility**: Publishers can wire environment variables, endpoints, and arguments generically.
* **Runtime uniformity**: Dashboards and orchestrators treat resources based on capabilities, not type-specific logic.
* **Ecosystem extensibility**: New resource types can plug into the system without modifying core code.

Interfaces allow Aspire to remain **open, flexible, and adaptable** as new types of services, platforms, and deployment targets emerge.

# Resource Publishing

Aspire provides a flexible mechanism for publishing resource manifests, enabling seamless integration with various deployment environments. Resources are serialized into JSON format, which can be consumed by deployment tools.

Custom resources that publish JSON manifest entries must:

1. **Register a callback** using `ManifestPublishingCallbackAnnotation` in the constructor.
2. **Implement the callback** to write JSON via `ManifestPublishingContext.Writer`.
3. **Use value objects** (`IManifestExpressionProvider`) for structured fields.

Resources can opt-out of being included in the publishing manifest entirely by calling the `ExcludeFromManifest()` extension method on the `IResourceBuilder<T>`. Resources marked this way will be omitted when generating publishing assets like Docker Compose files or Kubernetes manifests.

### Registering the callback

[Section titled “Registering the callback”](#registering-the-callback)

Consider the following example of a custom Azure Bicep resource that publishes its parameters to a manifest:

C# — AzureBicepResource.cs

```csharp
public class AzureBicepResource : Resource, IAzureResource
{
    public AzureBicepResource(string name, ...) : base(name)
    {
        Annotations.Add(new ManifestPublishingCallbackAnnotation(WriteToManifest));
    }
}
```

### Writing to the manifest

[Section titled “Writing to the manifest”](#writing-to-the-manifest)

As an example, the `WriteToManifest` method serializes the resource’s parameters into a JSON object. This method is invoked during the manifest publishing phase:

```csharp
public virtual void WriteToManifest(ManifestPublishingContext context)
{
    context.Writer.WriteString("type", "azure.bicep.v0");
    context.Writer.WriteString("path", context.GetManifestRelativePath(path));


    context.Writer.WriteStartObject("params");
    foreach (var kv in Parameters)
    {
        context.Writer.WritePropertyName(kv.Key);
        var v = kv.Value is IManifestExpressionProvider p ? p.ValueExpression : kv.Value?.ToString();
        context.Writer.WriteString(kv.Key, v ?? "");
        context.TryAddDependentResources(kv.Value);
    }
    context.Writer.WriteEndObject();
}
```

### Summary table

[Section titled “Summary table”](#summary-table)

The following table summarizes the key steps and conventions for publishing resources:

| Step                        | API / Call                                                                   | Purpose                                        |
| --------------------------- | ---------------------------------------------------------------------------- | ---------------------------------------------- |
| Register callback           | `Annotations.Add(new ManifestPublishingCallbackAnnotation(WriteToManifest))` | Hook custom JSON writer                        |
| Implement `WriteToManifest` | Use `context.Writer` to emit JSON properties                                 | Define resource manifest representation        |
| Structured fields           | `IManifestExpressionProvider.ValueExpression`                                | Ensure publish-time placeholders are preserved |

## Key conventions

[Section titled “Key conventions”](#key-conventions)

| Convention                       | Rationale                                      |
| -------------------------------- | ---------------------------------------------- |
| Data-only resource classes       | Separates data model from behavior             |
| `*BuilderExtensions` classes     | Groups all API methods per integration         |
| Public annotations               | Allow dynamic runtime addition/removal         |
| `[ResourceName]` attribute       | Enforces valid resource naming at compile time |
| Preserve parameter/value objects | Ensures deferred evaluation of secrets/outputs |

# Save the date!

> Aspire Conf <h6>March 23, 9:00 PT</h6> <p>Save the date and tune in for our free, livestream event. </p><p> Discover Aspire and learn how it can transform the way you build and deploy your distributed apps and agents.</p>

## Come meet the new Aspire

Discover Aspire and learn how it can transform the way you build and deploy your distributed apps and agents. With code-centric control, orchestrate and observe simple or complex systems with no rewrites, and deploy anywhere. Come meet the new Aspire.

We’ll have sessions for everyone and every skill level. All developers welcome no matter what languages, frameworks, compute environments, clouds, or coding agents you use. See how Aspire provides the primitives that make AI-assisted development practical and fun.

Streaming on [YouTube](https://www.youtube.com/@aspiredotdev/) and [Twitch](https://www.twitch.tv/aspiredotdev), ask questions and interact with us live. We hope to see you there!

**Stay tuned for the full agenda.**



[Get Aspire ](../get-started/install-cli/)Install Aspire and streamline your workflow.

[Explore docs ](../docs/)Learn how to model, run, and deploy apps with Aspire.

# Contributor guide for aspire.dev

Thank you for your interest in contributing to `aspire.dev`! Whether you’re fixing typos, adding new content, or improving existing pages, this guide will help you get started and your contributions are greatly appreciated.

## 🚀 About this site

[Section titled “🚀 About this site”](#-about-this-site)

This documentation site is built using [Starlight](https://starlight.astro.build/), a full-featured documentation theme built on top of [Astro](https://astro.build/). Starlight provides a fast, accessible, and SEO-friendly foundation, while Astro’s component-based architecture makes it easy to create and maintain content.

## 🤔 Ways to contribute

[Section titled “🤔 Ways to contribute”](#-ways-to-contribute)

There are several ways you can contribute to `aspire.dev`:

* **Small fixes** - Correct typos, grammar mistakes, or formatting issues.
* **Content additions** - Add new documentation pages or sections to cover missing topics.
* **Content improvements** - Enhance existing documentation with clearer explanations, updated information, or additional examples.
* **Code contributions** - Improve the site’s codebase, fix bugs, or add new features.

There’s also different methods for contributing, from selecting the **Edit page** button at the bottom of any documentation page, to using [GitHub Codespaces](/get-started/github-codespaces/) for a fully configured development environment, or setting up a local development environment on your machine.

### Click-edit

[Section titled “Click-edit”](#click-edit)

Selecting the **Edit page** button at the bottom of any documentation page will take you to the corresponding file in the GitHub repository. From there, you can make changes directly in the GitHub web interface and submit a pull request. This is best suited for small fixes or minor content additions.

Tip

If you haven’t noticed the **Edit page** button, scroll to the bottom of this page and you should see it there:

![Edit page button at the bottom of a documentation page](/_astro/edit-page.DKe4ror6.png)

### Codespaces

[Section titled “Codespaces”](#codespaces)

To avoid local setup, you can use [GitHub Codespaces](/get-started/github-codespaces/) for a fully configured development environment in the cloud. This is ideal for larger contributions or if you prefer not to set up a local environment.

[![Open microsoft\&#x2F;aspire.dev in GitHub Codespaces](https://github.com/codespaces/badge.svg "Open microsoft\&#x2F;aspire.dev in GitHub Codespaces")](https://codespaces.new/microsoft/aspire.dev)

Note

If you choose to use Codespaces, please still refer to the rest of this guide for information on writing style, code quality, and the contribution workflow. Continue reading at the [Writing style section below](#%EF%B8%8F-writing-style-guide).

### Local development

[Section titled “Local development”](#local-development)

If you prefer to work locally, you can set up a development environment on your machine. Follow the instructions below to get started.

## 📋 Prerequisites

[Section titled “📋 Prerequisites”](#-prerequisites)

Before you begin, ensure you have the following installed:

* [Node.js](https://nodejs.org/en/download) (LTS version recommended) - For running the development server
* [pnpm](https://pnpm.io/installation) - Fast, disk space efficient package manager
* [Visual Studio Code](https://code.visualstudio.com/) - Recommended code editor
* [Git](https://git-scm.com/downloads) - For version control

## ⚙️ Local dev setup

[Section titled “⚙️ Local dev setup”](#️-local-dev-setup)

1. Clone the `aspire.dev` repository.

   ```bash
   git clone https://github.com/microsoft/aspire.dev.git
   ```

2. Navigate to the `aspire.dev` directory.

   ```bash
   cd aspire.dev
   ```

3. Install dependencies

   * pnpm

     ```bash
     pnpm install
     ```

   * npm

     ```bash
     npm install
     ```

     Stop using npm

     If you’re not already using `pnpm`, consider switching! [![pnpm logo](/_astro/pnpm.Bm2ieaYB.svg)](https://pnpm.io/installation "https://pnpm.io/installation") It’s faster and more efficient than `npm` or `yarn`.

     Install globally with:

     ```bash
     npm install -g pnpm
     ```

4. Run the development server

   ```bash
   pnpm dev
   ```

   This starts the Vite development server for the front end and provide hot-reload capabilities.

5. View the site locally

   Open your browser to `http://localhost:4321` (or the port shown in your terminal)

### Known formatting limitations

[Section titled “Known formatting limitations”](#known-formatting-limitations)

We expose `lint` and `format` scripts in the `package.json` to help maintain code quality and consistency. This isn’t something that you’re need to run manually. However, regardless of whether or not you run these scrips, be aware of the following known limitation when working with MDX files.

Caution

**Prettier and Steps components**

The Prettier formatter has a known limitation when formatting MDX files containing the `Steps` component. Prettier incorrectly converts all ordered lists (`ol`) as a single line, which causes the steps to render malformed.

**Workaround:** Always ensure there is a blank line between each step item in a `Steps` component. For example:

```md
<Steps>


1. First step with content


1. Second step with content


1. Third step with content


</Steps>
```

Without the blank lines between steps, the inner content won’t render correctly. If you notice steps appearing malformed after running `pnpm format`, manually add the blank lines back before committing.

## ➡️ Git workflow

[Section titled “➡️ Git workflow”](#️-git-workflow)

1. Start from an issue (or a discussion that leads to an issue)

2. Fork the repository

   As mentioned in the local dev setup section, start by forking the `aspire.dev` repository to your own GitHub account

3. Create a new branch for your changes

   ```bash
   git checkout -b feature/your-feature-name
   ```

4. Make your changes, considering the writing style guide

5. Commit with descriptive messages

6. Push to your fork

7. Create a pull request, and always follow the [Code of Conduct](https://github.com/microsoft/aspire.dev/blob/main/CODE_OF_CONDUCT.md)

## ✍️ Writing style guide

[Section titled “✍️ Writing style guide”](#️-writing-style-guide)

When contributing to `aspire.dev`, follow these writing guidelines to ensure consistency and clarity:

* **Use clear and concise language** - Aim for simplicity. Avoid jargon unless necessary, and explain technical terms when they first appear.
* **Be consistent** - Follow existing conventions in terminology, formatting, and structure. Refer to other documentation pages for examples.
* **Use active voice** - Write in active voice to make instructions and explanations more direct and engaging.
* **Use sentence case** - Capitalize only the first word and proper nouns in headings, sidebars, and table of contents.
* **Be inclusive** - Use inclusive language that respects all readers. Avoid gendered terms and stereotypes.
* **Provide examples** - Where applicable, include code snippets or examples to illustrate concepts.
* **Use proper grammar and spelling** - Proofread your contributions to ensure they are free of errors and typos.
* **Structure content logically** - Use headings, subheadings, and lists to organize information in a way that is easy to follow.
* **Link to relevant resources** - When mentioning concepts, tools, or related documentation, provide links to help readers find more information.
* **Follow formatting conventions** - Use consistent formatting for code snippets, commands, and technical terms. Refer to the examples in this guide for guidance.
* **Review existing content** - Before adding new content, review existing documentation to avoid duplication and ensure coherence.

## 📝 Write Markdown

[Section titled “📝 Write Markdown”](#-write-markdown)

Here are some common Markdown formatting examples to help you write documentation:

### Frontmatter

[Section titled “Frontmatter”](#frontmatter)

You can customize individual pages in `aspire.dev` by setting values in their frontmatter. Frontmatter is set at the top of your files between `---` separators:

src/content/docs/example.md

```md
---
title: My page title
---


Page content follows the second `---`.
```

Every page must include at least a `title`. See the [frontmatter reference](https://starlight.astro.build/reference/frontmatter/) for all available fields and how to add custom fields.

### Headings

[Section titled “Headings”](#headings)

Use `#` symbols to create headings. More `#` symbols create smaller headings:

src/content/docs/example.md

```md
## Heading 2
### Heading 3
#### Heading 4
```

Headings are automatically created as bookmarks (shareable deep links) for easy navigation.

Note

Avoid using Heading 1 (`#`) in your content, as it is reserved for the page title defined in frontmatter.

Tip

To configure which headings appear in the **On this page** sidebar, use the `tableOfContents` frontmatter field. See the [tableOfContents reference](https://starlight.astro.build/reference/frontmatter/#tableofcontents) for more details.

### Text formatting

[Section titled “Text formatting”](#text-formatting)

**Bold text** is created with double asterisks:

src/content/docs/example.md

```md
**Bold text**
```

*Italic text* is created with an `_` (or single asterisks `*`—while valid, for consistency we recommend using `_`):

src/content/docs/example.md

```md
_Italic text_
```

`Inline code` is created with backticks:

src/content/docs/example.md

```md
`Inline code`
```

### Links

[Section titled “Links”](#links)

Links are created with square brackets and parentheses:

src/content/docs/example.md

```md
[David Pine](https://davidpine.net)
```

Renders as:

[David Pine](https://davidpine.net)

Additionally, when linking to other pages within `aspire.dev`, use site relative paths:

src/content/docs/example.md

```md
[Build your first Aspire app](/get-started/first-app/)
```

Renders as:

[Build your first Aspire app](/get-started/first-app/)

Note

Site relative links should always include a trailing slash `/` at the end to ensure proper navigation.

This is confugred by default for `aspire.dev`, for more information see [Astro Docs: trailingSlash](https://docs.astro.build/en/reference/configuration-reference/#trailingslash).

### Lists

[Section titled “Lists”](#lists)

Unordered lists use `-` (or `*`—while valid, for consistency we recommend using `-`):

src/content/docs/example.md

```md
- First item
- Second item
- Third item
```

Renders as:

* First item
* Second item
* Third item

Ordered lists use numbers:

src/content/docs/example.md

```md
1. First step
2. Second step
3. Third step
```

Renders as:

1. First step
2. Second step
3. Third step

### Code blocks

[Section titled “Code blocks”](#code-blocks)

Use triple backticks with a language identifier for syntax highlighting:

src/content/docs/example.md

````md
```csharp title="C# — AppHost.cs"
var builder = DistributedApplication.CreateBuilder(args);
builder.AddProject<Projects.ApiService>("apiservice");
```
````

Renders as:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);
builder.AddProject<Projects.ApiService>("apiservice");
```

To add a title to a code block, use this syntax:

src/content/docs/example.md

````md
```csharp title="Program.cs"
var builder = DistributedApplication.CreateBuilder(args);
builder.AddProject<Projects.ApiService>("apiservice");
```
````

Renders as:

Program.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);
builder.AddProject<Projects.ApiService>("apiservice");
```

### Blockquotes

[Section titled “Blockquotes”](#blockquotes)

Use `>` to create blockquotes:

src/content/docs/example.md

```md
> This is a note or important callout.
```

Renders as:

> This is a note or important callout.

### Tables

[Section titled “Tables”](#tables)

Create tables using pipes `|` and hyphens `-`:

src/content/docs/example.md

```md
| Feature | Description | Status |
|--|--|--|
| Dashboard | Web-based monitoring | ✅ Available |
| Telemetry | OpenTelemetry support | ✅ Available |
| Deployment | Kubernetes deployment | 🚧 Preview |
```

Renders as:

| Feature    | Description           | Status      |
| ---------- | --------------------- | ----------- |
| Dashboard  | Web-based monitoring  | ✅ Available |
| Telemetry  | OpenTelemetry support | ✅ Available |
| Deployment | Kubernetes deployment | 🚧 Preview  |

Tip

You can align columns using colons: `| :--- |` for left, `| :---: |` for center, and `| ---: |` for right alignment.

### Horizontal rules

[Section titled “Horizontal rules”](#horizontal-rules)

Create a horizontal rule with three or more hyphens, asterisks, or underscores:

src/content/docs/example.md

```md
---
```

Renders as:

***

### Strikethrough

[Section titled “Strikethrough”](#strikethrough)

Use double tildes to create strikethrough text:

src/content/docs/example.md

```md
~~This text is crossed out~~
```

Renders as:

~~This text is crossed out~~

### Task lists

[Section titled “Task lists”](#task-lists)

Create interactive task lists in Markdown:

```md
- [x] Add Aspire to your project
- [x] Configure service defaults
- [ ] Deploy to Azure
- [ ] Set up monitoring
```

Renders as:

* [x] Add Aspire to your project
* [x] Configure service defaults
* [ ] Deploy to Azure
* [ ] Set up monitoring

### Nested lists

[Section titled “Nested lists”](#nested-lists)

You can nest lists by indenting with two spaces:

```md
- Aspire components
  - Databases
    - PostgreSQL
    - Redis
  - Messaging
    - RabbitMQ
    - Azure Service Bus
```

Renders as:

* Aspire components

  * Databases

    * PostgreSQL
    * Redis

  * Messaging

    * RabbitMQ
    * Azure Service Bus

### Escaping characters

[Section titled “Escaping characters”](#escaping-characters)

Use a backslash `\` to escape special Markdown characters:

```md
\*This text is not italic\*
\[This is not a link\]
```

Renders as:

\*This text is not italic\* \[This is not a link]

### Line breaks

[Section titled “Line breaks”](#line-breaks)

End a line with two or more spaces to create a line break:

```md
First line with two spaces at the end
Second line
```

Or use an empty line to create a paragraph break.

## ➕ Markdown extensions

[Section titled “➕ Markdown extensions”](#-markdown-extensions)

The `aspire.dev` site supports several Markdown extensions to enhance your documentation:

### Mermaid diagrams

[Section titled “Mermaid diagrams”](#mermaid-diagrams)

You can write mermaid diagrams as code blocks:

src/content/docs/example.md

````md
```mermaid
graph TD
    A[build-apiservice] --> C[push-apiservice]
    B[provision-container-registry] --> C
    C --> D[deploy-apiservice]
    E[provision-cosmosdb] --> D
    F[provision-identity] --> D
```
````

Renders as:

```
graph TD
    A[build-apiservice] --> C[push-apiservice]
    B[provision-container-registry] --> C
    C --> D[deploy-apiservice]
    E[provision-cosmosdb] --> D
    F[provision-identity] --> D
```

### Asides

[Section titled “Asides”](#asides)

[Asides](https://starlight.astro.build/components/asides/), “admonitions”, “callouts”, or “alerts” are special highlighted blocks used to draw attention to important information, tips, warnings, or notes.

The `:::` syntax creates asides given a type of `note`, `tip`, `caution`, or `danger` in both Markdown and [MDX](#write-mdx):

src/content/docs/example.md

````md
:::note
Some content in an aside.
:::


:::caution
Some cautionary content.
:::


:::tip


Other content is also supported in asides.


```js
// A code snippet, for example.
```


:::


:::danger
Do not give your password to anyone.
:::
````

Renders as:

Note

Some content in an aside.

Caution

Some cautionary content.

Tip

Other content is also supported in asides.

```js
// A code snippet, for example.
```

Danger

Do not give your password to anyone.

Additionally, `aspire.dev` supports [GitHub Alerts](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts) syntax with the [community plugin](https://starlight-github-alerts.netlify.app/getting-started/):

For example, you can write:

#### Note

[Section titled “Note”](#note)

src/content/docs/example.md

```md
> [!NOTE]
> Useful information that users should know, even when skimming content.
```

Renders as:

Note

Useful information that users should know, even when skimming content.

See the full demo here: [Starlight: GitHub Alerts](https://starlight-github-alerts.netlify.app/demo/).

For the Starlight component, see the [Aside component](#aside-component) section below.

## ☑️ Write MDX

[Section titled “☑️ Write MDX”](#️-write-mdx)

MDX files use the `.mdx` extension and combine standard Markdown with the power of JSX. This means you can write content and seamlessly embed interactive components—all in one file.

[Learn more about MDX](https://mdxjs.com/docs/what-is-mdx/).

With the power of Astro components, you can enhance your documentation with interactive elements, custom layouts, and dynamic content. To use any of the built-in Starlight or custom components available in `aspire.dev`, simply import them at the top of your MDX file and use them like regular JSX components.

### LinkButton component

[Section titled “LinkButton component”](#linkbutton-component)

src/content/docs/example.mdx

```mdx
---
title: Example MDX Page
---


import { LinkButton } from '@astrojs/starlight/components';


Here's an example of an MDX page with a custom button:


<LinkButton href="https://aspire.dev" variant="primary">
  Visit aspire.dev
</LinkButton>
```

Renders as:

Here’s an example of an MDX page with a custom button:

[Visit aspire.dev](https://aspire.dev)

For all available components, see: [Starlight: Components](https://starlight.astro.build/components/using-components/).

### Aside component

[Section titled “Aside component”](#aside-component)

The `Aside` component from Starlight can be used to create asides in your documentation:

src/content/docs/example.mdx

````mdx
---
title: Example MDX Page
---


import { Aside } from '@astrojs/starlight/components';


<Aside>Some content in an aside.</Aside>


<Aside type="caution">Some cautionary content.</Aside>


<Aside type="tip">


  Other content is also supported in asides.


  ```js
  // A code snippet, for example.
  ```


</Aside>


<Aside type="danger">Do not give your password to anyone.</Aside>
````

Renders as:

Note

Some content in an aside.

Caution

Some cautionary content.

Tip

Other content is also supported in asides.

```js
// A code snippet, for example.
```

Danger

Do not give your password to anyone.

### Using custom components

[Section titled “Using custom components”](#using-custom-components)

To use custom components available in `aspire.dev`, import them at the top of your MDX file. Custom component imports rely on configured aliases—have a look at the `tsconfig.json` file for more information:

JSON — tsconfig.json

```json
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"],
  "compilerOptions": {
    "paths": {
      "@assets/*": ["./src/assets/*"],
      "@components/*": ["./src/components/*"],
      "@data/*": ["./src/data/*"],
      "@utils/*": ["./src/utils/*"]
    }
  }
}
```

By using the `@components` alias, you can easily import any custom component from the `frontend/src/components/` directory. For example, to import the `LearnMore` component used in this guide:

src/content/docs/example.mdx

```mdx
---
title: Example MDX Page
---


import LearnMore from '@components/LearnMore.astro';


Here's an example of using the `LearnMore` component:


<LearnMore>
  Please give our [repository a star on GitHub! ⭐](https://github.com/microsoft/aspire.dev)
</LearnMore>
```

Renders as:

Here’s an example of using the `LearnMore` component:

Please give our [repository a star on GitHub! ⭐](https://github.com/microsoft/aspire.dev)

## 🆘 Getting help

[Section titled “🆘 Getting help”](#-getting-help)

* **Issues** - Report bugs or request features via [GitHub Issues](https://github.com/microsoft/aspire.dev/issues)
* **Discussions** - Join conversations in [GitHub Discussions](https://github.com/microsoft/aspire.dev/discussions)
* **Discord** - Connect with the community on the [Aspire Discord](https://discord.com/invite/raNPcaaSj8)

# Contributors 🤝

> We're grateful for the contributions of our community members who help make Aspire better every day.

Aspire wouldn’t be what it is today without the amazing contributions from our community. From code contributions to documentation improvements, every bit helps us grow and improve. Your ideas have the potential to shape the future of the project, and issues you uncover help others be successful too. Interested in contributing?

[Contribute to aspire.dev!](/community/contributor-guide/)

## 🙏 Aspire contributors

[Section titled “🙏 Aspire contributors”](#-aspire-contributors)

Thank you to all the community members who have contributed to Aspire! Your efforts help shape the future of this project. Collaborating on Aspire means joining a vibrant community that’s building the next evolution of cloud-native applications. Aspire is the successor to Microsoft’s experimental “Project Tye”—originally called “Astra”—and its ambitions are far reaching and extensible. By contributing, you’re helping to define new patterns, unlock extensibility, and drive innovation for developers everywhere. Jump in and help us push the boundaries of what’s possible!

<!-- Thanks to @5t3ph for https://smolcss.dev/#smol-avatar-list! -->

* [![JamesNK](https://avatars.githubusercontent.com/u/303201?s=64 "JamesNK")](https://github.com/JamesNK)
* [![eerhardt](https://avatars.githubusercontent.com/u/8291187?s=64 "eerhardt")](https://github.com/eerhardt)
* [![mitchdenny](https://avatars.githubusercontent.com/u/513398?s=64 "mitchdenny")](https://github.com/mitchdenny)
* [![davidfowl](https://avatars.githubusercontent.com/u/95136?s=64 "davidfowl")](https://github.com/davidfowl)
* [![joperezr](https://avatars.githubusercontent.com/u/13854455?s=64 "joperezr")](https://github.com/joperezr)
* [![radical](https://avatars.githubusercontent.com/u/1472?s=64 "radical")](https://github.com/radical)
* [![adamint](https://avatars.githubusercontent.com/u/20359921?s=64 "adamint")](https://github.com/adamint)
* [![sebastienros](https://avatars.githubusercontent.com/u/1165805?s=64 "sebastienros")](https://github.com/sebastienros)
* [![DamianEdwards](https://avatars.githubusercontent.com/u/249088?s=64 "DamianEdwards")](https://github.com/DamianEdwards)
* [![danegsta](https://avatars.githubusercontent.com/u/50252651?s=64 "danegsta")](https://github.com/danegsta)
* [![dotnet-bot](https://avatars.githubusercontent.com/u/9011267?s=64 "dotnet-bot")](https://github.com/dotnet-bot)
* [![tlmii](https://avatars.githubusercontent.com/u/9613109?s=64 "tlmii")](https://github.com/tlmii)
* [![drewnoakes](https://avatars.githubusercontent.com/u/350947?s=64 "drewnoakes")](https://github.com/drewnoakes)
* [![ReubenBond](https://avatars.githubusercontent.com/u/203839?s=64 "ReubenBond")](https://github.com/ReubenBond)
* [![danmoseley](https://avatars.githubusercontent.com/u/6385855?s=64 "danmoseley")](https://github.com/danmoseley)
* [![karolz-ms](https://avatars.githubusercontent.com/u/15271049?s=64 "karolz-ms")](https://github.com/karolz-ms)
* [![Alirexaa](https://avatars.githubusercontent.com/u/70141416?s=64 "Alirexaa")](https://github.com/Alirexaa)
* [![RussKie](https://avatars.githubusercontent.com/u/4403806?s=64 "RussKie")](https://github.com/RussKie)
* [![afscrome](https://avatars.githubusercontent.com/u/289860?s=64 "afscrome")](https://github.com/afscrome)
* [![smitpatel](https://avatars.githubusercontent.com/u/1528107?s=64 "smitpatel")](https://github.com/smitpatel)
* [![IEvangelist](https://avatars.githubusercontent.com/u/7679720?s=64 "IEvangelist")](https://github.com/IEvangelist)
* [![BrennanConroy](https://avatars.githubusercontent.com/u/7574801?s=64 "BrennanConroy")](https://github.com/BrennanConroy)
* [![davidebbo](https://avatars.githubusercontent.com/u/556238?s=64 "davidebbo")](https://github.com/davidebbo)
* [![timheuer](https://avatars.githubusercontent.com/u/4821?s=64 "timheuer")](https://github.com/timheuer)
* [![Zombach](https://avatars.githubusercontent.com/u/52016832?s=64 "Zombach")](https://github.com/Zombach)
* [![vnbaaij](https://avatars.githubusercontent.com/u/1761079?s=64 "vnbaaij")](https://github.com/vnbaaij)
* [![aaronpowell](https://avatars.githubusercontent.com/u/434140?s=64 "aaronpowell")](https://github.com/aaronpowell)
* [![benjaminpetit](https://avatars.githubusercontent.com/u/20427417?s=64 "benjaminpetit")](https://github.com/benjaminpetit)
* [![maddymontaquila](https://avatars.githubusercontent.com/u/12660687?s=64 "maddymontaquila")](https://github.com/maddymontaquila)
* [![wtgodbe](https://avatars.githubusercontent.com/u/14283640?s=64 "wtgodbe")](https://github.com/wtgodbe)
* [![mmitche](https://avatars.githubusercontent.com/u/8725170?s=64 "mmitche")](https://github.com/mmitche)
* [![martincostello](https://avatars.githubusercontent.com/u/1439341?s=64 "martincostello")](https://github.com/martincostello)
* [![DeagleGross](https://avatars.githubusercontent.com/u/31598696?s=64 "DeagleGross")](https://github.com/DeagleGross)
* [![MattKotsenas](https://avatars.githubusercontent.com/u/51421?s=64 "MattKotsenas")](https://github.com/MattKotsenas)
* [![ShilpiRach](https://avatars.githubusercontent.com/u/233947509?s=64 "ShilpiRach")](https://github.com/ShilpiRach)
* [![Youssef1313](https://avatars.githubusercontent.com/u/31348972?s=64 "Youssef1313")](https://github.com/Youssef1313)
* [![jfversluis](https://avatars.githubusercontent.com/u/939291?s=64 "jfversluis")](https://github.com/jfversluis)
* [![vicancy](https://avatars.githubusercontent.com/u/668244?s=64 "vicancy")](https://github.com/vicancy)
* [![normj](https://avatars.githubusercontent.com/u/1653751?s=64 "normj")](https://github.com/normj)
* [![WeihanLi](https://avatars.githubusercontent.com/u/7604648?s=64 "WeihanLi")](https://github.com/WeihanLi)
* [![ArcturusZhang](https://avatars.githubusercontent.com/u/10554446?s=64 "ArcturusZhang")](https://github.com/ArcturusZhang)
* [![MatsM16](https://avatars.githubusercontent.com/u/17270481?s=64 "MatsM16")](https://github.com/MatsM16)
* [![bjorkstromm](https://avatars.githubusercontent.com/u/7863439?s=64 "bjorkstromm")](https://github.com/bjorkstromm)
* [![zhiyuanliang-ms](https://avatars.githubusercontent.com/u/141655842?s=64 "zhiyuanliang-ms")](https://github.com/zhiyuanliang-ms)
* [![bart-vmware](https://avatars.githubusercontent.com/u/104792814?s=64 "bart-vmware")](https://github.com/bart-vmware)
* [![kiapanahi](https://avatars.githubusercontent.com/u/4063578?s=64 "kiapanahi")](https://github.com/kiapanahi)
* [![phenning](https://avatars.githubusercontent.com/u/2433750?s=64 "phenning")](https://github.com/phenning)
* [![captainsafia](https://avatars.githubusercontent.com/u/1857993?s=64 "captainsafia")](https://github.com/captainsafia)
* [![hewe-saxo](https://avatars.githubusercontent.com/u/105797295?s=64 "hewe-saxo")](https://github.com/hewe-saxo)
* [![matthebrown](https://avatars.githubusercontent.com/u/45107667?s=64 "matthebrown")](https://github.com/matthebrown)
* [![Meir017](https://avatars.githubusercontent.com/u/9786571?s=64 "Meir017")](https://github.com/Meir017)
* [![oising](https://avatars.githubusercontent.com/u/1844001?s=64 "oising")](https://github.com/oising)
* [![VincentH-Net](https://avatars.githubusercontent.com/u/1872271?s=64 "VincentH-Net")](https://github.com/VincentH-Net)
* [![kundadebdatta](https://avatars.githubusercontent.com/u/87335885?s=64 "kundadebdatta")](https://github.com/kundadebdatta)
* [![prom3theu5](https://avatars.githubusercontent.com/u/1518610?s=64 "prom3theu5")](https://github.com/prom3theu5)
* [![cqnguy23](https://avatars.githubusercontent.com/u/44353219?s=64 "cqnguy23")](https://github.com/cqnguy23)
* [![paulomorgado](https://avatars.githubusercontent.com/u/470455?s=64 "paulomorgado")](https://github.com/paulomorgado)
* [![bgrainger](https://avatars.githubusercontent.com/u/188129?s=64 "bgrainger")](https://github.com/bgrainger)
* [![Kahbazi](https://avatars.githubusercontent.com/u/19396090?s=64 "Kahbazi")](https://github.com/Kahbazi)
* [![akoeplinger](https://avatars.githubusercontent.com/u/1376924?s=64 "akoeplinger")](https://github.com/akoeplinger)
* [![stbau04](https://avatars.githubusercontent.com/u/67107950?s=64 "stbau04")](https://github.com/stbau04)
* [![Pilchie](https://avatars.githubusercontent.com/u/312835?s=64 "Pilchie")](https://github.com/Pilchie)
* [![mtmk](https://avatars.githubusercontent.com/u/386903?s=64 "mtmk")](https://github.com/mtmk)
* [![sliekens](https://avatars.githubusercontent.com/u/1583241?s=64 "sliekens")](https://github.com/sliekens)
* [![SimonCropp](https://avatars.githubusercontent.com/u/122666?s=64 "SimonCropp")](https://github.com/SimonCropp)
* [![samsp-msft](https://avatars.githubusercontent.com/u/54915162?s=64 "samsp-msft")](https://github.com/samsp-msft)
* [![RafaelJCamara](https://avatars.githubusercontent.com/u/52082556?s=64 "RafaelJCamara")](https://github.com/RafaelJCamara)
* [![philliphoff](https://avatars.githubusercontent.com/u/6402946?s=64 "philliphoff")](https://github.com/philliphoff)
* [![g7ed6e](https://avatars.githubusercontent.com/u/681739?s=64 "g7ed6e")](https://github.com/g7ed6e)
* [![baronfel](https://avatars.githubusercontent.com/u/573979?s=64 "baronfel")](https://github.com/baronfel)
* [![adegeo](https://avatars.githubusercontent.com/u/67293991?s=64 "adegeo")](https://github.com/adegeo)
* [![vhvb1989](https://avatars.githubusercontent.com/u/24213737?s=64 "vhvb1989")](https://github.com/vhvb1989)
* [![Varorbc](https://avatars.githubusercontent.com/u/5714438?s=64 "Varorbc")](https://github.com/Varorbc)
* [![twsouthwick](https://avatars.githubusercontent.com/u/583206?s=64 "twsouthwick")](https://github.com/twsouthwick)
* [![stephentoub](https://avatars.githubusercontent.com/u/2642209?s=64 "stephentoub")](https://github.com/stephentoub)
* [![MackinnonBuck](https://avatars.githubusercontent.com/u/10456961?s=64 "MackinnonBuck")](https://github.com/MackinnonBuck)
* [![Kumima](https://avatars.githubusercontent.com/u/93973732?s=64 "Kumima")](https://github.com/Kumima)
* [![JoshLove-msft](https://avatars.githubusercontent.com/u/54595583?s=64 "JoshLove-msft")](https://github.com/JoshLove-msft)
* [![brendandburns](https://avatars.githubusercontent.com/u/5751682?s=64 "brendandburns")](https://github.com/brendandburns)
* [![andrevlins](https://avatars.githubusercontent.com/u/5325718?s=64 "andrevlins")](https://github.com/andrevlins)
* [![adityamandaleeka](https://avatars.githubusercontent.com/u/219224?s=64 "adityamandaleeka")](https://github.com/adityamandaleeka)
* [![julioct](https://avatars.githubusercontent.com/u/2374270?s=64 "julioct")](https://github.com/julioct)
* [![marshalhayes](https://avatars.githubusercontent.com/u/17213165?s=64 "marshalhayes")](https://github.com/marshalhayes)
* [![MermaidIsla](https://avatars.githubusercontent.com/u/155835512?s=64 "MermaidIsla")](https://github.com/MermaidIsla)
* [![mfcollins3](https://avatars.githubusercontent.com/u/104274?s=64 "mfcollins3")](https://github.com/mfcollins3)
* [![rzikm](https://avatars.githubusercontent.com/u/32671551?s=64 "rzikm")](https://github.com/rzikm)
* [![SteveSandersonMS](https://avatars.githubusercontent.com/u/1101362?s=64 "SteveSandersonMS")](https://github.com/SteveSandersonMS)
* [![vlesierse](https://avatars.githubusercontent.com/u/270232?s=64 "vlesierse")](https://github.com/vlesierse)
* [![WhitWaldo](https://avatars.githubusercontent.com/u/2238529?s=64 "WhitWaldo")](https://github.com/WhitWaldo)
* [![paule96](https://avatars.githubusercontent.com/u/11291885?s=64 "paule96")](https://github.com/paule96)
* [![illay1994](https://avatars.githubusercontent.com/u/10198202?s=64 "illay1994")](https://github.com/illay1994)
* [![Evangelink](https://avatars.githubusercontent.com/u/11340282?s=64 "Evangelink")](https://github.com/Evangelink)
* [![liammclennan](https://avatars.githubusercontent.com/u/271514?s=64 "liammclennan")](https://github.com/liammclennan)
* [![adamsitnik](https://avatars.githubusercontent.com/u/6011991?s=64 "adamsitnik")](https://github.com/adamsitnik)
* [![askpt](https://avatars.githubusercontent.com/u/2493377?s=64 "askpt")](https://github.com/askpt)
* [![bwateratmsft](https://avatars.githubusercontent.com/u/36966225?s=64 "bwateratmsft")](https://github.com/bwateratmsft)
* [![cmeyertons](https://avatars.githubusercontent.com/u/19917677?s=64 "cmeyertons")](https://github.com/cmeyertons)
* [![cmdkeen](https://avatars.githubusercontent.com/u/54735?s=64 "cmdkeen")](https://github.com/cmdkeen)
* [![chrisdcmoore](https://avatars.githubusercontent.com/u/5628773?s=64 "chrisdcmoore")](https://github.com/chrisdcmoore)
* [![danespinosa](https://avatars.githubusercontent.com/u/30415120?s=64 "danespinosa")](https://github.com/danespinosa)
* [![Dona278](https://avatars.githubusercontent.com/u/10567243?s=64 "Dona278")](https://github.com/Dona278)
* [![ericmutta](https://avatars.githubusercontent.com/u/20465797?s=64 "ericmutta")](https://github.com/ericmutta)
* [![Daluur](https://avatars.githubusercontent.com/u/6771251?s=64 "Daluur")](https://github.com/Daluur)
* [![james-gould](https://avatars.githubusercontent.com/u/15638113?s=64 "james-gould")](https://github.com/james-gould)
* [![jeffhandley](https://avatars.githubusercontent.com/u/1031940?s=64 "jeffhandley")](https://github.com/jeffhandley)
* [![GMouaad](https://avatars.githubusercontent.com/u/22234383?s=64 "GMouaad")](https://github.com/GMouaad)
* [![Mrxx99](https://avatars.githubusercontent.com/u/33566379?s=64 "Mrxx99")](https://github.com/Mrxx99)
* [![murataslan1](https://avatars.githubusercontent.com/u/78961478?s=64 "murataslan1")](https://github.com/murataslan1)
* [![OptimusPi](https://avatars.githubusercontent.com/u/16853743?s=64 "OptimusPi")](https://github.com/OptimusPi)
* [![foxminchan](https://avatars.githubusercontent.com/u/56079798?s=64 "foxminchan")](https://github.com/foxminchan)
* [![GryBsh](https://avatars.githubusercontent.com/u/120699894?s=64 "GryBsh")](https://github.com/GryBsh)
* [![NinoFloris](https://avatars.githubusercontent.com/u/4218809?s=64 "NinoFloris")](https://github.com/NinoFloris)
* [![pvanbuijtene](https://avatars.githubusercontent.com/u/7116354?s=64 "pvanbuijtene")](https://github.com/pvanbuijtene)
* [![msftph](https://avatars.githubusercontent.com/u/65667413?s=64 "msftph")](https://github.com/msftph)
* [![pdekkers](https://avatars.githubusercontent.com/u/11230135?s=64 "pdekkers")](https://github.com/pdekkers)
* [![peterwald](https://avatars.githubusercontent.com/u/5578?s=64 "peterwald")](https://github.com/peterwald)
* [![epsitec](https://avatars.githubusercontent.com/u/3872435?s=64 "epsitec")](https://github.com/epsitec)
* [![pierrebelin](https://avatars.githubusercontent.com/u/25244392?s=64 "pierrebelin")](https://github.com/pierrebelin)
* [![rdeveen](https://avatars.githubusercontent.com/u/5731724?s=64 "rdeveen")](https://github.com/rdeveen)
* [![romansp](https://avatars.githubusercontent.com/u/3474842?s=64 "romansp")](https://github.com/romansp)
* [![r0ss88](https://avatars.githubusercontent.com/u/35737434?s=64 "r0ss88")](https://github.com/r0ss88)
* [![mu88](https://avatars.githubusercontent.com/u/4560672?s=64 "mu88")](https://github.com/mu88)
* [![MichaelSimons](https://avatars.githubusercontent.com/u/8290530?s=64 "MichaelSimons")](https://github.com/MichaelSimons)
* [![mbwilding](https://avatars.githubusercontent.com/u/8856912?s=64 "mbwilding")](https://github.com/mbwilding)
* [![MatthewSteeples](https://avatars.githubusercontent.com/u/255971?s=64 "MatthewSteeples")](https://github.com/MatthewSteeples)
* [![mattchenderson](https://avatars.githubusercontent.com/u/5815695?s=64 "mattchenderson")](https://github.com/mattchenderson)
* [![wicksipedia](https://avatars.githubusercontent.com/u/600044?s=64 "wicksipedia")](https://github.com/wicksipedia)
* [![markphillips100](https://avatars.githubusercontent.com/u/6239029?s=64 "markphillips100")](https://github.com/markphillips100)
* [![maraf](https://avatars.githubusercontent.com/u/10020471?s=64 "maraf")](https://github.com/maraf)
* [![Marcus-Kanon](https://avatars.githubusercontent.com/u/89650029?s=64 "Marcus-Kanon")](https://github.com/Marcus-Kanon)
* [![MarcinJuraszek](https://avatars.githubusercontent.com/u/6841973?s=64 "MarcinJuraszek")](https://github.com/MarcinJuraszek)
* [![marcfreiheit](https://avatars.githubusercontent.com/u/27914201?s=64 "marcfreiheit")](https://github.com/marcfreiheit)
* [![saibimajdi](https://avatars.githubusercontent.com/u/8198978?s=64 "saibimajdi")](https://github.com/saibimajdi)
* [![mangeg](https://avatars.githubusercontent.com/u/803458?s=64 "mangeg")](https://github.com/mangeg)
* [![levimatheri](https://avatars.githubusercontent.com/u/16405269?s=64 "levimatheri")](https://github.com/levimatheri)
* [![GrabYourPitchforks](https://avatars.githubusercontent.com/u/1746272?s=64 "GrabYourPitchforks")](https://github.com/GrabYourPitchforks)
* [![aaron-hardin](https://avatars.githubusercontent.com/u/3603910?s=64 "aaron-hardin")](https://github.com/aaron-hardin)
* [![rynowak](https://avatars.githubusercontent.com/u/1430011?s=64 "rynowak")](https://github.com/rynowak)
* [![Costo](https://avatars.githubusercontent.com/u/46972?s=64 "Costo")](https://github.com/Costo)
* [![vladimir-shirmanov](https://avatars.githubusercontent.com/u/11080463?s=64 "vladimir-shirmanov")](https://github.com/vladimir-shirmanov)
* [![wmeints](https://avatars.githubusercontent.com/u/1550763?s=64 "wmeints")](https://github.com/wmeints)
* [![yreynhout](https://avatars.githubusercontent.com/u/142834?s=64 "yreynhout")](https://github.com/yreynhout)
* [![amrali21](https://avatars.githubusercontent.com/u/18468966?s=64 "amrali21")](https://github.com/amrali21)
* [![andi0b](https://avatars.githubusercontent.com/u/2432095?s=64 "andi0b")](https://github.com/andi0b)
* [![andrei-ungureanu-uipath](https://avatars.githubusercontent.com/u/61829128?s=64 "andrei-ungureanu-uipath")](https://github.com/andrei-ungureanu-uipath)
* [![danikishin](https://avatars.githubusercontent.com/u/68384137?s=64 "danikishin")](https://github.com/danikishin)
* [![devsko](https://avatars.githubusercontent.com/u/12471105?s=64 "devsko")](https://github.com/devsko)
* [![duskembayev](https://avatars.githubusercontent.com/u/14294244?s=64 "duskembayev")](https://github.com/duskembayev)
* [![microsoft-github-operations\[bot\]](https://avatars.githubusercontent.com/u/55726097?s=64 "microsoft-github-operations\[bot\]")](https://github.com/microsoft-github-operations\[bot])
* [![ojamte](https://avatars.githubusercontent.com/u/1688780?s=64 "ojamte")](https://github.com/ojamte)
* [![pizerg](https://avatars.githubusercontent.com/u/4287940?s=64 "pizerg")](https://github.com/pizerg)
* [![sharpSteff](https://avatars.githubusercontent.com/u/30927510?s=64 "sharpSteff")](https://github.com/sharpSteff)
* [![tg-msft](https://avatars.githubusercontent.com/u/1179329?s=64 "tg-msft")](https://github.com/tg-msft)
* [![AkosLukacs](https://avatars.githubusercontent.com/u/844331?s=64 "AkosLukacs")](https://github.com/AkosLukacs)
* [![sayedihashimi](https://avatars.githubusercontent.com/u/1283154?s=64 "sayedihashimi")](https://github.com/sayedihashimi)
* [![scottaddie](https://avatars.githubusercontent.com/u/10702007?s=64 "scottaddie")](https://github.com/scottaddie)
* [![coolcsh](https://avatars.githubusercontent.com/u/816505?s=64 "coolcsh")](https://github.com/coolcsh)
* [![spboyer](https://avatars.githubusercontent.com/u/7681382?s=64 "spboyer")](https://github.com/spboyer)
* [![ShilpiRachna1](https://avatars.githubusercontent.com/u/163410222?s=64 "ShilpiRachna1")](https://github.com/ShilpiRachna1)
* [![ShreyasJejurkar](https://avatars.githubusercontent.com/u/17148381?s=64 "ShreyasJejurkar")](https://github.com/ShreyasJejurkar)
* [![stefannikolei](https://avatars.githubusercontent.com/u/873751?s=64 "stefannikolei")](https://github.com/stefannikolei)
* [![sunandabalu](https://avatars.githubusercontent.com/u/16616736?s=64 "sunandabalu")](https://github.com/sunandabalu)
* [![tskimmett](https://avatars.githubusercontent.com/u/4603206?s=64 "tskimmett")](https://github.com/tskimmett)
* [![thimok](https://avatars.githubusercontent.com/u/20819818?s=64 "thimok")](https://github.com/thimok)
* [![Thovenaar](https://avatars.githubusercontent.com/u/11218403?s=64 "Thovenaar")](https://github.com/Thovenaar)
* [![ikkentim](https://avatars.githubusercontent.com/u/2820647?s=64 "ikkentim")](https://github.com/ikkentim)
* [![tmat](https://avatars.githubusercontent.com/u/41759?s=64 "tmat")](https://github.com/tmat)
* [![vha-schleupen](https://avatars.githubusercontent.com/u/88094233?s=64 "vha-schleupen")](https://github.com/vha-schleupen)
* [![vsantele](https://avatars.githubusercontent.com/u/26800140?s=64 "vsantele")](https://github.com/vsantele)
* [![ViktorHofer](https://avatars.githubusercontent.com/u/7412651?s=64 "ViktorHofer")](https://github.com/ViktorHofer)
* [![willibrandon](https://avatars.githubusercontent.com/u/5017479?s=64 "willibrandon")](https://github.com/willibrandon)
* [![brettcannon](https://avatars.githubusercontent.com/u/54418?s=64 "brettcannon")](https://github.com/brettcannon)
* [![FullStackChef](https://avatars.githubusercontent.com/u/28607748?s=64 "FullStackChef")](https://github.com/FullStackChef)
* [![buvinghausen](https://avatars.githubusercontent.com/u/1130210?s=64 "buvinghausen")](https://github.com/buvinghausen)
* [![bdukes](https://avatars.githubusercontent.com/u/59507?s=64 "bdukes")](https://github.com/bdukes)
* [![CaitieM20](https://avatars.githubusercontent.com/u/3310141?s=64 "CaitieM20")](https://github.com/CaitieM20)
* [![ChaseKnowlden](https://avatars.githubusercontent.com/u/46290258?s=64 "ChaseKnowlden")](https://github.com/ChaseKnowlden)
* [![ChinoUkaegbu](https://avatars.githubusercontent.com/u/77782533?s=64 "ChinoUkaegbu")](https://github.com/ChinoUkaegbu)
* [![Tratcher](https://avatars.githubusercontent.com/u/1821173?s=64 "Tratcher")](https://github.com/Tratcher)
* [![colinwilliams91](https://avatars.githubusercontent.com/u/92059005?s=64 "colinwilliams91")](https://github.com/colinwilliams91)
* [![cyrusdargahi](https://avatars.githubusercontent.com/u/20536256?s=64 "cyrusdargahi")](https://github.com/cyrusdargahi)
* [![djonser](https://avatars.githubusercontent.com/u/8218022?s=64 "djonser")](https://github.com/djonser)
* [![danspark](https://avatars.githubusercontent.com/u/23037278?s=64 "danspark")](https://github.com/danspark)
* [![dkattan](https://avatars.githubusercontent.com/u/1424395?s=64 "dkattan")](https://github.com/dkattan)
* [![Odonno](https://avatars.githubusercontent.com/u/6053067?s=64 "Odonno")](https://github.com/Odonno)
* [![flcdrg](https://avatars.githubusercontent.com/u/384747?s=64 "flcdrg")](https://github.com/flcdrg)
* [![Aaronontheweb](https://avatars.githubusercontent.com/u/326939?s=64 "Aaronontheweb")](https://github.com/Aaronontheweb)
* [![abdallahsellem](https://avatars.githubusercontent.com/u/77124997?s=64 "abdallahsellem")](https://github.com/abdallahsellem)
* [![wahab-cide](https://avatars.githubusercontent.com/u/124523882?s=64 "wahab-cide")](https://github.com/wahab-cide)
* [![los93sol](https://avatars.githubusercontent.com/u/6626120?s=64 "los93sol")](https://github.com/los93sol)
* [![adelinowona](https://avatars.githubusercontent.com/u/51498470?s=64 "adelinowona")](https://github.com/adelinowona)
* [![ailtonguitar](https://avatars.githubusercontent.com/u/7503689?s=64 "ailtonguitar")](https://github.com/ailtonguitar)
* [![alexander-kucherov](https://avatars.githubusercontent.com/u/50913857?s=64 "alexander-kucherov")](https://github.com/alexander-kucherov)
* [![HofmeisterAn](https://avatars.githubusercontent.com/u/9199345?s=64 "HofmeisterAn")](https://github.com/HofmeisterAn)
* [![amilochau](https://avatars.githubusercontent.com/u/48644548?s=64 "amilochau")](https://github.com/amilochau)
* [![Asafima](https://avatars.githubusercontent.com/u/100016552?s=64 "Asafima")](https://github.com/Asafima)
* [![attilah](https://avatars.githubusercontent.com/u/230432?s=64 "attilah")](https://github.com/attilah)
* [![gansb](https://avatars.githubusercontent.com/u/1140050?s=64 "gansb")](https://github.com/gansb)
* [![benwitmanmsft](https://avatars.githubusercontent.com/u/160950603?s=64 "benwitmanmsft")](https://github.com/benwitmanmsft)
* [![berkansasmaz](https://avatars.githubusercontent.com/u/31216880?s=64 "berkansasmaz")](https://github.com/berkansasmaz)
* [![BillHiebert](https://avatars.githubusercontent.com/u/1553785?s=64 "BillHiebert")](https://github.com/BillHiebert)
* [![Cethric](https://avatars.githubusercontent.com/u/7356786?s=64 "Cethric")](https://github.com/Cethric)
* [![CyberDNS](https://avatars.githubusercontent.com/u/34795406?s=64 "CyberDNS")](https://github.com/CyberDNS)
* [![eltociear](https://avatars.githubusercontent.com/u/22633385?s=64 "eltociear")](https://github.com/eltociear)
* [![Banovvv](https://avatars.githubusercontent.com/u/44908454?s=64 "Banovvv")](https://github.com/Banovvv)
* [![JakeRadMSFT](https://avatars.githubusercontent.com/u/31937616?s=64 "JakeRadMSFT")](https://github.com/JakeRadMSFT)
* [![nohwnd](https://avatars.githubusercontent.com/u/5735905?s=64 "nohwnd")](https://github.com/nohwnd)
* [![licon4812](https://avatars.githubusercontent.com/u/32421608?s=64 "licon4812")](https://github.com/licon4812)
* [![jeffl8n](https://avatars.githubusercontent.com/u/160512?s=64 "jeffl8n")](https://github.com/jeffl8n)
* [![jomaxso](https://avatars.githubusercontent.com/u/55972873?s=64 "jomaxso")](https://github.com/jomaxso)
* [![jnyrup](https://avatars.githubusercontent.com/u/919634?s=64 "jnyrup")](https://github.com/jnyrup)
* [![jguadagno](https://avatars.githubusercontent.com/u/3209610?s=64 "jguadagno")](https://github.com/jguadagno)
* [![Steinblock](https://avatars.githubusercontent.com/u/6850324?s=64 "Steinblock")](https://github.com/Steinblock)
* [![vcsjones](https://avatars.githubusercontent.com/u/361677?s=64 "vcsjones")](https://github.com/vcsjones)
* [![kieronlanning](https://avatars.githubusercontent.com/u/5364423?s=64 "kieronlanning")](https://github.com/kieronlanning)
* [![KirillOsenkov](https://avatars.githubusercontent.com/u/679326?s=64 "KirillOsenkov")](https://github.com/KirillOsenkov)
* [![KuraiAndras](https://avatars.githubusercontent.com/u/19240945?s=64 "KuraiAndras")](https://github.com/KuraiAndras)
* [![larsfjerm](https://avatars.githubusercontent.com/u/6827807?s=64 "larsfjerm")](https://github.com/larsfjerm)
* [![laurentkempe](https://avatars.githubusercontent.com/u/272612?s=64 "laurentkempe")](https://github.com/laurentkempe)
* [![yorek](https://avatars.githubusercontent.com/u/2612362?s=64 "yorek")](https://github.com/yorek)
* [![dvoituron](https://avatars.githubusercontent.com/u/8350694?s=64 "dvoituron")](https://github.com/dvoituron)
* [![dbreshears](https://avatars.githubusercontent.com/u/3432571?s=64 "dbreshears")](https://github.com/dbreshears)
* [![aelij](https://avatars.githubusercontent.com/u/496737?s=64 "aelij")](https://github.com/aelij)
* [![ellahathaway](https://avatars.githubusercontent.com/u/67609881?s=64 "ellahathaway")](https://github.com/ellahathaway)
* [![emilienbev](https://avatars.githubusercontent.com/u/44171454?s=64 "emilienbev")](https://github.com/emilienbev)
* [![EmmittJ](https://avatars.githubusercontent.com/u/7478125?s=64 "EmmittJ")](https://github.com/EmmittJ)
* [![ericstj](https://avatars.githubusercontent.com/u/8918108?s=64 "ericstj")](https://github.com/ericstj)
* [![onionhammer](https://avatars.githubusercontent.com/u/969938?s=64 "onionhammer")](https://github.com/onionhammer)
* [![fabiocav](https://avatars.githubusercontent.com/u/2507935?s=64 "fabiocav")](https://github.com/fabiocav)
* [![jeremy-vm](https://avatars.githubusercontent.com/u/42162085?s=64 "jeremy-vm")](https://github.com/jeremy-vm)
* [![frankbuckley](https://avatars.githubusercontent.com/u/5655810?s=64 "frankbuckley")](https://github.com/frankbuckley)
* [![glennc](https://avatars.githubusercontent.com/u/234688?s=64 "glennc")](https://github.com/glennc)
* [![Depechie](https://avatars.githubusercontent.com/u/351693?s=64 "Depechie")](https://github.com/Depechie)
* [![gkulin](https://avatars.githubusercontent.com/u/55554236?s=64 "gkulin")](https://github.com/gkulin)
* [![hansmbakker](https://avatars.githubusercontent.com/u/3463496?s=64 "hansmbakker")](https://github.com/hansmbakker)

[ dotnet/aspire ](https://github.com/dotnet/aspire)

[ Stars 5,433 ](https://github.com/dotnet/aspire)

[ MIT License ](https://github.com/dotnet/aspire/blob/main/LICENSE.TXT)

## 💜 Aspire samples contributors

[Section titled “💜 Aspire samples contributors”](#-aspire-samples-contributors)

Thank you to all the community members who have contributed to Aspire Samples! Your contributions help showcase the power and flexibility of Aspire in real-world scenarios. By sharing your solutions and examples, you empower others to learn, experiment, and build with confidence. Every sample you contribute can inspire new ideas and help fellow developers overcome challenges. Join us in collaborating and contributing—your real-world scenarios make a difference and help the entire community grow!

<!-- Thanks to @5t3ph for https://smolcss.dev/#smol-avatar-list! -->

* [![DamianEdwards](https://avatars.githubusercontent.com/u/249088?s=64 "DamianEdwards")](https://github.com/DamianEdwards)
* [![danmoseley](https://avatars.githubusercontent.com/u/6385855?s=64 "danmoseley")](https://github.com/danmoseley)
* [![JamesNK](https://avatars.githubusercontent.com/u/303201?s=64 "JamesNK")](https://github.com/JamesNK)
* [![joperezr](https://avatars.githubusercontent.com/u/13854455?s=64 "joperezr")](https://github.com/joperezr)
* [![eerhardt](https://avatars.githubusercontent.com/u/8291187?s=64 "eerhardt")](https://github.com/eerhardt)
* [![IEvangelist](https://avatars.githubusercontent.com/u/7679720?s=64 "IEvangelist")](https://github.com/IEvangelist)
* [![davidfowl](https://avatars.githubusercontent.com/u/95136?s=64 "davidfowl")](https://github.com/davidfowl)
* [![sebastienros](https://avatars.githubusercontent.com/u/1165805?s=64 "sebastienros")](https://github.com/sebastienros)
* [![wtgodbe](https://avatars.githubusercontent.com/u/14283640?s=64 "wtgodbe")](https://github.com/wtgodbe)
* [![mitchdenny](https://avatars.githubusercontent.com/u/513398?s=64 "mitchdenny")](https://github.com/mitchdenny)
* [![jeffhandley](https://avatars.githubusercontent.com/u/1031940?s=64 "jeffhandley")](https://github.com/jeffhandley)
* [![bradygaster](https://avatars.githubusercontent.com/u/41929050?s=64 "bradygaster")](https://github.com/bradygaster)
* [![moljac](https://avatars.githubusercontent.com/u/1768576?s=64 "moljac")](https://github.com/moljac)
* [![microsoft-github-operations\[bot\]](https://avatars.githubusercontent.com/u/55726097?s=64 "microsoft-github-operations\[bot\]")](https://github.com/microsoft-github-operations\[bot])
* [![alexwolfmsft](https://avatars.githubusercontent.com/u/93200798?s=64 "alexwolfmsft")](https://github.com/alexwolfmsft)
* [![vishipayyallore](https://avatars.githubusercontent.com/u/8255269?s=64 "vishipayyallore")](https://github.com/vishipayyallore)
* [![timdeschryver](https://avatars.githubusercontent.com/u/28659384?s=64 "timdeschryver")](https://github.com/timdeschryver)
* [![sliekens](https://avatars.githubusercontent.com/u/1583241?s=64 "sliekens")](https://github.com/sliekens)
* [![SimonCropp](https://avatars.githubusercontent.com/u/122666?s=64 "SimonCropp")](https://github.com/SimonCropp)
* [![sgbj](https://avatars.githubusercontent.com/u/5178445?s=64 "sgbj")](https://github.com/sgbj)
* [![sayedihashimi](https://avatars.githubusercontent.com/u/1283154?s=64 "sayedihashimi")](https://github.com/sayedihashimi)
* [![sammychinedu2ky](https://avatars.githubusercontent.com/u/36219292?s=64 "sammychinedu2ky")](https://github.com/sammychinedu2ky)
* [![captainsafia](https://avatars.githubusercontent.com/u/1857993?s=64 "captainsafia")](https://github.com/captainsafia)
* [![Rick-Anderson](https://avatars.githubusercontent.com/u/3605364?s=64 "Rick-Anderson")](https://github.com/Rick-Anderson)
* [![ReubenBond](https://avatars.githubusercontent.com/u/203839?s=64 "ReubenBond")](https://github.com/ReubenBond)
* [![michaelto20](https://avatars.githubusercontent.com/u/4887488?s=64 "michaelto20")](https://github.com/michaelto20)
* [![mmitche](https://avatars.githubusercontent.com/u/8725170?s=64 "mmitche")](https://github.com/mmitche)
* [![prisecano](https://avatars.githubusercontent.com/u/53272907?s=64 "prisecano")](https://github.com/prisecano)
* [![Layla-P](https://avatars.githubusercontent.com/u/15874598?s=64 "Layla-P")](https://github.com/Layla-P)
* [![jongalloway](https://avatars.githubusercontent.com/u/68539?s=64 "jongalloway")](https://github.com/jongalloway)
* [![hishamco](https://avatars.githubusercontent.com/u/3237266?s=64 "hishamco")](https://github.com/hishamco)
* [![Depechie](https://avatars.githubusercontent.com/u/351693?s=64 "Depechie")](https://github.com/Depechie)
* [![balachir](https://avatars.githubusercontent.com/u/8246794?s=64 "balachir")](https://github.com/balachir)
* [![asilverman](https://avatars.githubusercontent.com/u/9611108?s=64 "asilverman")](https://github.com/asilverman)
* [![antonfirsov](https://avatars.githubusercontent.com/u/6835152?s=64 "antonfirsov")](https://github.com/antonfirsov)
* [![radical](https://avatars.githubusercontent.com/u/1472?s=64 "radical")](https://github.com/radical)
* [![AndriySvyryd](https://avatars.githubusercontent.com/u/6539701?s=64 "AndriySvyryd")](https://github.com/AndriySvyryd)

[ dotnet/aspire-samples ](https://github.com/dotnet/aspire-samples)

[ Stars 1,137 ](https://github.com/dotnet/aspire-samples)

[ MIT License ](https://github.com/dotnet/aspire-samples/blob/main/LICENSE)

## 🧰 Aspire Community Toolkit contributors

[Section titled “🧰 Aspire Community Toolkit contributors”](#-aspire-community-toolkit-contributors)

For the community, by the community. The Aspire Community Toolkit grows through passionate contributors building extensions and enhancements for the ecosystem. Your contributions shape Aspire’s future and empower developers worldwide. Join the journey and help craft a toolkit reflecting diverse needs and our shared innovative spirit.

<!-- Thanks to @5t3ph for https://smolcss.dev/#smol-avatar-list! -->

* [![aaronpowell](https://avatars.githubusercontent.com/u/434140?s=64 "aaronpowell")](https://github.com/aaronpowell)
* [![tommasodotNET](https://avatars.githubusercontent.com/u/12819039?s=64 "tommasodotNET")](https://github.com/tommasodotNET)
* [![Alirexaa](https://avatars.githubusercontent.com/u/70141416?s=64 "Alirexaa")](https://github.com/Alirexaa)
* [![fboucher](https://avatars.githubusercontent.com/u/2404846?s=64 "fboucher")](https://github.com/fboucher)
* [![brian-guerrero](https://avatars.githubusercontent.com/u/5503800?s=64 "brian-guerrero")](https://github.com/brian-guerrero)
* [![Odonno](https://avatars.githubusercontent.com/u/6053067?s=64 "Odonno")](https://github.com/Odonno)
* [![gabynevada](https://avatars.githubusercontent.com/u/20828017?s=64 "gabynevada")](https://github.com/gabynevada)
* [![ErikEJ](https://avatars.githubusercontent.com/u/4169187?s=64 "ErikEJ")](https://github.com/ErikEJ)
* [![anoordover](https://avatars.githubusercontent.com/u/5289365?s=64 "anoordover")](https://github.com/anoordover)
* [![justinyoo](https://avatars.githubusercontent.com/u/1538528?s=64 "justinyoo")](https://github.com/justinyoo)
* [![QuantumNightmare](https://avatars.githubusercontent.com/u/3094648?s=64 "QuantumNightmare")](https://github.com/QuantumNightmare)
* [![FullStackChef](https://avatars.githubusercontent.com/u/28607748?s=64 "FullStackChef")](https://github.com/FullStackChef)
* [![afscrome](https://avatars.githubusercontent.com/u/289860?s=64 "afscrome")](https://github.com/afscrome)
* [![krubenok](https://avatars.githubusercontent.com/u/2529120?s=64 "krubenok")](https://github.com/krubenok)
* [![fabio-marini](https://avatars.githubusercontent.com/u/10209472?s=64 "fabio-marini")](https://github.com/fabio-marini)
* [![karl-sjogren](https://avatars.githubusercontent.com/u/875092?s=64 "karl-sjogren")](https://github.com/karl-sjogren)
* [![JerryNixon](https://avatars.githubusercontent.com/u/1749983?s=64 "JerryNixon")](https://github.com/JerryNixon)
* [![askpt](https://avatars.githubusercontent.com/u/2493377?s=64 "askpt")](https://github.com/askpt)
* [![MackinnonBuck](https://avatars.githubusercontent.com/u/10456961?s=64 "MackinnonBuck")](https://github.com/MackinnonBuck)
* [![martinjt](https://avatars.githubusercontent.com/u/1699587?s=64 "martinjt")](https://github.com/martinjt)
* [![timheuer](https://avatars.githubusercontent.com/u/4821?s=64 "timheuer")](https://github.com/timheuer)
* [![jmezach](https://avatars.githubusercontent.com/u/1225489?s=64 "jmezach")](https://github.com/jmezach)
* [![TheBlueSky](https://avatars.githubusercontent.com/u/807685?s=64 "TheBlueSky")](https://github.com/TheBlueSky)
* [![Harold-Morgan](https://avatars.githubusercontent.com/u/6255074?s=64 "Harold-Morgan")](https://github.com/Harold-Morgan)
* [![shiranshalom](https://avatars.githubusercontent.com/u/46426884?s=64 "shiranshalom")](https://github.com/shiranshalom)
* [![paulomorgado](https://avatars.githubusercontent.com/u/470455?s=64 "paulomorgado")](https://github.com/paulomorgado)
* [![oising](https://avatars.githubusercontent.com/u/1844001?s=64 "oising")](https://github.com/oising)
* [![MatsM16](https://avatars.githubusercontent.com/u/17270481?s=64 "MatsM16")](https://github.com/MatsM16)
* [![maddymontaquila](https://avatars.githubusercontent.com/u/12660687?s=64 "maddymontaquila")](https://github.com/maddymontaquila)
* [![kristremblay](https://avatars.githubusercontent.com/u/7587183?s=64 "kristremblay")](https://github.com/kristremblay)
* [![JamesNK](https://avatars.githubusercontent.com/u/303201?s=64 "JamesNK")](https://github.com/JamesNK)
* [![fredimachado](https://avatars.githubusercontent.com/u/29800?s=64 "fredimachado")](https://github.com/fredimachado)
* [![eerhardt](https://avatars.githubusercontent.com/u/8291187?s=64 "eerhardt")](https://github.com/eerhardt)
* [![prom3theu5](https://avatars.githubusercontent.com/u/1518610?s=64 "prom3theu5")](https://github.com/prom3theu5)
* [![TechWatching](https://avatars.githubusercontent.com/u/15186176?s=64 "TechWatching")](https://github.com/TechWatching)
* [![lvmajor](https://avatars.githubusercontent.com/u/1885400?s=64 "lvmajor")](https://github.com/lvmajor)
* [![BickelLukas](https://avatars.githubusercontent.com/u/16354178?s=64 "BickelLukas")](https://github.com/BickelLukas)
* [![marshalhayes](https://avatars.githubusercontent.com/u/17213165?s=64 "marshalhayes")](https://github.com/marshalhayes)
* [![martincostello](https://avatars.githubusercontent.com/u/1439341?s=64 "martincostello")](https://github.com/martincostello)
* [![mfcollins3](https://avatars.githubusercontent.com/u/104274?s=64 "mfcollins3")](https://github.com/mfcollins3)
* [![Mrxx99](https://avatars.githubusercontent.com/u/33566379?s=64 "Mrxx99")](https://github.com/Mrxx99)
* [![foxminchan](https://avatars.githubusercontent.com/u/56079798?s=64 "foxminchan")](https://github.com/foxminchan)
* [![r4hulp](https://avatars.githubusercontent.com/u/292704?s=64 "r4hulp")](https://github.com/r4hulp)
* [![sschutten](https://avatars.githubusercontent.com/u/10097564?s=64 "sschutten")](https://github.com/sschutten)
* [![esskar](https://avatars.githubusercontent.com/u/65206?s=64 "esskar")](https://github.com/esskar)
* [![stephentoub](https://avatars.githubusercontent.com/u/2642209?s=64 "stephentoub")](https://github.com/stephentoub)
* [![TimHess](https://avatars.githubusercontent.com/u/3947063?s=64 "TimHess")](https://github.com/TimHess)
* [![lukedukeus](https://avatars.githubusercontent.com/u/23089287?s=64 "lukedukeus")](https://github.com/lukedukeus)
* [![MichielBrys](https://avatars.githubusercontent.com/u/94305767?s=64 "MichielBrys")](https://github.com/MichielBrys)
* [![Sjark](https://avatars.githubusercontent.com/u/435441?s=64 "Sjark")](https://github.com/Sjark)
* [![larsfjerm](https://avatars.githubusercontent.com/u/6827807?s=64 "larsfjerm")](https://github.com/larsfjerm)
* [![nnitkasw](https://avatars.githubusercontent.com/u/126857618?s=64 "nnitkasw")](https://github.com/nnitkasw)
* [![josemalm32](https://avatars.githubusercontent.com/u/23101537?s=64 "josemalm32")](https://github.com/josemalm32)
* [![gitbutler-client](https://avatars.githubusercontent.com/u/132921372?s=64 "gitbutler-client")](https://github.com/gitbutler-client)
* [![jfversluis](https://avatars.githubusercontent.com/u/939291?s=64 "jfversluis")](https://github.com/jfversluis)
* [![dluc](https://avatars.githubusercontent.com/u/371009?s=64 "dluc")](https://github.com/dluc)
* [![programmation](https://avatars.githubusercontent.com/u/10096185?s=64 "programmation")](https://github.com/programmation)
* [![Catalin-Andronie](https://avatars.githubusercontent.com/u/10738038?s=64 "Catalin-Andronie")](https://github.com/Catalin-Andronie)
* [![cdschneider](https://avatars.githubusercontent.com/u/5581662?s=64 "cdschneider")](https://github.com/cdschneider)
* [![Chicoo](https://avatars.githubusercontent.com/u/566365?s=64 "Chicoo")](https://github.com/Chicoo)
* [![axies20](https://avatars.githubusercontent.com/u/19223232?s=64 "axies20")](https://github.com/axies20)
* [![AlexTroshkin](https://avatars.githubusercontent.com/u/11016542?s=64 "AlexTroshkin")](https://github.com/AlexTroshkin)

[ CommunityToolkit/Aspire ](https://github.com/CommunityToolkit/Aspire)

[ Stars 573 ](https://github.com/CommunityToolkit/Aspire)

[ MIT License ](https://github.com/CommunityToolkit/Aspire/blob/main/LICENSE)

## 🌐 aspire.dev contributors

[Section titled “🌐 aspire.dev contributors”](#-aspiredev-contributors)

Want to help [improve the aspire.dev site?](/community/contributor-guide/) We’re always looking for contributors to help enhance our docs, fix typos, and add new content. Your contributions make it easier for everyone to learn and use Aspire effectively. Join us in making aspire.dev the best resource it can be!

<!-- Thanks to @5t3ph for https://smolcss.dev/#smol-avatar-list! -->

* [![IEvangelist](https://avatars.githubusercontent.com/u/7679720?s=64 "IEvangelist")](https://github.com/IEvangelist)
* [![alistairmatthews](https://avatars.githubusercontent.com/u/41286777?s=64 "alistairmatthews")](https://github.com/alistairmatthews)
* [![eerhardt](https://avatars.githubusercontent.com/u/8291187?s=64 "eerhardt")](https://github.com/eerhardt)
* [![takashiuesaka](https://avatars.githubusercontent.com/u/61622933?s=64 "takashiuesaka")](https://github.com/takashiuesaka)
* [![JamesNK](https://avatars.githubusercontent.com/u/303201?s=64 "JamesNK")](https://github.com/JamesNK)
* [![Odonno](https://avatars.githubusercontent.com/u/6053067?s=64 "Odonno")](https://github.com/Odonno)
* [![BethMassi](https://avatars.githubusercontent.com/u/5115571?s=64 "BethMassi")](https://github.com/BethMassi)
* [![jfversluis](https://avatars.githubusercontent.com/u/939291?s=64 "jfversluis")](https://github.com/jfversluis)
* [![captainsafia](https://avatars.githubusercontent.com/u/1857993?s=64 "captainsafia")](https://github.com/captainsafia)
* [![timdeschryver](https://avatars.githubusercontent.com/u/28659384?s=64 "timdeschryver")](https://github.com/timdeschryver)
* [![mitchdenny](https://avatars.githubusercontent.com/u/513398?s=64 "mitchdenny")](https://github.com/mitchdenny)
* [![joperezr](https://avatars.githubusercontent.com/u/13854455?s=64 "joperezr")](https://github.com/joperezr)
* [![Cameron-McBroom](https://avatars.githubusercontent.com/u/45535570?s=64 "Cameron-McBroom")](https://github.com/Cameron-McBroom)
* [![agriffard](https://avatars.githubusercontent.com/u/703248?s=64 "agriffard")](https://github.com/agriffard)
* [![aaronpowell](https://avatars.githubusercontent.com/u/434140?s=64 "aaronpowell")](https://github.com/aaronpowell)
* [![BOBx5](https://avatars.githubusercontent.com/u/55046528?s=64 "BOBx5")](https://github.com/BOBx5)
* [![suugbut](https://avatars.githubusercontent.com/u/153189317?s=64 "suugbut")](https://github.com/suugbut)
* [![philipp985](https://avatars.githubusercontent.com/u/11349081?s=64 "philipp985")](https://github.com/philipp985)
* [![lim-dy](https://avatars.githubusercontent.com/u/225886905?s=64 "lim-dy")](https://github.com/lim-dy)
* [![huangkevin-apr](https://avatars.githubusercontent.com/u/182325027?s=64 "huangkevin-apr")](https://github.com/huangkevin-apr)
* [![zprobinson](https://avatars.githubusercontent.com/u/59841145?s=64 "zprobinson")](https://github.com/zprobinson)
* [![WeihanLi](https://avatars.githubusercontent.com/u/7604648?s=64 "WeihanLi")](https://github.com/WeihanLi)
* [![vsantele](https://avatars.githubusercontent.com/u/26800140?s=64 "vsantele")](https://github.com/vsantele)
* [![Tri125](https://avatars.githubusercontent.com/u/2048645?s=64 "Tri125")](https://github.com/Tri125)
* [![rocklau](https://avatars.githubusercontent.com/u/221825?s=64 "rocklau")](https://github.com/rocklau)
* [![foxminchan](https://avatars.githubusercontent.com/u/56079798?s=64 "foxminchan")](https://github.com/foxminchan)
* [![mohsin-mehmood](https://avatars.githubusercontent.com/u/7757162?s=64 "mohsin-mehmood")](https://github.com/mohsin-mehmood)
* [![MatsM16](https://avatars.githubusercontent.com/u/17270481?s=64 "MatsM16")](https://github.com/MatsM16)
* [![maraf](https://avatars.githubusercontent.com/u/10020471?s=64 "maraf")](https://github.com/maraf)
* [![butskristof](https://avatars.githubusercontent.com/u/4030759?s=64 "butskristof")](https://github.com/butskristof)
* [![kijanawoodard](https://avatars.githubusercontent.com/u/152013?s=64 "kijanawoodard")](https://github.com/kijanawoodard)
* [![javiercn](https://avatars.githubusercontent.com/u/6995051?s=64 "javiercn")](https://github.com/javiercn)
* [![ErikEJ](https://avatars.githubusercontent.com/u/4169187?s=64 "ErikEJ")](https://github.com/ErikEJ)
* [![danegsta](https://avatars.githubusercontent.com/u/50252651?s=64 "danegsta")](https://github.com/danegsta)
* [![dkroderos](https://avatars.githubusercontent.com/u/75028710?s=64 "dkroderos")](https://github.com/dkroderos)
* [![BoyanYK](https://avatars.githubusercontent.com/u/28277932?s=64 "BoyanYK")](https://github.com/BoyanYK)
* [![lvb2104](https://avatars.githubusercontent.com/u/93746846?s=64 "lvb2104")](https://github.com/lvb2104)
* [![meijeran](https://avatars.githubusercontent.com/u/13779871?s=64 "meijeran")](https://github.com/meijeran)
* [![angelobelchior](https://avatars.githubusercontent.com/u/4245518?s=64 "angelobelchior")](https://github.com/angelobelchior)
* [![alexravenna](https://avatars.githubusercontent.com/u/29532881?s=64 "alexravenna")](https://github.com/alexravenna)
* [![afscrome](https://avatars.githubusercontent.com/u/289860?s=64 "afscrome")](https://github.com/afscrome)

[ microsoft/aspire.dev ](https://github.com/microsoft/aspire.dev)

[ Stars 84 ](https://github.com/microsoft/aspire.dev)

[ MIT License ](https://github.com/microsoft/aspire.dev/blob/main/LICENSE)

## ⚙️ DCP contributors

[Section titled “⚙️ DCP contributors”](#️-dcp-contributors)

The [Distributed Component Platform (DCP)](/architecture/overview/#developer-control-plane) is an open-source project that provides a framework for building distributed applications. It is designed to simplify the development of microservices and serverless applications by providing a set of tools and libraries that make it easy to create, deploy, and manage distributed components.

<!-- Thanks to @5t3ph for https://smolcss.dev/#smol-avatar-list! -->

* [![karolz-ms](https://avatars.githubusercontent.com/u/15271049?s=64 "karolz-ms")](https://github.com/karolz-ms)
* [![danegsta](https://avatars.githubusercontent.com/u/50252651?s=64 "danegsta")](https://github.com/danegsta)
* [![bwateratmsft](https://avatars.githubusercontent.com/u/36966225?s=64 "bwateratmsft")](https://github.com/bwateratmsft)
* [![dbreshears](https://avatars.githubusercontent.com/u/3432571?s=64 "dbreshears")](https://github.com/dbreshears)
* [![RussKie](https://avatars.githubusercontent.com/u/4403806?s=64 "RussKie")](https://github.com/RussKie)
* [![timheuer](https://avatars.githubusercontent.com/u/4821?s=64 "timheuer")](https://github.com/timheuer)
* [![ellismg](https://avatars.githubusercontent.com/u/9602953?s=64 "ellismg")](https://github.com/ellismg)
* [![microsoft-github-policy-service\[bot\]](https://avatars.githubusercontent.com/u/77245923?s=64 "microsoft-github-policy-service\[bot\]")](https://github.com/microsoft-github-policy-service\[bot])

[ microsoft/dcp ](https://github.com/microsoft/dcp)

[ Stars 144 ](https://github.com/microsoft/dcp)

[ MIT License ](https://github.com/microsoft/dcp/blob/main/LICENSE)

## 🤓 Aspire team

[Section titled “🤓 Aspire team”](#-aspire-team)

Made with 💜 at Microsoft…

![Map showing Aspire community locations around the world](/_astro/map-darkdots.BcBHPwzz.svg)

# BlueSky Posts ✒️

> Explore community posts about Aspire.

\#aspire

<!-- only render the first PAGE_SIZE posts into the live DOM -->

[![Joe Ingeno](https://cdn.bsky.app/img/avatar/plain/did:plc:w2gemkuyjfxa3whvwixnzihz/bafkreifm6f26ziwakltjdatoyueirz7maewzhl7htss4r35n6ftgliy3qu@jpeg)](https://bsky.app/profile/joeingeno.bsky.social)

[Joe Ingeno](https://bsky.app/profile/joeingeno.bsky.social) [@joeingeno.bsky.social](https://bsky.app/profile/joeingeno.bsky.social)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:w2gemkuyjfxa3whvwixnzihz/post/3lxato2p6bb2r)

Deploying .NET Aspire to Azure with App Service, Azure SQL and Application Insights [www.dandoescode.com/blog/deployi...](https://www.dandoescode.com/blog/deploying-dotnet-aspire-to-azure-app-service) [#aspire](https://bsky.app/hashtag/aspire) [#azure](https://bsky.app/hashtag/azure) [#dotnet](https://bsky.app/hashtag/dotnet)

[![Deploying .NET Aspire to Azure with App Service, Azure SQL and Application Insights](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:w2gemkuyjfxa3whvwixnzihz/bafkreihsxm6ny4kv7absgh2kkyuonzrildl5rgelfpu72rgbyfmt6qq2oq@jpeg)](https://www.dandoescode.com/blog/deploying-dotnet-aspire-to-azure-app-service)

[www.dandoescode.com](https://www.dandoescode.com/blog/deploying-dotnet-aspire-to-azure-app-service)

[Deploying .NET Aspire to Azure with App Service, Azure SQL and Application Insights](https://www.dandoescode.com/blog/deploying-dotnet-aspire-to-azure-app-service)

[Learn how to deploy .NET Aspire applications to Azure App Service, Azure SQL Database, and Application Insights instead of the default Container Apps, including AZD configuration and deployment…](https://www.dandoescode.com/blog/deploying-dotnet-aspire-to-azure-app-service)

[August 25, 2025 at 8:29 PM UTC](https://bsky.app/profile/did:plc:w2gemkuyjfxa3whvwixnzihz/post/3lxato2p6bb2r)

[![David Fowler ](https://cdn.bsky.app/img/avatar/plain/did:plc:d47qj4iye2tgorzu3os4ayss/bafkreiganw2mxxnrw3kg4nitijphnq6su5tmitwp654uua6ffjnfcs47x4@jpeg)](https://bsky.app/profile/davidfowl.com)

[David Fowler ](https://bsky.app/profile/davidfowl.com)[@davidfowl.com](https://bsky.app/profile/davidfowl.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:d47qj4iye2tgorzu3os4ayss/post/3lx36xnw43c2k)

New swag alert [www.bonfire.com/aspire-side-...](https://www.bonfire.com/aspire-side-of-the-moon/) [#aspire](https://bsky.app/hashtag/aspire)

[![Aspire side of the moon | Bonfire](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:d47qj4iye2tgorzu3os4ayss/bafkreiciqdqz7fotpxrfrl4egattksck5n3bpzkxoz5hjx7x2cfjkftp5a@jpeg)](https://www.bonfire.com/aspire-side-of-the-moon/)

[www.bonfire.com](https://www.bonfire.com/aspire-side-of-the-moon/)

[Aspire side of the moon | Bonfire](https://www.bonfire.com/aspire-side-of-the-moon/)

[The infamous shirts wore by the Aspire team at //build 2025, now available to the public!. Hi evryone! Now that the entire Aspire team has gotten their shirts, we decided...](https://www.bonfire.com/aspire-side-of-the-moon/)

[August 23, 2025 at 2:35 PM UTC](https://bsky.app/profile/did:plc:d47qj4iye2tgorzu3os4ayss/post/3lx36xnw43c2k)

[![Isaac Levin](https://cdn.bsky.app/img/avatar/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreihp5cmzsuvszslb27qbf7jrauhr3xtelvxcgurv5zbrc2gjojfdku@jpeg)](https://bsky.app/profile/isaacrlevin.com)

[Isaac Levin](https://bsky.app/profile/isaacrlevin.com) [@isaacrlevin.com](https://bsky.app/profile/isaacrlevin.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwyj6upovr2g)

Explore how to build generative AI applications using GitHub models and .NET Aspire. Learn best practices, tools, and coding techniques to elevate your development skills.[#AI](https://bsky.app/hashtag/AI)[#GenerativeAI](https://bsky.app/hashtag/GenerativeAI)[#dotnet](https://bsky.app/hashtag/dotnet)[#aspnet](https://bsky.app/hashtag/aspnet)[#aspire](https://bsky.app/hashtag/aspire) <https://isaacl.dev/gp8>

[![Embed Card for https://isaacl.dev/gp8](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreifcgf77ys6ymsspqvxe7tlnzcgyiko2ilb2e3rw6ysu7hpzkptgda@jpeg)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwyj6upovr2g)

[August 22, 2025 at 1:00 PM UTC](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwyj6upovr2g)

[![Mitch Denny](https://cdn.bsky.app/img/avatar/plain/did:plc:nrnx6yibuwirqru4srnygxgp/bafkreibq3sb7jmzekisiz5bjzhrtuzwemg4vytpj4qs35q3lt46xuvah6e@jpeg)](https://bsky.app/profile/mitchdenny.dev)

[Mitch Denny](https://bsky.app/profile/mitchdenny.dev) [@mitchdenny.dev](https://bsky.app/profile/mitchdenny.dev)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:nrnx6yibuwirqru4srnygxgp/post/3lwux3wroek2s)

Trying out [@captainsafia.com](https://bsky.app/profile/did:plc:3ww4zeqrea4pbyk3e7gfxaol) 's 11030 PR into [#aspire](https://bsky.app/hashtag/aspire) and I'm like

[![a man in a white shirt and tie with his mouth open](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:nrnx6yibuwirqru4srnygxgp/bafkreiadwqeioggqn57bkj6xhjfbyip7urlonakk2bnta2fwsw2dfxgw3i@jpeg)](https://media.tenor.com/miKgqpYcyX0AAAAC/shocked-happy.gif?hh=224\&ww=400)

[media.tenor.com](https://media.tenor.com/miKgqpYcyX0AAAAC/shocked-happy.gif?hh=224\&ww=400)

[a man in a white shirt and tie with his mouth open](https://media.tenor.com/miKgqpYcyX0AAAAC/shocked-happy.gif?hh=224\&ww=400)

[ALT: a man in a white shirt and tie with his mouth open](https://media.tenor.com/miKgqpYcyX0AAAAC/shocked-happy.gif?hh=224\&ww=400)

[August 21, 2025 at 2:58 AM UTC](https://bsky.app/profile/did:plc:nrnx6yibuwirqru4srnygxgp/post/3lwux3wroek2s)

[![David Fowler ](https://cdn.bsky.app/img/avatar/plain/did:plc:d47qj4iye2tgorzu3os4ayss/bafkreiganw2mxxnrw3kg4nitijphnq6su5tmitwp654uua6ffjnfcs47x4@jpeg)](https://bsky.app/profile/davidfowl.com)

[David Fowler ](https://bsky.app/profile/davidfowl.com)[@davidfowl.com](https://bsky.app/profile/davidfowl.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:d47qj4iye2tgorzu3os4ayss/post/3lwurshktbk25)

[#aspire](https://bsky.app/hashtag/aspire)

[![a man with a beard is standing in front of a green screen .](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:d47qj4iye2tgorzu3os4ayss/bafkreiaf6uxvtrg3ik3mcqfz6767iourkvzefgtnejvjd4hdyn423v2cea@jpeg)](https://media.tenor.com/3qN5h3tfSdwAAAAC/gherkin-pifi.gif?hh=320\&ww=320)

[media.tenor.com](https://media.tenor.com/3qN5h3tfSdwAAAAC/gherkin-pifi.gif?hh=320\&ww=320)

[a man with a beard is standing in front of a green screen .](https://media.tenor.com/3qN5h3tfSdwAAAAC/gherkin-pifi.gif?hh=320\&ww=320)

[ALT: a man with a beard is standing in front of a green screen .](https://media.tenor.com/3qN5h3tfSdwAAAAC/gherkin-pifi.gif?hh=320\&ww=320)

[![Damian Edwards](https://cdn.bsky.app/img/avatar/plain/did:plc:tlaiqoqjss3nznnj4hjzqw7m/bafkreibsc4q2wju3vknf6akmkibxyye2wpd5vramko7bxhgcatqis3h2eq@jpeg)](https://bsky.app/profile/did:plc:tlaiqoqjss3nznnj4hjzqw7m/post/3lwuriog37k22)

[Damian Edwards@damianedwards.com](https://bsky.app/profile/did:plc:tlaiqoqjss3nznnj4hjzqw7m/post/3lwuriog37k22)

[Aspire is at version 9.4.1 now. That's the only supported version. If you're using an older version, update now. You must update to the latest version to be in support & get the awesome new features. What are you waiting for? learn.microsoft.com/dotnet/aspir... #dotnet](https://bsky.app/profile/did:plc:tlaiqoqjss3nznnj4hjzqw7m/post/3lwuriog37k22)

[learn.microsoft.com](https://learn.microsoft.com/dotnet/aspire/whats-new/dotnet-aspire-9.4#-upgrade-to-net-aspire-94)

[August 21, 2025 at 1:23 AM UTC](https://bsky.app/profile/did:plc:d47qj4iye2tgorzu3os4ayss/post/3lwurshktbk25)

[![Isaac Levin](https://cdn.bsky.app/img/avatar/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreihp5cmzsuvszslb27qbf7jrauhr3xtelvxcgurv5zbrc2gjojfdku@jpeg)](https://bsky.app/profile/isaacrlevin.com)

[Isaac Levin](https://bsky.app/profile/isaacrlevin.com) [@isaacrlevin.com](https://bsky.app/profile/isaacrlevin.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwujrvyczh2y)

Discover the power of .NET Aspire CLI and how it streamlines developer workflows. Dive into creating intuitive dashboards that elevate productivity and enhance user experiences.[#dotnet](https://bsky.app/hashtag/dotnet)[#aspnet](https://bsky.app/hashtag/aspnet)[#aspire](https://bsky.app/hashtag/aspire) <https://isaacl.dev/gp3>

[![Embed Card for https://isaacl.dev/gp3](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreias64trgbb7n7r6nb4bdkjgzavbvbqxgludvskcahcuj34a2zfwqi@jpeg)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwujrvyczh2y)

[August 20, 2025 at 11:00 PM UTC](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwujrvyczh2y)

[![Isaac Levin](https://cdn.bsky.app/img/avatar/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreihp5cmzsuvszslb27qbf7jrauhr3xtelvxcgurv5zbrc2gjojfdku@jpeg)](https://bsky.app/profile/isaacrlevin.com)

[Isaac Levin](https://bsky.app/profile/isaacrlevin.com) [@isaacrlevin.com](https://bsky.app/profile/isaacrlevin.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwu4etinfh2v)

Discover how to create a reusable .NET Aspire API template efficiently. Streamline your development process and enhance productivity with simple steps.[#dotnet](https://bsky.app/hashtag/dotnet)[#aspnet](https://bsky.app/hashtag/aspnet)[#aspire](https://bsky.app/hashtag/aspire) <https://isaacl.dev/gp2>

[![Embed Card for https://isaacl.dev/gp2](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreihhbbdfngx6p5xbbryihwjzyaxnhtjzma3yt3cw3m2a5azouqemnm@jpeg)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwu4etinfh2v)

[August 20, 2025 at 7:00 PM UTC](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lwu4etinfh2v)

[![Alvin Ashcraft](https://cdn.bsky.app/img/avatar/plain/did:plc:tdj5ie3dprhi242wsd7ykk7k/bafkreigbym7lhw73cscwuce4ssdx5ziq2mncozdvvcajyng5iyqq37ygxy@jpeg)](https://bsky.app/profile/alvinashcraft.com)

[Alvin Ashcraft](https://bsky.app/profile/alvinashcraft.com) [@alvinashcraft.com](https://bsky.app/profile/alvinashcraft.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:tdj5ie3dprhi242wsd7ykk7k/post/3lwr6jxbafm2h)

Custom domains with Aspire | by Mitch Denny. [buff.ly/GvUZ99r](https://buff.ly/GvUZ99r) [#dotnet](https://bsky.app/hashtag/dotnet) [#webdev](https://bsky.app/hashtag/webdev) [#aspire](https://bsky.app/hashtag/aspire) [#dotnetaspire](https://bsky.app/hashtag/dotnetaspire)

[![Custom domains with Aspire](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:tdj5ie3dprhi242wsd7ykk7k/bafkreihxb2mk4mr23rrtxwy7lkqizig3sm76oktpsdagqclg3655fvc6gi@jpeg)](https://buff.ly/GvUZ99r)

[buff.ly](https://buff.ly/GvUZ99r)

[Custom domains with Aspire](https://buff.ly/GvUZ99r)

[Recently a member of the Aspire discord asked about support for configuring custom domains on Azure Container App instances. The ability to configure custom domains is currently an experimental…](https://buff.ly/GvUZ99r)

[August 19, 2025 at 3:01 PM UTC](https://bsky.app/profile/did:plc:tdj5ie3dprhi242wsd7ykk7k/post/3lwr6jxbafm2h)

[![James Newton-King ♔](https://cdn.bsky.app/img/avatar/plain/did:plc:7bfxmbb55oujmny7rk6u6omm/bafkreidz4necekd6ra7j4o4xr6rdwjairhzkt5f2xqqrc526xkc3w2jeeq@jpeg)](https://bsky.app/profile/james.newtonking.com)

[James Newton-King ♔](https://bsky.app/profile/james.newtonking.com) [@james.newtonking.com](https://bsky.app/profile/james.newtonking.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:7bfxmbb55oujmny7rk6u6omm/post/3lwpsmhktuk24)

The Aspire team is cooking up a new (All) option for the console logs page. Want everything at once? (All) gives you all resource logs in one view 🚀 [#dotnet](https://bsky.app/hashtag/dotnet) [#aspire](https://bsky.app/hashtag/aspire)

[![Console logs page with (All) selected.](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:7bfxmbb55oujmny7rk6u6omm/bafkreig5jwfkzyrjvws63gl2sktgbuuynvglxrrd6ddpzbcpny3efmxrey@jpeg)](https://bsky.app/profile/did:plc:7bfxmbb55oujmny7rk6u6omm/post/3lwpsmhktuk24)

[August 19, 2025 at 1:55 AM UTC](https://bsky.app/profile/did:plc:7bfxmbb55oujmny7rk6u6omm/post/3lwpsmhktuk24)

[![.NET Barcelona](https://cdn.bsky.app/img/avatar/plain/did:plc:67zty5mxzv4owhyi3xa4iunn/bafkreigrwlaljirguu5c5wjma3wnmbmacrjw5dholvu5mkazblgpbesch4@jpeg)](https://bsky.app/profile/dotnetbarcelona.bsky.social)

[.NET Barcelona](https://bsky.app/profile/dotnetbarcelona.bsky.social) [@dotnetbarcelona.bsky.social](https://bsky.app/profile/dotnetbarcelona.bsky.social)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:67zty5mxzv4owhyi3xa4iunn/post/3lwoxcti7kc2y)

Yes, that's just becoming better and better. The new cli is something really handy, even mandatory for a concept such as this one. [devblogs.microsoft.com/dotnet/annou...](https://devblogs.microsoft.com/dotnet/announcing-aspire-9-4/) [#dotnet](https://bsky.app/hashtag/dotnet) [#aspire](https://bsky.app/hashtag/aspire)

[![Aspire 9.4 is here with a CLI and interactive dashboard features - .NET Blog](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:67zty5mxzv4owhyi3xa4iunn/bafkreidz3ysjeab4di6mskt5p3diz5m4asd4q5b6gc6fc6x2zutdgjcbxe@jpeg)](https://devblogs.microsoft.com/dotnet/announcing-aspire-9-4/)

[devblogs.microsoft.com](https://devblogs.microsoft.com/dotnet/announcing-aspire-9-4/)

[Aspire 9.4 is here with a CLI and interactive dashboard features - .NET Blog](https://devblogs.microsoft.com/dotnet/announcing-aspire-9-4/)

[Aspire 9.4 is packed with new features, integrations, and improvements](https://devblogs.microsoft.com/dotnet/announcing-aspire-9-4/)

[August 18, 2025 at 5:46 PM UTC](https://bsky.app/profile/did:plc:67zty5mxzv4owhyi3xa4iunn/post/3lwoxcti7kc2y)

[![maddy montaquila](https://cdn.bsky.app/img/avatar/plain/did:plc:s2s5xvwyagujsscligj4yogv/bafkreid2stshnqqi2iulcn6njmxtb33v3knhpa445y6cscqu5pojl3t4ua@jpeg)](https://bsky.app/profile/maddymontaquila.net)

[maddy montaquila](https://bsky.app/profile/maddymontaquila.net) [@maddymontaquila.net](https://bsky.app/profile/maddymontaquila.net)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:s2s5xvwyagujsscligj4yogv/post/3lwolwub5nc2g)

not [@mitchdenny.dev](https://bsky.app/profile/did:plc:nrnx6yibuwirqru4srnygxgp) dropping a 22 min read blog post over the weekend about multi-env situations with [#aspire](https://bsky.app/hashtag/aspire) lol absolute MENACE [www.withaspire.dev/p/ea243557-e...](https://www.withaspire.dev/p/ea243557-e6a6-44f0-a1dd-579277063485/?member_status=free)

[![Custom domains with Aspire](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:s2s5xvwyagujsscligj4yogv/bafkreifucyeqllrs6o377dsjelqbmd2jhc3hmffwfsw6lunriln5u2lpbi@jpeg)](https://www.withaspire.dev/p/ea243557-e6a6-44f0-a1dd-579277063485/?member_status=free)

[www.withaspire.dev](https://www.withaspire.dev/p/ea243557-e6a6-44f0-a1dd-579277063485/?member_status=free)

[Custom domains with Aspire](https://www.withaspire.dev/p/ea243557-e6a6-44f0-a1dd-579277063485/?member_status=free)

[Recently a member of the Aspire discord asked about support for configuring custom domains on Azure Container App instances. The ability to configure custom domains is currently an experimental featur...](https://www.withaspire.dev/p/ea243557-e6a6-44f0-a1dd-579277063485/?member_status=free)

[August 18, 2025 at 2:22 PM UTC](https://bsky.app/profile/did:plc:s2s5xvwyagujsscligj4yogv/post/3lwolwub5nc2g)

[![Joseph Guadagno](https://cdn.bsky.app/img/avatar/plain/did:plc:zrubh7flxwdxfyxeu7b47rei/bafkreia3yybbseucbbf63nbtfnum723qid5p2y6fbfflmzza7u5hpnzb6m@jpeg)](https://bsky.app/profile/jguadagno.com)

[Joseph Guadagno](https://bsky.app/profile/jguadagno.com) [@jguadagno.com](https://bsky.app/profile/jguadagno.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:zrubh7flxwdxfyxeu7b47rei/post/3lwnzvxegtj23)

ICYMI: (07/09/2025): "Simplify Your .NET Development with Aspire." RPs and feedback are always appreciated! <https://jjg.me/4kqEWio> [#Articles](https://bsky.app/hashtag/Articles) [#Aspire](https://bsky.app/hashtag/Aspire) [#.NET](https://bsky.app/hashtag/.NET) [#dotnet](https://bsky.app/hashtag/dotnet) [#Development](https://bsky.app/hashtag/Development) [#ASP.NET](https://bsky.app/hashtag/ASP.NET) [#Containers](https://bsky.app/hashtag/Containers)

[![Simplify Your .NET Development with Aspire](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:zrubh7flxwdxfyxeu7b47rei/bafkreib4opx2o5k4vlk6avm3ecsj3a3e2df46qwob5szzi6krn7k7w7lbm@jpeg)](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[www.josephguadagno.net](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[Simplify Your .NET Development with Aspire](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[Learn how Aspire can streamline your .NET development process, making it easier to manage dependencies and enhance productivity](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[August 18, 2025 at 9:00 AM UTC](https://bsky.app/profile/did:plc:zrubh7flxwdxfyxeu7b47rei/post/3lwnzvxegtj23)

[![Michael Washington](https://cdn.bsky.app/img/avatar/plain/did:plc:mjp2lenosijv5decc646uqcn/bafkreicpxpam7aekavu6e3hitp4fma3bh2tfyevairsmyxuo2meukxwaiu@jpeg)](https://bsky.app/profile/adefwebserver.com)

[Michael Washington](https://bsky.app/profile/adefwebserver.com) [@adefwebserver.com](https://bsky.app/profile/adefwebserver.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:mjp2lenosijv5decc646uqcn/post/3lwmwf6dy5s2p)

Put a📌on this one. This is the next big [#Blazor](https://bsky.app/hashtag/Blazor) [#OpenSource](https://bsky.app/hashtag/OpenSource) project I will be working on in September on [BlazorData.net](https://BlazorData.net) using [#Aspire](https://bsky.app/hashtag/Aspire) of course 👍🏽

[![Flowchart illustrating a web application with sections for dashboard, jobs, logs, and configuration options like Azure and AI settings.](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:mjp2lenosijv5decc646uqcn/bafkreibj32iw4tkezb2gd7ce62lysuhh3ucb65nqia5kt7jmxdbtw76pbi@jpeg)](https://bsky.app/profile/did:plc:mjp2lenosijv5decc646uqcn/post/3lwmwf6dy5s2p)

[August 17, 2025 at 10:24 PM UTC](https://bsky.app/profile/did:plc:mjp2lenosijv5decc646uqcn/post/3lwmwf6dy5s2p)

[![Jamie Taylor](https://cdn.bsky.app/img/avatar/plain/did:plc:l57xtcclnxkd3p535queikal/bafkreidudr5aaay2esha3ym3jdktslaqqyobtdtojqfxc7ee7csyns3xda@jpeg)](https://bsky.app/profile/gaprogman.com)

[Jamie Taylor](https://bsky.app/profile/gaprogman.com) [@gaprogman.com](https://bsky.app/profile/gaprogman.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:l57xtcclnxkd3p535queikal/post/3lwmabyqlry2u)

to the recent discussion with Maddy about .NET Aspire. In Maddy's words, Aspire is like the green baseplate you get with Lego sets, but it's actually more than that. Tune in to find out what Aspire is all about! [#Dotnet](https://bsky.app/hashtag/Dotnet) [#Aspire](https://bsky.app/hashtag/Aspire) [#TechTalk](https://bsky.app/hashtag/TechTalk) [dotnetcore.show/season-7/net...](https://dotnetcore.show/season-7/net-aspire-how-maddy-montaquila-and-the-net-team-are-revolutionizing-development/Throwback)

[![S07E20 - .NET Aspire: How Maddy Montaquila and the .NET Team Are Revolutionizing Development](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:l57xtcclnxkd3p535queikal/bafkreif6hpjim4ua262ma3hj47mf7nkl5uacsthtke52ggy4cf5of2fin4@jpeg)](https://dotnetcore.show/season-7/net-aspire-how-maddy-montaquila-and-the-net-team-are-revolutionizing-development/)

[dotnetcore.show](https://dotnetcore.show/season-7/net-aspire-how-maddy-montaquila-and-the-net-team-are-revolutionizing-development/)

[S07E20 - .NET Aspire: How Maddy Montaquila and the .NET Team Are Revolutionizing Development](https://dotnetcore.show/season-7/net-aspire-how-maddy-montaquila-and-the-net-team-are-revolutionizing-development/)

[In this exclusive interview, Maddy Montaquila, a leading expert on .NET Aspire, shares her insights on the latest cloud-native development platform. Learn how to harness the power of Aspire to build scalable, secure, and efficient applications with ease. From its origins in Microsoft's Cloud Native Initiative, .NET Aspire has emerged as a game-changer for developers and businesses alike. In this conversation, Maddy Montaquila opens up about the key features, benefits, and use cases of Aspire, including its integration with GenAI models, Ollama, and GitHub. Tune in to this informative interview to learn more about .NET Aspire and how it can transform your development workflow](https://dotnetcore.show/season-7/net-aspire-how-maddy-montaquila-and-the-net-team-are-revolutionizing-development/)

[August 17, 2025 at 3:49 PM UTC](https://bsky.app/profile/did:plc:l57xtcclnxkd3p535queikal/post/3lwmabyqlry2u)

[![Joseph Guadagno](https://cdn.bsky.app/img/avatar/plain/did:plc:zrubh7flxwdxfyxeu7b47rei/bafkreia3yybbseucbbf63nbtfnum723qid5p2y6fbfflmzza7u5hpnzb6m@jpeg)](https://bsky.app/profile/jguadagno.com)

[Joseph Guadagno](https://bsky.app/profile/jguadagno.com) [@jguadagno.com](https://bsky.app/profile/jguadagno.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:zrubh7flxwdxfyxeu7b47rei/post/3lwjqii7fc32m)

ICYMI: (07/09/2025): "Simplify Your .NET Development with Aspire." RPs and feedback are always appreciated! <https://jjg.me/4kqEWio> [#Articles](https://bsky.app/hashtag/Articles) [#Aspire](https://bsky.app/hashtag/Aspire) [#.NET](https://bsky.app/hashtag/.NET) [#dotnet](https://bsky.app/hashtag/dotnet) [#Development](https://bsky.app/hashtag/Development) [#ASP.NET](https://bsky.app/hashtag/ASP.NET) [#Containers](https://bsky.app/hashtag/Containers)

[![Simplify Your .NET Development with Aspire](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:zrubh7flxwdxfyxeu7b47rei/bafkreib4opx2o5k4vlk6avm3ecsj3a3e2df46qwob5szzi6krn7k7w7lbm@jpeg)](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[www.josephguadagno.net](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[Simplify Your .NET Development with Aspire](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[Learn how Aspire can streamline your .NET development process, making it easier to manage dependencies and enhance productivity](https://www.josephguadagno.net/2025/07/08/simplify-your-dot-net-development-with-aspire)

[August 16, 2025 at 4:00 PM UTC](https://bsky.app/profile/did:plc:zrubh7flxwdxfyxeu7b47rei/post/3lwjqii7fc32m)

[![Antão Almada](https://cdn.bsky.app/img/avatar/plain/did:plc:f7iu5ednubfrzaug536v4mxn/bafkreifmsmc3sxna3om4ziynxl4dfbngtvanby2mymy2igutlydhjthlla@jpeg)](https://bsky.app/profile/antaoalmada.bsky.social)

[Antão Almada](https://bsky.app/profile/antaoalmada.bsky.social) [@antaoalmada.bsky.social](https://bsky.app/profile/antaoalmada.bsky.social)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:f7iu5ednubfrzaug536v4mxn/post/3lwh4k7wgjc26)

WSL + Docker + Aspire = smooth .NET cloud-native dev on Windows. Sharing how I set it up and why it’s made local development way easier. [aalmada.github.io/posts/A-Guid...](https://aalmada.github.io/posts/A-Guide-to-Dotnet-Development-with-VSCode-andWSL/) [#dotnet](https://bsky.app/hashtag/dotnet) [#aspire](https://bsky.app/hashtag/aspire) [#WSL](https://bsky.app/hashtag/WSL) [#devsetup](https://bsky.app/hashtag/devsetup)

[![Harnessing WSL for Modern .NET Development with VS Code, Docker, and Aspire](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:f7iu5ednubfrzaug536v4mxn/bafkreiefnd5etdrniom3ow44k5ylcwi5txj23x56mtoiwu3rvawoihqxhu@jpeg)](https://aalmada.github.io/posts/A-Guide-to-Dotnet-Development-with-VSCode-andWSL/)

[aalmada.github.io](https://aalmada.github.io/posts/A-Guide-to-Dotnet-Development-with-VSCode-andWSL/)

[Harnessing WSL for Modern .NET Development with VS Code, Docker, and Aspire](https://aalmada.github.io/posts/A-Guide-to-Dotnet-Development-with-VSCode-andWSL/)

[WSL (Windows Subsystem for Linux) lets you run a full Linux environment alongside Windows, improving the development experience and making it easy to use Linux-native tools. With Docker installed in WSL and Aspire orchestrating cloud-native .NET apps, you get an excellent cloud-first development setup, everything runs locally but is ready to deploy to the cloud.](https://aalmada.github.io/posts/A-Guide-to-Dotnet-Development-with-VSCode-andWSL/)

[August 15, 2025 at 2:58 PM UTC](https://bsky.app/profile/did:plc:f7iu5ednubfrzaug536v4mxn/post/3lwh4k7wgjc26)

[![Murph](https://cdn.bsky.app/img/avatar/plain/did:plc:44u6lm5poqy6zc73qj6jyvfs/bafkreiat5ykobl25mhjavpegea3ugvuzfa63r44qauyjjan5nma2kbqez4@jpeg)](https://bsky.app/profile/murph.recumbent.co.uk)

[Murph](https://bsky.app/profile/murph.recumbent.co.uk) [@murph.recumbent.co.uk](https://bsky.app/profile/murph.recumbent.co.uk)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:44u6lm5poqy6zc73qj6jyvfs/post/3lwet6jyhjs2w)

The [#dotnet](https://bsky.app/hashtag/dotnet) [#aspire](https://bsky.app/hashtag/aspire) team on [#AspiriFridays](https://bsky.app/hashtag/AspiriFridays): "Global installs bad!" Also the dotnet aspire team: dotnet tool install -g Aspire.Cli (I'm ignoring the "install.ps1" version) 🤔 I appreciate that this is a difficult problem, and at some point something has to bootstrap something, but...

[August 14, 2025 at 5:05 PM UTC](https://bsky.app/profile/did:plc:44u6lm5poqy6zc73qj6jyvfs/post/3lwet6jyhjs2w)

[![Frank Boucher](https://cdn.bsky.app/img/avatar/plain/did:plc:fixcxv6z7pgrs7m57tuwwzfe/bafkreib7c7dhlir75l7mfc3xlg4ylswb7hhc6glifazj5mvl2mdm35uge4@jpeg)](https://bsky.app/profile/fboucheros.bsky.social)

[Frank Boucher](https://bsky.app/profile/fboucheros.bsky.social) [@fboucheros.bsky.social](https://bsky.app/profile/fboucheros.bsky.social)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:fixcxv6z7pgrs7m57tuwwzfe/post/3lw5ixhdvd22q)

Looking for something to read, or listen to catch-up after your summer break? [c5m.ca/RN-660](https://c5m.ca/RN-660) This week's [#ReadingNotes](https://bsky.app/hashtag/ReadingNotes) cover GenAI vs agentic [#AI](https://bsky.app/hashtag/AI) 🧠, fresh [#Docker](https://bsky.app/hashtag/Docker) and [#Aspire](https://bsky.app/hashtag/Aspire) news ,🐳 how to run WordPress in containers, and building apps with React and .NET. Plus a few podcasts worth a listen 🎧

[![Reading Notes #660](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:fixcxv6z7pgrs7m57tuwwzfe/bafkreifqkp6quxafyza6np7sqrgg3zmf5ckohemdlmdy5357v72dme4i3q@jpeg)](https://c5m.ca/RN-660)

[c5m.ca](https://c5m.ca/RN-660)

[Reading Notes #660](https://c5m.ca/RN-660)

[August 11, 2025 at 7:14 PM UTC](https://bsky.app/profile/did:plc:fixcxv6z7pgrs7m57tuwwzfe/post/3lw5ixhdvd22q)

[![Isaac Levin](https://cdn.bsky.app/img/avatar/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreihp5cmzsuvszslb27qbf7jrauhr3xtelvxcgurv5zbrc2gjojfdku@jpeg)](https://bsky.app/profile/isaacrlevin.com)

[Isaac Levin](https://bsky.app/profile/isaacrlevin.com) [@isaacrlevin.com](https://bsky.app/profile/isaacrlevin.com)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lw5i6hc3hh2c)

Discover the latest enhancements in .NET Aspire 9.4, featuring streamlined CLI core commands and advanced AI integrations.[#dotnet](https://bsky.app/hashtag/dotnet)[#aspnet](https://bsky.app/hashtag/aspnet)[#aspire](https://bsky.app/hashtag/aspire)[#ai](https://bsky.app/hashtag/ai) <https://isaacl.dev/gps>

[![Embed Card for https://isaacl.dev/gps](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:yyhj5wloszrpj2wg5adb3ijs/bafkreig4dx4oddjfhex2zghzgdna3qpdu5chjeec6wuovfztyxq224nrya@jpeg)](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lw5i6hc3hh2c)

[August 11, 2025 at 7:00 PM UTC](https://bsky.app/profile/did:plc:yyhj5wloszrpj2wg5adb3ijs/post/3lw5i6hc3hh2c)

[![Rival Abdrakhmanov](https://cdn.bsky.app/img/avatar/plain/did:plc:h77visoxi3x3wq36s47r2vdp/bafkreicxgkfhlus4p5sent36rgeeptqtacr4slex6pkdzczuiop7hi6ete@jpeg)](https://bsky.app/profile/rafaelldi.bsky.social)

[Rival Abdrakhmanov](https://bsky.app/profile/rafaelldi.bsky.social) [@rafaelldi.bsky.social](https://bsky.app/profile/rafaelldi.bsky.social)

[![Bluesky](data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20fill='none'%20viewBox='0%200%20320%20286'%3e%3cpath%20fill='rgb\(10,122,255\)'%20d='M69.364%2019.146c36.687%2027.806%2076.147%2084.186%2090.636%20114.439%2014.489-30.253%2053.948-86.633%2090.636-114.439C277.107-.917%20320-16.44%20320%2032.957c0%209.865-5.603%2082.875-8.889%2094.729-11.423%2041.208-53.045%2051.719-90.071%2045.357%2064.719%2011.12%2081.182%2047.953%2045.627%2084.785-80%2082.874-106.667-44.333-106.667-44.333s-26.667%20127.207-106.667%2044.333c-35.555-36.832-19.092-73.665%2045.627-84.785-37.026%206.362-78.648-4.149-90.071-45.357C5.603%20115.832%200%2042.822%200%2032.957%200-16.44%2042.893-.917%2069.364%2019.147Z'/%3e%3c/svg%3e)](https://bsky.app/profile/did:plc:h77visoxi3x3wq36s47r2vdp/post/3lw4jcq5lls2f)

The previous week was quite productive. A bunch of fixes and improvements for our [#aspire](https://bsky.app/hashtag/aspire) plugin for Rider [#perasperaadastra](https://bsky.app/hashtag/perasperaadastra)

[![Changelog of the Rider Aspire plugin](https://cdn.bsky.app/img/feed_thumbnail/plain/did:plc:h77visoxi3x3wq36s47r2vdp/bafkreihvurnjzgsqbv2qygedfut5y2qlzfxp6nabaqohy3gbruq6uwttcu@jpeg)](https://bsky.app/profile/did:plc:h77visoxi3x3wq36s47r2vdp/post/3lw4jcq5lls2f)

[August 11, 2025 at 9:47 AM UTC](https://bsky.app/profile/did:plc:h77visoxi3x3wq36s47r2vdp/post/3lw4jcq5lls2f)

<!-- render the remaining posts inside templates (inert) -->

<!-- sentinel for IntersectionObserver -->

# Community Videos 📺

> A collection of community videos showcasing Aspire in action.

## YouTube

[Section titled “YouTube ”](#youtube)

Dive into our vibrant developer community with these curated **YouTube** videos! Discover how others are building amazing things with Aspire, get inspired by real-world projects, and join the excitement as the community grows.

[Play](https://youtube.com/watch?v=u5_yOjzgmCM)

### AspiriFridays

[Section titled “AspiriFridays”](#aspirifridays)

Watch [live streams](https://www.youtube.com/@aspiredotdev/streams) from the Aspire team as they add Aspire to existing apps from the community.

* [Play](https://youtube.com/watch?v=UjQ-fVkwqpY)

  AspiriFridays - Bitwarden

  Welcome to the first ever AspiriFriday! Join David Fowler, Damian Edwards, and Maddy Montaquila while they try to Aspireify (aka add Aspire to) your apps, live on stream!

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=c7-Xeg67IUs)

  AspiriFridays - James Montemagno + Feedback Flow

  Damian and Maddy join James Montemagno to add Aspire to his Feedback Flow app.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=PDwtUpipWbA)

  AspiriFridays - Ed Keilholz (Hex Master)

  David, Damian, and Maddy join Eduard Keilholz (hexmaster) to further Aspirify his app on a lively Friday stream.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=dCwwvXmclEs)

  AspiriFridays - Joe Guadagno

  Join Maddy, Damian, and David for the 3rd AspiriFriday where Microsoft MVP and Realtime Technologies VP Joseph Guadagno will be adding Aspire to his personal broadcast site.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=XXYvI11Rz7g)

  AspiriFridays - Sean from SCT Software

  David, Damian, and Maddy join Sean Killeen from SCT Software to Aspireify his production code.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=Js06lpu_YsM)

  AspiriFridays - Tommaso Stocchi and Jerry Nixon with Data API Builder

  Maddy and Damian join special guests Tommaso Stocchi and Jerry Nixon to Aspirify the Azure Data API Builder after a summer break.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=MbTHQCO5TEo)

  AspiriFridays - Oisin and ProjectCommander

  The Aspire team joins Oisin to add Aspire to ProjectCommander.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=IEXiSAMMRdU)

  AspiriFridays - Maddy vs Deployment

  Join Maddy as she tackles Aspire deployment challenges.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=Z1EjpsOAZBU)

  AspiriFridays - Hanselman gets Aspirified

  The team joins Scott Hanselman to Aspirify his application.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=29zIIH9rMtU)

  Aspire 9.5 Release Party + Unboxing

  Join the team for a special release party celebrating Aspire 9.5.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=80ckukH-29w)

  AspiriFridays - Maddy vs Deployment Pt 2: The Proxies Strike Back

  Maddy continues her deployment journey with proxy configurations.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=rrurHUfzyTY)

  AspiriFridays - Excalidraw

  The Aspire team adds Aspire to Excalidraw.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=9ORep52vuQk)

  AspiriFridays - Bingo Deployment, Rogue Edition

  A rogue edition of deployment challenges with the Bingo app.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=P7JJcTVe1Xo)

  (Not) AspiriFridays - Maddy is back!

  Maddy returns to the stream.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=inowoXFbP9s)

  AspiriFridays - Halloween Edition

  A special Halloween edition of AspiriFridays.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=IuDgGIuNqG4)

  AspiriFridays - GitHub Codespaces with Thomas Mahlberg

  The team joins Thomas Mahlberg to explore Aspire with GitHub Codespaces.

  OfficialAspiriFridays

* [Play](https://youtube.com/watch?v=zbm4BzIN6rk)

  AspiriFridays - Updating Samples to 13

  The team works on updating Aspire samples to version 13.

  OfficialAspiriFridays

### .NET Conf 2025

[Section titled “.NET Conf 2025”](#net-conf-2025)

* [Play](https://youtube.com/watch?v=FcAi-kqo3ps)

  Taking .NET out of Aspire

  Learn how to orchestrate non-.NET applications like Python and Node.js with Aspire.

  Official.NET Conf 2025Polyglot

* [Play](https://youtube.com/watch?v=8NoetLolw-0)

  Aspire Documented with Copilot

  Automatically generate living documentation from Aspire AppHost definitions using GitHub Copilot.

  Official.NET Conf 2025Documentation

* [Play](https://youtube.com/watch?v=p_zslgBi06k)

  Windows 365 Meets Aspire

  Boost multi-repo microservice productivity with Aspire extensions for simplified onboarding.

  Official.NET Conf 2025Microservices

* [Play](https://youtube.com/watch?v=u0iK6Bv5BZ0)

  Taming Service Dependencies with Aspire

  Simplify managing databases, message queues, and APIs with Aspire for local development.

  Official.NET Conf 2025Dependencies

* [Play](https://youtube.com/watch?v=aXouOsBh4ro)

  Cloud-Native Development Simplified

  Overview of Aspire features for building cloud-native applications with service discovery and telemetry.

  Official.NET Conf 2025Cloud-Native

* [Play](https://youtube.com/watch?v=UQiL3nbQbtM)

  Extending and Customizing Aspire

  David Fowler and Damian Edwards show how to build custom integrations and resource types.

  Official.NET Conf 2025Deep Dive

* [Play](https://youtube.com/watch?v=dJdXdRiIfDw)

  Aspire Unplugged with David and Maddy

  Informal conversation about Aspire's vision, design decisions, and future direction.

  Official.NET Conf 2025Interview

### Community Videos

[Section titled “Community Videos”](#community-videos)

* [Play](https://youtube.com/watch?v=sKGx3mOPlB0)

  Aspire is Finally Awesome

  Nick Chapsas shows you every .NET Aspire 9 features and explain why I finally think that it is production ready and that everyone should be using it.

  Community9.0

* [Play](https://youtube.com/watch?v=QvSDRRGv8cs)

  Aspire 9.2 is Amazing

  In this video, Milan Jovanović demonstrates how to upgrade an existing .NET Aspire 8 application to the newly released Aspire 9.2

  9.2CommunityUpgrade

* [Play](https://youtube.com/watch?v=dftmYBuZOLA)

  Microservices: Aspire & Blazor SSR

  Codewrinkles builds a microservices app, orchestrated with .NET Aspire and using Blazor SSR on the front end.

  CommunityBlazorSSR

* [Play](https://youtube.com/watch?v=EvxmwQKJ4Nw)

  Aspire Dashboard in 60 Seconds

  David Fowler and Nick Chapsas quickly discuss the future of app development with Aspire.

  CommunityShorts

* [Play](https://youtube.com/watch?v=g-fKXzrNOhI)

  Your first Azure Function with Aspire

  In this video, you will learn how to build your first Azure Function with Aspire support.

  OfficalAzure FunctionsServerless

* [Play](https://youtube.com/watch?v=J02mvcEKrsI)

  Cloud-native apps with Aspire

  The launch of Aspire promises to revolutionise the development of microservices, solving many of the problems developers face.

  Community.NET

* [Play](https://youtube.com/watch?v=fN3ufsIF7vs)

  What is Aspire?

  Aspire is a cloud-ready stack for building distributed apps. See how to add Aspire to an existing app with Redis, OTEL, and Postgres!

  Community.NET

* [Play](https://youtube.com/watch?v=dJ4uEANZIdQ)

  Introducing Aspire

  Fritz introduces Aspire and shows how to add it to existing apps for distributed development and deployment.

  CommunityTwitch

# Aspire dashboard configuration

> Aspire dashboard configuration options

The dashboard is configured when it starts up. Configuration includes frontend and OpenTelemetry Protocol (OTLP) addresses, the resource service endpoint, authentication, telemetry limits, and more.

Caution

The dashboard displays information about resources, including their configuration, console logs and in-depth telemetry.

Data displayed in the dashboard can be sensitive. For example, secrets in environment variables, and sensitive runtime data in telemetry. Care should be taken to configure the dashboard to secure access.

For more information, see [dashboard security](/dashboard/security-considerations/).

## How to configure the dashboard

[Section titled “How to configure the dashboard”](#how-to-configure-the-dashboard)

How you configure the dashboard depends on whether it’s started by the Aspire AppHost project or run in [standalone mode](overview#standalone-mode).

### Aspire AppHost

[Section titled “Aspire AppHost”](#aspire-apphost)

The AppHost automatically configures the dashboard, but you can override values if needed. The recommended way to configure the dashboard from the Aspire AppHost is by adding environment variables to the *launchSettings.json* file.

JSON — launchSettings.json

```json
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:17134;http://localhost:15170",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21030",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22057",
        "DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT": "50000"
      }
    }
  }
}
```

These launch settings increase the `Dashboard:TelemetryLimits:MaxLogCount` [telemetry limit](#telemetry-limits) to 50,000. The `:` delimiter must be replaced with double underscore (`__`) in environment variable names.

### Standalone dashboard

[Section titled “Standalone dashboard”](#standalone-dashboard)

There are many ways to provide configuration:

* Command line arguments.
* Environment variables. The `:` delimiter should be replaced with double underscore (`__`) in environment variable names.
* Optional JSON configuration file. The `ASPIRE_DASHBOARD_CONFIG_FILE_PATH` setting can be used to specify a JSON configuration file.

Consider the following example, which shows how to configure the dashboard when started from a Docker container:

* Bash

  ```bash
  docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard \
      -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT='1000' \
      -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT='1000' \
      -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT='1000' \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard `
      -e DASHBOARD__TELEMETRYLIMITS__MAXLOGCOUNT='1000' `
      -e DASHBOARD__TELEMETRYLIMITS__MAXTRACECOUNT='1000' `
      -e DASHBOARD__TELEMETRYLIMITS__MAXMETRICSCOUNT='1000' `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

Alternatively, these same values could be configured using a JSON configuration file that is specified using `ASPIRE_DASHBOARD_CONFIG_FILE_PATH`:

JSON — appsettings.json

```json
{
  "Dashboard": {
    "TelemetryLimits": {
      "MaxLogCount": 50000,
      "MaxTraceCount": 50000,
      "MaxMetricsCount": 50000
    }
  }
}
```

## Common configuration

[Section titled “Common configuration”](#common-configuration)

| Option                                                                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| --------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ASPNETCORE_URLS` Default: `http://localhost:18888`                         | One or more HTTP endpoints through which the dashboard frontend is served. The frontend endpoint is used to view the dashboard in a browser. When the dashboard is launched by the Aspire AppHost this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended.                                                                                                                                                                                     |
| `ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL` Default: `http://localhost:18889`      | The [OTLP/gRPC](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc) endpoint. This endpoint hosts an OTLP service and receives telemetry using gRPC. When the dashboard is launched by the Aspire AppHost this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended.                                                                                                                                                                             |
| `ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL` Default: `http://localhost:18890` | The [OTLP/HTTP](https://opentelemetry.io/docs/specs/otlp/#otlphttp) endpoint. This endpoint hosts an OTLP service and receives telemetry using Protobuf over HTTP. When the dashboard is launched by the Aspire AppHost the OTLP/HTTP endpoint isn’t configured by default. To configure an OTLP/HTTP endpoint with the AppHost, set an `ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL` env var value in *launchSettings.json*. Securing the dashboard with HTTPS is recommended. |
| `ASPIRE_DASHBOARD_MCP_ENDPOINT_URL` Default: `http://localhost:18891`       | The [Aspire MCP](/dashboard/mcp-server/) endpoint. When this value isn’t specified then the MCP server is hosted with an `ASPNETCORE_URLS` endpoint. The MCP server can be disabled by configuring `Dashboard:Mcp:Disabled` to `true`. When the dashboard is launched by the Aspire AppHost this address is secured with HTTPS. Securing the dashboard with HTTPS is recommended.                                                                                           |
| `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS` Default: `false`               | Configures the dashboard to not use authentication and accepts anonymous access. This setting is a shortcut to configuring `Dashboard:Frontend:AuthMode`, `Dashboard:Otlp:AuthMode` and `Dashboard:Mcp:AuthMode` to `Unsecured`.                                                                                                                                                                                                                                            |
| `ASPIRE_DASHBOARD_CONFIG_FILE_PATH` Default: `null`                         | The path for a JSON configuration file. If the dashboard is being run in a Docker container, then this is the path to the configuration file in a mounted volume. This value is optional.                                                                                                                                                                                                                                                                                   |
| `ASPIRE_DASHBOARD_FILE_CONFIG_DIRECTORY` Default: `null`                    | The directory where the dashboard looks for key-per-file configuration. This value is optional.                                                                                                                                                                                                                                                                                                                                                                             |
| `ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL` Default: `null`                      | The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs. This setting is a shortcut to `Dashboard:ResourceServiceClient:Url`.                                                                                                                                                                                                                                 |

## Frontend

[Section titled “Frontend”](#frontend)

The dashboard frontend endpoint authentication is configured with `Dashboard:Frontend:AuthMode`. The frontend can be secured with OpenID Connect (OIDC) or browser token authentication.

Browser token authentication works by the frontend asking for a token. The token can either be entered in the UI or provided as a query string value to the login page. For example, `https://localhost:1234/login?t=TheToken`. When the token is successfully authenticated an auth cookie is persisted to the browser, and the browser is redirected to the app.

| Option                                                                             | Description                                                                                                                                                                                                                                                                                                                                     |
| ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Dashboard:Frontend:AuthMode` Default: `BrowserToken`                              | Can be set to `BrowserToken`, `OpenIdConnect` or `Unsecured`. `Unsecured` should only be used during local development. It’s not recommended when hosting the dashboard publicly or in other settings.                                                                                                                                          |
| `Dashboard:Frontend:BrowserToken` Default: `null`                                  | Specifies the browser token. If the browser token isn’t specified, then the dashboard generates one. Tooling that wants to automate logging in with browser token authentication can specify a token and open a browser with the token in the query string. A new token should be generated each time the dashboard is launched.                |
| `Dashboard:Frontend:PublicUrl` Default: `null`                                     | Specifies the public URL used to access the dashboard frontend. The public URL is used when constructing links to the dashboard frontend. If a public URL isn’t specified, the frontend endpoint is used instead. This setting is important when the dashboard is accessed through a proxy and the dashboard endpoint isn’t directly reachable. |
| `Dashboard:Frontend:OpenIdConnect:NameClaimType` Default: `name`                   | Specifies one or more claim types that should be used to display the authenticated user’s full name. Can be a single claim type or a comma-delimited list of claim types.                                                                                                                                                                       |
| `Dashboard:Frontend:OpenIdConnect:UsernameClaimType` Default: `preferred_username` | Specifies one or more claim types that should be used to display the authenticated user’s username. Can be a single claim type or a comma-delimited list of claim types.                                                                                                                                                                        |
| `Dashboard:Frontend:OpenIdConnect:RequiredClaimType` Default: `null`               | Specifies the claim that must be present for authorized users. Authorization fails without this claim. This value is optional.                                                                                                                                                                                                                  |
| `Dashboard:Frontend:OpenIdConnect:RequiredClaimValue` Default: `null`              | Specifies the value of the required claim. Only used if `Dashboard:Frontend:OpenIdConnect:RequireClaimType` is also specified. This value is optional.                                                                                                                                                                                          |
| `Authentication:Schemes:OpenIdConnect:Authority` Default: `null`                   | URL to the identity provider (IdP).                                                                                                                                                                                                                                                                                                             |
| `Authentication:Schemes:OpenIdConnect:ClientId` Default: `null`                    | Identity of the relying party (RP).                                                                                                                                                                                                                                                                                                             |
| `Authentication:Schemes:OpenIdConnect:ClientSecret` Default: `null`                | A secret that only the real RP would know.                                                                                                                                                                                                                                                                                                      |
| Other properties of `OpenIdConnectOptions` Default: `null`                         | Values inside configuration section `Authentication:Schemes:OpenIdConnect:*` are bound to `OpenIdConnectOptions`, such as `Scope`.                                                                                                                                                                                                              |

Note

Additional configuration may be required when using `OpenIdConnect` as authentication mode behind a reverse-proxy that terminates SSL. Check if you need `ASPNETCORE_FORWARDEDHEADERS_ENABLED` to be set to `true`.

For more information, see [Configure ASP.NET Core to work with proxy servers and load balancers](https://learn.microsoft.com/aspnet/core/host-and-deploy/proxy-load-balancer).

## OTLP

[Section titled “OTLP”](#otlp)

The OTLP endpoint authentication is configured with `Dashboard:Otlp:AuthMode`. The OTLP endpoint can be secured with an API key or [client certificate](http://learn.microsoft.com/aspnet/core/security/authentication/certauth) authentication.

API key authentication works by requiring each OTLP request to have a valid `x-otlp-api-key` header value. It must match either the primary or secondary key.

| Option                                                     | Description                                                                                                                                                                                                                                                                          |
| ---------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Dashboard:Otlp:AuthMode` Default: `Unsecured`             | Can be set to `ApiKey`, `Certificate` or `Unsecured`. `Unsecured` should only be used during local development. It’s not recommended when hosting the dashboard publicly or in other settings.                                                                                       |
| `Dashboard:Otlp:PrimaryApiKey` Default: `null`             | Specifies the primary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is required if auth mode is API key.                                                                                                            |
| `Dashboard:Otlp:SecondaryApiKey` Default: `null`           | Specifies the secondary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is optional. If a second API key is specified, then the incoming `x-otlp-api-key` header value can match either the primary or secondary key. |
| `Dashboard:Otlp:SuppressUnsecuredMessage` Default: `false` | Suppresses the unsecured message displayed in the dashboard when `Dashboard:Otlp:AuthMode` is `Unsecured`. This message should only be suppressed if an external frontdoor proxy is securing access to the endpoint.                                                                 |

## OTLP CORS

[Section titled “OTLP CORS”](#otlp-cors)

Cross-origin resource sharing (CORS) can be configured to allow browser apps to send telemetry to the dashboard.

By default, browser apps are restricted from making cross domain API calls. This impacts sending telemetry to the dashboard because the dashboard and the browser app are always on different domains. To configure CORS, use the `Dashboard:Otlp:Cors` section and specify the allowed origins and headers:

JSON — appsettings.json

```json
{
  "Dashboard": {
    "Otlp": {
      "Cors": {
        "AllowedOrigins": "http://localhost:5000,https://localhost:5001"
      }
    }
  }
}
```

Consider the following configuration options:

| Option                                               | Description                                                                                                                                                                                                                                |
| ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Dashboard:Otlp:Cors:AllowedOrigins` Default: `null` | Specifies the allowed origins for CORS. It’s a comma-delimited string and can include the `*` wildcard to allow any domain. This option is optional and can be set using the `DASHBOARD__OTLP__CORS__ALLOWEDORIGINS` environment variable. |
| `Dashboard:Otlp:Cors:AllowedHeaders` Default: `null` | A comma-delimited string representing the allowed headers for CORS. This setting is optional and can be set using the `DASHBOARD__OTLP__CORS__ALLOWEDHEADERS` environment variable.                                                        |

Note

The dashboard only supports the `POST` method for sending telemetry and doesn’t allow configuration of the *allowed methods* (`Access-Control-Allow-Methods`) for CORS.

## MCP

[Section titled “MCP”](#mcp)

The MCP endpoint authentication is configured with `Dashboard:Mcp:AuthMode`. The MCP endpoint can be secured with API key authentication.

API key authentication works by requiring each MCP request to have a valid `x-mcp-api-key` header value. It must match either the primary or secondary key.

| Option                                                    | Description                                                                                                                                                                                                                                                                                                                |
| --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Dashboard:Mcp:AuthMode` Default: `Unsecured`             | Can be set to `ApiKey` or `Unsecured`. `Unsecured` should only be used during local development. It’s not recommended when hosting the dashboard publicly or in other settings.                                                                                                                                            |
| `Dashboard:Mcp:PrimaryApiKey` Default: `null`             | Specifies the primary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is required if auth mode is API key.                                                                                                                                                  |
| `Dashboard:Mcp:SecondaryApiKey` Default: `null`           | Specifies the secondary API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended. This value is optional. If a second API key is specified, then the incoming `x-mcp-api-key` header value can match either the primary or secondary key.                                        |
| `Dashboard:Mcp:SuppressUnsecuredMessage` Default: `false` | Suppresses the unsecured message displayed in the dashboard when `Dashboard:Mcp:AuthMode` is `Unsecured`. This message should only be suppressed if an external frontdoor proxy is securing access to the endpoint.                                                                                                        |
| `Dashboard:Mcp:PublicUrl` Default: `null`                 | Specifies the public URL used to access the MCP server. The public URL is used when constructing links to the MCP server. If a public URL isn’t specified, the MCP endpoint is used instead. This setting is important when the dashboard is accessed through a proxy and the dashboard endpoint isn’t directly reachable. |
| `Dashboard:Mcp:Disabled` Default: `false`                 | Disables the MCP server and remove MCP UI in the dashboard.                                                                                                                                                                                                                                                                |

## Resources

[Section titled “Resources”](#resources)

The dashboard connects to a resource service to load and display resource information. The client is configured in the dashboard for how to connect to the service.

The resource service client authentication is configured with `Dashboard:ResourceServiceClient:AuthMode`. The client can be configured to support API key or client certificate authentication.

| Option                                                                              | Description                                                                                                                                                                                                                                                   |
| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Dashboard:ResourceServiceClient:Url` Default: `null`                               | The gRPC endpoint to which the dashboard connects for its data. If this value is unspecified, the dashboard shows telemetry data but no resource list or console logs.                                                                                        |
| `Dashboard:ResourceServiceClient:AuthMode` Default: `null`                          | Can be set to `ApiKey`, `Certificate` or `Unsecured`. `Unsecured` should only be used during local development. It’s not recommended when hosting the dashboard publicly or in other settings. This value is required if a resource service URL is specified. |
| `Dashboard:ResourceServiceClient:ApiKey` Default: `null`                            | The API to send to the resource service in the `x-resource-service-api-key` header. This value is required if auth mode is API key.                                                                                                                           |
| `Dashboard:ResourceServiceClient:ClientCertificate:Source` Default: `null`          | Can be set to `File` or `KeyStore`. This value is required if auth mode is client certificate.                                                                                                                                                                |
| `Dashboard:ResourceServiceClient:ClientCertificate:FilePath` Default: `null`        | The certificate file path. This value is required if source is `File`.                                                                                                                                                                                        |
| `Dashboard:ResourceServiceClient:ClientCertificate:Password` Default: `null`        | The password for the certificate file. This value is optional.                                                                                                                                                                                                |
| `Dashboard:ResourceServiceClient:ClientCertificate:Subject` Default: `null`         | The certificate subject. This value is required if source is `KeyStore`.                                                                                                                                                                                      |
| `Dashboard:ResourceServiceClient:ClientCertificate:Store` Default: `My`             | The certificate `X509Certificates.StoreName`.                                                                                                                                                                                                                 |
| `Dashboard:ResourceServiceClient:ClientCertificate:Location` Default: `CurrentUser` | The certificate `X509Certificates.StoreLocation`.                                                                                                                                                                                                             |

### Telemetry limits

[Section titled “Telemetry limits”](#telemetry-limits)

Telemetry is stored in memory. To avoid excessive memory usage, the dashboard has limits on the count and size of stored telemetry. When a count limit is reached, new telemetry is added, and the oldest telemetry is removed. When a size limit is reached, data is truncated to the limit.

Telemetry limits have different scopes depending upon the telemetry type:

* `MaxLogCount` and `MaxTraceCount` are shared across resources. For example, a `MaxLogCount` value of 5,000 configures the dashboard to store up to 5,000 total log entries for all resources.
* `MaxMetricsCount` is per-resource. For example, a `MaxMetricsCount` value of 10,000 configures the dashboard to store up to 10,000 metrics data points per-resource.

| Option                                                         | Description                                                          |
| -------------------------------------------------------------- | -------------------------------------------------------------------- |
| `Dashboard:TelemetryLimits:MaxLogCount` Default: `10,000`      | The maximum number of log entries. Limit is shared across resources. |
| `Dashboard:TelemetryLimits:MaxTraceCount` Default: `10,000`    | The maximum number of log traces. Limit is shared across resources.  |
| `Dashboard:TelemetryLimits:MaxMetricsCount` Default: `50,000`  | The maximum number of metric data points. Limit is per-resource.     |
| `Dashboard:TelemetryLimits:MaxAttributeCount` Default: `128`   | The maximum number of attributes on telemetry.                       |
| `Dashboard:TelemetryLimits:MaxAttributeLength` Default: `null` | The maximum length of attributes.                                    |
| `Dashboard:TelemetryLimits:MaxSpanEventCount` Default: `null`  | The maximum number of events on span attributes.                     |

## Other

[Section titled “Other”](#other)

| Option                                               | Description                                                                                                                                                                              |
| ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Dashboard:ApplicationName` Default: `Aspire`        | The application name to be displayed in the UI. This applies only when no resource service URL is specified. When a resource service exists, the service specifies the application name. |
| `Dashboard:UI:DisableResourceGraph` Default: `false` | Disables displaying the resource graph UI in the dashboard.                                                                                                                              |

## Next steps

[Section titled “Next steps”](#next-steps)

* [Security considerations for running the Aspire dashboard](/dashboard/security-considerations/)

# GitHub Copilot in the Aspire dashboard

> Learn how to use GitHub Copilot in the Aspire dashboard.

New in Aspire 13.1

Starting with Aspire 13.1, you can configure the MCP server automatically using the `aspire mcp init` command. See [Configure MCP](/get-started/configure-mcp/) for the recommended approach.

Introducing GitHub Copilot in the Aspire dashboard! GitHub Copilot is your new AI debugging assistant.

GitHub Copilot supercharges the dashboard’s OpenTelemetry debugging and diagnostics experience. With AI, you can:

* Review hundreds of log messages with a single click.
* Investigate the root cause of errors across multiple apps.
* Highlight performance issues in traces.
* Explain obscure error codes using AI’s huge knowledge repository.

You’ll have access to Copilot in the dashboard when you launch your app from VS Code or Visual Studio.

## Requirements

[Section titled “Requirements”](#requirements)

GitHub Copilot is only available when an Aspire project is run from an IDE.

* VS Code and C# Dev Kit 1.19.63 or later.
* Visual Studio 17.14 or later.

You must also be logged into a GitHub account in the IDE that has a GitHub Copilot subscription. Copilot interactions in the Aspire dashboard use the GitHub account associated with your IDE.

If you don’t have a Copilot subscription yet, you can use Copilot for free by signing up for the [Copilot Free plan](https://aka.ms/dotnet/aspire/copilot-free-signup), which includes a monthly limit of chat interactions.

## Get started

[Section titled “Get started”](#get-started)

To get started, launch your Aspire solution as usual in your IDE.

1. Open your Aspire solution in a supported version of Visual Studio or VS Code with the C# Dev Kit extension installed.

2. Ensure you’re logged into the IDE with a GitHub account:

   * For Visual Studio, see [Add your GitHub accounts to your Visual Studio keychain](https://aka.ms/dotnet/aspire/copilot-vs-login).
   * For VS Code and C# Dev Kit, see [Set up GitHub Copilot in VS Code](https://aka.ms/dotnet/aspire/copilot-vscode-login).

3. Run the Aspire AppHost.

A GitHub Copilot button appears in the top-right corner of the dashboard. Selecting the button opens the Copilot UI.

![A screenshot of the dashboard with the GitHub Copilot button highlighted.](/_astro/copilot-headerbutton.DGq3c8We_1kS7Ga.webp)

In the Copilot UI, you can either select a suggested question, such as **Summarize resources**, or enter your own question in the chat input field. Press Enter to submit. For example: `What health checks are configured in my app?`

![A screenshot of the dashboard with GitHub Copilot open. It contains a chat question and answer.](/_astro/copilot-chatquestion.DT9DgJ52_pgY89.webp)

At the top of the Copilot UI are buttons to start a new conversation, expand the chat, or close the UI.

## Analyze resources, console logs, and telemetry

[Section titled “Analyze resources, console logs, and telemetry”](#analyze-resources-console-logs-and-telemetry)

There are several options for analyzing resources, console logs, and telemetry in your app. Two were discussed above:

* Select a suggested question. Copilot’s suggested questions are contextual. For example, questions about resources appear on the resources page, and questions about distributed traces appear on the traces page.
* Enter your own question in the chat input field, such as `Why did the product cache fail to start?` or `What caused recent errors in the frontend?`

The dashboard also includes a Copilot option in the context menus for resources, structured logs, traces, and spans. Select **Ask GitHub Copilot** to investigate the selected data.

![A screenshot of the Ask GitHub Copilot option in the resource context menu page.](/_astro/resources-askcopilot.Z7RKIEwb_27vz0B.webp)

If your app has structured logs or traces with errors, an **Explain errors** button appears on those pages. Selecting it makes all errors available to Copilot for investigation.

![A screenshot of the structured logs page with an Explain errors button.](/_astro/structuredlogs-explainerror.DDJpS6lO_20NGGn.webp)

On the trace details page, the **Explain trace** button is always visible. It provides a quick way to analyze the currently viewed trace.

![A screenshot of the trace details page with an Explain trace button.](/_astro/tracedetails-explaintrace.D0op0vaB_1UtE5x.webp)

## Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

### Copilot hangs on “Getting ready”

[Section titled “Copilot hangs on “Getting ready””](#copilot-hangs-on-getting-ready)

A known issue can cause the Copilot UI to hang with a “Getting ready” message when it is first accessed. This occurs when the dashboard is not launched from a [supported version](#requirements) of Visual Studio or VS Code, or when no GitHub account is logged into the IDE. Closing and reopening the Copilot UI fixes the issue. Once fixed, the UI correctly displays a message with requirements for using the dashboard with GitHub Copilot.

### Reached monthly limit of Copilot Free plan

[Section titled “Reached monthly limit of Copilot Free plan”](#reached-monthly-limit-of-copilot-free-plan)

The GitHub Copilot Free plan includes a monthly limit on chat usage. When this limit is exceeded, Copilot will no longer function in the dashboard. [Upgrade your Copilot subscription](https://aka.ms/dotnet/aspire/copilot-pro) or wait for the limit to reset.

## Limitations

[Section titled “Limitations”](#limitations)

### Data size

[Section titled “Data size”](#data-size)

AI models have limits on how much data they can process at once. The Aspire dashboard may limit the amount of data sent to GitHub Copilot when necessary.

* Large data fields (e.g., long exception stack traces) may be truncated.
* Requests involving large collections of telemetry may be shortened by omitting older items.

## Disable GitHub Copilot in the dashboard

[Section titled “Disable GitHub Copilot in the dashboard”](#disable-github-copilot-in-the-dashboard)

GitHub Copilot only accesses data when you explicitly interact with it. For example, submitting a chat query or selecting **Ask GitHub Copilot** from a context menu.

If you prefer to disable the feature entirely, set the `ASPIRE_DASHBOARD_AI_DISABLED` environment variable to `true` in your AppHost’s *launchSettings.json* file. This hides all Copilot UI elements in the dashboard.

launchSettings.json

```json
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:17129;http://localhost:15010",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21124",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22206",
        "ASPIRE_DASHBOARD_AI_DISABLED": "true"
      }
    }
  }
}
```

## GitHub Copilot frequently asked questions

[Section titled “GitHub Copilot frequently asked questions”](#github-copilot-frequently-asked-questions)

For more information about GitHub Copilot, such as questions around plans, privacy and responsible AI usage, see the [GitHub Copilot frequently asked questions](https://github.com/features/copilot#faq).

# Enable browser telemetry

> Learn how to enable browser telemetry in the Aspire dashboard.

The Aspire dashboard can be configured to receive telemetry sent from browser apps. This feature is useful for monitoring client-side performance and user interactions. Browser telemetry requires additional dashboard configuration and that the [JavaScript OTEL SDK](https://opentelemetry.io/docs/languages/js/getting-started/browser/) is added to the browser apps.

This article discusses how to enable browser telemetry in the Aspire dashboard.

## Dashboard configuration

[Section titled “Dashboard configuration”](#dashboard-configuration)

Browser telemetry requires the dashboard to enable these features:

* OTLP HTTP endpoint. This endpoint is used by the dashboard to receive telemetry from browser apps.
* Cross-origin resource sharing (CORS). CORS allows browser apps to make requests to the dashboard.

### OTLP configuration

[Section titled “OTLP configuration”](#otlp-configuration)

The Aspire dashboard receives telemetry through OTLP endpoints. [HTTP OTLP endpoints](https://opentelemetry.io/docs/specs/otlp/#otlphttp) and gRPC OTLP endpoints are supported by the dashboard. Browser apps must use HTTP OLTP to send telemetry to the dashboard because browser apps don’t support gRPC.

To configure the gPRC or HTTP endpoints, specify the following environment variables:

* `ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL`: The gRPC endpoint to which the dashboard connects for its data.
* `ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL`: The HTTP endpoint to which the dashboard connects for its data.

Configuration of the HTTP OTLP endpoint depends on whether the dashboard is started by the AppHost or is run standalone.

#### Configure OTLP HTTP with AppHost

[Section titled “Configure OTLP HTTP with AppHost”](#configure-otlp-http-with-apphost)

If the dashboard and your app are started by the AppHost, the dashboard OTLP endpoints are configured in the AppHost’s *launchSettings.json* file.

Consider the following example *launchSettings.json* file:

JSON — launchSettings.json

```json
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:15887;http://localhost:15888",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL": "https://localhost:16175",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:17037",
        "ASPIRE_SHOW_DASHBOARD_RESOURCES": "true"
      }
    },
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:15888",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL": "http://localhost:16175",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "http://localhost:17037",
        "ASPIRE_SHOW_DASHBOARD_RESOURCES": "true",
        "ASPIRE_ALLOW_UNSECURED_TRANSPORT": "true"
      }
    },
    "generate-manifest": {
      "commandName": "Project",
      "launchBrowser": true,
      "dotnetRunMessages": true,
      "commandLineArgs": "--publisher manifest --output-path aspire-manifest.json",
      "applicationUrl": "http://localhost:15888",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development"
      }
    }
  }
}
```

The preceding launch settings JSON file configures all profiles to include the `ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL` environment variable.

#### Configure OTLP HTTP with standalone dashboard

[Section titled “Configure OTLP HTTP with standalone dashboard”](#configure-otlp-http-with-standalone-dashboard)

If the dashboard is used standalone, without the rest of Aspire, the OTLP HTTP endpoint is enabled by default on port `18890`. However, the port must be mapped when the dashboard container is started:

* Bash

  ```bash
  docker run --rm -it -d \
      -p 18888:18888 \
      -p 4317:18889 \
      -p 4318:18890 \
      --name aspire-dashboard \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -d `
      -p 18888:18888 `
      -p 4317:18889 `
      -p 4318:18890 `
      --name aspire-dashboard `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

The preceding command runs the dashboard container and maps gRPC OTLP to port `4317` and HTTP OTLP to port `4318`.

### CORS configuration

[Section titled “CORS configuration”](#cors-configuration)

By default, browser apps are restricted from making cross domain API calls. This impacts sending telemetry to the dashboard because the dashboard and the browser app are always on different domains. Configuring CORS in the Aspire dashboard removes the restriction.

If the dashboard and your app are started by the AppHost, no CORS configuration is required. Aspire automatically configures the dashboard to allow all resource origins.

If the dashboard is used standlone then CORS must be configured manually. The domain used to view the browser app must be configured as an allowed origin by specifing the `DASHBOARD__OTLP__CORS__ALLOWEDORIGINS` environment variable when the dashboard container is started.

* Bash

  ```bash
  docker run --rm -it -d \
      -p 18888:18888 \
      -p 4317:18889 \
      -p 4318:18890 \
      -e DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=https://localhost:8080 \
      --name aspire-dashboard \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -d `
      -p 18888:18888 `
      -p 4317:18889 `
      -p 4318:18890 `
      -e DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=https://localhost:8080 `
      --name aspire-dashboard `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

The preceding command runs the dashboard container and configures `https://localhost:8080` as an allowed origin. That means a browser app that is accessed using `https://localhost:8080` has permission to send the dashboard telemetry.

Multiple origins can be allowed with a comma separated value. Or all origins can be allowed with the `*` wildcard. For example, `DASHBOARD__OTLP__CORS__ALLOWEDORIGINS=*`.

For more information, see [Aspire dashboard configuration: OTLP CORS](configuration#otlp-cors).

### OTLP endpoint security

[Section titled “OTLP endpoint security”](#otlp-endpoint-security)

Dashboard OTLP endpoints can be secured with API key authentication. When enabled, HTTP OTLP requests to the dashboard must include the API key as the `x-otlp-api-key` header. By default a new API key is generated each time the dashboard is run.

API key authentication is automatically enabled when the dashboard is run from the AppHost. Dashboard authentication can be disabled by setting `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS` to `true` in the AppHost’s *launchSettings.json* file.

OTLP endpoints are unsecured by default in the standalone dashboard.

## Browser app configuration

[Section titled “Browser app configuration”](#browser-app-configuration)

A browser app uses the [JavaScript OTEL SDK](https://opentelemetry.io/docs/languages/js/getting-started/browser/) to send telemetry to the dashboard. Successfully sending telemetry to the dashboard requires the SDK to be correctly configured.

### OTLP exporter

[Section titled “OTLP exporter”](#otlp-exporter)

OTLP exporters must be included in the browser app and configured with the SDK. For example, exporting distributed tracing with OTLP uses the [@opentelemetry/exporter-trace-otlp-proto](https://www.npmjs.com/package/@opentelemetry/exporter-trace-otlp-proto) package.

When OTLP is added to the SDK, OTLP options must be specified. OTLP options includes:

* `url`: The address that HTTP OTLP requests are made to. The address should be the dashboard HTTP OTLP endpoint and the path to the OTLP HTTP API. For example, `https://localhost:4318/v1/traces` for the trace OTLP exporter. If the browser app is launched by the AppHost then the HTTP OTLP endpoint is available from the `OTEL_EXPORTER_OTLP_ENDPOINT` environment variable.

* `headers`: The headers sent with requests. If OTLP endpoint API key authentication is enabled the `x-otlp-api-key` header must be sent with OTLP requests. If the browser app is launched by the AppHost then the API key is available from the `OTEL_EXPORTER_OTLP_HEADERS` environment variable.

### Browser metadata

[Section titled “Browser metadata”](#browser-metadata)

When a browser app is configured to collect distributed traces, the browser app can set the trace parent a browser’s spans using the `meta` element in the HTML. The value of the `name="traceparent"` meta element should correspond to the current trace.

In a .NET app, for example, the trace parent value would likely be assigned from the `Activity.Current` and passing its `Activity.Id` value as the `content`. For example, consider the following Razor code:

```razor
<head>
    @if (Activity.Current is { } currentActivity)
    {
        <meta name="traceparent" content="@currentActivity.Id" />
    }
    <!-- Other elements omitted for brevity... -->
</head>
```

The preceding code sets the `traceparent` meta element to the current activity ID.

## Example browser telemetry code

[Section titled “Example browser telemetry code”](#example-browser-telemetry-code)

The following JavaScript code demonstrates the initialization of the OpenTelemetry JavaScript SDK and the sending of telemetry data to the dashboard:

```javascript
import { ConsoleSpanExporter, SimpleSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { DocumentLoadInstrumentation } from '@opentelemetry/instrumentation-document-load';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { resourceFromAttributes } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { ZoneContextManager } from '@opentelemetry/context-zone';


export function initializeTelemetry(otlpUrl, headers, resourceAttributes) {
    const otlpOptions = {
        url: `${otlpUrl}/v1/traces`,
        headers: parseDelimitedValues(headers)
    };


    const attributes = parseDelimitedValues(resourceAttributes);
    attributes[SemanticResourceAttributes.SERVICE_NAME] = 'browser';


    const provider = new WebTracerProvider({
        resource: resourceFromAttributes(attributes),
    });
    provider.addSpanProcessor(new SimpleSpanProcessor(new ConsoleSpanExporter()));
    provider.addSpanProcessor(new SimpleSpanProcessor(new OTLPTraceExporter(otlpOptions)));


    provider.register({
        // Prefer ZoneContextManager: supports asynchronous operations
        contextManager: new ZoneContextManager(),
    });


    // Registering instrumentations
    registerInstrumentations({
        instrumentations: [new DocumentLoadInstrumentation()],
    });
}


function parseDelimitedValues(s) {
    const headers = s.split(','); // Split by comma
    const result = {};


    headers.forEach(header => {
        const [key, value] = header.split('='); // Split by equal sign
        result[key.trim()] = value.trim(); // Add to the object, trimming spaces
    });


    return result;
}
```

The preceding JavaScript code defines an `initializeTelemetry` function that expects the OTLP endpoint URL, the headers, and the resource attributes. These parameters are provided by the consuming browser app that pulls them from the environment variables set by the app host. Consider the following Razor code:

```razor
@using System.Diagnostics
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@ViewData["Title"] - BrowserTelemetry</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="~/css/site.css" asp-append-version="true" />


    @if (Activity.Current is { } currentActivity)
    {
        <meta name="traceparent" content="@currentActivity.Id" />
    }
</head>
<body>
    <header>
        <nav class="navbar navbar-expand-sm navbar-toggleable-sm navbar-light bg-white border-bottom box-shadow mb-3">
            <div class="container">
                <a class="navbar-brand" asp-area="" asp-page="/Index">BrowserTelemetry</a>
            </div>
        </nav>
    </header>
    <div class="container">
        <main role="main" class="pb-3">
            @RenderBody()
        </main>
    </div>
    @await RenderSectionAsync("Scripts", required: false)
    <script src="scripts/bundle.js"></script>
    @if (Environment.GetEnvironmentVariable("OTEL_EXPORTER_OTLP_ENDPOINT") is { Length: > 0 } endpointUrl)
    {
        var headers = Environment.GetEnvironmentVariable("OTEL_EXPORTER_OTLP_HEADERS");
        var attributes = Environment.GetEnvironmentVariable("OTEL_RESOURCE_ATTRIBUTES");
        <script>
            BrowserTelemetry.initializeTelemetry('@endpointUrl', '@headers', '@attributes');
        </script>
    }
</body>
</html>
```

Tip

The bundling and minification of the JavaScript code is beyond the scope of this article.

For the complete working example of how to configure the JavaScript OTEL SDK to send telemetry to the dashboard, see the [browser telemetry sample](https://github.com/dotnet/aspire/tree/main/playground/BrowserTelemetry).

## See also

[Section titled “See also”](#see-also)

* [Aspire dashboard configuration](/dashboard/configuration/)
* [Standalone Aspire dashboard](/dashboard/standalone/)

# Explore Aspire dashboard

> Explore the Aspire dashboard features through the Aspire Starter app.

In the upcoming sections, you discover how to create an Aspire project and embark on the following tasks:

* Investigate the dashboard’s capabilities by using the app generated from the project template as explained in the [Quickstart: Build your first Aspire project.](/get-started/first-app/)
* Delve into the features of the Aspire dashboard app.

The screenshots featured in this article showcase the dark theme. For more information on theme selection, see [Theme selection](#theme-selection).

The Aspire dashboard also includes **GitHub Copilot**, your AI debugging assistant, which can help you analyze resources, logs, traces, and telemetry data. Copilot is available when you launch your app from VS Code or Visual Studio with a GitHub account that has a Copilot subscription. For complete details, see [GitHub Copilot in the Aspire dashboard](copilot).

## Dashboard authentication

[Section titled “Dashboard authentication”](#dashboard-authentication)

When you run an Aspire AppHost, the orchestrator starts up all the app’s dependent resources and then opens a browser window to the dashboard. The Aspire dashboard requires token-based authentication for its users because it displays environment variables and other sensitive information.

When the dashboard is launched from Visual Studio or Visual Studio Code (with the [C# Dev Kit extension](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit)), the browser is automatically logged in, and the dashboard opens directly. This is the typical developer F5 experience, and the authentication login flow is automated by the Aspire tooling.

However, if you start the AppHost from the command line, you’re presented with the login page. The console window displays a URL that you can select on to open the dashboard in your browser.

Example output of aspire run

```bash
aspire run


🔍  Finding apphosts...
apphost.cs


🗄  Created settings file at '.aspire/settings.json'.


        AppHost:  apphost.cs


    Dashboard:  https://localhost:17213/login?t=2b4a2ebc362b7fef9b5ccf73e702647b


        Logs:  $HOME/.aspire/cli/logs/apphost-27732-2025-10-31-19-21-27.log


                Press CTRL+C to stop the apphost and exit.
```

The URL contains a token query string (with the token value mapped to the `t` name part) that’s used to *log in* to the dashboard. If your console supports it, you can hold the  Command `Command` Control `Control` Control `Control` key and then select the link to open the dashboard in your browser. This method is easier than copying the token from the console and pasting it into the login page. If you end up on the dashboard login page without either of the previously described methods, you can always return to the console to copy the token.

![Aspire dashboard login page.](/_astro/aspire-login.Dfw43CHe_Z1w4QS7.webp)

The login page accepts a token and provides helpful instructions on how to obtain the token, as shown in the following screenshot:

![Aspire dashboard login page with instructions on how to obtain the token.](/_astro/aspire-login-help.RAeQC_Oz_2kFD1b.webp)

After copying the token from the console and pasting it into the login page, select the **Log in** button.

![Aspire dashboard login page with the token pasted into the textbox.](/_astro/aspire-login-filled.V8Jaeq6Q_Z26WLSa.webp)

The dashboard persists the token as a browser persistent cookie, which remains valid for three days. Persistent cookies have an expiration date and remain valid even after closing the browser. This means that users don’t need to log in again if they close and reopen the browser. For more information, see the [Security considerations for running the Aspire dashboard](/dashboard/security-considerations/) documentation.

Tip

You can also obtain the login token from the container logs. For more information, see [Login to the dashboard](/dashboard/standalone/#login-to-the-dashboard).

## Resources page

[Section titled “Resources page”](#resources-page)

The **Resources** page is the default home page of the Aspire dashboard. This page lists all of the projects, containers, and executables included in your Aspire solution. For example, the starter application includes two projects:

* **apiservice**: A back-end API project built using Minimal APIs.
* **webfrontend**: The front-end UI project built using Blazor.

The dashboard also provides essential details about each resource:

* **Type**: Displays whether the resource is a project, container, or executable.

* **Name**: The name of the resource.

* **State**: Displays whether or not the resource is currently running.
  * **Errors**: Within the **State** column, errors are displayed as a badge with the error count. It’s useful to understand quickly what resources are reporting errors. Selecting the badge takes you to the [semantic logs](#structured-logs-page) for that resource with the filter at an error level.

* **Start time**: When the resource started running.

* **Source**: The location of the resource on the device.

* **Endpoints**: One or more URLs to reach the running resource directly.

* **Logs**: A link to the resource logs page.

* **Actions**: A [set of actions](#resource-actions) that can be performed on the resource:

  * **Stop / Start**: Stop (or Start) the resource—depending on the current **State**.

  * **Console logs**: Navigate to the resource’s console logs.

  * **Ellipsis**: A submenu with extra resource specific actions:

    * **View details**: View the resource details.
    * **Console log**: Navigate to the resource’s console logs.
    * **Structured logs**: Navigate to the resource’s structured logs.
    * **Traces**: Navigate to the resource’s traces.
    * **Metrics**: Navigate to the resource’s metrics.
    * **Restart**: Stop and then start the resource.

Consider the following screenshot of the resources page:

![A screenshot of the Aspire dashboard Resources page.](/_astro/projects.DsYvwQXm_ZWdNRW.webp)

Alternatively, you can view the resources as a graph. The graph view provides a visual representation of the resources and their dependencies. This view is useful for understanding how the different resources in your app are connected and how they interact with each other:

![A screenshot of the Aspire dashboard Resources page in graph view.](/_astro/project-graphs.UgSAun99_ZUHnUm.webp)

You can interact with the graph by selecting a resource to view its details. The overall view also supports zooming in and out.

### Resource actions

[Section titled “Resource actions”](#resource-actions)

Each resource has a set of available actions that are conditionally enabled based on the resource’s current state. For example, if a resource is running, the **Stop** action is enabled. If the resource is stopped, the **Start** action is enabled. Likewise, some actions are disabled when they’re unavailable, for example, some resources don’t have structured logs. In these situations, the **Structured logs** action is disabled.

#### Stop or Start a resource

[Section titled “Stop or Start a resource”](#stop-or-start-a-resource)

The Aspire dashboard allows you to stop or start a resource by selecting the **Stop** or **Start** button in the **Actions** column. Consider the following screenshot of the resources page with the **Stop** button selected:

![Aspire dashboard stop resource.](/_astro/resource-stop-action.CnscEjGy_Z1ef88E.webp)

When you select **Stop**, the resource stops running, and the **State** column updates to reflect the change.

Note

For project resources, when the debugger is attached, it’s reattached on restart.

The **Start** button is then enabled, allowing you to start the resource again. Additionally, the dashboard displays a toast notification of the result of the action:

![Aspire dashboard resource stopped.](/_astro/resource-stopped-action.BJ5qsBIe_Z2hCr0K.webp)

When a resource is in a non-running state, the **Start** button is enabled. Selecting **Start** starts the resource, and the **State** column updates to reflect the change. The **Stop** button is then enabled, allowing you to stop the resource again. The dashboard displays a toast notification of the result of the action:

![Aspire dashboard started resource.](/_astro/resource-started-action.Cda3bNdk_1Olnso.webp)

Tip

Resources that depend on other resources that are stopped, or restarted, might experience temporary errors. This is expected behavior and is typically resolved when the dependent resources are in a **Running** state once again.

##### Resource submenu actions

[Section titled “Resource submenu actions”](#resource-submenu-actions)

Selecting the horizontal ellipsis icon in the **Actions** column opens a submenu with additional resource-specific actions. In addition to the built-in resource submenu actions, you can also define custom resource actions by defining custom commands. For more information, see [Custom resource commands in Aspire](https://learn.microsoft.com/dotnet/aspire/fundamentals/custom-resource-commands/). For the built-in resource submenu actions, consider the following screenshot:

![Aspire dashboard resource submenu actions.](/_astro/resource-actions.BhYwC8M8_QklMf.webp)

The following submenu actions are available:

* **View details**: View the resource details.
* **Console log**: Navigate to the resource’s console logs.
* **Structured logs**: Navigate to the resource’s structured logs.
* **Traces**: Navigate to the resource’s traces.
* **Metrics**: Navigate to the resource’s metrics.
* **Restart**: Stop and then start the resource.

Caution

There might be resources with disabled submenu actions. They’re greyed out when they’re disabled. For example, the following screenshot shows the submenu actions disabled:

![Aspire dashboard disabled submenu actions.](/_astro/resource-submenu-actions.gacagQ44_1CxzpG.webp)

When GitHub Copilot is available (when launching from VS Code or Visual Studio with a Copilot subscription), resource context menus also include an **Ask GitHub Copilot** option. This allows you to investigate resources using AI analysis.

#### Copy or Open in text visualizer

[Section titled “Copy or Open in text visualizer”](#copy-or-open-in-text-visualizer)

To view a *text visualizer* of certain columns, on hover you see a vertical ellipsis icon. Select the icon to display the available options:

* **Copy to clipboard**
* **Open in text visualizer**

Consider the following screenshot of the ellipsis menu options:

![A screenshot of the Aspire dashboard Resources page, showing the ellipsis menu options.](/_astro/text-visualizer-selection-menu.CNR1V2_3_1th6Kc.webp)

When you select the **Open in text visualizer** option, a modal dialog opens with the text displayed in a larger format. Consider the following screenshot of the text visualizer modal dialog:

![A screenshot of the Aspire dashboard Resources page, showing the text visualizer.](/_astro/text-visualizer-resources.C5X7sSAI_Z2cX2ya.webp)

Some values are formatted as JSON or XML. In these cases, the text visualizer enables the **Select format** dropdown to switch between the different formats.

### Resource details

[Section titled “Resource details”](#resource-details)

You can obtain full details about each resource by selecting the ellipsis button in the **Actions** column and then selecting **View details**. The **Details** page provides a comprehensive view of the resource:

![A screenshot of the Aspire dashboard Resources page with the details of a selected resource displayed.](/_astro/resource-details.DVJeeBvm_Z1pmUpj.webp)

The search bar in the upper right of the dashboard also provides the option to filter the list, which is useful for Aspire projects with many resources. To select the types of resources that are displayed, drop down the arrow to the left of the filter textbox:

![A screenshot of the resource type selector list in the Aspire dashboard Resources page.](/_astro/select-resource-type.h2A-6tQT_2rne4h.webp)

In this example, only containers are displayed in the list. For example, if you enable **Use Redis for caching** when creating a Aspire project, you should see a Redis container listed:

![A screenshot of the Aspire dashboard Resources page filtered to show only containers.](/_astro/resources-filtered-containers.BCOo52Ub_Z2g6p0k.webp)

Executables are stand-alone processes. You can configure a Aspire project to run a stand-alone executable during startup, though the default starter templates don’t include any executables by default.

The following screenshot shows an example of a project that has errors:

![A screenshot of the Aspire dashboard Resources page, showing a project with errors.](/_astro/projects-errors.Cs6GLaCJ_1chaAN.webp)

Selecting the error count badge navigates to the [Structured logs](#structured-logs-page) page with a filter applied to show only the logs relevant to the resource:

![A screenshot of the Aspire dashboard Structured logs page, showing a filter applied to show only the logs relevant to the resource.](/_astro/structured-logs-errors.lt_-2vve_2uRB8k.webp)

To see the log entry in detail for the error, select the **View** button to open a window below the list with the structured log entry details:

![A screenshot of the Aspire dashboard Structured logs page, showing a lower window with the structured log entry details.](/_astro/structured-logs-errors-view.C98fary-_PjbGz.webp)

For more information and examples of Structured logs, see the [Structured logs page](#structured-logs-page) section.

Note

The resources page isn’t available if the dashboard is started without a configured resource service. The dashboard starts on the [Structured logs page](#structured-logs-page) instead. This is the default experience when the dashboard is run in standalone mode without additional configuration.

For more information about configuring a resource service, see [Dashboard configuration](/dashboard/configuration/).

## Monitoring pages

[Section titled “Monitoring pages”](#monitoring-pages)

The Aspire dashboard provides various ways to view logs, traces, and metrics for your app. This information enables you to track the behavior and performance of your app and to diagnose any issues that arise.

### Console logs page

[Section titled “Console logs page”](#console-logs-page)

The **Console logs** page displays text that each resource in your app has sent to standard output. Logs are a useful way to monitor the health of your app and diagnose issues. Logs are displayed differently depending on the source, such as project, container, or executable.

When you open the Console logs page, you must select a source in the **Select a resource** drop-down list.

If you select a project, the live logs are rendered with a stylized set of colors that correspond to the severity of the log; green for information as an example. Consider the following example screenshot of project logs with the `apiservice` project selected:

![A screenshot of the Aspire dashboard Console Logs page with a source selected.](/_astro/project-logs.B7C9-teZ_2aViFC.webp)

When errors occur, they’re styled in the logs such that they’re easy to identify. Consider the following example screenshot of project logs with errors:

![A screenshot of the Aspire dashboard Console Logs page, showing logs with errors.](/_astro/project-logs-error.D3BQ-b_A_ZYhHvM.webp)

If you select a container or executable, formatting is different from a project but verbose behavior information is still available. Consider the following example screenshot of a container log with the `cache` container selected:

![A screenshot of the Aspire dashboard Console logs page with a container source selected.](/_astro/container-logs.DA_NCaZh_bdo9s.webp)

You can download any console log to your local machine and use your preferred text programs to analyze it:

![A screenshot of the Aspire dashboard Console logs page showing how to download a log to your local machine.](/_astro/download-console-logs.d89Mr8W0_JGbD6.webp)

#### Resource replicas

[Section titled “Resource replicas”](#resource-replicas)

When project resources are replicated using the `WithReplicas` API, they’re represented in the resource selector under a top-level named resource entry with an icon to indicator. Each replicated resource is listed under the top-level resource entry, with its corresponding unique name. Consider the following example screenshot of a replicated project resource:

![Aspire dashboard: Console logs page resource selector with nested replica resources.](/_astro/console-logs-with-replicas.BQ9VdNYV_ZSEWuP.webp)

The preceding screenshot shows the `catalogservice (application)` project with two replicas, `catalogservice-2bpj2qdq6k` and `catalogservice-6ljdin0hc0`. Each replica has its own set of logs that can be viewed by selecting the replica name.

### Structured logs page

[Section titled “Structured logs page”](#structured-logs-page)

Aspire automatically configures your projects with logging using OpenTelemetry. Navigate to the **Structured logs** page to view the semantic logs for your Aspire project. [Semantic, or structured logging](https://github.com/NLog/NLog/wiki/How-to-use-structured-logging) makes it easier to store and query log-events, as the log-event message-template and message-parameters are preserved, instead of just transforming them into a formatted message. You notice a clean structure for the different logs displayed on the page using columns:

* **Resource**: The resource the log originated from.
* **Level**: The log level of the entry, such as information, warning, or error.
* **Timestamp**: The time that the log occurred.
* **Message**: The details of the log.
* **Trace**: A link to the relevant trace for the log, if applicable.
* **Details**: Additional details or metadata about the log entry.

Consider the following example screenshot of semantic logs:

![A screenshot of the Aspire dashboard Semantic logs page.](/_astro/structured-logs.BGKYPgoZ_1hkTmR.webp)

#### Filter structured logs

[Section titled “Filter structured logs”](#filter-structured-logs)

The structured logs page also provides a search bar to filter the logs by service, level, or message. You use the **Level** drop down to filter by log level. You can also filter by any log property by selecting the filter icon button, which opens the advanced filter dialog.

Consider the following screenshots showing the structured logs filter dialog:

![A screenshot of the Aspire dashboard Structured logs page showing the filter dialog.](/_astro/structured-logs-filtered.gRP2jFej_2corHf.webp)

When GitHub Copilot is available and your app has structured logs with errors, an **Explain errors** button appears on the structured logs page. Selecting it makes all errors available to Copilot for AI-powered investigation. Additionally, structured log entries include an **Ask GitHub Copilot** option in their context menus.

### Traces page

[Section titled “Traces page”](#traces-page)

Navigate to the **Traces** page to view all of the traces for your app. Aspire automatically configures tracing for the different projects in your app. Distributed tracing is a diagnostic technique that helps engineers localize failures and performance issues within applications, especially those that might be distributed across multiple machines or processes. For more information, see [.NET distributed tracing](https://learn.microsoft.com/dotnet/core/diagnostics/distributed-tracing). This technique tracks requests through an application and correlates work done by different application integrations. Traces also help identify how long different stages of the request took to complete. The traces page displays the following information:

* **Timestamp**: When the trace completed.
* **Name**: The name of the trace, prefixed with the project name.
* **Spans**: The resources involved in the request.
* **Duration**: The time it took to complete the request. This column includes a radial icon that illustrates the duration of the request in comparison with the others in the list.

![A screenshot of the Aspire dashboard Traces page.](/_astro/traces.CtZeH-wc_Z1vYq7K.webp)

#### Filter traces

[Section titled “Filter traces”](#filter-traces)

The traces page also provides a search bar to filter the traces by name or span. Apply a filter, and notice the trace results are updated immediately. Consider the following screenshot of traces with a filter applied to `weather` and notice how the search term is highlighted in the results:

![A screenshot of the Aspire dashboard Traces page, showing a filter applied to show only traces with the term 'weather'.](/_astro/trace-view-filter.C-aIQExh_2pxlRq.webp)

When filtering traces in the **Add filter** dialog, after selecting a **Parameter** and corresponding **Condition**, the **Value** selection is pre-populated with the available values for the selected parameter. Consider the following screenshot of the **Add filter** dialog with the `http.route` parameter selected:

![A screenshot of the Aspire dashboard Traces page, showing the Add filter dialog with the http.route parameter selected.](/_astro/traces-filtering.B_LGGpva_Z10lWps.webp)

#### Combine telemetry from multiple resources

[Section titled “Combine telemetry from multiple resources”](#combine-telemetry-from-multiple-resources)

When a resource has multiple replicas, you can filter telemetry to view data from all instances at once. Select the parent resource, labeled `(application)`, as shown in the following screenshot:

![Filter by all instances of a resource](/_astro/telemetry-resource-filter.CDQTCl9F_bWQSg.webp)

After selecting the parent resource, the traces page displays telemetry from all instances of the resource.

#### Trace details

[Section titled “Trace details”](#trace-details)

The trace details page contains various details pertinent to the request, including:

* **Trace Detail**: When the trace started.
* **Duration**: The time it took to complete the request.
* **Resources**: The number of resources involved in the request.
* **Depth**: The number of layers involved in the request.
* **Total Spans**: The total number of spans involved in the request.

Each span is represented as a row in the table, and contains a **Name**. Spans also display the error icon if an error occurred within that particular span of the trace. Spans that have a type of client/consumer, but don’t have a span on the server, show an arrow icon and then the destination address. This represents a client call to a system outside of the Aspire project. For example, an HTTP request an external web API, or a database call.

Within the trace details page, there’s a **View Logs** button that takes you to the structured logs page with a filter applied to show only the logs relevant to the request. Consider an example screenshot depicting the structured logs page with a filter applied to show only the logs relevant to the trace:

![A screenshot of the Aspire dashboard Structured logs page, showing a filter applied to show only the logs relevant to the trace.](/_astro/structured-logs-trace-errors.B7OaZa9V_laeLy.webp)

When GitHub Copilot is available, the trace details page also includes an **Explain trace** button that provides a quick way to analyze the currently viewed trace using AI. Additionally, traces and individual spans include **Ask GitHub Copilot** options in their context menus for detailed investigation.

The structured logs page is discussed in more detail in the [Structured logs page](#structured-logs-page) section.

#### Trace examples

[Section titled “Trace examples”](#trace-examples)

Each trace has a color, which is generated to help differentiate between spans—one color for each resource. The colors are reflected in both the *traces page* and the *trace detail page*. When traces depict an arrow icon, those icons are colorized as well to match the span of the target trace. Consider the following example screenshot of traces:

![A screenshot of the Aspire dashboard Traces page.](/_astro/traces.CtZeH-wc_Z1vYq7K.webp)

In the **Actions** column, you can select **View details** to navigate to a detailed view of the request and the duration of time it spent traveling through each application layer. Consider an example selection of a trace to view its details:

![A screenshot of the Aspire dashboard Trace details page.](/_astro/trace.IZkzBbTH_Z2ntmcx.webp)

For each span in the trace, select **View details** to see more details:

![A screenshot of the Aspire dashboard Trace details page with the details of a span displayed.](/_astro/trace-span-details.sRmPJAKL_sajEg.webp)

Scroll down in the span details pain to see full information. At the bottom of the span details pane, some span types, such as this call to a cache, show span event timings:

![A screenshot of the Aspire dashboard Trace details page with the event timings for a span displayed.](/_astro/trace-span-event-details.o1M0vlir_1uMGOl.webp)

For complex traces with many spans, use the **Filter** textbox to display only matching spans:

![A screenshot of the Aspire dashboard Trace details page with the filter used to display only weather spans.](/_astro/filter-spans-trace-details.BAC5Wv_E_Z1JxrBe.webp)

When errors are present, the page renders an error icon next to the trace name. Consider an example screenshot of traces with errors:

![A screenshot of the Aspire dashboard Traces page, showing traces with errors.](/_astro/traces-errors.CE26Ws_o_2fTh9a.webp)

And the corresponding detailed view of the trace with errors:

![A screenshot of the Aspire dashboard Trace details page, showing a trace with errors.](/_astro/trace-view-errors.B3GIJxK5_ZCuHir.webp)

### Metrics page

[Section titled “Metrics page”](#metrics-page)

Navigate to the **Metrics** page to view the metrics for your app. Aspire automatically configures metrics for the different projects in your app. Metrics are a way to measure the health of your application and can be used to monitor the performance of your app over time.

Each metric-publishing project in your app has its own metrics. The metrics page displays a selection pane for each top-level meter and the corresponding instruments that you can select to view the metric.

Consider the following example screenshot of the metrics page, with the `webfrontend` project selected and the `System.Net.Http` meter’s `http.client.request.duration` metric selected:

![A screenshot of the Aspire dashboard Metrics page.](/_astro/metrics-view.Buki09_8_1gSVAO.webp)

In addition to the metrics chart, the metrics page includes an option to view the data as a table instead. Consider the following screenshot of the metrics page with the table view selected:

![A screenshot of the Aspire dashboard Metrics page with the table view selected.](/_astro/metrics-table-view.HLajsJDc_wrUAY.webp)

Under the chart, there’s a list of filters you can apply to focus on the data that interests you. For example, in the following screenshot, the **http.request.method** field is filtered to show only **GET** requests:

![A screenshot of the Aspire dashboard Metrics page with a filter applied to the chart.](/_astro/metrics-view-filtered.08SO--_y_ZFwuQM.webp)

You can also choose to select the count of the displayed metric on the vertical access, instead of its values:

![A screenshot of the Aspire dashboard Metrics page with the count option applied.](/_astro/metrics-view-count.BOR_uilr_1eQi6O.webp)

For more information about metrics, see [Built-in Metrics in .NET](https://learn.microsoft.com/dotnet/core/diagnostics/built-in-metrics).

### GenAI telemetry visualization

[Section titled “GenAI telemetry visualization”](#genai-telemetry-visualization)

The Aspire dashboard provides a specialized dialog for viewing GenAI (Generative AI) telemetry data. This feature helps you analyze and understand AI-related operations in your application, including chat completions, embeddings, and other AI interactions.

The following is an animation demonstrating the GenAI telemetry visualizer in action:

![]() ![An animated screenshot of the Aspire dashboard GenAI telemetry visualizer in action.](/_astro/dashboard-geni-visualizer.DhKO2e8H.gif)    Pause animation

The GenAI telemetry visualizer works best when message content is recorded to telemetry. Without message content, the dialog displays a note and provides a link to documentation about how to enable this feature.

#### Configure message content recording

[Section titled “Configure message content recording”](#configure-message-content-recording)

To get the most value from the GenAI telemetry visualizer, configure your AI integrations to record message content. This configuration varies depending on which AI client library you’re using:

##### Microsoft.Extensions.AI (MEAI)

[Section titled “Microsoft.Extensions.AI (MEAI)”](#microsoftextensionsai-meai)

When using `Microsoft.Extensions.AI` (`IChatClient` and related abstractions), you can enable sensitive data recording by configuring the chat client options. For specific AI integrations that support `Microsoft.Extensions.AI`, refer to their individual documentation for the exact configuration syntax. The configuration typically involves setting an `EnableSensitiveData` property or similar telemetry-related option

##### Environment variable configuration

[Section titled “Environment variable configuration”](#environment-variable-configuration)

Many OpenTelemetry libraries support the `OTEL_INSTRUMENTATION_GENAI_CAPTURE_MESSAGE_CONTENT` environment variable to enable message content capture. Set this environment variable to `true`:

* Bash

  ```bash
  OTEL_INSTRUMENTATION_GENAI_CAPTURE_MESSAGE_CONTENT=true
  ```

* PowerShell

  ```powershell
  $env:OTEL_INSTRUMENTATION_GENAI_CAPTURE_MESSAGE_CONTENT="true"
  ```

You can set this environment variable in your application’s configuration, in your development environment, or in your deployment settings.

##### AI integrations

[Section titled “AI integrations”](#ai-integrations)

For specific guidance on configuring message content recording with different AI integrations, see the documentation for each integration:

* [Azure OpenAI integration](https://learn.microsoft.com/dotnet/aspire/azureai/azureai-openai-integration#configuring-sensitive-data-in-telemetry).
* [Azure AI Inference integration](https://learn.microsoft.com/dotnet/aspire/azureai/azureai-inference-integration#configuring-sensitive-data-in-telemetry).
* [OpenAI integration](https://learn.microsoft.com/dotnet/aspire/openai/openai-integration#configuring-sensitive-data-in-telemetry).

Tip

When message content recording is disabled, the GenAI telemetry visualizer still provides valuable information about AI operations, including timing, metadata, and performance metrics. However, enabling message content recording provides the most comprehensive view of your AI interactions.

##### Other AI clients

[Section titled “Other AI clients”](#other-ai-clients)

Please refer to your AI client’s documentation for instructions on enabling message content recording in telemetry.

### Exemplars

[Section titled “Exemplars”](#exemplars)

The Aspire dashboard supports and displays OpenTelemetry *Exemplars*. An *exemplar* links a metric data point to the operation that recorded it, serving as a bridge between metrics and traces.

Exemplars are useful because they provide additional context about why a specific metric value was recorded. For example, if you notice a spike in latency in the `http.client.request.duration` metric, an exemplar could point to a specific trace or span that caused the spike, helping you understand the root cause.

Exemplars are displayed in the metrics chart as a small round dot next to the data point. When you hover over the indicator, a tooltip displays the exemplar details as shown in the following screenshot:

![Aspire Dashboard: Metrics Page, with exemplar indicator hover details.](/_astro/metrics-page-exemplars.DwHnEd-y_RgVVI.webp)

The preceding screenshot shows the exemplar details for the `http.client.request.duration` metric. The exemplar details include the:

* Resource name.

* Operation performed, in this case an:

  HTTP — images collection request

  ```http
  GET /catalog/images/{id}
  ```

* Corresponding value and the time stamp.

Selecting the exemplar indicator opens the trace details page, where you can view the trace associated, for example consider the following screenshot:

![Aspire Dashboard: Trace Page, navigated to from the corresponding Metrics Page exemplar.](/_astro/trace-page-from-exemplars.C6mxwllc_hbpGD.webp)

For more information, see [OpenTelemetry Docs: Exemplars](https://opentelemetry.io/docs/specs/otel/metrics/data-model/#exemplars).

### Interact with telemetry

[Section titled “Interact with telemetry”](#interact-with-telemetry)

Telemetry information is generated continuously while you run a Aspire application and it can flood the dashboard with information. The dashboard includes tools you can use to reduce the amount of data displayed in monitoring pages and make it easier to target specific events.

#### Pause telemetry output

[Section titled “Pause telemetry output”](#pause-telemetry-output)

In the **Console logs**, **Structured logs**, **Traces**, and **Metrics** pages, you can pause the collection of telemetry data:

![A screenshot of the Aspire dashboard Console logs page, showing how to pause telemetry.](/_astro/pause-telemetry.Cu-UqTeP_Z14Tm17.webp)

The pause button affects only the type of telemetry displayed on that page. So, for example, if you pause console logs collection, your app continues to collect structured logs, traces, and metrics telemetry.

#### Remove data

[Section titled “Remove data”](#remove-data)

Next to the **Pause** button, the **Remove data** button enables you to clear the telemetry on the current page. Drop down the list, and choose whether to remove the telemetry for all resource, or only for the current resource:

![A screenshot of the Aspire dashboard Structured logs page, showing how to remove telemetry.](/_astro/remove-telemetry-data.DQMe3AIz_2rGqOY.webp)

The button is available for control logs, structured logs, traces, and metrics. It works independently for each type of data.

If you want to remove all telemetry of all types and for all resources in a single step, use the **Remove all** button in the **Settings** dialog:

![A screenshot of the Aspire dashboard Settings page, showing how to remove all telemetry.](/_astro/remove-all-telemetry.qBmYIf38_1auXV6.webp)

## Settings dialog

[Section titled “Settings dialog”](#settings-dialog)

The Aspire dashboard provides a settings dialog that allows you to configure the theme, the language, functionality to clear all the logs and telemetry, and the .NET version used by the dashboard.

By default, the theme is set to follow the System theme, which means the dashboard uses the same theme as your operating system. You can also select the **Light** or **Dark** theme to override the system theme. Theme selections are persisted.

The following screenshot shows the theme selection dialog, with the default System theme selected:

![The Aspire dashboard Settings dialog, showing the System theme default selection.](/_astro/theme-selection.Conhsnig_Z1Qd9sW.webp)

If you prefer the Light theme, you can select it from the theme selection dialog:

![The Aspire dashboard Settings dialog, showing the Light theme selection.](/_astro/theme-selection-light.DnoaCaPE_ZPvte7.webp)

## Dashboard shortcuts

[Section titled “Dashboard shortcuts”](#dashboard-shortcuts)

The Aspire dashboard provides various shortcuts to *help* you navigate and control different parts of the dashboard. To display the keyboard shortcuts, press Shift + Question Mark `Shift?` Shift + Question Mark `Shift?` Shift + Question Mark `Shift?` , or select the question mark icon in the top-right corner of the dashboard:

![Aspire dashboard Help modal dialog.](/_astro/dashboard-help.Bmej--78_ZWcsfu.webp)

The following shortcuts are available:

**Panels**:

* Plus Sign `+` Plus Sign `+` Plus Sign `+` : Increase panel size.
* Minus Sign `-` Minus Sign `-` Minus Sign `-` : Decrease panel size.
* Shift + R `ShiftR` Shift + R `ShiftR` Shift + R `ShiftR` : *R*eset panel size.
* Shift + T `ShiftT` Shift + T `ShiftT` Shift + T `ShiftT` : *T*oggle panel orientation.
* Shift + X `ShiftX` Shift + X `ShiftX` Shift + X `ShiftX` : Close panel.

**Page navigation**:

* R `R` R `R` R `R` : Go to ***R*esources**.
* C `C` C `C` C `C` : Go to ***C*onsole Logs**.
* S `S` S `S` S `S` : Go to ***S*tructured Logs**.
* T `T` T `T` T `T` : Go to ***T*races**.
* M `M` M `M` M `M` : Go to ***M*etrics**.

**Site-wide navigation**:

* Question Mark `?` Question Mark `?` Question Mark `?` : Got to **Help**.
* Shift + S `ShiftS` Shift + S `ShiftS` Shift + S `ShiftS` : Go to ***S*ettings**.

## Interaction prompts

[Section titled “Interaction prompts”](#interaction-prompts)

Some resources or commands might prompt you for values when using the dashboard. This interactive functionality is powered by the **interaction service**, which allows integrations to display notifications or to request input from users when needed.

For example, Azure resources that are missing required configuration might prompt you for configuration values when the dashboard starts or when you interact with those resources. These prompts help ensure that resources are properly configured and can function correctly within your Aspire application.

In the dashboard, interaction prompts appear as:

* Input dialogs for missing configuration values.
* Confirmation dialogs for important actions.
* Notification messages with details about resource status.

These prompts appear directly in the dashboard interface, making it easy to provide the necessary information without switching to external tools or configuration files.

## GitHub Copilot in the dashboard

[Section titled “GitHub Copilot in the dashboard”](#github-copilot-in-the-dashboard)

The Aspire dashboard includes GitHub Copilot as your AI debugging assistant when you launch your app from VS Code or Visual Studio with a GitHub account that has a Copilot subscription. Copilot can help you:

* Review hundreds of log messages with a single click.
* Investigate the root cause of errors across multiple apps.
* Highlight performance issues in traces.
* Explain obscure error codes using AI’s vast knowledge repository.

Copilot features appear throughout the dashboard interface:

* **Copilot button**: This button is available in the top-right corner to open the Copilot chat interface.
* **Context menus**: “Ask GitHub Copilot” options appear in resource, log, trace, and span context menus.
* **Explain buttons**: “Explain errors” buttons appear on structured logs and “Explain trace” buttons appear on trace details pages.
* **Suggested questions**: Contextual AI suggestions appear based on the current page.

For comprehensive information about GitHub Copilot features, requirements, troubleshooting, and configuration options, see [GitHub Copilot in the Aspire dashboard](/dashboard/copilot/).

## Next steps

[Section titled “Next steps”](#next-steps)

[Standalone Aspire dashboard](/dashboard/standalone/)

# Manual MCP server configuration

> Learn how to manually configure the Aspire MCP server for older Aspire versions (9.0 - 13.0).

New in Aspire 13.1

Starting with Aspire 13.1, you can configure the MCP server automatically using the `aspire mcp init` command. See [Configure MCP](/get-started/configure-mcp/) for the recommended approach.

This page describes manual MCP configuration for Aspire versions 9.0 through 13.0, or for situations where you need more control over the configuration.

The Aspire MCP server is a local [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) server. Aspire MCP integrates Aspire into your development AI eco-system. With Aspire MCP, you can:

* Query resources, including resource states, endpoints, health status and commands.
* Debug with real-time console logs.
* Investigate development time telemetry, such as structured logs and distributed tracing across resources.
* Execute resource commands.

## Get started

[Section titled “Get started”](#get-started)

There are two ways to configure your AI assistant to use Aspire MCP:

### Option 1: Using the Aspire CLI (recommended)

[Section titled “Option 1: Using the Aspire CLI (recommended)”](#option-1-using-the-aspire-cli-recommended)

The simplest way to get started is using the Aspire CLI, which can automatically detect and configure your AI assistant:

1. Open a terminal in your Aspire project directory.

2. Run the [`aspire mcp init`](/reference/cli/commands/aspire-mcp-init/) command:

   ```bash
   aspire mcp init
   ```

3. Follow the prompts to select which AI assistants to configure.

4. The CLI will automatically set up the MCP server configuration for your selected environments.

For more information, see the [aspire mcp](/reference/cli/commands/aspire-mcp/) command documentation.

### Option 2: Manual configuration

[Section titled “Option 2: Manual configuration”](#option-2-manual-configuration)

You can also manually configure your AI assistant to use Aspire MCP:

1. Run your Aspire app.
2. Open the Aspire dashboard and click on the MCP button in the top right corner of the dashboard. This launches a dialog that contains instructions for using Aspire MCP.
3. Use the specified details in the dialog to configure your local AI assistant.

Important settings required to use Aspire MCP:

* `url` - Aspire MCP address.
* `type` - `http` to indicate Aspire MCP is a [streamable-HTTP MCP server](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports#streamable-http).
* `x-mcp-api-key` - An HTTP header with a key to secure access to the MCP server.

![A screenshot of the Aspire MCP dialog in the dashboard with the url and API header highlighted.](/_astro/mcp-dialog.DJhOAzMI_Z2kOzKG.webp)

There isn’t a standard way to configure AI assistants with new MCP servers. Configuration varies depending on your local AI assistant:

* [Claude Code](https://docs.claude.com/en/docs/claude-code/mcp)
* [Codex](https://developers.openai.com/codex/mcp/)
* [Copilot CLI](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli#add-an-mcp-server)
* [Cursor](https://cursor.com/docs/context/mcp#installing-mcp-servers)
* [Visual Studio](https://learn.microsoft.com/visualstudio/ide/mcp-servers?view=visualstudio#options-for-adding-an-mcp-server)
* [VS Code](https://code.visualstudio.com/docs/copilot/customization/mcp-servers)

The `x-mcp-api-key` value is used to secure access to the MCP, but the AI assistant must have access to it. Use features in the AI assistant to securely store the value. For example, if you’re using VS Code then [input variables](https://code.visualstudio.com/docs/copilot/customization/mcp-servers#_input-variables-for-sensitive-data) can be used to configure the API key and avoid adding the API key to source control in an *mcp.json* file.

## Your first prompts

[Section titled “Your first prompts”](#your-first-prompts)

After configuration, try asking your AI assistant:

> “Are all my resources running?”

> “Analyze HTTP requests performance for RESOURCE\_NAME.”

> “Restart unhealthy resources.”

## Tools

[Section titled “Tools”](#tools)

The Aspire MCP server provides the following tools:

### Resource management

[Section titled “Resource management”](#resource-management)

* `list_resources` - Lists all resources, including their state, health status, source, endpoints, and commands.
* `execute_resource_command` - Executes a resource command. This tool accepts parameters for the resource name and command name.

### Logging and telemetry

[Section titled “Logging and telemetry”](#logging-and-telemetry)

* `list_console_logs` - Lists console logs for a resource.
* `list_structured_logs` - Lists structured logs, optionally filtered by resource name.
* `list_traces` - Lists distributed traces. Traces can be filtered using an optional resource name parameter.
* `list_trace_structured_logs` - Lists structured logs for a trace.

### Integration discovery

[Section titled “Integration discovery”](#integration-discovery)

* `list_integrations` - Lists all available Aspire hosting integrations with their package IDs and versions.
* `get_integration_docs` - Retrieves documentation for a specific Aspire hosting integration package.

### AppHost management

[Section titled “AppHost management”](#apphost-management)

* `list_apphosts` - Lists all available AppHosts in the workspace.
* `select_apphost` - Selects a specific AppHost to work with.

By default all resources, console logs and telemetry is accessible by Aspire MCP. Resources and associated telemetry can be excluded from MCP results by annotating the resource in the app host with `ExcludeFromMcp()`.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiservice = builder.AddProject<Projects.AspireApp_ApiService>("apiservice")
    .ExcludeFromMcp();


builder.AddProject<Projects.AspireApp_Web>("webfrontend")
    .WithExternalHttpEndpoints()
    .WithReference(apiService);


builder.Build().Run();
```

## Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

Aspire MCP is designed to work seamlessly with AI assistants, but you may encounter some setup challenges depending on your environment.

### MCP connection secured with self-signed HTTPS certificate not supported by some AI assistants

[Section titled “MCP connection secured with self-signed HTTPS certificate not supported by some AI assistants”](#mcp-connection-secured-with-self-signed-https-certificate-not-supported-by-some-ai-assistants)

An MCP connection secured with HTTPS is recommended for security. However, some AI assistants currently don’t support calling endpoints secured with a trusted, self-signed certificate. This includes the Aspire MCP, which is secured using [a self-signed certificate](https://learn.microsoft.com/dotnet/core/additional-tools/self-signed-certificates-guide).

Currently the only work around for using Aspire MCP with these AI assistants is to configure an `http` MCP endpoint.

* If you already launch your Aspire app with [the `http` launch profile](https://learn.microsoft.com/dotnet/aspire/fundamentals/launch-profiles) then your app isn’t using HTTPS and you don’t need to do anything.

* If you use HTTPS everywhere, you can configure just the MCP endpoint to use `http` by updating *launchSettings.json*.

  * Set `ASPIRE_DASHBOARD_MCP_ENDPOINT_URL` to an `http` address.
  * Add `ASPIRE_ALLOW_UNSECURED_TRANSPORT` set to `true`.

JSON — launchSettings.json

```json
{
  "profiles": {
    "https": {
      "commandName": "Project",
      "launchBrowser": true,
      "dotnetRunMessages": true,
      "applicationUrl": "https://localhost:15887;http://localhost:15888",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:16037",
        "ASPIRE_DASHBOARD_OTLP_HTTP_ENDPOINT_URL": "https://localhost:16038",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:17037",
        "ASPIRE_DASHBOARD_MCP_ENDPOINT_URL": "http://localhost:16036",
        "ASPIRE_ALLOW_UNSECURED_TRANSPORT": "true"
      }
    }
  }
}
```

Caution

This configuration will remove transport security from Aspire MCP communication. It could allow data to be read by a third party.

## Limitations

[Section titled “Limitations”](#limitations)

Aspire MCP is a powerful tool, but there are a few things to keep in mind when using it.

### Data size

[Section titled “Data size”](#data-size)

AI models have limits on how much data they can process at once. Aspire MCP may limit the amount of data returned from tools when necessary.

* Large data fields (e.g., long exception stack traces) may be truncated.
* Requests involving large collections of telemetry may be shortened by omitting older items.

# Microsoft-collected dashboard telemetry

> Learn about what telemetry the Aspire dashboard sends and how to opt out.

The Aspire dashboard collects diagnostic data to help developers monitor and analyze their applications. Separately, when the dashboard is launched through Visual Studio or Visual Studio Code as part of a running Aspire application, Microsoft collects usage data about the dashboard itself. This data helps the Aspire team improve the product. Additionally, unhandled exception details from the dashboard are sent to Microsoft to assist in identifying and resolving issues.

## Scope

[Section titled “Scope”](#scope)

Aspire dashboard usage telemetry is collected only when running the dashboard from Visual Studio or Visual Studio Code. Telemetry is gathered while the dashboard is open in the browser, unless you have [opted out](#how-to-opt-out) of telemetry collection.

## How to opt-out

[Section titled “How to opt-out”](#how-to-opt-out)

Starting with Aspire 9.3, dashboard usage telemetry is enabled by default. Dashboard usage telemetry isn’t collected in early version. This feature aligns with the following IDE versions:

* Visual Studio: 17.14 or later.
* C# Dev Kit: 1.18.25 or later.

To opt-out of telemetry collection, set the `ASPIRE_DASHBOARD_TELEMETRY_OPTOUT` environment variable to `true`. This will apply to all users accessing the Aspire dashboard:

* Bash

  ```bash
  export ASPIRE_DASHBOARD_TELEMETRY_OPTOUT=true
  ```

* PowerShell

  ```powershell
  $env:ASPIRE_DASHBOARD_TELEMETRY_OPTOUT= "true"
  ```

Alternatively, you can opt-out of telemetry collection by disabling telemetry collection in the host IDE. Learn how to opt out in Visual Studio or Visual Studio Code.

## Disclosure

[Section titled “Disclosure”](#disclosure)

When dashboard usage telemetry is enabled, there’s a disclosure statement at the bottom of the settings panel, informing you that telemetry is enabled. This disclosure statement appears when usage telemetry is enabled.

## Data points

[Section titled “Data points”](#data-points)

Aspire dashboard usage telemetry doesn’t collect personal data, such as, IP addresses or use browser fingerprinting. It doesn’t scan your code and doesn’t extract source code, authorship, or deployment configuration. The data is sent securely to Microsoft using Azure Monitor through existing telemetry APIs in Visual Studio and Visual Studio Code.

Protecting your privacy is important to Microsoft. If you suspect that telemetry is collecting sensitive data or the data is being insecurely or inappropriately handled, file an issue in the [GitHub dotnet/aspire](https://github.com/dotnet/aspire) repository for investigation.

The Aspire dashboard doesn’t collect telemetry on Visual Studio versions `< 17.14` or C# Dev Kit versions `< 1.18.25`. It collects the following data:

| Aspire dashboard versions | Data                                         | Notes                                                 |
| ------------------------- | -------------------------------------------- | ----------------------------------------------------- |
| 9.3                       | Page navigation history.                     | Includes page settings.                               |
| 9.3                       | Resource types being used.                   | Custom resource type names are not sent to Microsoft. |
| 9.3                       | Request user agent.                          | —                                                     |
| 9.3                       | Invoked dashboard commands.                  | Custom command names are not sent to Microsoft.       |
| 9.3                       | Request language and set dashboard language. | —                                                     |
| 9.3                       | Resource restart times.                      | —                                                     |
| 9.3                       | OTel data processing times.                  | —                                                     |
| 9.3                       | Dashboard-related unhandled exceptions.      | —                                                     |
| 9.3                       | GitHub Copilot usage statistics.             | —                                                     |
| 9.3                       | GitHub Copilot help/unhelp feedback.         | —                                                     |

## See also

[Section titled “See also”](#see-also)

* [Aspire dashboard](/dashboard/overview/)
* [Aspire dashboard configuration](/dashboard/configuration/)

# Aspire dashboard overview

> Overview of Aspire dashboard and getting started.

[Aspire](/get-started/what-is-aspire/) project templates include a sophisticated dashboard for comprehensive app monitoring and inspection. The dashboard is also available in [standalone mode](#standalone-mode).

The dashboard enables real-time tracking of key aspects of your app, including logs, traces, and environment configurations. It’s designed to enhance the development experience by providing a clear and insightful view of your app’s state and structure.

Key features of the dashboard include:

* Real-time tracking of logs, traces, and environment configurations.
* User interface to [stop, start, and restart resources](/dashboard/explore/#resource-actions).
* Collects and displays logs and telemetry; [view structured logs, traces, and metrics](/dashboard/explore/#monitoring-pages) in an intuitive UI.
* Enhanced debugging with [GitHub Copilot](/dashboard/copilot/), your AI-powered assistant built into the dashboard.

## Use the dashboard with Aspire projects

[Section titled “Use the dashboard with Aspire projects”](#use-the-dashboard-with-aspire-projects)

The dashboard is integrated into the [Aspire *\*.AppHost*](/get-started/app-host/). During development the dashboard is automatically launched when you start the project. It’s configured to display the Aspire project’s resources and telemetry.

![A screenshot of the Aspire dashboard Resources page.](/_astro/projects.DsYvwQXm_ZWdNRW.webp)

For more information about using the dashboard during Aspire development, see [Explore dashboard features](/dashboard/explore/).

## Standalone mode

[Section titled “Standalone mode”](#standalone-mode)

The Aspire dashboard is also shipped as a Docker image and can be used standalone, without the rest of Aspire. The standalone dashboard provides a great UI for viewing telemetry and can be used by any application.

* Bash

  ```bash
  docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -p 18888:18888 -p 4317:18889 -d --name aspire-dashboard `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

The preceding Docker command:

* Starts a container from the `mcr.microsoft.com/dotnet/aspire-dashboard:latest` image.

* The container instance exposing two ports:

  * Maps the dashboard’s OTLP port `18889` to the host’s port `4317`. Port `4317` receives OpenTelemetry data from apps. Apps send data using [OpenTelemetry Protocol (OTLP)](https://opentelemetry.io/docs/specs/otlp/).
  * Maps the dashboard’s port `18888` to the host’s port `18888`. Port `18888` has the dashboard UI. Navigate to `http://localhost:18888` in the browser to view the dashboard.

For more information, see the [Standalone Aspire dashboard](/dashboard/standalone/).

## Configuration

[Section titled “Configuration”](#configuration)

The dashboard is configured when it starts up. Configuration includes frontend and OTLP addresses, the resource service endpoint, authentication, telemetry limits and more.

For more information, see [Aspire dashboard configuration](/dashboard/configuration/).

## Architecture

[Section titled “Architecture”](#architecture)

The dashboard user experience is built with a variety of technologies. The frontend is built with [Grpc.AspNetCore](https://www.nuget.org/packages/Grpc.AspNetCore) NuGet package to the resource server. Consider the following diagram that illustrates the architecture of the Aspire dashboard:

![A diagram showing the architecture of the Aspire dashboard.](/_astro/architecture-diagram-dark.CDI1wAiO.svg)

## Security

[Section titled “Security”](#security)

The Aspire dashboard offers powerful insights to your apps. The UI displays information about resources, including their configuration, console logs and in-depth telemetry.

Data displayed in the dashboard can be sensitive. For example, configuration can include secrets in environment variables, and telemetry can include sensitive runtime data. Care should be taken to secure access to the dashboard.

For more information, see [Aspire dashboard security considerations](/dashboard/security-considerations/).

## Next steps

[Section titled “Next steps”](#next-steps)

* [Explore the Aspire dashboard](/dashboard/explore/)

# Aspire dashboard security considerations

> Security considerations for running the Aspire dashboard

The [Aspire dashboard](/dashboard/overview/) offers powerful insights to your apps. The dashboard displays information about resources, including their configuration, console logs and in-depth telemetry.

Data displayed in the dashboard can be sensitive. For example, configuration can include secrets in environment variables, and telemetry can include sensitive runtime data. Care should be taken to secure access to the dashboard.

## Scenarios for running the dashboard

[Section titled “Scenarios for running the dashboard”](#scenarios-for-running-the-dashboard)

The dashboard can be run in different scenarios, such as being automatically starting by Aspire tooling, or as a standalone application that is separate from other Aspire integrations. Steps to secure the dashboard depend on how it’s being run.

### Aspire tooling

[Section titled “Aspire tooling”](#aspire-tooling)

The dashboard is automatically started when an Aspire AppHost is run. The dashboard is secure by default when run from Aspire tooling:

* Transport is secured with HTTPS. Using HTTPS is configured by default in *launchSettings.json*. The launch profile includes `https` addresses in `applicationUrl` and `ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL` values.
* Browser frontend authenticated with a browser token.
* Incoming telemetry authenticated with an API key.

HTTPS in the dashboard uses the ASP.NET Core development certificate. The certificate must be trusted for the dashboard to work correctly. The steps required to trust the development cert are different depending on the machine’s operating system:

* Trust the ASP.NET Core HTTPS development certificate on Windows and macOS
* Trust HTTPS certificate on Linux

There are scenarios where you might want to allow an unsecured transport. The dashboard can run without HTTPS from the Aspire AppHost by configuring the `ASPIRE_ALLOW_UNSECURED_TRANSPORT` setting to `true`.

### Standalone mode

[Section titled “Standalone mode”](#standalone-mode)

The dashboard is shipped as a Docker image and can be used without the rest of Aspire. When the dashboard is launched in standalone mode, it defaults to a mix of secure and unsecured settings.

* Browser frontend authenticated with a browser token.
* Incoming telemetry is unsecured. Warnings are displayed in the console and dashboard UI.

The telemetry endpoint accepts incoming OTLP data without authentication. When the endpoint is unsecured, the dashboard is open to receiving telemetry from untrusted apps.

For information about securing the telemetry when running the dashboard in standalone mode, see [Securing the telemetry endpoint](#secure-telemetry-endpoint).

## Secure telemetry endpoint

[Section titled “Secure telemetry endpoint”](#secure-telemetry-endpoint)

The Aspire dashboard provides a variety of ways to view logs, traces, and metrics for your app. This information enables you to track the behavior and performance of your app and to diagnose any issues that arise. It’s important that you can trust this information, and a warning is displayed in the dashboard UI if telemetry isn’t secured.

The dashboard collects telemetry through an [OTLP (OpenTelemetry protocol)](https://opentelemetry.io/docs/specs/otel/protocol/) endpoint. Apps send telemetry to this endpoint, and the dashboard stores the external information it receives in memory, which is then accessible via the UI.

To prevent untrusted apps from sending telemetry to Aspire, the OTLP endpoint should be secured. The OTLP endpoint is automatically secured with an API key when the dashboard is started by Aspire tooling. Additional configuration is required for standalone mode.

API key authentication can be enabled on the telemetry endpoint with some additional configuration:

* Bash

  ```bash
  docker run --rm -it -d -p 18888:18888 -p 4317:18889 --name aspire-dashboard \
      -e DASHBOARD__OTLP__AUTHMODE='ApiKey' \
      -e DASHBOARD__OTLP__PRIMARYAPIKEY='{MY_APIKEY}' \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -d -p 18888:18888 -p 4317:18889 --name aspire-dashboard `
      -e DASHBOARD__OTLP__AUTHMODE='ApiKey' `
      -e DASHBOARD__OTLP__PRIMARYAPIKEY='{MY_APIKEY}' `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

The preceding Docker command:

* Starts the Aspire dashboard image and exposes OTLP endpoint as port 4317
* Configures the OTLP endpoint to use `ApiKey` authentication. This requires that incoming telemetry has a valid `x-otlp-api-key` header value.
* Configures the expected API key. `{MY_APIKEY}` in the example value should be replaced with a real API key. The API key can be any text, but a value with at least 128 bits of entropy is recommended.

When API key authentication is configured, the dashboard validates incoming telemetry has a required API key. Apps that send the dashboard telemetry must be configured to send the API key. This can be configured in .NET with `OtlpExporterOptions.Headers`:

```csharp
builder.Services.Configure<OtlpExporterOptions>(
    o => o.Headers = $"x-otlp-api-key={MY_APIKEY}");
```

Other languages have different OpenTelemetry APIs. Passing the [`OTEL_EXPORTER_OTLP_HEADERS` environment variable](https://opentelemetry.io/docs/specs/otel/protocol/exporter/) to apps is a universal way to configure the header.

## Memory exhaustion

[Section titled “Memory exhaustion”](#memory-exhaustion)

The dashboard stores external information it receives in memory, such as resource details and telemetry. While the number of resources the dashboard tracks are bounded, there isn’t a limit to how much telemetry apps send to the dashboard. Limits must be placed on how much information is stored to prevent the dashboard using an excessive amount of memory and exhausting available memory on the current machine.

### Telemetry limits

[Section titled “Telemetry limits”](#telemetry-limits)

To help prevent memory exhaustion, the dashboard limits how much telemetry it stores by default. For example, there is a maximum of 10,000 structured log entries per resource. Once the limit is reached, each new log entry received causes an old entry to be removed.

Configuration can customize telemetry limits.

# Standalone Aspire dashboard

> How to use the Aspire dashboard standalone.

The [Aspire dashboard](/dashboard/overview/) provides a great UI for viewing telemetry. The dashboard:

* Ships as a container image that can be used with any OpenTelemetry enabled app.
* Can be used standalone, without the rest of Aspire.

![A screenshot of the Aspire dashboard running in standalone mode.](/_astro/standalone-mode.CSrn3G_Z.png)

## Start the dashboard

[Section titled “Start the dashboard”](#start-the-dashboard)

The dashboard is started using the Docker command line.

* Bash

  ```bash
  docker run --rm -it -d \
      -p 18888:18888 \
      -p 4317:18889 \
      --name aspire-dashboard \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -d `
      -p 18888:18888 `
      -p 4317:18889 `
      --name aspire-dashboard `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

The preceding Docker command:

* Starts a container from the `mcr.microsoft.com/dotnet/aspire-dashboard:latest` image.

* The container exposes two ports:

  * Mapping the dashboard’s OTLP port `18889` to the host’s port `4317`. Port `4317` receives OpenTelemetry data from apps. Apps send data using [OpenTelemetry Protocol (OTLP)](https://opentelemetry.io/docs/specs/otlp/).
  * Mapping the dashboard’s port `18888` to the host’s port `18888`. Port `18888` has the dashboard UI. Navigate to `http://localhost:18888` in the browser to view the dashboard.

## Login to the dashboard

[Section titled “Login to the dashboard”](#login-to-the-dashboard)

Data displayed in the dashboard can be sensitive. By default, the dashboard is secured with authentication that requires a token to login.

When the dashboard is run from a standalone container, the login token is printed to the container logs. The logs are displayed in the Docker Desktop user interface on the **Logs** tab for the **aspire-dashboard** container:

![Screenshot of the Aspire dashboard container logs.](/_astro/aspire-dashboard-container-log.2KBAPQw7_dpYMb.webp)

After copying the highlighted token into the login page, select the *Login* button.

Alternatively, you can obtain the token from the logs by using the `docker` command:

* Bash

  ```bash
  #!/bin/bash
  loginLine=$(docker container logs aspire-dashboard | grep "login?t=")
  match=$(echo "$loginLine" | sed -n 's/.*login?t=\([^[:space:]]*\).*/\1/p')
  echo -n "$match" | xclip -selection clipboard
  echo "$match"
  ```

  Tip

  This script requires that your system has the `sed` and `xclip` tools installed.

* PowerShell

  ```powershell
  $loginLine =  docker container logs aspire-dashboard | Select-String "login\?t="
  $matches = [regex]::Match($loginLine, "(?<=login\?t=)(\S+)")
  $matches.Value | Set-Clipboard
  echo $matches.Value
  ```

Tip

To avoid the login, you can disable the authentication requirement by setting the `ASPIRE_DASHBOARD_UNSECURED_ALLOW_ANONYMOUS` environment variable to `true`. Additional configuration is available, see [Dashboard configuration](/dashboard/configuration/).

For more information about logging into the dashboard, see [Dashboard authentication](/dashboard/explore/#dashboard-authentication).

## Explore the dashboard

[Section titled “Explore the dashboard”](#explore-the-dashboard)

The dashboard offers a UI for viewing telemetry. Refer to the documentation to explore the telemetry functionality:

* [Structured logs page](/dashboard/explore/#structured-logs-page)
* [Traces page](/dashboard/explore/#traces-page)
* [Metrics page](/dashboard/explore/#metrics-page)

Although there is no restriction on where the dashboard is run, the dashboard is designed as a development and short-term diagnostic tool. The dashboard persists telemetry in-memory which creates some limitations:

* Telemetry is automatically removed if [telemetry limits](configuration#telemetry-limits) are exceeded.
* No telemetry is persisted when the dashboard is restarted.

### Unavailable features when standalone

[Section titled “Unavailable features when standalone”](#unavailable-features-when-standalone)

The dashboard has functionality for viewing Aspire resources. The dashboard resource features are disabled when it is run in standalone mode. To enable the resources UI, [add configuration for a resource service](/dashboard/configuration/#resources).

[GitHub Copilot functionality](/dashboard/copilot/) isn’t available in the standalone dashboard. Copilot uses a connection to your IDE to communicate with GitHub Copilot and that connection isn’t available when the dashboard is in standalone mode.

## Send telemetry to the dashboard

[Section titled “Send telemetry to the dashboard”](#send-telemetry-to-the-dashboard)

Apps send telemetry to the dashboard using [OpenTelemetry Protocol (OTLP)](https://opentelemetry.io/docs/specs/otlp/). The dashboard must expose a port for receiving OpenTelemetry data, and apps are configured to send data to that address.

A Docker command was shown earlier to [start the dashboard](#start-the-dashboard). It configured the container to receive OpenTelemetry data on port `4317`. The OTLP endpoint’s full address is `http://localhost:4317`.

### Configure OpenTelemetry SDK

[Section titled “Configure OpenTelemetry SDK”](#configure-opentelemetry-sdk)

Apps collect and send telemetry using [their language’s OpenTelemetry SDK](https://opentelemetry.io/docs/languages/).

Important OpenTelemetry SDK options to configure:

* OTLP endpoint, which should match the dashboard’s configuration, for example, `http://localhost:4317`.
* OTLP protocol, with the dashboard currently supporting only the [OTLP/gRPC protocol](https://opentelemetry.io/docs/specs/otlp/#otlpgrpc). Configure applications to use the `grpc` protocol.

To configure applications:

* Use the OpenTelemetry SDK APIs within the application, or

* Start the app with [known environment variables](https://opentelemetry.io/docs/specs/otel/protocol/exporter/#configuration-options):

  * `OTEL_EXPORTER_OTLP_PROTOCOL` with a value of `grpc`.
  * `OTEL_EXPORTER_OTLP_ENDPOINT` with a value of `http://localhost:4317`.

## Sample

[Section titled “Sample”](#sample)

For a sample of using the standalone dashboard, see the [Standalone Aspire dashboard sample app](https://github.com/dotnet/aspire-samples/tree/main/samples/standalone-dashboard).

## Next steps

[Section titled “Next steps”](#next-steps)

* [Configure the Aspire dashboard](/dashboard/configuration/)

# Use the Aspire dashboard with Node.js apps

> How to use the Aspire Dashboard in a Node.js application.

The [Aspire dashboard](/dashboard/overview/) provides a great user experience for viewing telemetry, and is available as a standalone container image that can be used with any OpenTelemetry-enabled app. In this article, you’ll learn how to:

* Start the Aspire dashboard in standalone mode.
* Use the Aspire dashboard with a Node.js app.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

To complete this tutorial, you need the following:

* [Container runtime](/get-started/prerequisites/#install-an-oci-compliant-container-runtime).
  * You can use an alternative container runtime, but the commands in this article are for Docker.
* [Node.js 18 or higher](https://nodejs.org/en/download/package-manager) locally installed.

## Create a sample application

[Section titled “Create a sample application”](#create-a-sample-application)

For this tutorial, you’ll create a simple Express.js API that demonstrates how to integrate the Aspire dashboard with any Node.js application. While Aspire 13.0 includes JavaScript starter templates, this tutorial shows you how to add dashboard integration to any existing Node.js project.

1. Create a new directory for your application:

   Create project directory

   ```bash
   mkdir aspire-nodejs-sample
   cd aspire-nodejs-sample
   ```

2. Initialize a new Node.js project:

   Initialize npm project

   ```bash
   npm init -y
   ```

3. Install Express.js and OpenTelemetry dependencies:

   Install dependencies

   ```bash
   npm install express @opentelemetry/api @opentelemetry/sdk-node \
     @opentelemetry/exporter-trace-otlp-grpc \
     @opentelemetry/exporter-metrics-otlp-grpc \
     @opentelemetry/auto-instrumentations-node
   ```

4. Create an Express.js API with a weather endpoint. Create an *app.js* file:

   JavaScript — app.js

   ```javascript
   const express = require('express');
   const app = express();
   const port = process.env.PORT || 3000;


   // Simple middleware for logging
   app.use((req, res, next) => {
       console.log(`${req.method} ${req.path}`);
       next();
   });


   app.get('/', (req, res) => {
       res.json({
           message: 'Weather API - Node.js',
           endpoints: ['/api/weatherforecast', '/health']
       });
   });


   app.get('/api/weatherforecast', (req, res) => {
       const forecasts = [
           { date: '2024-01-01', temperatureC: 25, summary: 'Sunny' },
           { date: '2024-01-02', temperatureC: 20, summary: 'Cloudy' },
           { date: '2024-01-03', temperatureC: 22, summary: 'Partly Cloudy' },
           { date: '2024-01-04', temperatureC: 18, summary: 'Rainy' },
           { date: '2024-01-05', temperatureC: 28, summary: 'Hot' }
       ];


       console.log('Returning weather forecast data');
       res.json(forecasts);
   });


   app.get('/health', (req, res) => {
       res.json({ status: 'healthy' });
   });


   app.listen(port, () => {
       console.log(`Server running at http://localhost:${port}`);
   });
   ```

5. Test the application:

   Run the application

   ```bash
   node app.js
   ```

6. Browse to `http://localhost:3000/api/weatherforecast` to verify the API is working.

7. Stop the application with `Ctrl+C`.

## Configure OpenTelemetry

[Section titled “Configure OpenTelemetry”](#configure-opentelemetry)

Now let’s add OpenTelemetry instrumentation to send telemetry data to the Aspire dashboard.

1. Create a new file called *telemetry.js* to configure OpenTelemetry with proper resource attributes:

   JavaScript — telemetry.js

   ```javascript
   const { NodeSDK } = require('@opentelemetry/sdk-node');
   const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
   const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-grpc');
   const { OTLPMetricExporter } = require('@opentelemetry/exporter-metrics-otlp-grpc');
   const { PeriodicExportingMetricReader } = require('@opentelemetry/sdk-metrics');
   const { resourceFromAttributes } = require('@opentelemetry/resources');
   const { ATTR_SERVICE_NAME } = require('@opentelemetry/semantic-conventions');


   // Configure the OTLP endpoint for standalone dashboard
   const otlpEndpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';


   // Create resource with service name
   const resource = resourceFromAttributes({
       [ATTR_SERVICE_NAME]: 'weather-api-nodejs',
   });


   const sdk = new NodeSDK({
       resource: resource,
       traceExporter: new OTLPTraceExporter({
           url: otlpEndpoint,
       }),
       metricReader: new PeriodicExportingMetricReader({
           exporter: new OTLPMetricExporter({
               url: otlpEndpoint,
           }),
           exportIntervalMillis: 5000,
       }),
       instrumentations: [getNodeAutoInstrumentations({
           // Disable file system instrumentation to reduce noise
           '@opentelemetry/instrumentation-fs': {
               enabled: false,
           },
       })],
   });


   sdk.start();


   console.log('✅ OpenTelemetry configured for Aspire dashboard');


   process.on('SIGTERM', () => {
       sdk.shutdown()
       .then(() => console.log('Tracing terminated'))
       .catch((error) => console.log('Error terminating tracing', error))
       .finally(() => process.exit(0));
   });
   ```

2. Update your *app.js* to import the telemetry configuration at the very beginning:

   JavaScript — app.js (beginning of file)

   ```javascript
    // This must be imported first to initialize OpenTelemetry!
    require('./telemetry');


    const express = require('express');
    const app = express();
    const port = process.env.PORT || 3000;


    app.get('/', (req, res) => {
        console.log('Received request for home page');
        res.json({
            message: 'Hello from Node.js!',
            timestamp: new Date().toISOString()
        });
    });


    app.get('/api/weather', (req, res) => {
        const weather = [
            { city: 'Seattle', temperature: 72, condition: 'Cloudy' },
            { city: 'Portland', temperature: 68, condition: 'Rainy' },
            { city: 'San Francisco', temperature: 65, condition: 'Foggy' },
            { city: 'Los Angeles', temperature: 78, condition: 'Sunny' }
        ];


        console.log('Received request for weather data');
        res.json(weather);
    });


    app.listen(port, () => {
        console.log(`Server running at http://localhost:${port}`);
    });
   ```

3. Restart your application:

   ```bash
   npm start
   ```

## Start the Aspire dashboard

[Section titled “Start the Aspire dashboard”](#start-the-aspire-dashboard)

To start the Aspire dashboard in standalone mode, run the following Docker command:

* Bash

  ```bash
  docker run --rm -it -p 18888:18888 -p 4317:18889 --name aspire-dashboard \
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

* PowerShell

  ```powershell
  docker run --rm -it -p 18888:18888 -p 4317:18889 --name aspire-dashboard `
      mcr.microsoft.com/dotnet/aspire-dashboard:latest
  ```

In the Docker logs, the endpoint and key for the dashboard are displayed. Copy the key and navigate to `http://localhost:18888` in a web browser. Enter the key to log in to the dashboard.

## View telemetry in the dashboard

[Section titled “View telemetry in the dashboard”](#view-telemetry-in-the-dashboard)

After starting both the dashboard and your Node.js application, you can view telemetry data by making requests to your application and observing the results in the dashboard.

1. Make some requests to your Node.js application:

   ```bash
   curl http://localhost:3000/
   curl http://localhost:3000/api/weather
   ```

2. Navigate to the Aspire dashboard at `http://localhost:18888` and explore the different sections:

### Traces

[Section titled “Traces”](#traces)

The **Traces** page shows distributed traces for HTTP requests. Each request to your Express.js application creates a trace that you can explore to see the request flow and timing information.

### Metrics

[Section titled “Metrics”](#metrics)

The **Metrics** page displays various metrics collected from your Node.js application, including HTTP request metrics, Node.js runtime metrics, and custom metrics if you choose to add them.

## Add custom telemetry (optional)

[Section titled “Add custom telemetry (optional)”](#add-custom-telemetry-optional)

You can enhance your application with custom spans and metrics. Here’s an example of adding a custom metric to track API requests:

JavaScript — app.js (with custom metrics)

```javascript
// This must be imported first!
require('./telemetry');


const express = require('express');
const { trace, metrics } = require('@opentelemetry/api');


const app = express();
const port = process.env.PORT || 3000;


// Get a tracer for custom spans
const tracer = trace.getTracer('weather-api-nodejs');


// Create a custom metric counter
const meter = metrics.getMeter('weather-api-nodejs');
const apiRequestCounter = meter.createCounter('api.requests', {
    description: 'Total number of API requests',
});


app.use((req, res, next) => {
    console.log(`${req.method} ${req.path}`);
    next();
});


app.get('/', (req, res) => {
    res.json({
        message: 'Weather API - Node.js',
        endpoints: ['/api/weatherforecast', '/health']
    });
});


app.get('/api/weatherforecast', (req, res) => {
    // Create a custom span for this operation
    const span = tracer.startSpan('get-weather-forecast');


    try {
        const forecasts = [
            { date: '2024-01-01', temperatureC: 25, summary: 'Sunny' },
            { date: '2024-01-02', temperatureC: 20, summary: 'Cloudy' },
            { date: '2024-01-03', temperatureC: 22, summary: 'Partly Cloudy' },
            { date: '2024-01-04', temperatureC: 18, summary: 'Rainy' },
            { date: '2024-01-05', temperatureC: 28, summary: 'Hot' }
        ];


        // Increment custom metric
        apiRequestCounter.add(1, { endpoint: '/api/weatherforecast' });


        // Add custom attributes to span
        span.setAttributes({
            'forecast.count': forecasts.length,
            'endpoint': '/api/weatherforecast'
        });


        console.log('Returning weather forecast data');
        res.json(forecasts);
    } finally {
        span.end();
    }
});


app.get('/health', (req, res) => {
    res.json({ status: 'healthy' });
});


app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});
```

## Next steps

[Section titled “Next steps”](#next-steps)

You have successfully used the Aspire dashboard with a Node.js application. To learn more about the Aspire dashboard, see the [Aspire dashboard overview](/dashboard/overview/) and how to orchestrate a Node.js application with the Aspire AppHost.

To learn more about OpenTelemetry instrumentation for Node.js applications, see the [OpenTelemetry JavaScript documentation](https://opentelemetry.io/docs/languages/js/).

# Use the Aspire dashboard with Python apps

> How to use the Aspire Dashboard in a Python application.

The [Aspire dashboard](/dashboard/overview/) provides a great user experience for viewing telemetry, and is available as a standalone container image that can be used with any OpenTelemetry-enabled app. In this article, you’ll learn how to:

* Start the Aspire dashboard in standalone mode.
* Use the Aspire dashboard with a Python app.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

To complete this tutorial, you need the following:

* [Container runtime](/get-started/prerequisites/#install-an-oci-compliant-container-runtime).
  * You can use an alternative container runtime, but the commands in this article are for Docker.
* [Aspire 13.0 or later](/get-started/install-cli/) installed.
* [Python 3.10 or higher](https://www.python.org/downloads/) with [uv](https://docs.astral.sh/uv/) installed.

## Create a sample application

[Section titled “Create a sample application”](#create-a-sample-application)

This tutorial uses the Aspire 13.0 Python starter template which includes a FastAPI backend and React frontend. You’ll focus on the FastAPI app to demonstrate dashboard integration with standalone mode.

1. Create a new Aspire solution from the Python starter template:

   Create a new Aspire Python solution

   ```bash
   aspire new aspire-py-starter -n aspire-dashboard-sample -o aspire-dashboard-sample
   ```

2. Navigate to the application folder:

   Change directory

   ```bash
   cd aspire-dashboard-sample/app
   ```

3. Review the generated FastAPI application structure. The template includes:

   * `.dockerignore` Common Docker ignore patterns
   * `.python-version` Python version specification
   * `main.py` FastAPI app with basic endpoints
   * `pyproject.toml` Python dependencies
   * `telemetry.py` Basic telemetry configuration

4. The starter template already has basic dependencies. Install them:

   Install dependencies with uv

   ```bash
   uv sync
   ```

## Start the Aspire dashboard

[Section titled “Start the Aspire dashboard”](#start-the-aspire-dashboard)

Before running the Python app, start the Aspire dashboard in standalone mode so it’s ready to receive telemetry data:

```bash
docker run --rm -it -p 18888:18888 -p 4317:18889 --name aspire-dashboard \
    mcr.microsoft.com/dotnet/aspire-dashboard:latest
```

In the Docker logs, the endpoint and key for the dashboard are displayed. Copy the key and navigate to `http://localhost:18888` in a web browser. Enter the key to log in to the dashboard.

Leave the dashboard running and open a new terminal for the next steps.

## Enhance OpenTelemetry configuration

[Section titled “Enhance OpenTelemetry configuration”](#enhance-opentelemetry-configuration)

The starter template includes basic telemetry configuration in `telemetry.py`. Let’s enhance it to work with the standalone Aspire dashboard.

1. Install additional OpenTelemetry packages for better instrumentation:

   Install OpenTelemetry packages

   ```bash
   uv add opentelemetry-instrumentation-fastapi opentelemetry-instrumentation-httpx
   ```

2. Update the `telemetry.py` file to configure OpenTelemetry to send data to the dashboard:

   Python — app/telemetry.py

   ```python
   import logging
   import os
   from opentelemetry import metrics, trace
   from opentelemetry._logs import set_logger_provider
   from opentelemetry.exporter.otlp.proto.grpc._log_exporter import OTLPLogExporter
   from opentelemetry.exporter.otlp.proto.grpc.metric_exporter import OTLPMetricExporter
   from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
   from opentelemetry.sdk._logs import LoggerProvider, LoggingHandler
   from opentelemetry.sdk._logs.export import BatchLogRecordProcessor
   from opentelemetry.sdk.metrics import MeterProvider
   from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader
   from opentelemetry.sdk.resources import Resource
   from opentelemetry.sdk.trace import TracerProvider
   from opentelemetry.sdk.trace.export import BatchSpanProcessor
   from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor


   def configure_telemetry(app, service_name: str = "app"):
       """Configure OpenTelemetry for FastAPI application."""


       # Get OTLP endpoint from environment or use default for standalone dashboard
       otlp_endpoint = os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4317")


       # Create resource with service name
       resource = Resource.create({"service.name": service_name})


       # Configure Tracing
       trace_provider = TracerProvider(resource=resource)
       trace_provider.add_span_processor(
           BatchSpanProcessor(OTLPSpanExporter(endpoint=otlp_endpoint))
       )
       trace.set_tracer_provider(trace_provider)


       # Configure Metrics
       metric_reader = PeriodicExportingMetricReader(
           OTLPMetricExporter(endpoint=otlp_endpoint)
       )
       meter_provider = MeterProvider(resource=resource, metric_readers=[metric_reader])
       metrics.set_meter_provider(meter_provider)


       # Configure Logging
       logger_provider = LoggerProvider(resource=resource)
       logger_provider.add_log_record_processor(
           BatchLogRecordProcessor(OTLPLogExporter(endpoint=otlp_endpoint))
       )
       set_logger_provider(logger_provider)


       # Add logging handler
       handler = LoggingHandler(level=logging.NOTSET, logger_provider=logger_provider)
       logging.getLogger().addHandler(handler)


       # Instrument FastAPI application
       FastAPIInstrumentor.instrument_app(app)


       return trace.get_tracer(__name__)
   ```

3. Update `main.py` to use the enhanced telemetry configuration. Replace the entire file content with the following code, which includes the telemetry setup and example endpoints:

   Python — app/main.py

   ```python
   import logging
   from fastapi import FastAPI
   from telemetry import configure_telemetry


   logging.basicConfig(level=logging.INFO)


   app = FastAPI()


   # Configure telemetry for standalone dashboard
   tracer = configure_telemetry(app, service_name="weather-api")
   logger = logging.getLogger(__name__)


   # Example endpoints (replace or extend these based on your application needs)
   @app.get("/")
   async def root():
       logger.info("Root endpoint called")
       return {"message": "Hello from FastAPI with Aspire dashboard!"}


   @app.get("/health")
   async def health():
       logger.info("Health check called")
       return {"status": "healthy"}


   @app.get("/simulate-error")
   async def simulate_error():
       logger.warning("This is a simulated warning.")
       logger.error("This is a simulated error.")
       return {"message": "Simulated warning and error logs generated"}
   ```

   Tip

   If you want to keep the template’s original endpoints, copy them from the generated `main.py` before replacing the file content, then merge them with the telemetry configuration shown above.

4. Run the FastAPI application (note: without `--reload` to avoid telemetry issues):

   * Bash

     ```bash
     uv run uvicorn main:app --host 127.0.0.1 --port 8000
     ```

   * PowerShell

     ```powershell
     uv run uvicorn main:app --host 127.0.0.1 --port 8000
     ```

5. Test the application by browsing to `http://localhost:8000` and `http://localhost:8000/health` to generate telemetry data.

## View telemetry in the dashboard

[Section titled “View telemetry in the dashboard”](#view-telemetry-in-the-dashboard)

With both the dashboard and your Python application running, you can now view telemetry data in real-time:

1. Navigate to the Aspire dashboard at `http://localhost:18888` (if not already open).

2. Make requests to your FastAPI application:

   * Browse to `http://localhost:8000` for the root endpoint
   * Browse to `http://localhost:8000/health` for the health check
   * Browse to `http://localhost:8000/simulate-error` to generate warning and error logs

3. In the dashboard, explore the different sections:

   * **Structured Logs**: View application logs with filtering and search capabilities
   * **Traces**: See distributed traces for HTTP requests
   * **Metrics**: Monitor application performance metrics

The structured logs page displays logs from your application with rich filtering and search capabilities:

![Screenshot of the Aspire dashboard showing the Python application logs](/_astro/aspire-dashboard-python-logs.BLifIv7F.png)

## Stop the Python app and dashboard

[Section titled “Stop the Python app and dashboard”](#stop-the-python-app-and-dashboard)

When you’re done exploring the Aspire dashboard with your Python app, stop both the FastAPI application and the dashboard:

1. Stop the FastAPI application by pressing ⌘+C `⌘+C` Control + C `CtrlC` Control + C `CtrlC` in the terminal where it’s running.
2. Stop the Aspire dashboard by pressing CommandthenPlus SignthenC `⌘` `+` `C` Control + C `CtrlC` Control + C `CtrlC` in the terminal where the Docker container is running.

## Next steps

[Section titled “Next steps”](#next-steps)

You have successfully used the Aspire dashboard with a Python application. To learn more:

* [Aspire dashboard overview](/dashboard/overview/) - Learn about all dashboard features
* [Build your first Aspire app](/get-started/first-app/?lang=python) - Create a full-stack Python application with Aspire orchestration
* [Deploy your first Aspire app](/get-started/deploy-first-app/?lang=python) - Deploy your Python application to Azure

# Deploy using the Aspire CLI

> Learn how to deploy Aspire applications to Azure Container Apps using the aspire deploy command.

When you deploy Aspire applications to Azure Container Apps using the `aspire deploy` command, the platform provides several deployment options and configurations. This guide explains how to use the Aspire CLI to deploy your applications to Azure Container Apps. For general information about deploying Aspire applications, see [Aspire deployment overview](/deployment/overview/).

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

* Aspire common [prerequisites](/get-started/prerequisites/)
* The [Aspire CLI](/get-started/install-cli/) installed
* An Azure subscription: [Create one for free](https://azure.microsoft.com/free/)
* Install the [Azure CLI](https://learn.microsoft.com/cli/azure/install-azure-cli)

## Authenticate with Azure

[Section titled “Authenticate with Azure”](#authenticate-with-azure)

Before deploying, you must authenticate with Azure CLI. Run the following command:

Authenticate with Azure CLI

```azurecli
az login
```

This command opens a web browser for you to sign in with your Azure credentials. The `aspire deploy` command automatically validates your Azure CLI authentication before proceeding with deployment. For more information, see:

* [Sign in with Azure CLI](https://learn.microsoft.com/cli/azure/authenticate-azure-cli)
* [The `aspire deploy` command reference](/reference/cli/commands/aspire-deploy/)

## Create an Aspire project

[Section titled “Create an Aspire project”](#create-an-aspire-project)

If you don’t already have an Aspire project, create one using the Aspire CLI:

1. Open a terminal or command prompt.

2. Run the following commands to create a new Aspire project:

   Create new Aspire project

   ```bash
   aspire new aspire-starter --name AspireApp
   ```

3. Navigate to the project directory:

   Navigate to project directory

   ```bash
   cd AspireApp
   ```

For more details on creating projects, see [Build your first Aspire project](/get-started/first-app/).

## Configure for Azure Container Apps

[Section titled “Configure for Azure Container Apps”](#configure-for-azure-container-apps)

To deploy to Azure Container Apps, add a package reference to your AppHost project that includes the [📦 Aspire.Hosting.Azure.AppContainers](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppContainers) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.AppContainers package

  ```bash
  aspire add azure-appcontainers
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-appcontainers (Aspire.Hosting.Azure.AppContainers)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.AppContainers@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.AppContainers package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.AppContainers" Version="*" />
  ```

In your AppHost project’s *AppHost.cs* file, add the Container Apps environment:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Azure Container Apps environment
builder.AddAzureContainerAppEnvironment("aspire-env");


var apiService = builder.AddProject<Projects.AspireDeploy_ApiService>("apiservice")
    .WithHttpHealthCheck("/health");


builder.AddProject<Projects.AspireDeploy_Web>("webfrontend")
    .WithExternalHttpEndpoints()
    .WithHttpHealthCheck("/health")
    .WithReference(apiService)
    .WaitFor(apiService);


builder.Build().Run();
```

For more information, see [Configure Azure Container Apps environments](/integrations/cloud/azure/configure-container-apps/).

### Resource naming

[Section titled “Resource naming”](#resource-naming)

Azure Container Apps have specific naming requirements that Aspire handles automatically during deployment. Resource names must be lowercase, alphanumeric, and between 2-32 characters. When you define resources in your AppHost, Aspire generates valid Azure resource names based on your provided names.

## Deploy with aspire deploy

[Section titled “Deploy with aspire deploy”](#deploy-with-aspire-deploy)

Once your project is configured, deploy it using the `aspire deploy` command:

Deploy to Azure Container Apps

```bash
aspire deploy
```

Tip

The `aspire deploy` command is interactive by default. To deploy without prompts, set these environment variables first:

* `Azure__SubscriptionId`: Target Azure subscription ID.
* `Azure__Location`: Azure region (for example, `eastus`).
* `Azure__ResourceGroup`: Resource group name to create or reuse.

## Deployment process

[Section titled “Deployment process”](#deployment-process)

The `aspire deploy` command performs the following steps automatically. First, the command validates that you’re authenticated with Azure CLI. If you’re not logged in, you’ll see an error message prompting you to run `az login`.

### Interactive prompts

[Section titled “Interactive prompts”](#interactive-prompts)

The deployment process prompts you interactively to select your Azure tenant, subscription, and resource group. Use the Up Arrow `↑` Up Arrow `↑` Up Arrow `↑` and Down Arrow `↓` Down Arrow `↓` Down Arrow `↓` keys to navigate the options, or press the corresponding number key ( 1 `1` 1 `1` 1 `1` , 2 `2` 2 `2` 2 `2` , etc.) to jump directly to an option. Press Return `Return` Enter `Enter` Enter `Enter` to confirm your selection.

Tenant and subscription selection

```plaintext
(validate-azure-login) ✓ Azure CLI authentication validated successfully
(fetch-tenant) → Fetching available tenants
(fetch-tenant) ✓ Found 3 available tenant(s)
Select your Azure tenant:
Tenant ID:  Default Directory (yourname.onmicrosoft.com) — xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
(fetch-subscription) → Fetching available subscriptions
(fetch-subscription) ✓ Found 1 available subscription(s)
Select your Azure subscription:
Subscription ID:  Visual Studio Enterprise (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
(fetch-resource-groups) → Fetching resource groups
(fetch-resource-groups) ✓ Found 2 resource group(s)
Select your Azure resource group or enter a new name:
Resource group:  my-resource-group
```

For more information about the interactive prompts, see [Interaction service](/extensibility/interaction-service/).

### Build and provision

[Section titled “Build and provision”](#build-and-provision)

After selections are made, Aspire builds container images and provisions Azure infrastructure in parallel:

Building and provisioning

```plaintext
(build-apiservice) → Starting build-apiservice...
(build-webfrontend) → Starting build-webfrontend...
(build-apiservice) i [INF] Building container image for resource apiservice
(build-webfrontend) i [INF] Building container image for resource webfrontend
(build-webfrontend) i [INF] Building image for webfrontend completed
(build-webfrontend) ✓ build-webfrontend completed successfully
(build-apiservice) i [INF] Building image for apiservice completed
(build-apiservice) ✓ build-apiservice completed successfully
(provision-aspire-env-acr) → Deploying aspire-env-acr
(provision-aspire-env-acr) ✓ Successfully provisioned aspire-env-acr (15.2s)
(provision-aspire-env) → Deploying aspire-env
```

### Push to Container Registry

[Section titled “Push to Container Registry”](#push-to-container-registry)

Once images are built and the Azure Container Registry is provisioned, the CLI authenticates and pushes your images:

Pushing images

```plaintext
(login-to-acr-aspire-env-acr) → Logging in to aspireenvacrabcd1234xyz
(login-to-acr-aspire-env-acr) ✓ Successfully logged in to aspireenvacrabcd1234xyz.azurecr.io (4.6s)
(push-webfrontend) → Pushing webfrontend to aspireenvacrabcd1234xyz
(push-apiservice) → Pushing apiservice to aspireenvacrabcd1234xyz
(push-webfrontend) ✓ Successfully pushed webfrontend to aspireenvacrabcd1234xyz.azurecr.io/webfrontend:aspire-deploy-20260128154830 (78.5s)
(push-apiservice) ✓ Successfully pushed apiservice to aspireenvacrabcd1234xyz.azurecr.io/apiservice:aspire-deploy-20260128154830 (79.7s)
```

### Deployment complete

[Section titled “Deployment complete”](#deployment-complete)

Upon successful deployment, you’ll see a summary of all steps completed:

Pipeline success

```plaintext
------------------------------------------------------------
✓ 24/24 steps succeeded • Total time: 4m 31s


Steps Summary:
      4m 31s  ✓ pipeline-execution
      3m 24s  ✓ provision-aspire-env
      1m 20s  ✓ push-apiservice
      1m 19s  ✓ push-webfrontend
      27.14s  ✓ create-provisioning-context
      22.62s  ✓ provision-webfrontend-containerapp
      22.29s  ✓ provision-apiservice-containerapp
      15.18s  ✓ provision-aspire-env-acr
      13.18s  ✓ build-apiservice
      13.18s  ✓ build-webfrontend
       4.60s  ✓ login-to-acr-aspire-env-acr
       3.08s  ✓ fetch-tenant
       2.01s  ✓ validate-azure-login
       1.47s  ✓ fetch-resource-groups
       1.08s  ✓ fetch-subscription
      ...


✓ PIPELINE SUCCEEDED
------------------------------------------------------------
```

Note

This is example output; actual resource names and deployment times will vary based on your environment.

For more information, see the [`aspire deploy` command reference](/reference/cli/commands/aspire-deploy/).

## Monitor deployment

[Section titled “Monitor deployment”](#monitor-deployment)

During deployment, you can monitor progress through:

1. **Console output**: Real-time progress updates and status messages.
2. **Azure portal**: View resources being created in your resource group.
3. **Azure CLI**: Use `az containerapp list` to see deployed applications.

## Troubleshooting deployment

[Section titled “Troubleshooting deployment”](#troubleshooting-deployment)

When using the `aspire deploy` command, you may encounter various issues during deployment. Use this section to learn common problems and tips for troubleshooting, helping you quickly identify and fix errors.

### Authentication issues

[Section titled “Authentication issues”](#authentication-issues)

If you encounter authentication errors:

Authentication error

```plaintext
❌ Azure CLI authentication failed. Please run 'az login' to authenticate before deploying.
```

Run `az login` and ensure you have the necessary permissions in your Azure subscription.

For more information, see [Sign in with Azure CLI](https://learn.microsoft.com/cli/azure/authenticate-azure-cli).

### Resource naming conflicts

[Section titled “Resource naming conflicts”](#resource-naming-conflicts)

If resource names conflict with existing Azure resources, modify your resource names in the AppHost:

Unique environment name

```csharp
// Change the environment name to a unique value
builder.AddAzureContainerAppEnvironment("my-unique-env-name");
```

### Container build failures

[Section titled “Container build failures”](#container-build-failures)

If container builds fail, ensure:

* Docker is running and accessible.
* Your project builds successfully locally: `dotnet build`.
* Container runtime is properly configured.

## Access your deployed application

[Section titled “Access your deployed application”](#access-your-deployed-application)

After successful deployment:

1. **Aspire Dashboard**: Access the dashboard URL provided in the deployment output.

2. **Application endpoints**: Find your application URLs in the Azure portal under Container Apps.

3. **Azure CLI**: List endpoints using:

   * Bash

     Get application endpoint

     ```bash
     az containerapp show \
     --name <app-name> \
     --resource-group <resource-group> \
     --query properties.configuration.ingress.fqdn
     ```

   * PowerShell

     Get application endpoint

     ```powershell
     az containerapp show `
     --name <app-name> `
     --resource-group <resource-group> `
     --query properties.configuration.ingress.fqdn
     ```

## Clean up resources

[Section titled “Clean up resources”](#clean-up-resources)

To remove deployed resources, delete the resource group:

Delete resource group

```azurecli
az group delete --name <resource-group-name>
```

Danger

This command deletes all resources in the resource group, including any resources not created by the Aspire CLI.

* [Aspire deployment overview](/deployment/overview/)
* [Configure Azure Container Apps environments](/integrations/cloud/azure/configure-container-apps/)
* [`aspire deploy` command reference](/reference/cli/commands/aspire-deploy/)

# Azure security best practices for Aspire deployments

> Learn about the default security posture of Aspire deployments to Azure Container Apps and additional steps to enhance security.

When you deploy Aspire applications to Azure using the Aspire CLI or Azure Developer CLI (`azd`), the platform provides several security features by default. This article explains the default security posture and provides guidance on additional steps you can take to enhance the security of your applications.

## Overview

[Section titled “Overview”](#overview)

This guide covers:

* Understanding the default security configuration for Aspire deployments
* Learning about built-in security features in Azure Container Apps
* Implementing additional security hardening measures
* Configuring secure communication between services
* Applying security best practices for production deployments

## Default security posture

[Section titled “Default security posture”](#default-security-posture)

When you deploy an Aspire application to Azure Container Apps using `azd`, several security measures are automatically configured:

### Container-level security

[Section titled “Container-level security”](#container-level-security)

**Secure base images**: Aspire generates container images using secure Microsoft-maintained base images that are regularly updated with security patches.

**Non-root execution**: Containers run with non-root user permissions by default, reducing the attack surface.

**Minimal image surface**: The generated containers include only the necessary runtime components, following the principle of least privilege.

### Network security

[Section titled “Network security”](#network-security)

**Private networking**: Azure Container Apps environments use virtual networks with private IP addresses for internal communication between services.

**Secure service-to-service communication**: Inter-service communication uses Azure Container Apps’ built-in service discovery with encrypted traffic.

**HTTPS endpoints**: Public-facing endpoints are automatically configured with HTTPS using Azure-managed certificates.

### Identity and access management

[Section titled “Identity and access management”](#identity-and-access-management)

**Managed identities**: Azure Container Apps are configured with system-assigned managed identities by default, eliminating the need to store credentials in your application code.

**Azure RBAC integration**: Resources are deployed with appropriate role-based access control (RBAC) permissions.

### Configuration and secrets management

[Section titled “Configuration and secrets management”](#configuration-and-secrets-management)

**Secure configuration**: Application configuration is stored in Azure App Configuration when available, separate from your application code.

**Environment variables**: Sensitive configuration values are injected as secure environment variables rather than being embedded in container images.

## Additional security hardening

[Section titled “Additional security hardening”](#additional-security-hardening)

While Aspire provides good security defaults, you can implement additional measures for enhanced protection:

### Enable Azure Key Vault integration

[Section titled “Enable Azure Key Vault integration”](#enable-azure-key-vault-integration)

Store sensitive configuration data and secrets in Azure Key Vault:

AppHost.cs - Add Azure Key Vault

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Azure Key Vault resource
var keyVault = builder.AddAzureKeyVault("key-vault");


// Reference Key Vault in your services
builder.AddProject<Projects.ApiService>()
       .WithReference(keyVault);
```

For more information, see [Aspire Azure Key Vault integration](/integrations/cloud/azure/azure-key-vault/).

### Configure user-assigned managed identities

[Section titled “Configure user-assigned managed identities”](#configure-user-assigned-managed-identities)

For more granular control over permissions, use user-assigned managed identities:

AppHost.cs - Add user-assigned managed identity

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Create or reference a user-assigned managed identity
var managedIdentity = builder.AddAzureUserAssignedIdentity("app-identity");


// Apply the identity to your container apps
builder.AddProject<Projects.ApiService>()
       .WithReference(managedIdentity);
```

For detailed guidance, see [Aspire Azure user-assigned managed identity integration](/integrations/cloud/azure/user-assigned-identity/).

### Enable comprehensive monitoring

[Section titled “Enable comprehensive monitoring”](#enable-comprehensive-monitoring)

**Application Insights**: Monitor your applications for security anomalies and performance issues:

AppHost.cs - Add Application Insights

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Application Insights
var appInsights = builder.AddAzureApplicationInsights("monitoring");


builder.AddProject<Projects.ApiService>()
    .WithReference(appInsights);
```

**Azure Monitor**: Configure alerts for suspicious activities and resource consumption anomalies.

## Additional security resources

[Section titled “Additional security resources”](#additional-security-resources)

For comprehensive guidance on Azure security, see [Azure security best practices and patterns](https://learn.microsoft.com/azure/security/fundamentals/best-practices-and-patterns/).

## Related content

[Section titled “Related content”](#related-content)

* [Deploy to Azure Container Apps using the Aspire CLI](/deployment/azure/aca-deployment-aspire-cli/)
* [Aspire Azure Key Vault integration](/integrations/cloud/azure/azure-key-vault/)
* [Aspire Azure user-assigned managed identity integration](/integrations/cloud/azure/user-assigned-identity/)

# Building custom deployment pipelines

> Learn how to build container images from your Aspire resources and create custom deployment pipelines.

Aspire provides powerful APIs for building container images from your resources during publishing and deployment operations. This article covers the key components that enable programmatic container image creation and progress reporting.

## Overview

[Section titled “Overview”](#overview)

During publishing and deployment, the container image builder is available to create images for resources that need them. Aspire uses this builder when a resource requires a container image, such as when publishing with Docker Compose. The process involves two main components:

* `IResourceContainerImageBuilder`: The service that turns resource definitions into runnable container images.
* `IPipelineActivityReporter`: The API that provides structured progress reporting during long-running operations.

These APIs give you fine-grained control over the image building process and provide real-time feedback to users during lengthy build operations.

Caution

These APIs are currently in preview and subject to change. They are designed for advanced scenarios where you need custom control over container image building and progress reporting. To suppress warnings for these APIs, see [Compiler Error ASPIREPUBLISHERS001](/diagnostics/aspirepublishers001/).

## When to use these APIs

[Section titled “When to use these APIs”](#when-to-use-these-apis)

Consider using the container image building and progress reporting APIs in these scenarios:

* **Custom deployment targets**: When you need to deploy to platforms that require specific image formats or build configurations.
* **Complex build pipelines**: When your publishing process involves multiple steps that users should see.
* **Enterprise scenarios**: When you need custom progress reporting for integration with CI/CD systems or dashboards.
* **Custom resource types**: When implementing custom resources that need to participate in the publishing and deployment process.

Note

For most standard Aspire applications, the built-in publishing process builds container images automatically without requiring these APIs.

## Resource container image builder API

[Section titled “Resource container image builder API”](#resource-container-image-builder-api)

The `IResourceContainerImageBuilder` is the core service in the `Aspire.Hosting.Publishing` layer that converts resource definitions into container images. It analyzes each resource in your distributed application model and determines whether to:

* Reuse an existing image.
* Build from a .NET project using `dotnet publish /t:PublishContainer`.
* Build from a Dockerfile using the local container runtime.

### Container build options

[Section titled “Container build options”](#container-build-options)

The `ContainerBuildOptions` class provides strongly typed configuration for container builds. This class allows you to specify:

* **Image format**: Docker or Open Container Initiative (OCI) format.
* **Target platform**: Linux x64, Windows, ARM64, etc.
* **Output path**: Where to save the built images.

### Container runtime health checks

[Section titled “Container runtime health checks”](#container-runtime-health-checks)

The builder performs container runtime health checks (Docker/Podman) only when at least one resource requires a Dockerfile build. This change eliminates false-positive errors in projects that publish directly from .NET assemblies. If the container runtime is required but unhealthy, the builder throws an explicit `InvalidOperationException` to surface the problem early.

## Pipeline activity reporter API

[Section titled “Pipeline activity reporter API”](#pipeline-activity-reporter-api)

The `PipelineActivityReporter` API enables structured progress reporting during `aspire publish` and `aspire deploy` commands. This reduces uncertainty during long-running operations and surfaces failures early.

### API overview and behavior

[Section titled “API overview and behavior”](#api-overview-and-behavior)

The progress reporter uses a hierarchical model with guaranteed ordering and thread-safe operations:

| Concept              | Description                                                    | CLI Rendering                                    | Behavior                                                                                                                |
| -------------------- | -------------------------------------------------------------- | ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| **Step**             | Top-level phase, such as “Build images” or “Deploy workloads”. | Step message with status glyph and elapsed time. | Forms a strict tree structure; nested steps are unsupported. Steps are created automatically during pipeline execution. |
| **Task**             | Discrete unit of work nested under a step.                     | Task message with indentation.                   | Belongs to a single step; supports parallel creation with deterministic completion ordering.                            |
| **Completion state** | Final status: `Completed`, `Warning`, or `Error`.              | ✅ (Completed) ⚠️ (Warning) ❌ (Error)             | Each step/task transitions exactly once to a final state.                                                               |

### API structure and usage

[Section titled “API structure and usage”](#api-structure-and-usage)

The reporter API provides structured access to progress reporting with the following characteristics:

* **Acquisition**: Retrieved from `PublishingContext.ActivityReporter` or through the `PipelineStepContext.ReportingStep` property in pipeline steps.
* **Step creation**: Steps are now created automatically during pipeline execution. The `CreateStepAsync(title, ct)` method returns an `IReportingStep`.
* **Task creation**: `IReportingStep.CreateTaskAsync(title, ct)` returns an `IReportingTask`.
* **State transitions**: `SucceedAsync`, `WarnAsync`, `FailAsync` methods accept a summary message.
* **Completion**: `CompletePublishAsync(message, state, isDeploy, ct)` marks the entire operation.
* **Ordering**: Creation and completion events preserve call order; updates are serialized.
* **Cancellation**: All APIs accept `CancellationToken` and propagate cancellation to the CLI.
* **Disposal contract**: Disposing steps automatically completes them if unfinished, preventing orphaned phases.

## Example: Build container images and report progress

[Section titled “Example: Build container images and report progress”](#example-build-container-images-and-report-progress)

To use these APIs, add a `PublishingCallbackAnnotation`, a `DeployingCallbackAnnotation`, or both to a resource in your app model. You can annotate custom (or built-in) resources by adding annotations to the `IResource.Annotations` collection.

As a developer, you can choose to:

* Use both annotations if your resource needs to do work in both publishing and deployment. For example, build images and generate manifests during publishing, then push images or configure deployment targets during deployment. Publishing always happens before deployment, so you can keep logic for each phase separate.
* Use only `PublishingCallbackAnnotation` if your resource only needs to do something during publishing. This is common when you just need to build artifacts or images, but don’t need to do anything during deployment.
* Use only `DeployingCallbackAnnotation` if your resource only needs to do something during deployment. This fits cases where you use prebuilt images and just need to deploy or configure them.

Choose one or more annotations that match your resource’s responsibilities to keep your application model clear and maintainable. This separation lets you clearly define logic for each phase, but you can use both the activity reporter and the resource container image builder in either callback as needed.

### Example resource with annotations

[Section titled “Example resource with annotations”](#example-resource-with-annotations)

For example, consider the `ComputeEnvironmentResource` constructor:

ComputeEnvironmentResource.cs

```csharp
public ComputeEnvironmentResource(string name) : base(name)
{
    Annotations.Add(new PublishingCallbackAnnotation(PublishAsync));
    Annotations.Add(new DeployingCallbackAnnotation(DeployAsync));
}
```

When instantiated, it defines both a publishing and deploying callback annotation.

Given the example `ComputeEnvironmentResource` type, imagine you have an extension method that you expose so consumers are able to add the compute environment:

ComputeEnvironmentResourceExtensions.cs

```csharp
using System.Diagnostics.CodeAnalysis;


[Experimental("ASPIRECOMPUTE001")]
public static class ComputeEnvironmentResourceExtensions
{
    public static IResourceBuilder<ComputeEnvironmentResource> AddComputeEnvironment(
        this IDistributedApplicationBuilder builder,
        [ResourceName] string name)
    {
        var resource = new ComputeEnvironmentResource(name);


        return builder.AddResource(resource);
    }
}
```

The preceding code:

* Defines an extension method on the `IDistributedApplicationBuilder`.
* Accepts a `name` for the compute environment resource, protected by the `ResourceNameAttribute`.
* Instantiates a `ComputeEnvironmentResource` given the `name` and adds it to the `builder`.

### Example AppHost

[Section titled “Example AppHost”](#example-apphost)

In your AppHost, you can add the `ComputeEnvironmentResource` to the application model like this:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("redis");


builder.AddProject<Projects.Api>("api")
       .WithReference(cache);


builder.AddComputeEnvironment("compute-env");


builder.Build().Run();
```

The preceding code uses the `AddComputeEnvironment` extension method to add the `ComputeEnvironmentResource` to the application model.

### Publishing callback annotation

[Section titled “Publishing callback annotation”](#publishing-callback-annotation)

When you add the `ComputeEnvironmentResource`, it registers a `PublishingCallbackAnnotation`. The callback uses the `PublishAsync` method:

ComputeEnvironmentResource.cs

```csharp
private static async Task PublishAsync(PublishingContext context)
{
    var reporter = context.ActivityReporter;
    var imageBuilder = context.Services.GetRequiredService<IResourceContainerImageBuilder>();


    // Build container images for all project resources in the application
    await using (var buildStep = await reporter.CreateStepAsync(
        "Build container images", context.CancellationToken))
    {
        // Find all resources that need container images
        var projectResources = context.Model.Resources
            .OfType<ProjectResource>()
            .ToList();


        if (projectResources.Count > 0)
        {
            // Configure how images should be built
            var buildOptions = new ContainerBuildOptions
            {
                ImageFormat = ContainerImageFormat.Oci,
                TargetPlatform = ContainerTargetPlatform.LinuxAmd64,
                OutputPath = Path.Combine(context.OutputPath, "images")
            };


            var buildTask = await buildStep.CreateTaskAsync(
                $"Building {projectResources.Count} container image(s)", context.CancellationToken);


            // Build all the container images
            await imageBuilder.BuildImagesAsync(
                projectResources, buildOptions, context.CancellationToken);


            await buildTask.SucceedAsync(
                $"Built {projectResources.Count} image(s) successfully", context.CancellationToken);
        }
        else
        {
            var skipTask = await buildStep.CreateTaskAsync(
                "No container images to build", context.CancellationToken);


            await skipTask.SucceedAsync("Skipped - no project resources found", context.CancellationToken);
        }


        await buildStep.SucceedAsync("Container image build completed", context.CancellationToken);
    }


    // Generate deployment manifests
    await using (var manifestStep = await reporter.CreateStepAsync(
        "Generate deployment manifests", context.CancellationToken))
    {
        var bicepTask = await manifestStep.CreateTaskAsync(
            "Write main.bicep", context.CancellationToken);


        // Write file to context.OutputPath …
        await bicepTask.SucceedAsync(
            $"main.bicep at {context.OutputPath}", context.CancellationToken);


        await manifestStep.SucceedAsync("Manifests ready", context.CancellationToken);
    }


    // Complete the publishing operation
    await reporter.CompletePublishAsync(
        completionMessage: "Publishing pipeline completed successfully",
        completionState: CompletionState.Completed,
        cancellationToken: context.CancellationToken);
}
```

The preceding code:

* Implements a publishing pipeline that builds container images and generates deployment manifests.
* Uses the `IResourceContainerImageBuilder` API to build container images.
* Reports progress and completion status using the `PipelineActivityReporter` API.

Your publishing callback might use `IResourceContainerImageBuilder` to build container images, while your deployment callback might use the built images and push them to a registry or deployment target.

### Deploying callback annotation

[Section titled “Deploying callback annotation”](#deploying-callback-annotation)

Like the publishing callback, the deploying callback is registered using the `DeployingCallbackAnnotation` and calls the `DeployAsync` method:

ComputeEnvironmentResource.cs

```csharp
private static async Task DeployAsync(DeployingContext context)
{
    var reporter = context.ActivityReporter;


    await using (var deployStep = await reporter.CreateStepAsync(
        "Deploy to target environment", context.CancellationToken))
    {
        var applyTask = await deployStep.CreateTaskAsync(
            "Apply Kubernetes manifests", context.CancellationToken);


        // Simulate deploying to Kubernetes cluster
        await Task.Delay(1_000, context.CancellationToken);


        await applyTask.SucceedAsync("All workloads deployed", context.CancellationToken);


        await deployStep.SucceedAsync("Deployment to cluster completed", context.CancellationToken);
    }


    // Complete the deployment operation
    await reporter.CompletePublishAsync(
        completionMessage: "Deployment completed successfully",
        completionState: CompletionState.Completed,
        isDeploy: true,
        cancellationToken: context.CancellationToken);
}
```

The preceding code:

* Simulates deploying workloads to a Kubernetes cluster.
* Uses the `PipelineActivityReporter` API to create and manage deployment steps and tasks.
* Reports progress and marks each deployment phase as completed.
* Completes the deployment operation with a final status update.
* Handles cancellation through the provided `CancellationToken`.

## Best practices

[Section titled “Best practices”](#best-practices)

When using these APIs, follow these guidelines:

### Image building

[Section titled “Image building”](#image-building)

* Always specify explicit `ContainerBuildOptions` for production scenarios.
* Consider target platform requirements when building for deployment.
* Use OCI format for maximum compatibility with container registries.
* Handle `InvalidOperationException` when container runtime health checks fail.

### Progress reporting

[Section titled “Progress reporting”](#progress-reporting)

* Encapsulate long-running logical phases in steps rather than emitting raw tasks.
* Keep titles concise (under 60 characters) as the CLI truncates longer strings.
* Call `CompletePublishAsync` exactly once per publishing or deployment operation.
* Treat warnings as recoverable and allow subsequent steps to proceed.
* Treat errors as fatal and fail fast with clear diagnostics.
* Use asynchronous, cancellation-aware operations to avoid blocking event processing.

### State management

[Section titled “State management”](#state-management)

* Each step and task starts in *Running* state and transitions exactly once to *Completed*, *Warning*, or *Error*.
* Throw an exception when attempting multiple state transitions.
* Leverage the reporter to guarantee ordered events and prevent interleaving.
* Dispose of `IPublishingActivityStep` to automatically complete unfinished steps.

# Deployment state caching

> Learn how the aspire deploy command manages deployment state through cached configuration files.

The `aspire deploy` command manages deployment state through cached configuration files stored locally on your machine. This caching mechanism streamlines repeated deployments by preserving provisioning settings and parameters, making subsequent deployments faster and more efficient.

## Default behavior

[Section titled “Default behavior”](#default-behavior)

The `aspire deploy` command automatically manages deployment state based on whether cached configuration exists for your application and target environment.

### First deployment

[Section titled “First deployment”](#first-deployment)

When you run `aspire deploy` for the first time, or for the first time in a target `--environment`, the command:

1. Prompts for provisioning information (subscription ID, resource group name, location).
2. Prompts for deployment parameters (for example, API keys, connection strings).
3. Initiates the deployment process.
4. Saves all prompted values and deployment state to `~/.aspire/deployments/AppHostSha/production.json`.

### Subsequent deployments

[Section titled “Subsequent deployments”](#subsequent-deployments)

On subsequent `aspire deploy` executions, the command:

1. Detects the existing deployment state file at `~/.aspire/deployments/AppHostSha/production.json`.
2. Notifies you that settings will be read from the cached file.
3. Prompts for confirmation to load the cached settings.
4. Loads the configuration from the cached file into the configuration provider.
5. Proceeds with deployment using the cached values (no re-prompting).

## Environment-specific deployments

[Section titled “Environment-specific deployments”](#environment-specific-deployments)

Different deployment environments (such as development, staging, and production) typically require different configurations, resource names, and connection strings. The `aspire deploy` command supports environment-specific deployments, ensuring that each environment maintains isolated deployment state.

### Specify an environment

[Section titled “Specify an environment”](#specify-an-environment)

Use the `--environment` flag to deploy to different environments:

Deploy to staging

```bash
aspire deploy --environment staging
```

[Command reference: `aspire deploy`](/reference/cli/commands/aspire-deploy/)

**First deployment to a specific environment:**

* Prompts for all provisioning and parameter information.
* Saves deployment state to `~/.aspire/deployments/{AppHostSha}/{environment}.json` (for example, `staging.json`).

**Subsequent deployments:**

* Reads the environment-specific cached file.
* Loads configuration from the cached state.
* Uses cached values without prompting.

### Environment variable support

[Section titled “Environment variable support”](#environment-variable-support)

The deployment environment can also be specified using the `DOTNET_ENVIRONMENT` environment variable:

Set environment variable

```bash
export DOTNET_ENVIRONMENT=staging && aspire deploy
```

This behaves identically to using the `--environment` flag, loading the appropriate cached configuration file.

## Cache management

[Section titled “Cache management”](#cache-management)

The `aspire deploy` command provides mechanisms to manage cached deployment state, giving you control over when to use cached values and when to start fresh.

### Clear the cache

[Section titled “Clear the cache”](#clear-the-cache)

Use the `--clear-cache` flag to reset deployment state:

Clear deployment cache

```bash
aspire deploy --clear-cache
```

**Behavior:**

1. Prompts for confirmation before deleting the cache for the specified environment.
2. Deletes the environment-specific deployment state file (for example, `~/.aspire/deployments/{AppHostSha}/production.json`).
3. Prompts for all provisioning and parameter information as if deploying for the first time.
4. Proceeds with deployment.
5. **Does not save the prompted values** to cache.

### Environment-specific cache clearing

[Section titled “Environment-specific cache clearing”](#environment-specific-cache-clearing)

The `--clear-cache` flag respects the environment context:

Clear staging cache

```bash
aspire deploy --environment staging --clear-cache
```

This clears only the `staging.json` cache file while leaving other environment caches (like `production.json`) intact.

## File storage location

[Section titled “File storage location”](#file-storage-location)

* **Path pattern:** `~/.aspire/deployments/{AppHostSha}/{environment}.json`.
* **Default environment:** `production`.
* **AppHostSha:** A hash value representing the application host configuration, ensuring deployment states are specific to each application configuration.

## Use deployment state in CI/CD pipelines

[Section titled “Use deployment state in CI/CD pipelines”](#use-deployment-state-in-cicd-pipelines)

When using the `aspire deploy` command in continuous integration and deployment (CI/CD) pipelines, you might want to persist deployment state across pipeline runs. This approach can be useful for maintaining consistent deployment configurations without manual intervention.

### GitHub Actions example

[Section titled “GitHub Actions example”](#github-actions-example)

The following example demonstrates how to cache deployment state in a GitHub Actions workflow using the `actions/cache` action:

.github/workflows/deploy.yml

```yaml
name: Deploy to Azure


on:
  push:
    branches: [ main ]


jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4


    - name: Cache Aspire deployment state
      uses: actions/cache@v4
      with:
        path: ~/.aspire/deployments
        key: aspire-deploy-${{ hashFiles('**/AppHost.csproj') }}-${{ github.ref }}
        restore-keys: |
          aspire-deploy-${{ hashFiles('**/AppHost.csproj') }}-
          aspire-deploy-


    - name: Deploy with Aspire CLI
      run: aspire deploy --environment production
      env:
        AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
```

This workflow caches the `~/.aspire/deployments` directory, using the AppHost project file hash and branch reference as cache keys. The `actions/cache` action automatically restores the cache before the deployment step and saves any updates to the cache after the job completes. Subsequent workflow runs restore the cached deployment state, allowing automated deployments without re-prompting for configuration values.

Caution

When caching deployment state in CI/CD pipelines, ensure that your pipeline has appropriate access controls and secret management practices in place, as the cached state might contain sensitive configuration values.

## Security considerations

[Section titled “Security considerations”](#security-considerations)

The deployment state files are stored locally on your machine in the `~/.aspire/deployments` directory. These files contain provisioning settings and parameter values, including secrets that might be associated with parameter resources. The `aspire deploy` command follows the same security pattern as .NET’s user secrets manager:

* Files are stored outside of source code to mitigate against accidental secret leaks in version control.
* Secrets are stored in plain text in the local file system.
* Any process running under your user account can access these files.

Consider these security best practices:

* Ensure your local machine has appropriate security measures in place.
* Be cautious when sharing or backing up files from the `~/.aspire/deployments` directory.
* Use the `--clear-cache` flag when you need to change sensitive parameter values.

## Key points

[Section titled “Key points”](#key-points)

* Each environment maintains its own isolated deployment state.
* Cached values persist across deployments unless explicitly cleared.
* The `--clear-cache` flag performs a one-time deployment without persisting new values.
* Environment selection can be specified via flag or environment variable.
* You’re prompted for confirmation when loading cached settings.
* Cache files are stored per application (via AppHostSha) and per environment.

# Deployment manifest format

> Learn about the deployment manifest format for Aspire apps and the built-in resources available.

The deployment manifest is a JSON-formatted document generated by Aspire to describe your app’s resources and their relationships. This manifest is consumed by deployment tools to provision and configure infrastructure in target cloud environments.

## Generate the manifest

[Section titled “Generate the manifest”](#generate-the-manifest)

Create a new Aspire project using the following command:

Create new Aspire project

```bash
aspire new --name AspireApp --output AspireApp
```

[Command reference: `aspire new`](/reference/cli/commands/aspire-new/)

Navigate to the newly created project directory:

Navigate to project directory

```bash
cd ./AspireApp
```

Manifest generation is achieved by running the Aspire CLI with the `publish` command:

Generate manifest

```bash
aspire do publish-manifest --output-path ./aspire-manifest.json'
```

[Command reference: `aspire do`](/reference/cli/commands/aspire-do/)

Tip

The `--output-path` supports relative paths. The previous command uses `../aspire-manifest.json` to place the manifest file in the root of the project directory.

The previous command produces the following output:

```plaintext
11:55:09 (pipeline execution) → Starting pipeline execution...
11:55:09 (publish-manifest) → Starting publish-manifest...
11:55:09 (publish-manifest) i [INF] Published manifest to: ./AspireApp/aspire-manifest.json
11:55:09 (publish-manifest) ✓ publish-manifest completed successfully
11:55:09 (pipeline execution) ✓ Completed successfully
------------------------------------------------------------
✓ 2/2 steps succeeded • Total time: 0.0s


Steps Summary:
   0.0 s  ✓ pipeline execution
   0.0 s  ✓ publish-manifest


✓ PIPELINE SUCCEEDED
------------------------------------------------------------
```

The file generated is the Aspire manifest and is used by tools to support deploying into target cloud environments.

Note

You can also generate a manifest as part of the launch profile. Consider the following `launchSettings.json`:

launchSettings.json

```json
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "profiles": {
    "generate-manifest": {
      "commandName": "Project",
      "launchBrowser": false,
      "dotnetRunMessages": true,
      "commandLineArgs": "publish --output-format manifest --output-path aspire-manifest.json"
    }
  }
}
```

## Basic manifest format

[Section titled “Basic manifest format”](#basic-manifest-format)

Publishing the manifest from the default starter template for Aspire produces the following JSON output:

aspire-manifest.json

```json
{
  "resources": {
    "cache": {
      "type": "container.v0",
      "connectionString": "{cache.bindings.tcp.host}:{cache.bindings.tcp.port}",
      "image": "redis:7.4",
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 6379
        }
      }
    },
    "apiservice": {
      "type": "project.v0",
      "path": "../AspireApp.ApiService/AspireApp.ApiService.csproj",
      "env": {
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES": "true",
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES": "true"
      },
      "bindings": {
        "http": {
          "scheme": "http",
          "protocol": "tcp",
          "transport": "http"
        },
        "https": {
          "scheme": "https",
          "protocol": "tcp",
          "transport": "http"
        }
      }
    },
    "webfrontend": {
      "type": "project.v0",
      "path": "../AspireApp.Web/AspireApp.Web.csproj",
      "env": {
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES": "true",
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES": "true",
        "ConnectionStrings__cache": "{cache.connectionString}",
        "APISERVICE_HTTP": "{apiservice.bindings.http.url}",
        "APISERVICE_HTTPS": "{apiservice.bindings.https.url}",
        "services__apiservice__http__0": "{apiservice.bindings.http.url}",
        "services__apiservice__https__0": "{apiservice.bindings.https.url}"
      },
      "bindings": {
        "http": {
          "scheme": "http",
          "protocol": "tcp",
          "transport": "http"
        },
        "https": {
          "scheme": "https",
          "protocol": "tcp",
          "transport": "http"
        }
      }
    }
  }
}
```

The manifest format JSON consists of a single object called `resources`, which contains a property for each resource specified in `Program.cs` (the `name` argument for each name is used as the property for each of the child resource objects in JSON).

### Connection string and binding references

[Section titled “Connection string and binding references”](#connection-string-and-binding-references)

In the previous example, there are two project resources and one Redis cache resource. The *webfrontend* depends on both the *apiservice* (project) and *cache* (Redis) resources.

This dependency is known because the environment variables for the *webfrontend* contain placeholders that reference the two other resources:

Environment variables with placeholders

```json
"env": {
  // ... other environment variables omitted for clarity
  "ConnectionStrings__cache": "{cache.connectionString}",
  "APISERVICE_HTTP": "{apiservice.bindings.http.url}",
  "APISERVICE_HTTPS": "{apiservice.bindings.https.url}",
  "services__apiservice__http__0": "{apiservice.bindings.http.url}",
  "services__apiservice__https__0": "{apiservice.bindings.https.url}"
},
```

The `apiservice` resource is referenced by `webfrontend` using the call `WithReference(apiservice)` in the AppHost `Program.cs` file and `redis` is referenced using the call `WithReference(cache)`:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice");


builder.AddProject<Projects.AspireApp_Web>("webfrontend")
    .WithReference(cache)
    .WithReference(apiService);


builder.Build().Run();
```

References between project resource types result in [service discovery](/fundamentals/service-discovery/) variables being injected into the referencing project. References to well known reference types such as Redis result in connection strings being injected.

![A diagram showing which resources contribute to which corresponding placeholder strings.](/_astro/manifest-placeholder-strings.CEHQ55AW.svg)

For more information on how resources in the app model and references between them work, see, [Aspire orchestration overview](/get-started/app-host/).

### Placeholder string structure

[Section titled “Placeholder string structure”](#placeholder-string-structure)

Placeholder strings reference the structure of the Aspire manifest:

![A diagram showing how the manifest JSON structure maps to placeholder strings.](/_astro/placeholder-mappings.Cx1aP1Py.svg)

The final segment of the placeholder string (`url` in this case) is generated by the tool processing the manifest. There are several suffixes that could be used on the placeholder string:

* `connectionString`: For well-known resource types such as Redis. Deployment tools translate the resource in the most appropriate infrastructure for the target cloud environment and then produce an Aspire compatible connection string for the consuming application to use. On `container.v0` resources the `connectionString` field may be present and specified explicitly. This is to support scenarios where a container resource type is referenced using the `WithReference` extension but is desired to be hosted explicitly as a container.
* `url`: For service-to-service references where a well-formed URL is required. The deployment tool produces the `url` based on the scheme, protocol, and transport defined in the manifest and the underlying compute/networking topology that was deployed.
* `host`: The host segment of the URL.
* `port`: The port segment of the URL.

## Resource types

[Section titled “Resource types”](#resource-types)

Each resource has a `type` field. When a deployment tool reads the manifest, it should read the type to verify whether it can correctly process the manifest. During the Aspire preview period, all resource types have a `v0` suffix to indicate that they’re subject to change. As Aspire approaches release a `v1` suffix will be used to signify that the structure of the manifest for that resource type should be considered stable (subsequent updates increment the version number accordingly).

### Common resource fields

[Section titled “Common resource fields”](#common-resource-fields)

The `type` field is the only field that is common across all resource types, however, the `project.v0`, `container.v0`, and `executable.v0` resource types also share the `env` and `bindings` fields.

Note

The `executable.v0` resource type isn’t fully implemented in the manifest due to its lack of utility in deployment scenarios. For more information on containerizing executables, see [Dockerfile resource types](#dockerfile-resource-types).

The `env` field type is a basic key/value mapping where the values might contain [*placeholder strings*](#placeholder-string-structure).

Bindings are specified in the `bindings` field with each binding contained within its own field under the `bindings` JSON object. The fields emitted by the Aspire manifest in the `bindings` node include:

* `scheme`: One of the following values `tcp`, `udp`, `http`, or `https`.
* `protocol`: One of the following values `tcp` or `udp`
* `transport`: Same as `scheme`, but used to disambiguate between `http` and `http2`.
* `containerPort`: Optional, if omitted defaults to port 80.

### The `inputs` field

[Section titled “The inputs field”](#the-inputs-field)

Some resources generate an `inputs` field. This field is used to specify input parameters for the resource. The `inputs` field is a JSON object where each property is an input parameter that’s used in placeholder structure resolution. Resources that have a `connectionString`, for example, might use the `inputs` field to specify a `password` for the connection string:

Connection string with input parameter

```json
"connectionString": "Host={<resourceName>.bindings.tcp.host};Port={<resourceName>.bindings.tcp.port};Username=admin;Password={<resourceName>.inputs.password};"
```

The connection string placeholder references the `password` input parameter from the `inputs` field:

Input parameter definition

```json
"inputs": {
  "password": {
    "type": "string",
    "secret": true,
    "default": {
      "generate": {
        "minLength": 10
      }
    }
  }
}
```

The preceding JSON snippet shows the `inputs` field for a resource that has a `connectionString` field. The `password` input parameter is a string type and is marked as a secret. The `default` field is used to specify a default value for the input parameter. In this case, the default value is generated using the `generate` field, with random string of a minimum length.

When a parameter is using a filter (for example `uri`), the manifest contains an additional resource that represents the filtered projection.

* The resource type is `"annotated.string"`.
* `value` references the raw parameter value (`{parameter-name.value}`).
* `filter` names the formatter (e.g., `"uri"`, …).
* The resource name is derived from the parameter name and format (`{parameter}-{format}-encoded`). Names are deduplicated if multiple projections share the same base.

Example projection generated for a URI-encoded password:

```json
"redis-password-uri-encoded": {
  "type": "annotated.string",
  "value": "{redis-password.value}",
  "filter": "uri"
}
```

The original parameter remains in the manifest, preserving its secret metadata. Tools should apply the indicated `filter` when materializing the value.

## Built-in resources

[Section titled “Built-in resources”](#built-in-resources)

The following table is a list of resource types that are explicitly generated by Aspire and extensions developed by the Aspire team:

### Cloud-agnostic resource types

[Section titled “Cloud-agnostic resource types”](#cloud-agnostic-resource-types)

These resources are available in the [📦 Aspire.Hosting](https://www.nuget.org/packages/Aspire.Hosting) NuGet package.

| App model usage            | Manifest resource type | Heading link                                             |
| -------------------------- | ---------------------- | -------------------------------------------------------- |
| `AddContainer`             | `container.v0`         | [Container resource type](#container-resource-type)      |
| `PublishAsDockerFile`      | `dockerfile.v0`        | [Dockerfile resource types](#dockerfile-resource-types)  |
| `AddDatabase` (MongoDB)    | `value.v0`             | [MongoDB Server resource types](#mongodb-resource-types) |
| `AddMongoDB`               | `container.v0`         | [MongoDB resource types](#mongodb-resource-types)        |
| `AddDatabase` (MySQL)      | `value.v0`             | [MySQL Server resource types](#mysql-resource-types)     |
| `AddMySql`                 | `container.v0`         | [MySQL resource types](#mysql-resource-types)            |
| `AddDatabase` (Postgres)   | `value.v0`             | [Postgres resource types](#postgres-resource-types)      |
| `AddPostgres`              | `container.v0`         | [Postgres resource types](#postgres-resource-types)      |
| `AddProject`               | `project.v0`           | [Project resource type](#project-resource-type)          |
| `AddRabbitMQ`              | `container.v0`         | [RabbitMQ resource types](#rabbitmq-resource-types)      |
| `AddRedis`                 | `container.v0`         | [Redis resource type](#redis-resource-type)              |
| `AddDatabase` (SQL Server) | `value.v0`             | [SQL Server resource types](#sql-server-resource-types)  |
| `AddSqlServer`             | `container.v0`         | [SQL Server resource types](#sql-server-resource-types)  |

#### Project resource type

[Section titled “Project resource type”](#project-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);
var apiservice = builder.AddProject<Projects.AspireApp_ApiService>("apiservice");
```

Example manifest:

Project resource manifest

```json
"apiservice": {
  "type": "project.v0",
  "path": "../AspireApp.ApiService/AspireApp.ApiService.csproj",
  "env": {
    "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES": "true",
    "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES": "true"
  },
  "bindings": {
    "http": {
      "scheme": "http",
      "protocol": "tcp",
      "transport": "http"
    },
    "https": {
      "scheme": "https",
      "protocol": "tcp",
      "transport": "http"
    }
  }
}
```

#### Container resource type

[Section titled “Container resource type”](#container-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("mycontainer", "myimage")
       .WithEnvironment("LOG_LEVEL", "WARN")
       .WithHttpEndpoint(3000);
```

Example manifest:

Container resource manifest

```json
{
  "resources": {
    "mycontainer": {
      "type": "container.v0",
      "image": "myimage:latest",
      "env": {
        "LOG_LEVEL": "WARN"
      },
      "bindings": {
        "http": {
          "scheme": "http",
          "protocol": "tcp",
          "transport": "http",
          "containerPort": 3000
        }
      }
    }
  }
}
```

#### Dockerfile resource types

[Section titled “Dockerfile resource types”](#dockerfile-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddNodeApp("nodeapp", "../nodeapp/app.js")
       .WithHttpEndpoint(hostPort: 5031, env: "PORT")
       .PublishAsDockerFile();
```

Tip

The `PublishAsDockerFile` call is required to generate the Dockerfile resource type in the manifest, and this extension method is only available on the `ExecutableResource` type.

Example manifest:

Dockerfile resource manifest

```json
{
  "resources": {
    "nodeapp": {
      "type": "dockerfile.v0",
      "path": "../nodeapp/Dockerfile",
      "context": "../nodeapp",
      "env": {
        "NODE_ENV": "development",
        "PORT": "{nodeapp.bindings.http.port}"
      },
      "bindings": {
        "http": {
          "scheme": "http",
          "protocol": "tcp",
          "transport": "http",
          "containerPort": 5031
        }
      }
    }
  }
}
```

#### Postgres resource types

[Section titled “Postgres resource types”](#postgres-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddPostgres("postgres1")
       .AddDatabase("shipping");
```

Example manifest:

Postgres resource manifest

```json
{
  "resources": {
    "postgres1": {
      "type": "container.v0",
      "connectionString": "Host={postgres1.bindings.tcp.host};Port={postgres1.bindings.tcp.port};Username=postgres;Password={postgres1.inputs.password}",
      "image": "postgres:17.2",
      "env": {
        "POSTGRES_HOST_AUTH_METHOD": "scram-sha-256",
        "POSTGRES_INITDB_ARGS": "--auth-host=scram-sha-256 --auth-local=scram-sha-256",
        "POSTGRES_PASSWORD": "{postgres1.inputs.password}"
      },
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 5432
        }
      },
      "inputs": {
        "password": {
          "type": "string",
          "secret": true,
          "default": {
            "generate": {
              "minLength": 10
            }
          }
        }
      }
    },
    "shipping": {
      "type": "value.v0",
      "connectionString": "{postgres1.connectionString};Database=shipping"
    }
  }
}
```

#### RabbitMQ resource types

[Section titled “RabbitMQ resource types”](#rabbitmq-resource-types)

RabbitMQ is modeled as a container resource `container.v0`. The following sample shows how they’re added to the app model.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddRabbitMQ("rabbitmq1");
```

The previous code produces the following manifest:

RabbitMQ resource manifest

```json
{
  "resources": {
    "rabbitmq1": {
      "type": "container.v0",
      "connectionString": "amqp://guest:{rabbitmq1.inputs.password}@{rabbitmq1.bindings.tcp.host}:{rabbitmq1.bindings.tcp.port}",
      "image": "rabbitmq:3",
      "env": {
        "RABBITMQ_DEFAULT_USER": "guest",
        "RABBITMQ_DEFAULT_PASS": "{rabbitmq1.inputs.password}"
      },
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 5672
        }
      },
      "inputs": {
        "password": {
          "type": "string",
          "secret": true,
          "default": {
            "generate": {
              "minLength": 10
            }
          }
        }
      }
    }
  }
}
```

#### Redis resource type

[Section titled “Redis resource type”](#redis-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddRedis("redis1");
```

Example manifest:

Redis resource manifest

```json
{
  "resources": {
    "redis1": {
      "type": "container.v0",
      "connectionString": "{redis1.bindings.tcp.host}:{redis1.bindings.tcp.port}",
      "image": "redis:7.4",
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 6379
        }
      }
    }
  }
}
```

#### SQL Server resource types

[Section titled “SQL Server resource types”](#sql-server-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddSqlServer("sql1")
       .AddDatabase("shipping");
```

Example manifest:

SQL Server resource manifest

```json
{
  "resources": {
    "sql1": {
      "type": "container.v0",
      "connectionString": "Server={sql1.bindings.tcp.host},{sql1.bindings.tcp.port};User ID=sa;Password={sql1.inputs.password};TrustServerCertificate=true",
      "image": "mcr.microsoft.com/mssql/server:2022-latest",
      "env": {
        "ACCEPT_EULA": "Y",
        "MSSQL_SA_PASSWORD": "{sql1.inputs.password}"
      },
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 1433
        }
      },
      "inputs": {
        "password": {
          "type": "string",
          "secret": true,
          "default": {
            "generate": {
              "minLength": 10
            }
          }
        }
      }
    },
    "shipping": {
      "type": "value.v0",
      "connectionString": "{sql1.connectionString};Database=shipping"
    }
  }
}
```

#### MongoDB resource types

[Section titled “MongoDB resource types”](#mongodb-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddMongoDB("mongodb1")
       .AddDatabase("shipping");
```

Example manifest:

MongoDB resource manifest

```json
{
  "resources": {
    "mongodb1": {
      "type": "container.v0",
      "connectionString": "mongodb://{mongodb1.bindings.tcp.host}:{mongodb1.bindings.tcp.port}",
      "image": "mongo:8.0",
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 27017
        }
      }
    },
    "shipping": {
      "type": "value.v0",
      "connectionString": "{mongodb1.connectionString}/shipping"
    }
  }
}
```

#### MySQL resource types

[Section titled “MySQL resource types”](#mysql-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddMySql("mysql1")
       .AddDatabase("shipping");
```

Example manifest:

MySQL resource manifest

```json
{
  "resources": {
    "mysql1": {
      "type": "container.v0",
      "connectionString": "Server={mysql1.bindings.tcp.host};Port={mysql1.bindings.tcp.port};User ID=root;Password={mysql1.inputs.password}",
      "image": "mysql:9.1",
      "env": {
        "MYSQL_ROOT_PASSWORD": "{mysql1.inputs.password}"
      },
      "bindings": {
        "tcp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "containerPort": 3306
        }
      },
      "inputs": {
        "password": {
          "type": "string",
          "secret": true,
          "default": {
            "generate": {
              "minLength": 10
            }
          }
        }
      }
    },
    "shipping": {
      "type": "value.v0",
      "connectionString": "{mysql1.connectionString};Database=shipping"
    }
  }
}
```

### Azure-specific resource types

[Section titled “Azure-specific resource types”](#azure-specific-resource-types)

The following resources are available in the [📦 Aspire.Hosting.Azure](https://www.nuget.org/packages/Aspire.Hosting.Azure) NuGet package.

| App Model usage                                        | Manifest resource type | Heading link                                                                     |
| ------------------------------------------------------ | ---------------------- | -------------------------------------------------------------------------------- |
| `AddAzureAppConfiguration`                             | `azure.bicep.v0`       | [Azure App Configuration resource types](#azure-app-configuration-resource-type) |
| `AddAzureKeyVault`                                     | `azure.bicep.v0`       | [Azure Key Vault resource type](#azure-key-vault-resource-type)                  |
| `AddAzureRedis`                                        | `azure.bicep.v0`       | [Azure Redis resource types](#azure-redis-resource-type)                         |
| `AddAzureServiceBus`                                   | `azure.bicep.v0`       | [Azure Service Bus resource type](#azure-service-bus-resource-type)              |
| `AddAzureSqlServer(...)`                               | `azure.bicep.v0`       | [Azure SQL resource types](#azure-sql-resource-types)                            |
| `AddAzureSqlServer(...).AddDatabase(...)`              | `value.v0`             | [Azure SQL resource types](#azure-sql-resource-types)                            |
| `AddAzurePostgresFlexibleServer(...)`                  | `azure.bicep.v0`       | [Azure Postgres resource types](#azure-postgres-resource-types)                  |
| `AddAzurePostgresFlexibleServer(...).AddDatabase(...)` | `value.v0`             | [Azure Postgres resource types](#azure-postgres-resource-types)                  |
| `AddAzureStorage`                                      | `azure.storage.v0`     | [Azure Storage resource types](#azure-storage-resource-types)                    |
| `AddBlobs`                                             | `value.v0`             | [Azure Storage resource types](#azure-storage-resource-types)                    |
| `AddQueues`                                            | `value.v0`             | [Azure Storage resource types](#azure-storage-resource-types)                    |
| `AddTables`                                            | `value.v0`             | [Azure Storage resource types](#azure-storage-resource-types)                    |

#### Azure Key Vault resource type

[Section titled “Azure Key Vault resource type”](#azure-key-vault-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureKeyVault("keyvault1");
```

Example manifest:

Azure Key Vault resource manifest

```json
{
  "resources": {
    "keyvault1": {
      "type": "azure.bicep.v0",
      "connectionString": "{keyvault1.outputs.vaultUri}",
      "path": "aspire.hosting.azure.bicep.keyvault.bicep",
      "params": {
        "principalId": "",
        "principalType": "",
        "vaultName": "keyvault1"
      }
    }
  }
}
```

#### Azure Service Bus resource type

[Section titled “Azure Service Bus resource type”](#azure-service-bus-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureServiceBus("sb1")
       .AddTopic("topic1", [])
       .AddTopic("topic2", [])
       .AddQueue("queue1")
       .AddQueue("queue2");
```

Example manifest:

Azure Service Bus resource manifest

```json
{
  "resources": {
    "sb1": {
      "type": "azure.bicep.v0",
      "connectionString": "{sb1.outputs.serviceBusEndpoint}",
      "path": "aspire.hosting.azure.bicep.servicebus.bicep",
      "params": {
        "serviceBusNamespaceName": "sb1",
        "principalId": "",
        "principalType": "",
        "queues": [
          "queue1",
          "queue2"
        ],
        "topics": [
          {
            "name": "topic1",
            "subscriptions": []
          },
          {
            "name": "topic2",
            "subscriptions": []
          }
        ]
      }
    }
  }
}
```

#### Azure Storage resource types

[Section titled “Azure Storage resource types”](#azure-storage-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("images");


storage.AddBlobs("blobs");
storage.AddQueues("queues");
storage.AddTables("tables");
```

Example manifest:

Azure Storage resource manifest

```json
{
  "resources": {
    "images": {
      "type": "azure.bicep.v0",
      "path": "aspire.hosting.azure.bicep.storage.bicep",
      "params": {
        "principalId": "",
        "principalType": "",
        "storageName": "images"
      }
    },
    "blobs": {
      "type": "value.v0",
      "connectionString": "{images.outputs.blobEndpoint}"
    },
    "queues": {
      "type": "value.v0",
      "connectionString": "{images.outputs.queueEndpoint}"
    },
    "tables": {
      "type": "value.v0",
      "connectionString": "{images.outputs.tableEndpoint}"
    }
  }
}
```

#### Azure Redis resource type

[Section titled “Azure Redis resource type”](#azure-redis-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureRedis("azredis1");
```

Example manifest:

Azure Redis resource manifest

```json
{
  "resources": {
    "azredis": {
      "type": "azure.bicep.v0",
      "connectionString": "{azredis.outputs.connectionString}",
      "path": "azredis.module.bicep",
      "params": {
        "principalId": "",
        "principalName": ""
      }
    }
  }
}
```

#### Azure App Configuration resource type

[Section titled “Azure App Configuration resource type”](#azure-app-configuration-resource-type)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureAppConfiguration("appconfig1");
```

Example manifest:

Azure App Configuration resource manifest

```json
{
  "resources": {
    "appconfig1": {
      "type": "azure.bicep.v0",
      "connectionString": "{appconfig1.outputs.appConfigEndpoint}",
      "path": "aspire.hosting.azure.bicep.appconfig.bicep",
      "params": {
        "configName": "appconfig1",
        "principalId": "",
        "principalType": ""
      }
    }
  }
}
```

#### Azure SQL resource types

[Section titled “Azure SQL resource types”](#azure-sql-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureSqlServer("sql")
       .AddDatabase("inventory");
```

Example manifest:

Azure SQL resource manifest

```json
{
  "resources": {
    "sql": {
      "type": "azure.bicep.v0",
      "connectionString": "Server=tcp:{sql.outputs.sqlServerFqdn},1433;Encrypt=True;Authentication=\"Active Directory Default\"",
      "path": "sql.module.bicep",
      "params": {
        "principalId": "",
        "principalName": ""
      }
    },
    "inventory": {
      "type": "value.v0",
      "connectionString": "{sql.connectionString};Database=inventory"
    }
  }
}
```

#### Azure Postgres resource types

[Section titled “Azure Postgres resource types”](#azure-postgres-resource-types)

Example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzurePostgresFlexibleServer("postgres")
       .AddDatabase("db");
```

Example manifest:

Azure Postgres resource manifest

```json
{
  "resources": {
    "postgres": {
      "type": "azure.bicep.v0",
      "connectionString": "{postgres.outputs.connectionString}",
      "path": "postgres.module.bicep",
      "params": {
        "principalId": "",
        "principalType": "",
        "principalName": ""
      }
    },
    "db": {
      "type": "value.v0",
      "connectionString": "{postgres.connectionString};Database=db"
    }
  }
}
```

### Resource types supported in the Azure Developer CLI

[Section titled “Resource types supported in the Azure Developer CLI”](#resource-types-supported-in-the-azure-developer-cli)

The [Azure Developer CLI](https://learn.microsoft.com/azure/developer/azure-developer-cli/) (azd) is a tool that can be used to deploy Aspire projects to Azure Container Apps. With the `azure.bicep.v0` resource type, cloud-agnostic resource container types can be converted to Azure-specific resources for deployment. The following table shows the mapping between cloud-agnostic and Azure-specific resources:

| Name       | Cloud-agnostic API | Azure API                        |
| ---------- | ------------------ | -------------------------------- |
| Redis      | `AddRedis`         | `AddAzureRedis`                  |
| Postgres   | `AddPostgres`      | `AddAzurePostgresFlexibleServer` |
| SQL Server | `AddSqlServer`     | `AddAzureSqlServer`              |

When resources as configured as Azure resources, the `azure.bicep.v0` resource type is generated in the manifest.

# Publishing and deployment

> Learn how Aspire solutions are published and deployed.

Aspire separates the act of *producing deployment assets* from *executing a deployment*. The Aspire CLI (`aspire`) provides two high-level entrypoints:

* `aspire publish`: Generates intermediate, parameterized assets for one or more hosting integrations that implement publish semantics.
* `aspire deploy`: Executes a deployment (when an integration implements deploy semantics) by resolving parameters and applying changes to a target environment.

These commands provide direct access to publishing and deployment capabilities. The actual behavior (what gets generated, how deployment happens) comes from **hosting integrations** you reference (for example: Docker, Kubernetes, Azure). The system is **extensible**—you can build your own publishing or deployment integrations that plug into the same model.

The `aspire publish` command produces deployment artifacts that contain unresolved parameters (placeholders). The `aspire deploy` command uses these artifacts, resolves the parameters when supported by the target integration, and then executes the deployment. Some integrations don’t support the `deploy` command.

## Aspire CLI commands (conceptual behavior)

[Section titled “Aspire CLI commands (conceptual behavior)”](#aspire-cli-commands-conceptual-behavior)

| Command                                                     | What it does                                                                                                        | Outputs                                                 | Parameter state                                      | Requires integration capability |
| ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------- | ---------------------------------------------------- | ------------------------------- |
| [`aspire publish`](/reference/cli/commands/aspire-publish/) | Transforms the application model into integration-specific assets (Compose files, manifests, specifications, etc.). | Intermediate artifacts (not directly production-final). | Unresolved (placeholders, e.g. `${VAR}` or similar). | Publish support                 |
| [`aspire deploy`](/reference/cli/commands/aspire-deploy/)   | Runs a deployment using one or more integrations (build, parameter resolution, apply).                              | Real resources / applied changes.                       | Resolved.                                            | Deploy support                  |

If an integration does not implement deploy functionality, `aspire deploy` will not deploy that target (it may warn or no-op for it).

When you run `aspire publish` without any integrations that support publishing, you’ll see:

Error: No publish support

```plaintext
Step 1: Analyzing model.


       ✗ FAILED: Analyzing the distributed application model for publishing and deployment capabilities. 00:00:00
       No resources in the distributed application model support publishing.


❌ FAILED: Analyzing model. completed with errors
```

Similarly, when you run `aspire deploy` without any integrations that support deployment, you’ll see this error:

Error: No deploy support

```plaintext
Step 1: Analyzing model.


       ✗ FAILED: Analyzing the distributed application model for publishing and deployment capabilities. 00:00:00
       No resources in the distributed application model support deployment.


❌ FAILED: Analyzing model. completed with errors
```

These messages indicate that you need to add hosting integrations to your AppHost project. Hosting integrations are NuGet packages (like [📦 Aspire.Hosting.Docker](https://www.nuget.org/packages/Aspire.Hosting.Docker), [📦 Aspire.Hosting.Kubernetes](https://www.nuget.org/packages/Aspire.Hosting.Kubernetes), or [📦 Aspire.Hosting.Azure](https://www.nuget.org/packages/Aspire.Hosting.Azure)) that provide the publishing and deployment capabilities for specific target platforms.

Learn more: [Integrations overview](/integrations/overview/)

## Parameter placeholders

[Section titled “Parameter placeholders”](#parameter-placeholders)

Published assets intentionally contain placeholders instead of concrete values. For Docker Compose—based publish output, parameterization appears as standard environment variable references. For example, a publish artifact might include:

docker-compose.yml

```yaml
services:
  pg:
    image: "docker.io/library/postgres:17.2"
    environment:
      POSTGRES_HOST_AUTH_METHOD: "scram-sha-256"
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256 --auth-local=scram-sha-256"
      POSTGRES_USER: "postgres"
      POSTGRES_PASSWORD: "${PG_PASSWORD}"
    ports:
      - "8000:5432"
    networks:
      - "aspire"
  dbsetup:
    image: "${DBSETUP_IMAGE}"
    environment:
      OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES: "true"
      OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES: "true"
      OTEL_DOTNET_EXPERIMENTAL_OTLP_RETRY: "in_memory"
      ASPNETCORE_FORWARDEDHEADERS_ENABLED: "true"
      HTTP_PORTS: "8001"
      ConnectionStrings__db: "Host=pg;Port=5432;Username=postgres;Password=${PG_PASSWORD};Database=db"
    ports:
      - "8002:8001"
      - "8004:8003"
    depends_on:
      pg:
        condition: "service_started"
    networks:
      - "aspire"
```

Key points:

* `${PG_PASSWORD}` and `${DBSETUP_IMAGE}` (and similar) are *placeholders* in the published asset.
* They are not resolved during `aspire publish`.
* A deployment engine (which could be `aspire deploy`, `docker compose` plus a script exporting variables, CI/CD variable injection, etc.) supplies their values later.
* This keeps secrets and environment-specific values decoupled from generated structure.

Different integrations may use different placeholder conventions (environment variables, tokens, or parameter metadata), but the principle remains: publish preserves *shape*, deploy injects *values*.

## Publisher model and compute environments

[Section titled “Publisher model and compute environments”](#publisher-model-and-compute-environments)

Aspire uses a flexible publisher model that distributes publishing behavior across your application graph. Resources support publishing and deployment through annotations.

This design enables hybrid and heterogeneous deployments, where different services within the same app can be deployed to different targets (cloud, edge, local).

### Compute environments

[Section titled “Compute environments”](#compute-environments)

A **compute environment** is a core deployment concept in Aspire that represents a target platform where your application resources will be deployed. Compute environments define how resources should be transformed and what deployment artifacts should be generated. Examples of built-in compute environments include the Azure Container Apps environment and the Docker Compose environment.

**Compute resources** are the runnable parts of your application, such as .NET projects, containers, and executables that need to be deployed to a compute environment.

When you add a compute environment like Docker Compose or Kubernetes, Aspire applies the correct publishing behavior to all compatible compute resources in your app model—no extra configuration needed.

### Multiple environments require disambiguation

[Section titled “Multiple environments require disambiguation”](#multiple-environments-require-disambiguation)

If you add multiple compute environments, Aspire needs to know which resource goes where. Compute environments apply their transformations to all applicable compute resources (projects, containers, executables). If more than one environment matches a given resource, Aspire throws an ambiguous environment exception at publish time.

You can resolve this by using `WithComputeEnvironment`:

Program.cs

```csharp
var k8s = builder.AddKubernetesEnvironment("k8s-env");
var compose = builder.AddDockerComposeEnvironment("docker-env");


builder.AddProject<Projects.Frontend>("frontend")
    .WithComputeEnvironment(k8s);


builder.AddProject<Projects.Backend>("backend")
    .WithComputeEnvironment(compose);
```

This example shows how you could explicitly map services to different compute environments. For example, a frontend in Kubernetes and a backend in Docker Compose.

## Hosting integration support matrix

[Section titled “Hosting integration support matrix”](#hosting-integration-support-matrix)

| Integration                                                                                  | Target                  | Publish | Deploy          | Notes                                                   |
| -------------------------------------------------------------------------------------------- | ----------------------- | ------- | --------------- | ------------------------------------------------------- |
| [📦 Aspire.Hosting.Docker](/integrations/compute/docker/)                                    | Docker / Docker Compose | ✅ Yes   | 🧪 Preview      | Use generated Compose with your own scripts or tooling. |
| [📦 Aspire.Hosting.Kubernetes](/integrations/compute/kubernetes/)                            | Kubernetes              | ✅ Yes   | 🧪 Preview      | Apply with `kubectl`, GitOps, or other controllers.     |
| [📦 Aspire.Hosting.Azure.AppContainers](/integrations/cloud/azure/configure-container-apps/) | Azure Container Apps    | ✅ Yes   | ✅ Yes (Preview) | Deploy capability is in Preview and may change.         |
| [📦 Aspire.Hosting.Azure.AppService](/integrations/cloud/azure/azure-app-service/)           | Azure App Service       | ✅ Yes   | ✅ Yes (Preview) | Deploy capability is in Preview and may change.         |

Tip

Deploy support is integration-specific. Absence of deploy support means you use the published artifacts with external tooling.

## Typical workflows

[Section titled “Typical workflows”](#typical-workflows)

1. ### Generate artifacts (any integration)

   [Section titled “Generate artifacts (any integration)”](#generate-artifacts-any-integration)

   Generate artifacts

   ```bash
   aspire publish -o artifacts/
   ```

   Review the contents of *artifacts/* (for example: Docker Compose files, Kubernetes manifests, Azure specification documents, etc.).

2. ### Run locally (Docker example)

   [Section titled “Run locally (Docker example)”](#run-locally-docker-example)

   Run with Docker Compose

   ```bash
   # Provide or export required environment variables, then:
   docker compose -f artifacts/docker-compose.yml up --build
   ```

   Missing variables like `PG_PASSWORD` must be set in the shell, an `.env` file, or injected by your chosen runner.

3. ### Using `aspire deploy`

   [Section titled “Using aspire deploy”](#using-aspire-deploy)

   If an integration supports deployment, you can run:

   Deploy

   ```bash
   aspire deploy
   ```

   This resolves parameters and applies deployment changes for integrations that support deployment.

## Extensibility

[Section titled “Extensibility”](#extensibility)

The `aspire publish` and `aspire deploy` commands support extensible workflows through annotations that you can add to resources. This functionality is in preview and may change in future releases.

### Custom publishing and deployment callbacks

[Section titled “Custom publishing and deployment callbacks”](#custom-publishing-and-deployment-callbacks)

Resources support custom publishing and deployment behavior through annotations:

* `PublishingCallbackAnnotation`: Executes custom logic during `aspire publish` operations.
* `DeployingCallbackAnnotation`: Executes custom logic during `aspire deploy` operations.

The following example demonstrates using `DeployingCallbackAnnotation` to register custom deployment behavior:

AppHost.cs

```csharp
#pragma warning disable ASPIREPUBLISHERS001
#pragma warning disable ASPIREINTERACTION001


using Aspire.Hosting.Publishing;
using Microsoft.Extensions.DependencyInjection;


var builder = DistributedApplication.CreateBuilder(args);


// Custom deployment step defined below
builder.AddDataSeedJob("SeedInitialData", seedDataPath: "data/seeds");


builder.Build().Run();


internal class DataSeedJobResource(
    [ResourceName] string name, string seedDataPath)
        : Resource(name)
{
    public string SeedDataPath { get; } = seedDataPath;
}


internal static class DataSeedJobResourceBuilderExtensions
{
    public static IResourceBuilder<DataSeedJobResource> AddDataSeedJob(
        this IDistributedApplicationBuilder builder,
        string name,
        string seedDataPath = "data/seeds")
    {
        var job = new DataSeedJobResource(name, seedDataPath);
        var resourceBuilder = builder.AddResource(job);


        // Attach a DeployingCallbackAnnotation that will be invoked on `aspire deploy`
        job.Annotations.Add(new DeployingCallbackAnnotation(async ctx =>
        {
            CancellationToken ct = ctx.CancellationToken;


            // Prompt the user for a confirmation using the interaction service
            var interactionService = ctx.Services.GetRequiredService<IInteractionService>();


            var envResult = await interactionService.PromptInputAsync(
                "Environment Configuration",
                "Please enter the target environment name:",
                new InteractionInput
                {
                    Label = "Environment Name",
                    InputType = InputType.Text,
                    Required = true,
                    Placeholder = "dev, staging, prod"
                },
                cancellationToken: ct);


            // Custom deployment logic here
            var reporter = ctx.ActivityReporter;
            await using (var deployStep = await reporter.CreateStepAsync(
                $"Deploying data seed job to {envResult.Value}", ct))
            {
                // Simulate deployment work
                await Task.Delay(2000, ct);
                await deployStep.SucceedAsync("Data seed job deployed successfully", ct);
            }
        }));


        return resourceBuilder;
    }
}
```

This custom deployment logic integrates seamlessly with the `aspire deploy` command, providing interactive prompts and progress reporting.

[Aspire resource architecture](/architecture/resource-model/)

## Diagnostics and auditing

[Section titled “Diagnostics and auditing”](#diagnostics-and-auditing)

Publishing gives you an immutable snapshot of intended structure before secrets appear. You can:

* Diff published outputs between commits.
* Scan for disallowed images or configuration.
* Preserve a record for compliance, then separately record the resolved set applied at deployment time.

## Additional tools

[Section titled “Additional tools”](#additional-tools)

### Azure Developer CLI (`azd`)

[Section titled “Azure Developer CLI (azd)”](#azure-developer-cli-azd)

[Azure Developer CLI (azd)](https://learn.microsoft.com/azure/developer/azure-developer-cli/) has first-class support for deploying Aspire projects. It can provision infrastructure, manage environments, and coordinate secret/value injection. You can incorporate Aspire publish artifacts into `azd` workflows or use the Azure integration (preview) directly.

## Deployment manifest

[Section titled “Deployment manifest”](#deployment-manifest)

Starting with Aspire 9.2, the [manifest format](/deployment/manifest-format/) is slowly being phased out in favor of Aspire CLI publish and deploy command support and APIs for defining publishing and deploying functionality. Earlier workflows emphasized a single “deployment manifest” generated from specialized AppHost targets. The modern approach centers on `aspire publish` + integration extensibility. The legacy manifest format is **not being evolved further**, but you can still generate it for inspection or debugging:

Generate legacy manifest

```bash
aspire publish --publisher manifest -o diagnostics/
```

This:

* Produces a manifest snapshot useful for understanding resource graphs or troubleshooting.
* Should not be treated as the primary deployment contract.
* Is provided solely for backward compatibility and debugging visibility.

## Key takeaways

[Section titled “Key takeaways”](#key-takeaways)

Publishing comes first, followed by deployment, which separates the structure from the values. The artifacts produced during publishing are parameterized, with resolution occurring later in the process. Specific integrations determine the actual behaviors of publishing and deployment, and the system is designed to be extensible, allowing you to build custom integrations that target new platforms or internal tooling. While the legacy manifest can still be generated, it remains static and is no longer evolving.

# Compiler Warning ASPIRE001

> Learn more about compiler Warning ASPIRE001. The code language isn't fully supported by Aspire - some code generation targets will not run, so will require manual authoring.

Version introduced: 8.0.0

> The ‘CODELANGUAGE’ language isn’t fully supported by Aspire - some code generation targets will not run, so will require manual authoring.

This diagnostic warning is reported when using a code language other than C#.

## To correct this warning

[Section titled “To correct this warning”](#to-correct-this-warning)

In your Aspire project, use C#.

## Suppress the warning

[Section titled “Suppress the warning”](#suppress-the-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRE001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C#

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRE001</NoWarn>
  </PropertyGroup>
  ```

# Compiler Warning ASPIRE002

> Learn more about compiler Warning ASPIRE002. Project is an Aspire AppHost project but necessary dependencies aren't present. Are you missing an Aspire.Hosting.AppHost PackageReference?

Version introduced: 8.0.0

> ‘Project’ is an Aspire AppHost project but necessary dependencies aren’t present. Are you missing an Aspire.Hosting.AppHost PackageReference?

This diagnostic warning is reported when your project is missing reference to the Aspire AppHost.

## Suppress the warning

[Section titled “Suppress the warning”](#suppress-the-warning)

Add reference to the [📦 Aspire.Hosting.AppHost](https://www.nuget.org/packages/Aspire.Hosting.AppHost) NuGet package. For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

# Compiler Warning ASPIRE003

> Learn more about compiler Warning ASPIRE003. This project requires Visual Studio version '17.10' or higher to work properly.

Version introduced: 8.0.0

> This project requires Visual Studio version ‘17.10’ or higher to work properly.

When using Visual Studio to code your Aspire project, you must have Visual Studio 2022 version 17.10 or later.

## To correct this warning

[Section titled “To correct this warning”](#to-correct-this-warning)

To develop Aspire applications, [Visual Studio 2022 version 17.10 or higher](https://visualstudio.microsoft.com/vs/) is required.

# Compiler Warning ASPIRE004

> Learn more about compiler Warning ASPIRE004. Project is referenced by an Aspire Host project, but it is not an executable.

Version introduced: 8.0.0

> The Project reference isn’t to an executable project, so won’t be launched. Did you mean to set IsAspireProjectResource=“false”?

The project being referenced by the Aspire AppHost isn’t an executable, but is being treated like one for the purposes of orchestration.

## To correct this warning

[Section titled “To correct this warning”](#to-correct-this-warning)

Either change the build type of the project to an executable, or add the `IsAspireProjectResource="false"` setting to the project reference in your Aspire AppHost project file, as demonstrated in the following snippet:

C# project file

```xml
<ItemGroup>
  <ProjectReference Include="..\OtherProjects\Contracts.csproj" IsAspireProjectResource="false" />
</ItemGroup>
```

## Suppress the warning

[Section titled “Suppress the warning”](#suppress-the-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRE004.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRE004</NoWarn>
  </PropertyGroup>
  ```

# Compiler Error ASPIRE006

> Learn more about compiler Error ASPIRE006. The resource name is invalid.

Version introduced: 8.2.2

> The resource name ‘NAME’ is invalid: CONSTRAINT

This diagnostic error is reported when a resource’s name is invalid, such as a name with consecutive hyphen (`-`) characters.

This error shouldn’t be suppressed, as invalid model names throw an exception at runtime.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIRE006`:

C# — AppHost.cs

```csharp
var bbsContainer = builder.AddContainer("bbs--server", "coldwall/mystic")
                          .WithEndpoint(19991, 23);
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Use a valid name. For more information, see [Resource naming conventions](/architecture/resource-model/#resource-basics).

# Compiler Error ASPIRE007

> Learn more about compiler Error ASPIRE007. The project is missing a required Aspire.AppHost.Sdk with a version of at least 9.0.0.

Version introduced: 9.0.0

> The project is missing a required Aspire.AppHost.Sdk with a version of at least 9.0.0. Please add the following line after the Project declaration `<Sdk Name="Aspire.AppHost.Sdk" Version="9.0.0" />`.

The Aspire AppHost package references require Aspire SDK version 9.0.0 or greater. The SDK reference is either being omitted or is using a version older than 9.0.0.

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Update the referenced SDK version to 9.0.0 or the latest.

If the SDK reference is missing from your project file, add it, as demonstrated in the following snippet:

C# project file

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <Sdk Name="Aspire.AppHost.Sdk" Version="9.0.0" />


  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsAspireHost>true</IsAspireHost>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.AppHost" Version="9.2.0" />
  </ItemGroup>


</Project>
```

# Compiler Error ASPIRE008

> Learn more about compiler Error ASPIRE008. The installed Aspire workload is deprecated. It is recommended to migrate to the new format.

Version introduced: 8.2.3

> The Aspire workload that this project depends on is now deprecated.

This error appears when a project uses a version of Aspire that relies on the SDK workload, which is now deprecated. The error guides you to migrate your project to a supported version of Aspire that uses the SDK approach instead of the workload.

## Example

[Section titled “Example”](#example)

The following AppHost project file uses the deprecated Aspire workload:

C# project file

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsAspireHost>true</IsAspireHost>
    <UserSecretsId>98048c9c-bf28-46ba-a98e-63767ee5e3a8</UserSecretsId>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.AppHost" Version="8.2.2" />
  </ItemGroup>


</Project>
```

For more information on the Aspire SDK, see [Aspire SDK](https://learn.microsoft.com/dotnet/aspire/fundamentals/dotnet-aspire-sdk/).

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Follow the migration guide at <https://aka.ms/aspire/update-to-sdk> to upgrade your project to a supported version of Aspire that uses the SDK approach.

The migration typically involves:

1. Updating your AppHost project file to use the `Aspire.AppHost.Sdk`.
2. Removing references to the deprecated workload.
3. Updating package references to supported versions.

## Suppress the error

[Section titled “Suppress the error”](#suppress-the-error)

Danger

Suppressing this error isn’t recommended, as it leaves your project depending on an unsupported version of Aspire.

If you need to temporarily suppress this error, add the following property to your project file:

C# project file

```xml
<PropertyGroup>
  <SuppressAspireWorkloadDeprecationError>true</SuppressAspireWorkloadDeprecationError>
</PropertyGroup>
```

# Compiler Error ASPIREACADOMAINS001

> Learn more about compiler Error ASPIREACADOMAINS001. ConfigureCustomDomain is for evaluation purposes only and is subject to change or removal in future updates.

Version introduced: 9.0

> ConfigureCustomDomain is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire 9.0 introduces the ability to customize container app resources using any of the following extension methods:

* `Aspire.Hosting.AzureContainerAppProjectExtensions.PublishAsAzureContainerApp`
* `Aspire.Hosting.AzureContainerAppContainerExtensions.PublishAsAzureContainerApp`
* `Aspire.Hosting.AzureContainerAppExecutableExtensions.PublishAsAzureContainerApp`

When you use one of these methods, the Azure Developer CLI (`azd`) can no longer preserve custom domains. Instead use the `Aspire.Hosting.ContainerAppExtensions.ConfigureCustomDomain` method to configure a custom domain within the Aspire AppHost.

However, `app.ConfigureCustomDomain` is an experimental API and you must suppress it to use it.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREACADOMAINS001`:

C# — AppHost.cs

```csharp
var customDomain = builder.AddParameter("customDomain");
var certificateName = builder.AddParameter("certificateName");


builder.AddProject<Projects.AzureContainerApps_ApiService>("api")
       .WithExternalHttpEndpoints()
       .PublishAsAzureContainerApp((infra, app) =>
       {
           app.ConfigureCustomDomain(customDomain, certificateName);
       });
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREACADOMAINS001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREACADOMAINS001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREACADOMAINS001` directive.

# Compiler Error ASPIREAZURE001

> Learn more about compiler Error ASPIREAZURE001. Publishers are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 9.2

> Publishers are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

The Aspire Azure hosting integration now ships with a publisher. If you’re using any of the `Aspire.Hosting.AzurePublisherExtensions.AddAzurePublisher*` APIs, you might see a compiler error/warning indicating that the API is experimental. This behavior is expected, as the API is still in preview and the shape of this API is expected to change in the future.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREAZURE001`:

C# — AppHost.cs

```csharp
builder.AddAzurePublisher();
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREAZURE001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREAZURE001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREAZURE001` directive.

# Compiler Error ASPIREAZURE002

> Learn more about compiler Error ASPIREAZURE002. Azure Container App Jobs are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 9.5

> Azure Container App Jobs are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

The Aspire Azure hosting integration now ships with support for Azure Container App Jobs. If you’re using any of the `PublishAsAzureContainerAppJob` APIs, you might see a compiler error/warning indicating that the API is experimental. This behavior is expected, as the API is still in preview and the shape of this API is expected to change in the future.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREAZURE002`:

C# — AppHost.cs

```csharp
builder.AddProject<Projects.DataProcessor>("data-processor")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Schedule;
        job.Configuration.ScheduleTriggerConfig.CronExpression = "0 0 * * *";
    });
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREAZURE002.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREAZURE002</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREAZURE002` directive.

# Compiler Warning ASPIRECERTIFICATES001

> Learn more about compiler Warning ASPIRECERTIFICATES001. Certificate configuration types and members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.1

> Certificate configuration types and members are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warning is reported when using experimental certificate configuration APIs in Aspire, including:

* `IDeveloperCertificateService` interface
* `HttpsCertificateAnnotation` class
* Certificate-related extension methods like `WithHttpsCertificate`, `WithHttpsDeveloperCertificate`, `WithoutHttpsCertificate`
* Certificate configuration builder extensions like `WithHttpsCertificateConfig` and `WithHttpsCertificateConfiguration`

These APIs enable configuring HTTPS/TLS server certificates for resources in your Aspire application, including support for custom certificates and developer certificates for local development scenarios.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIRECERTIFICATES001`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Using developer certificate
builder.AddViteApp("frontend")
    .WithHttpsDeveloperCertificate();


// Using a custom certificate
var certificate = new X509Certificate2("path/to/certificate.pfx", "password");
builder.AddYarp("gateway")
    .WithHttpsCertificate(certificate);


// Disabling HTTPS certificate configuration
builder.AddRedis("cache")
    .WithoutHttpsCertificate();


// Using IDeveloperCertificateService
var developerCertService = builder.Services
    .BuildServiceProvider()
    .GetRequiredService<IDeveloperCertificateService>();
```

## Understanding certificate configuration

[Section titled “Understanding certificate configuration”](#understanding-certificate-configuration)

Aspire 13.1 introduced TLS termination support APIs that allow you to configure HTTPS certificates for resources that need to terminate TLS connections. Several containers have built-in TLS termination support:

| Container         | Default |
| ----------------- | ------- |
| YARP              | Enabled |
| Redis             | Enabled |
| Keycloak          | Enabled |
| Uvicorn (Python)  | Enabled |
| Vite (JavaScript) | Opt-in  |

When TLS is enabled by default, the ASP.NET Core developer certificate is automatically used if available and trusted.

### Developer certificate configuration

[Section titled “Developer certificate configuration”](#developer-certificate-configuration)

The `IDeveloperCertificateService` provides information about developer certificates:

* **`Certificates`** — List of valid development certificates available for trust
* **`SupportsContainerTrust`** — Indicates if certificates support container domains like `host.docker.internal`
* **`UseForHttps`** — Indicates if developer certificates should be used for TLS termination by default
* **`TrustCertificate`** — Indicates if certificates should be trusted at runtime by default

## To suppress this warning

[Section titled “To suppress this warning”](#to-suppress-this-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRECERTIFICATES001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRECERTIFICATES001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIRECERTIFICATES001` directive:

  C# — Suppressing the warning

  ```csharp
  #pragma warning disable ASPIRECERTIFICATES001
  var developerCertService = builder.Services
      .BuildServiceProvider()
      .GetRequiredService<IDeveloperCertificateService>();
  #pragma warning restore ASPIRECERTIFICATES001
  ```

## See also

[Section titled “See also”](#see-also)

* [Certificate configuration](/app-host/certificate-configuration/)
* [What’s new in Aspire 13.1 - Certificates and security](/whats-new/aspire-13-1/#-certificates-and-security)

# Compiler Error ASPIRECOMPUTE001

> Learn more about compiler Error ASPIRECOMPUTE001. Compute related types and members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 9.3

> Compute related types and members are for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIRECOMPUTE001`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddDockerComposeEnvironment("env");
// or
builder.AddAzureContainerAppEnvironment("env")
// or
builder.AddKubernetesEnvironment("env")
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRECOMPUTE001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRECOMPUTE001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIRECOMPUTE001` directive.

# Compiler Warning ASPIRECOMPUTE002

> Learn more about compiler Warning ASPIRECOMPUTE002. The GetHostAddressExpression method is for evaluation purposes only and is subject to change or removal in future updates.

Version introduced: 13.0

> The `GetHostAddressExpression` method is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warning is reported when using the experimental `GetHostAddressExpression` method from the `IComputeEnvironmentResource` interface.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIRECOMPUTE002`:

C# — Using GetHostAddressExpression

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var computeEnv = builder.AddAzureContainerAppEnvironment("env");


// Accessing GetHostAddressExpression on a compute environment resource
var endpoint = computeEnv.Resource.GetEndpoint("http");
var hostAddress = computeEnv.Resource.GetHostAddressExpression(endpoint);
```

## Understanding GetHostAddressExpression

[Section titled “Understanding GetHostAddressExpression”](#understanding-gethostaddressexpression)

The `GetHostAddressExpression` method is part of the `IComputeEnvironmentResource` interface and provides a way to retrieve the host address or hostname for a specified endpoint reference as a `ReferenceExpression`.

### Key characteristics

[Section titled “Key characteristics”](#key-characteristics)

* **Returns host only** — The returned value contains only the hostname or address, without scheme, port, or path information
* **Reference expression** — Returns a `ReferenceExpression` that can be evaluated in different contexts
* **Compute environment specific** — Designed for use with compute environment resources like Azure Container Apps, Kubernetes, or Docker Compose

This method is useful when you need to configure resources with just the hostname rather than a full URL, which is common in scenarios like:

* Configuring service-to-service communication within a compute environment
* Setting up DNS-based service discovery
* Configuring load balancers or ingress controllers

## To suppress this warning

[Section titled “To suppress this warning”](#to-suppress-this-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRECOMPUTE002.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRECOMPUTE002</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIRECOMPUTE002` directive:

  C# — Suppressing the warning

  ```csharp
  var builder = DistributedApplication.CreateBuilder(args);


  var computeEnv = builder.AddAzureContainerAppEnvironment("env");


  #pragma warning disable ASPIRECOMPUTE002
  var endpoint = computeEnv.Resource.GetEndpoint("http");
  var hostAddress = computeEnv.Resource.GetHostAddressExpression(endpoint);
  #pragma warning restore ASPIRECOMPUTE002
  ```

## See also

[Section titled “See also”](#see-also)

* [ASPIRECOMPUTE001](/diagnostics/aspirecompute001/) — Compute environment resource creation
* [ASPIRECOMPUTE003](/diagnostics/aspirecompute003/) — Container registry resources

# Compiler Warning ASPIRECOMPUTE003

> Learn more about compiler Warning ASPIRECOMPUTE003. The ContainerRegistryResource type is for evaluation purposes only and is subject to change or removal in future updates.

Version introduced: 13.1

> The `ContainerRegistryResource` type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warning is reported when using the experimental `ContainerRegistryResource` class and related container registry functionality.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIRECOMPUTE003`:

C# — Using ContainerRegistryResource

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a container registry with literal values
var registry = builder.AddContainerRegistry("docker-hub", "docker.io", "myusername");


var api = builder.AddProject<Projects.Api>("api")
    .WithContainerRegistry(registry);
```

C# — Using ContainerRegistryResource with parameters

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a container registry with parameterized values
var endpointParameter = builder.AddParameter("registry-endpoint");
var repositoryParameter = builder.AddParameter("registry-repo");


var registry = builder.AddContainerRegistry("my-registry", endpointParameter, repositoryParameter);


var api = builder.AddProject<Projects.Api>("api")
    .WithContainerRegistry(registry);
```

## Understanding container registry resources

[Section titled “Understanding container registry resources”](#understanding-container-registry-resources)

The `ContainerRegistryResource` represents a general-purpose container registry that can be referenced in your Aspire application model. It enables integration with:

* **Docker Hub** — Public or private Docker Hub repositories
* **GitHub Container Registry** — GitHub’s container registry (ghcr.io)
* **Azure Container Registry** — Azure’s managed container registry service
* **Private registries** — Self-hosted or third-party container registries

### Key features

[Section titled “Key features”](#key-features)

**Flexible configuration**

* Use literal strings for static registry configuration
* Use `ParameterResource` values for dynamic configuration
* Specify optional repository paths within the registry

**Integration with deployment pipelines**

* Automatic `Push` and `PushPrereq` steps for container registry operations
* Seamless integration with container image builds
* Support for authentication and credentials

**Resource builder pattern**

* Follows Aspire’s resource builder pattern for consistency
* Can be referenced by other resources using `WithContainerRegistry`
* Supports chaining with other resource configuration methods

## To suppress this warning

[Section titled “To suppress this warning”](#to-suppress-this-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRECOMPUTE003.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRECOMPUTE003</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIRECOMPUTE003` directive:

  C# — Suppressing the warning

  ```csharp
  var builder = DistributedApplication.CreateBuilder(args);


  #pragma warning disable ASPIRECOMPUTE003
  var registry = builder.AddContainerRegistry("docker-hub", "docker.io", "myusername");
  #pragma warning restore ASPIRECOMPUTE003


  var api = builder.AddProject<Projects.Api>("api")
      .WithContainerRegistry(registry);
  ```

## See also

[Section titled “See also”](#see-also)

* [ASPIRECOMPUTE001](/diagnostics/aspirecompute001/) — Compute environment resource creation
* [ASPIRECOMPUTE002](/diagnostics/aspirecompute002/) — Host address expression method
* [What’s new in Aspire 13.1 - Container registry support](/whats-new/aspire-13-1/#container-registry-resource)

# ASPIRECONTAINERRUNTIME001

> Diagnostic for experimental container runtime APIs

Version introduced: 13.1

> Type is for evaluation purposes only and is subject to change or removal in future updates

This diagnostic warns when using the experimental `IContainerRuntime` interface and related container runtime implementations. These APIs provide abstraction over container runtimes like Docker and Podman for building, tagging, pushing, and managing container images during deployment.

### Example generating diagnostic

[Section titled “Example generating diagnostic”](#example-generating-diagnostic)

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Using IContainerRuntime
var containerRuntime = builder.Services.BuildServiceProvider().GetRequiredService<IContainerRuntime>();
var isRunning = await containerRuntime.CheckIfRunningAsync(cancellationToken);
var runtimeName = containerRuntime.Name;
```

The diagnostic is triggered because `IContainerRuntime` is marked with the `[Experimental("ASPIRECONTAINERRUNTIME001")]` attribute.

## Understanding the diagnostic

[Section titled “Understanding the diagnostic”](#understanding-the-diagnostic)

The `IContainerRuntime` interface provides a unified abstraction for interacting with container runtimes:

* **Runtime detection**: Check if Docker or Podman is running and available
* **Image building**: Build container images from Dockerfiles with build arguments and secrets
* **Image management**: Tag, push, and remove container images
* **Registry operations**: Login to container registries for authentication

This API is experimental because the container runtime abstraction layer is being refined based on deployment scenario requirements, and the interface may evolve to support additional container runtime features or optimizations.

### Related types

[Section titled “Related types”](#related-types)

* **`IContainerRuntime`**: Interface representing a container runtime (Docker, Podman)
* **`DockerContainerRuntime`**: Implementation for Docker runtime
* **`PodmanContainerRuntime`**: Implementation for Podman runtime
* **`CheckIfRunningAsync()`**: Verifies if the container runtime is available
* **`BuildImageAsync()`**: Builds a container image from a Dockerfile
* **`TagImageAsync()`**: Tags a container image with a new name
* **`PushImageAsync()`**: Pushes a container image to a registry
* **`RemoveImageAsync()`**: Removes a container image
* **`LoginToRegistryAsync()`**: Authenticates with a container registry

## Suppressing the diagnostic

[Section titled “Suppressing the diagnostic”](#suppressing-the-diagnostic)

The diagnostic can be suppressed using one of several methods:

### Suppressing in .editorconfig

[Section titled “Suppressing in .editorconfig”](#suppressing-in-editorconfig)

.editorconfig

```ini
[*.cs]
dotnet_diagnostic.ASPIRECONTAINERRUNTIME001.severity = none
```

### Suppressing in a project file

[Section titled “Suppressing in a project file”](#suppressing-in-a-project-file)

YourProject.csproj

```xml
<PropertyGroup>
  <NoWarn>$(NoWarn);ASPIRECONTAINERRUNTIME001</NoWarn>
</PropertyGroup>
```

### Suppressing in source code

[Section titled “Suppressing in source code”](#suppressing-in-source-code)

```csharp
#pragma warning disable ASPIRECONTAINERRUNTIME001
var containerRuntime = builder.Services.BuildServiceProvider().GetRequiredService<IContainerRuntime>();
var isRunning = await containerRuntime.CheckIfRunningAsync(cancellationToken);
#pragma warning restore ASPIRECONTAINERRUNTIME001
```

# Compiler Error ASPIRECOSMOSDB001

> Learn more about compiler Error ASPIRECOSMOSDB001. `RunAsPreviewEmulator` is for evaluation purposes only and is subject to change or removal in future updates.

Version introduced: 9.0

> `RunAsPreviewEmulator` is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

—or—

> `WithDataExplorer` is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

Both `RunAsPreviewEmulator` and `WithDataExplorer` are considered experimental APIs.

Aspire provides a way to use the Cosmos DB Linux-based (preview) emulator and data explorer. These APIs are considered experimental and are expected to change in the future.

## Example

[Section titled “Example”](#example)

The following sample generates `ASPIRECOSMOSDB001`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos")
                    .RunAsPreviewEmulator(e => e.WithDataExplorer());
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the Error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRECOSMOSDB001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRECOSMOSDB001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIRECOSMOSDB001` directive.

# Compiler Error ASPIRECSHARPAPPS001

> Learn more about compiler Error ASPIRECSHARPAPPS001. `AddCSharpApp` is for evaluation purposes only and is subject to change or removal in future updates.

Version introduced: 13.0

> `AddCSharpApp` is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire provides a way to add C# app resources to the Aspire AppHost with the `AddCSharpApp` extension. This allows you to reference C# file-based app files (.cs), project files (.csproj), or project directories (directories containing a .csproj file) directly without needing a `ProjectReference` from the AppHost project to the C# application. Since the shape of this API is expected to change in the future, it’s experimental.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIRECSHARPAPPS001`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


builder.AddCSharpApp("worker", "../worker/Program.cs")
    .WithReference(cache);


builder.Build().Run();
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIRECSHARPAPPS001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIRECSHARPAPPS001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIRECSHARPAPPS001` directive.

# Compiler Warning ASPIREDOCKERFILEBUILDER001

> Learn more about compiler Warning ASPIREDOCKERFILEBUILDER001. Dockerfile builder types and members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.0

> Dockerfile builder types and members are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warning is reported when using experimental Dockerfile builder APIs in Aspire, specifically the `DockerfileBuilderCallbackContext` class and related programmatic Dockerfile generation functionality.

These APIs enable programmatic creation of Dockerfiles at build time, allowing dynamic generation of container images based on application configuration and requirements.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREDOCKERFILEBUILDER001`:

C# — Using DockerfileBuilderCallbackContext

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("my-service", "base-image")
    .WithDockerfile(ctx =>
    {
        // ctx is of type DockerfileBuilderCallbackContext
        ctx.Builder
            .From("node:20-alpine")
            .WorkDir("/app")
            .Copy("package*.json", "./")
            .Run("npm install")
            .Copy(".", ".")
            .Cmd("node", "index.js");
    });
```

## Understanding Dockerfile builder callbacks

[Section titled “Understanding Dockerfile builder callbacks”](#understanding-dockerfile-builder-callbacks)

The `DockerfileBuilderCallbackContext` provides context information for Dockerfile build callbacks, enabling dynamic Dockerfile generation. This is useful when:

* You need to generate Dockerfiles programmatically based on application state
* Different build configurations require different Dockerfile instructions
* You want to keep Dockerfile logic close to your application model definition

### Key properties

[Section titled “Key properties”](#key-properties)

**`Resource`**

* The resource being built (implements `IResource`)
* Provides access to resource metadata and configuration

**`Builder`**

* The `DockerfileBuilder` instance used to construct the Dockerfile
* Provides a fluent API for adding Dockerfile instructions

**`Services`**

* The service provider for dependency injection
* Allows access to other services during Dockerfile generation

**`CancellationToken`**

* Token to observe for cancellation requests
* Enables cooperative cancellation of long-running operations

## To suppress this warning

[Section titled “To suppress this warning”](#to-suppress-this-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREDOCKERFILEBUILDER001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREDOCKERFILEBUILDER001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREDOCKERFILEBUILDER001` directive:

  C# — Suppressing the warning

  ```csharp
  var builder = DistributedApplication.CreateBuilder(args);


  #pragma warning disable ASPIREDOCKERFILEBUILDER001
  builder.AddContainer("my-service", "base-image")
      .WithDockerfile(ctx =>
      {
          // Dockerfile building logic
      });
  #pragma warning restore ASPIREDOCKERFILEBUILDER001
  ```

# Compiler Warning ASPIREFILESYSTEM001

> Learn more about compiler Warning ASPIREFILESYSTEM001. File system service types and members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.1

> File system service types and members are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warning is reported when using experimental file system service APIs in Aspire, including:

* `IFileSystemService` interface
* `ITempFileSystemService` interface
* `TempDirectory` class
* `TempFile` class

These APIs provide a centralized way to manage temporary directories and files used by Aspire, improving testability and consistency across the platform.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREFILESYSTEM001`:

C# — Using IFileSystemService

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var fileSystemService = builder.Services
    .BuildServiceProvider()
    .GetRequiredService<IFileSystemService>();


// Create a temporary subdirectory
using var tempDir = fileSystemService.TempDirectory.CreateTempSubdirectory("aspire");
Console.WriteLine($"Temp directory: {tempDir.Path}");


// Create a temporary file
using var tempFile = fileSystemService.TempDirectory.CreateTempFile("config.json");
Console.WriteLine($"Temp file: {tempFile.Path}");
```

## Understanding the file system service

[Section titled “Understanding the file system service”](#understanding-the-file-system-service)

The `IFileSystemService` provides a standardized interface for managing temporary files and directories in Aspire. This abstraction enables:

* **Consistent temp file management** — Centralized handling of temporary resources
* **Automatic cleanup** — Disposable patterns ensure resources are cleaned up properly
* **Testability** — Easier to mock and test file system operations
* **Named files** — Ability to create temp files with specific names

### Key interfaces and classes

[Section titled “Key interfaces and classes”](#key-interfaces-and-classes)

**`IFileSystemService`**

* Main service interface providing access to temporary directory operations
* Access via `TempDirectory` property

**`ITempFileSystemService`**

* Provides methods for creating temporary subdirectories and files
* `CreateTempSubdirectory(string? prefix)` — Creates a temp subdirectory
* `CreateTempFile(string? fileName)` — Creates a temp file

**`TempDirectory`**

* Represents a temporary directory that is automatically deleted when disposed
* `Path` property provides the full path to the directory

**`TempFile`**

* Represents a temporary file that is automatically deleted when disposed
* `Path` property provides the full path to the file

## To suppress this warning

[Section titled “To suppress this warning”](#to-suppress-this-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREFILESYSTEM001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREFILESYSTEM001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREFILESYSTEM001` directive:

  C# — Suppressing the warning

  ```csharp
  #pragma warning disable ASPIREFILESYSTEM001
  var fileSystemService = builder.Services
      .BuildServiceProvider()
      .GetRequiredService<IFileSystemService>();
  #pragma warning restore ASPIREFILESYSTEM001
  ```

# Compiler Error ASPIREHOSTINGPYTHON001

> Learn more about compiler Error ASPIREHOSTINGPYTHON001. `AddPythonApp` is for evaluation purposes only and is subject to change or removal in future updates.

Version introduced: 9.0

> `AddPythonApp` is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire provides a way to add Python executables or applications to the Aspire AppHost with the `AddPythonApp` extension. Since the shape of this API is expected to change in the future, it’s experimental.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREHOSTINGPYTHON001`:

C# — AppHost.cs

```csharp
var pythonApp = builder.AddPythonApp("hello-python", "../hello-python", "main.py")
       .WithHttpEndpoint(env: "PORT")
       .WithExternalHttpEndpoints()
       .WithOtlpExporter();
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREHOSTINGPYTHON001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREHOSTINGPYTHON001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREHOSTINGPYTHON001` directive.

# Compiler Warning ASPIREINTERACTION001

> Learn more about compiler Warning ASPIREINTERACTION001. Interaction service types and members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.0

> Interaction service types and members are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warns when using the experimental `IInteractionService` interface and related interaction APIs. These APIs provide the ability to prompt users for input, request confirmation, and display messages in the Aspire dashboard or CLI during publish and deploy operations.

### Example generating diagnostic

[Section titled “Example generating diagnostic”](#example-generating-diagnostic)

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Using IInteractionService from an IServiceProvider instance
var interactionService = serviceProvider.GetRequiredService<IInteractionService>();
if (interactionService.IsAvailable)
{
    var result = await interactionService.PromptConfirmationAsync(
        title: "Confirmation",
        message: "Are you sure you want to proceed?");
}
```

The diagnostic is triggered because `IInteractionService` is marked with the `[Experimental("ASPIREINTERACTION001")]` attribute.

## Understanding the diagnostic

[Section titled “Understanding the diagnostic”](#understanding-the-diagnostic)

The `IInteractionService` interface provides user interaction functionality for Aspire applications:

* **Message display**: Show dialogs and notifications in the dashboard
* **User confirmation**: Request confirmation before destructive operations
* **Input collection**: Prompt users for single or multiple input values
* **Context awareness**: Works in both dashboard UI and CLI contexts

This API is experimental because the interaction patterns and API surface may evolve based on usage patterns and feedback from deployment scenarios.

### Related types

[Section titled “Related types”](#related-types)

* **`IInteractionService`**: Interface for prompting users and displaying messages
* **`InteractionInput`**: Defines input fields for user prompts
* **`InputType`**: Enum for input field types (Text, SecretText, Choice, Boolean, Number)
* **`InputLoadOptions`**: Configuration for dynamic input loading
* **`MessageBoxInteractionOptions`**: Options for message box dialogs
* **`NotificationInteractionOptions`**: Options for notification messages
* **`PromptMessageBoxAsync()`**: Displays a modal dialog box
* **`PromptNotificationAsync()`**: Displays a non-modal notification
* **`PromptConfirmationAsync()`**: Prompts for user confirmation
* **`PromptInputAsync()`**: Prompts for a single input value
* **`PromptInputsAsync()`**: Prompts for multiple input values

## Suppressing the diagnostic

[Section titled “Suppressing the diagnostic”](#suppressing-the-diagnostic)

The diagnostic can be suppressed using one of several methods:

### Suppressing in .editorconfig

[Section titled “Suppressing in .editorconfig”](#suppressing-in-editorconfig)

.editorconfig

```ini
[*.{cs,vb}]
dotnet_diagnostic.ASPIREINTERACTION001.severity = none
```

### Suppressing in a project file

[Section titled “Suppressing in a project file”](#suppressing-in-a-project-file)

YourProject.csproj

```xml
<PropertyGroup>
  <NoWarn>$(NoWarn);ASPIREINTERACTION001</NoWarn>
</PropertyGroup>
```

### Suppressing in source code

[Section titled “Suppressing in source code”](#suppressing-in-source-code)

```csharp
#pragma warning disable ASPIREINTERACTION001
var interactionService = serviceProvider.GetRequiredService<IInteractionService>();
var result = await interactionService.PromptConfirmationAsync(
    title: "Confirmation",
    message: "Are you sure?");
#pragma warning restore ASPIREINTERACTION001
```

## See also

[Section titled “See also”](#see-also)

* [Interaction service (Preview)](/extensibility/interaction-service/)

# Compiler Error ASPIREPIPELINES001

> Learn more about compiler Error ASPIREPIPELINES001. Pipeline infrastructure APIs are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.0

> Pipeline infrastructure APIs are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire introduced pipeline infrastructure APIs starting in version 9.2. These APIs provide core functionality for building deployment pipelines, including interfaces and types for pipeline activity reporting, step management, and publishing contexts. Pipeline infrastructure enables you to create custom deployment workflows and track their execution.

Pipeline infrastructure APIs are considered experimental and are expected to change in future updates.

## APIs affected

[Section titled “APIs affected”](#apis-affected)

This diagnostic applies to the following pipeline infrastructure APIs:

* `IPipelineActivityReporter` - Interface for reporting pipeline activities
* `IReportingStep` - Interface for managing pipeline steps
* `IReportingTask` - Interface for managing tasks within a step
* `CompletionState` - Enumeration for tracking completion status
* `PublishingContext` - Context for publishing operations
* `PublishingCallbackAnnotation` - Annotation for publishing callbacks
* Related extension methods and implementations

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with one of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREPIPELINES001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREPIPELINES001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREPIPELINES001` directive.

# Compiler Error ASPIREPIPELINES002

> Learn more about compiler Error ASPIREPIPELINES002. Deployment state manager APIs are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.0

> Deployment state manager APIs are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire introduced deployment state manager APIs as part of the pipeline infrastructure starting in version 13.0. These APIs enable you to manage and persist deployment state information across pipeline executions. The deployment state manager provides functionality for storing, retrieving, and clearing deployment artifacts and metadata, which is essential for incremental deployments and tracking deployment history.

Deployment state manager APIs are considered experimental and are expected to change in future updates.

## APIs affected

[Section titled “APIs affected”](#apis-affected)

This diagnostic applies to the following deployment state manager APIs:

* `IDeploymentStateManager` - Interface for managing deployment state
* Deployment state manager implementations
* `Deploy` property in `PublishingOptions`
* `ClearCache` property in `PublishingOptions`
* `Step` property in `PublishingOptions`
* `DeployingCallbackAnnotation` - Annotation for deploying callbacks
* Azure provisioning context providers
* Related extension methods and implementations

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with one of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREPIPELINES002.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREPIPELINES002</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREPIPELINES002` directive.

# Compiler Error ASPIREPIPELINES003

> Learn more about compiler Error ASPIREPIPELINES003. Container image build APIs are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 13.0

> Container image build APIs are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire introduced container image build APIs as part of the pipeline infrastructure starting in version 13.0. These APIs provide functionality for building container images as part of the deployment pipeline. The container image build APIs enable you to configure build options, specify target platforms, select image formats, and integrate with container runtimes like Docker and Podman.

Container image build APIs are considered experimental and are expected to change in future updates.

## APIs affected

[Section titled “APIs affected”](#apis-affected)

This diagnostic applies to the following container image build APIs:

* `IResourceContainerImageBuilder` - Interface for building container images
* `ContainerBuildOptions` - Options for configuring container builds
* `ContainerImageFormat` - Enumeration for specifying image format
* `ContainerTargetPlatform` - Type for specifying target platform
* `ContainerTargetPlatformExtensions` - Extension methods for platform configuration
* Docker and Podman container runtime implementations
* Related extension methods and implementations

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with one of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREPIPELINES003.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREPIPELINES003</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREPIPELINES003` directive.

# ASPIREPIPELINES004

> Diagnostic for experimental pipeline output service APIs

Version introduced: 13.1

> Type is for evaluation purposes only and is subject to change or removal in future updates

This diagnostic warns when using the experimental `IPipelineOutputService` interface and the `PipelineOutputService` implementation. These APIs are part of the Aspire pipeline infrastructure for managing output and temporary directories during deployment operations.

### Example generating diagnostic

[Section titled “Example generating diagnostic”](#example-generating-diagnostic)

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Using IPipelineOutputService
var outputService = builder.Services.BuildServiceProvider().GetRequiredService<IPipelineOutputService>();
var outputDir = outputService.GetOutputDirectory();
var tempDir = outputService.GetTempDirectory();
```

The diagnostic is triggered because `IPipelineOutputService` is marked with the `[Experimental("ASPIREPIPELINES004")]` attribute.

## Understanding the diagnostic

[Section titled “Understanding the diagnostic”](#understanding-the-diagnostic)

The `IPipelineOutputService` interface provides directory management functionality for Aspire deployment pipelines:

* **Output directories**: Manages the location where deployment artifacts are written
* **Temporary directories**: Provides isolated temporary storage for build operations
* **Resource-specific paths**: Creates subdirectories for individual resources

This API is experimental because the pipeline infrastructure is under active development, and the directory management strategy may evolve based on deployment scenario requirements.

### Related types

[Section titled “Related types”](#related-types)

* **`IPipelineOutputService`**: Service for managing pipeline output and temporary directories
* **`PipelineOutputService`**: Default implementation managing configured and default paths
* **`GetOutputDirectory()`**: Gets the base output directory for deployment artifacts
* **`GetOutputDirectory(IResource)`**: Gets a resource-specific output subdirectory
* **`GetTempDirectory()`**: Gets the base temporary directory for build artifacts
* **`GetTempDirectory(IResource)`**: Gets a resource-specific temporary subdirectory

## Suppressing the diagnostic

[Section titled “Suppressing the diagnostic”](#suppressing-the-diagnostic)

The diagnostic can be suppressed using one of several methods:

### Suppressing in .editorconfig

[Section titled “Suppressing in .editorconfig”](#suppressing-in-editorconfig)

.editorconfig

```ini
[*.cs]
dotnet_diagnostic.ASPIREPIPELINES004.severity = none
```

### Suppressing in a project file

[Section titled “Suppressing in a project file”](#suppressing-in-a-project-file)

YourProject.csproj

```xml
<PropertyGroup>
  <NoWarn>$(NoWarn);ASPIREPIPELINES004</NoWarn>
</PropertyGroup>
```

### Suppressing in source code

[Section titled “Suppressing in source code”](#suppressing-in-source-code)

```csharp
#pragma warning disable ASPIREPIPELINES004
var outputService = builder.Services.BuildServiceProvider().GetRequiredService<IPipelineOutputService>();
var outputDir = outputService.GetOutputDirectory();
#pragma warning restore ASPIREPIPELINES004
```

# Compiler Warning ASPIREPROBES001

> Learn more about compiler Warning ASPIREPROBES001. Probe-related types and members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 9.5

> Probe-related types and members are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

This diagnostic warning is reported when using experimental health probe APIs in Aspire, including:

* `IResourceWithProbes` interface
* `ProbeAnnotation` class and derived types
* `ProbeType` enumeration
* `WithHttpProbe` extension methods
* `EndpointProbeAnnotation` class

These APIs enable configuring HTTP health probes for resources to monitor startup, readiness, and liveness states, similar to Kubernetes health check concepts.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREPROBES001`:

C# — Using HTTP probes

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add readiness probe to ensure service is ready before routing traffic
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpProbe(ProbeType.Readiness, "/health/ready");


// Add liveness probe to detect if service needs restart
var worker = builder.AddProject<Projects.Worker>("worker")
    .WithHttpProbe(ProbeType.Liveness, "/health/live");


// Multiple probe types on one resource
var service = builder.AddProject<Projects.Service>("service")
    .WithHttpProbe(ProbeType.Startup, "/health/startup",
        initialDelaySeconds: 15, failureThreshold: 10)
    .WithHttpProbe(ProbeType.Readiness, "/health/ready",
        periodSeconds: 5, timeoutSeconds: 3)
    .WithHttpProbe(ProbeType.Liveness, "/health/live",
        periodSeconds: 30, failureThreshold: 3);


builder.Build().Run();
```

## Understanding health probes

[Section titled “Understanding health probes”](#understanding-health-probes)

Health probes allow you to configure monitoring for your resources’ health state. Aspire supports three types of probes that align with Kubernetes health check concepts:

### Probe types

[Section titled “Probe types”](#probe-types)

**`ProbeType.Startup`**

* Determines when the application has started successfully
* Runs during container startup before readiness or liveness probes begin
* Useful for applications with long initialization times
* Typically has higher failure thresholds to allow for startup time

**`ProbeType.Readiness`**

* Determines when the resource is ready to receive traffic
* If the probe fails, traffic is not routed to the resource
* Useful for checking dependencies like database connectivity
* Can temporarily fail without restarting the container

**`ProbeType.Liveness`**

* Detects if the service is still functioning properly
* If the probe fails repeatedly, the resource may be restarted
* Useful for detecting deadlocks or unrecoverable errors
* Should check core application health

### Probe configuration

[Section titled “Probe configuration”](#probe-configuration)

**`path`** — The HTTP path to probe (default: ”/”)

**`initialDelaySeconds`** — Delay before the first probe execution (default: 5)

**`periodSeconds`** — Interval between probe executions (default: 5)

**`timeoutSeconds`** — Seconds after which the probe times out (default: 1)

**`failureThreshold`** — Consecutive failures before marking as failed (default: 3)

**`successThreshold`** — Consecutive successes needed to mark as successful after failure (default: 1)

**`endpointName`** — Specific endpoint to probe (optional)

### Custom endpoint targeting

[Section titled “Custom endpoint targeting”](#custom-endpoint-targeting)

C# — Probe specific endpoint

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Probe specific endpoint by name
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpEndpoint(8080, name: "management")
    .WithHttpProbe(ProbeType.Readiness, "/actuator/health",
        endpointName: "management");


// Probe with endpoint selector function
var service = builder.AddProject<Projects.Service>("service")
    .WithHttpProbe(ProbeType.Liveness, "/status",
        endpointSelector: () => service.GetEndpoint("https"));


builder.Build().Run();
```

### Integration with resource dependencies

[Section titled “Integration with resource dependencies”](#integration-with-resource-dependencies)

Probes work seamlessly with resource wait dependencies:

C# — Probes with dependencies

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var database = builder.AddPostgres("postgres");
var cache = builder.AddRedis("redis");


// API with probes that check dependencies
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpProbe(ProbeType.Readiness, "/health/ready")
    .WaitFor(database)
    .WaitFor(cache)
    .WithReference(database)
    .WithReference(cache);


// Frontend waits for API to be ready (not just started)
var frontend = builder.AddProject<Projects.Frontend>("frontend")
    .WaitFor(api)  // Waits for API readiness probe to pass
    .WithReference(api);


builder.Build().Run();
```

## Deployment integration

[Section titled “Deployment integration”](#deployment-integration)

Probes are automatically configured when deploying to supported compute environments:

* **Azure Container Apps** — Probes are translated to Container Apps health probes
* **Kubernetes** — Probes are mapped to Kubernetes liveness, readiness, and startup probes
* **Docker Compose** — Health checks are configured based on probe settings

## To suppress this warning

[Section titled “To suppress this warning”](#to-suppress-this-warning)

Suppress the warning with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREPROBES001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREPROBES001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREPROBES001` directive:

  C# — Suppressing the warning

  ```csharp
  var builder = DistributedApplication.CreateBuilder(args);


  #pragma warning disable ASPIREPROBES001
  var api = builder.AddProject<Projects.Api>("api")
      .WithHttpProbe(ProbeType.Readiness, "/health/ready")
      .WithHttpProbe(ProbeType.Liveness, "/health/live");
  #pragma warning restore ASPIREPROBES001


  builder.Build().Run();
  ```

# Compiler Error ASPIREPROXYENDPOINTS001

> Learn more about compiler Error ASPIREPROXYENDPOINTS001. Members are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 9.1

> `WithEndpointProxySupport` is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

-or-

> `ProxySupportAnnotation` is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.

Both `WithEndpointProxySupport` and `ProxySupportAnnotation` are considered experimental APIs.

Container resources use proxied endpoints by default. Adjusting this setting is experimental.

## Example

[Section titled “Example”](#example)

The following code generates `ASPIREPROXYENDPOINTS001`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis($"example-redis", 1234)
                   .WithEndpointProxySupport(false);
```

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREPROXYENDPOINTS001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREPROXYENDPOINTS001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREPROXYENDPOINTS001` directive.

# Compiler Error ASPIREPUBLISHERS001

> Learn more about compiler Error ASPIREPUBLISHERS001. Publishers are for evaluation purposes only and are subject to change or removal in future updates.

Version introduced: 9.2

> Publishers are for evaluation purposes only and are subject to change or removal in future updates. Suppress this diagnostic to proceed.

Aspire introduced the concept of *Publishers* starting in version 9.2. Publishers play a pivotal role in the deployment process, enabling the transformation of your distributed app into deployable assets. This alleviates the intermediate step of producing the publishing [manifest](/architecture/resource-publishing/) for tools to act on, instead empowering the developer to express their intent directly in C#.

Publishers are considered experimental and are expected to change in the future.

## To correct this error

[Section titled “To correct this error”](#to-correct-this-error)

Suppress the error with either of the following methods:

* Set the severity of the rule in the *.editorconfig* file.

  .editorconfig

  ```ini
  [*.{cs,vb}]
  dotnet_diagnostic.ASPIREPUBLISHERS001.severity = none
  ```

  For more information about editor config files, see [Configuration files for code analysis rules](/diagnostics/overview/#suppress-in-the-editorconfig-file).

* Add the following `PropertyGroup` to your project file:

  C# project file

  ```xml
  <PropertyGroup>
      <NoWarn>$(NoWarn);ASPIREPUBLISHERS001</NoWarn>
  </PropertyGroup>
  ```

* Suppress in code with the `#pragma warning disable ASPIREPUBLISHERS001` directive.

# ASPIREUSERSECRETS001

> Diagnostic for experimental user secrets manager APIs

Version introduced: 13.1

> Type is for evaluation purposes only and is subject to change or removal in future updates

This diagnostic warns when using the experimental `IUserSecretsManager` interface and related user secrets management APIs. These APIs provide centralized management of user secrets for Aspire applications, enabling secure storage and retrieval of sensitive configuration values.

### Example generating diagnostic

[Section titled “Example generating diagnostic”](#example-generating-diagnostic)

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Using IUserSecretsManager
var userSecretsManager = builder.UserSecretsManager;
var filePath = userSecretsManager.FilePath;
bool success = userSecretsManager.TrySetSecret("MySecret", "SecretValue");
```

The diagnostic is triggered because `IUserSecretsManager` is marked with the `[Experimental("ASPIREUSERSECRETS001")]` attribute.

## Understanding the diagnostic

[Section titled “Understanding the diagnostic”](#understanding-the-diagnostic)

The `IUserSecretsManager` interface provides user secrets management functionality for Aspire:

* **Secret storage**: Save sensitive values like API keys and passwords outside source control
* **Secret retrieval**: Read secrets from the user secrets file
* **Configuration integration**: Automatically populate configuration from secrets
* **State management**: Support for saving deployment state to user secrets

This API is experimental because the user secrets management strategy is being refined based on security requirements and usage patterns, and the interface may evolve to support additional secret management scenarios.

### Related types

[Section titled “Related types”](#related-types)

* **`IUserSecretsManager`**: Interface for managing user secrets
* **`UserSecretsManager`**: Default implementation managing secrets file operations
* **`UserSecretsManagerFactory`**: Factory for creating and caching manager instances
* **`FilePath`**: Gets the path to the user secrets JSON file
* **`TrySetSecret()`**: Attempts to set a secret value in user secrets
* **`GetOrSetSecret()`**: Gets a secret from configuration or generates and saves a new value
* **`SaveStateAsync()`**: Saves deployment state to user secrets asynchronously

## Suppressing the diagnostic

[Section titled “Suppressing the diagnostic”](#suppressing-the-diagnostic)

The diagnostic can be suppressed using one of several methods:

### Suppressing in .editorconfig

[Section titled “Suppressing in .editorconfig”](#suppressing-in-editorconfig)

.editorconfig

```ini
[*.cs]
dotnet_diagnostic.ASPIREUSERSECRETS001.severity = none
```

### Suppressing in a project file

[Section titled “Suppressing in a project file”](#suppressing-in-a-project-file)

YourProject.csproj

```xml
<PropertyGroup>
  <NoWarn>$(NoWarn);ASPIREUSERSECRETS001</NoWarn>
</PropertyGroup>
```

### Suppressing in source code

[Section titled “Suppressing in source code”](#suppressing-in-source-code)

```csharp
#pragma warning disable ASPIREUSERSECRETS001
var userSecretsManager = builder.UserSecretsManager;
bool success = userSecretsManager.TrySetSecret("MySecret", "SecretValue");
#pragma warning restore ASPIREUSERSECRETS001
```

# Diagnostics overview

> Learn about the diagnostics tools and features available in Aspire.

The following table lists the possible MSBuild and analyzer warnings and errors you might encounter with Aspire:

| Diagnostic ID                                                          | Type                   | Description                                                                                                                                 |
| ---------------------------------------------------------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| [ASPIRE001](/diagnostics/aspire001/)                                   | Warning                | The code language isn’t fully supported by Aspire, some code generation targets will not run.                                               |
| [ASPIRE002](/diagnostics/aspire002/)                                   | Warning                | Project is an Aspire AppHost project but necessary dependencies aren’t present. Are you missing an Aspire.Hosting.AppHost PackageReference? |
| [ASPIRE003](/diagnostics/aspire003/)                                   | Warning                | ’Project’ is an Aspire AppHost project that requires Visual Studio version 17.10 or above to work correctly.                                |
| [ASPIRE004](/diagnostics/aspire004/)                                   | Warning                | ’Project’ is referenced by an Aspire Host project, but it is not an executable.                                                             |
| [ASPIRE006](/diagnostics/aspire006/)                                   | (Experimental) Error   | Application model items must have valid names.                                                                                              |
| [ASPIRE007](/diagnostics/aspire007/)                                   | Error                  | ’Project’ requires a reference to “Aspire.AppHost.Sdk” with version “9.0.0” or greater to work correctly.                                   |
| [ASPIRE008](/diagnostics/aspire008/)                                   | Error                  | The Aspire workload that this project depends on is now deprecated.                                                                         |
| [ASPIREACADOMAINS001](/diagnostics/aspireacadomains001/)               | (Experimental) Error   | `ConfigureCustomDomain` is for evaluation purposes only and is subject to change or removal in future updates.                              |
| [ASPIREAZURE001](/diagnostics/aspireazure001/)                         | (Experimental) Error   | Publishers are for evaluation purposes only and are subject to change or removal in future updates.                                         |
| [ASPIREAZURE002](/diagnostics/aspireazure002/)                         | (Experimental) Error   | Azure Container App Jobs are for evaluation purposes only and are subject to change or removal in future updates.                           |
| [ASPIRECERTIFICATES001](/diagnostics/aspirecertificates001/)           | (Experimental) Warning | Certificate configuration types and members are for evaluation purposes only and are subject to change or removal in future updates.        |
| [ASPIRECOMPUTE001](/diagnostics/aspirecompute001/)                     | (Experimental) Error   | Compute related types and members are for evaluation purposes only and is subject to change or removal in future updates.                   |
| [ASPIRECOMPUTE002](/diagnostics/aspirecompute002/)                     | (Experimental) Warning | The GetHostAddressExpression method is for evaluation purposes only and is subject to change or removal in future updates.                  |
| [ASPIRECOMPUTE003](/diagnostics/aspirecompute003/)                     | (Experimental) Warning | The ContainerRegistryResource type is for evaluation purposes only and is subject to change or removal in future updates.                   |
| [ASPIRECONTAINERRUNTIME001](/diagnostics/aspirecontainerruntime001/)   | (Experimental) Warning | Type is for evaluation purposes only and is subject to change or removal in future updates.                                                 |
| [ASPIRECSHARPAPPS001](/diagnostics/aspirecsharpapps001/)               | (Experimental) Error   | `AddCSharpApp` is for evaluation purposes only and is subject to change or removal in future updates.                                       |
| [ASPIRECOSMOSDB001](/diagnostics/aspirecosmosdb001/)                   | (Experimental) Error   | `RunAsPreviewEmulator` is for evaluation purposes only and is subject to change or removal in future updates.                               |
| [ASPIREDOCKERFILEBUILDER001](/diagnostics/aspiredockerfilebuilder001/) | (Experimental) Warning | Dockerfile builder types and members are for evaluation purposes only and are subject to change or removal in future updates.               |
| [ASPIREFILESYSTEM001](/diagnostics/aspirefilesystem001/)               | (Experimental) Warning | File system service types and members are for evaluation purposes only and are subject to change or removal in future updates.              |
| [ASPIREINTERACTION001](/diagnostics/aspireinteraction001/)             | (Experimental) Warning | Interaction service types and members are for evaluation purposes only and are subject to change or removal in future updates.              |
| [ASPIREPIPELINES004](/diagnostics/aspirepipelines004/)                 | (Experimental) Warning | Type is for evaluation purposes only and is subject to change or removal in future updates.                                                 |
| [ASPIREPROBES001](/diagnostics/aspireprobes001/)                       | (Experimental) Warning | Probe-related types and members are for evaluation purposes only and are subject to change or removal in future updates.                    |
| [ASPIREUSERSECRETS001](/diagnostics/aspireusersecrets001/)             | (Experimental) Warning | Type is for evaluation purposes only and is subject to change or removal in future updates.                                                 |
| [ASPIREHOSTINGPYTHON001](/diagnostics/aspirehostingpython001/)         | (Experimental) Error   | `AddPythonApp` is for evaluation purposes only and is subject to change or removal in future updates.                                       |
| [ASPIREPIPELINES001](/diagnostics/aspirepipelines001/)                 | (Experimental) Error   | Pipeline infrastructure APIs are for evaluation purposes only and are subject to change or removal in future updates.                       |
| [ASPIREPIPELINES002](/diagnostics/aspirepipelines002/)                 | (Experimental) Error   | Deployment state manager APIs are for evaluation purposes only and are subject to change or removal in future updates.                      |
| [ASPIREPIPELINES003](/diagnostics/aspirepipelines003/)                 | (Experimental) Error   | Container image build APIs are for evaluation purposes only and are subject to change or removal in future updates.                         |
| [ASPIREPROXYENDPOINTS001](/diagnostics/aspireproxyendpoints001/)       | (Experimental) Error   | ProxyEndpoint members are for evaluation purposes only and are subject to change or removal in future updates.                              |
| [ASPIREPUBLISHERS001](/diagnostics/aspirepublishers001/)               | Error                  | Publishers are for evaluation purposes only and are subject to change or removal in future updates.                                         |

## Suppress diagnostic

[Section titled “Suppress diagnostic”](#suppress-diagnostic)

You can suppress any diagnostic in this document using one of the following methods:

* Add the `System.Diagnostics.CodeAnalysis.SuppressMessageAttribute` at the assembly, class, method, line, etc.
* Include the diagnostic ID in the `NoWarn` property of your project file.
* Use preprocessor directives in your code.
* Configure diagnostic severity in an *.editorconfig* file.

There are some common patterns for suppressing diagnostics in .NET projects. The best method depends on your context and the specific diagnostic. Here’s a quick guide to help you choose:

Important

The following sections provide examples for suppressing the `ASPIREE000` diagnostic, which is a placeholder for any diagnostic ID you might encounter. Replace `ASPIREE000` with the actual diagnostic ID you want to suppress.

### Suppress with the suppress message attribute

[Section titled “Suppress with the suppress message attribute”](#suppress-with-the-suppress-message-attribute)

The `System.Diagnostics.CodeAnalysis.SuppressMessageAttribute` is ideal when you need targeted, documented suppression tied directly to a specific code element like a class or method. It shines when you’re making a deliberate exception to a rule that is valid in most other places. This attribute keeps the suppression close to the code it affects, which helps reviewers and future maintainers understand the rationale. While it’s a clean solution for isolated cases, it can clutter the code if overused, and it’s not the best choice for widespread or bulk suppressions.

**When to use:**

* For a specific method, class, or property where you want to document why the rule is being bypassed.
* When the suppression is localized and unlikely to apply elsewhere.

**Example:**

C# — AppHost.cs

```csharp
using System.Diagnostics.CodeAnalysis;


[assembly: SuppressMessage("Aspire", "ASPIREE000",
    Justification = "This is a valid reason for suppression.")]
```

### Suppress in the project file

[Section titled “Suppress in the project file”](#suppress-in-the-project-file)

Adding the diagnostic ID to the `NoWarn` property in your *.csproj* file is a straightforward, project-wide approach that doesn’t clutter the code itself. This method is particularly useful when a diagnostic doesn’t apply to your specific project scenario or when you want a blanket suppression across multiple files. However, it can be risky if used too liberally, as it can hide legitimate issues from team members or future maintainers. It’s best reserved for situations where you’re confident the diagnostic is irrelevant to the entire project or when a team has collectively agreed on the suppression.

**When to use:**

* When the diagnostic applies to the entire project and you’re confident it’s not relevant.
* For build-level warnings that don’t need per-file or per-method suppression.

**Example:**

C# project file

```xml
<PropertyGroup>
    <NoWarn>$(NoWarn);ASPIREE000</NoWarn>
</PropertyGroup>
```

### Suppress with preprocessor directives

[Section titled “Suppress with preprocessor directives”](#suppress-with-preprocessor-directives)

Preprocessor directives like `#pragma warning disable` provide pinpoint control over which specific lines of code are affected by the suppression. This makes them the most precise option when you want to temporarily mute a diagnostic for a small, well-defined section of code, such as a tricky workaround or legacy code. While their precision is a strength, it can also become a burden if the suppressions are scattered throughout a file. Additionally, they make the code slightly less readable due to the added directives, so they’re best used sparingly for short-lived or highly specific issues.

**When to use:**

* For a few lines of code in a method or block.
* When you need fine-grained control over exactly which code is suppressed.

**Example:**

C# — AppHost.cs

```csharp
#pragma warning disable ASPIREE000
// Code that triggers the diagnostic
#pragma warning restore ASPIREE000
```

### Suppress in the *.editorconfig* file

[Section titled “Suppress in the .editorconfig file”](#suppress-in-the-editorconfig-file)

An *.editorconfig* file is the most flexible and team-friendly way to manage diagnostic severity across your codebase. It allows you to suppress or adjust diagnostics for specific directories, file types, or even individual files, making it highly scalable for large projects. This approach keeps suppressions centralized and transparent, which is especially valuable in team environments where consistent code standards matter. It’s also ideal when you need to adjust the severity of a diagnostic (for example, turning an error into a warning) rather than suppressing it entirely. The downside is that it requires creating or modifying a separate configuration file, which might feel like overkill for very small projects or one-off suppressions.

**When to use:**

* For managing suppressions or severity levels across multiple files or directories.
* When you want a centralized, team-level policy for diagnostics.
* When you need to adjust the diagnostic severity instead of completely disabling it.

**Example:**

.editorconfig

```ini
[*.{cs,vb}]
dotnet_diagnostic.ASPIREE000.severity = none
```

For more information about editor config files, see [Configuration files for code analysis rules](https://learn.microsoft.com/dotnet/fundamentals/code-analysis/configuration-files).

# Welcome to Aspire

> Learn how Aspire simplifies the development, deployment, and debugging of distributed applications.

## Get started

[Section titled “Get started”](#get-started)

Use the following steps to get started with Aspire:

1. [Check prerequisites](/get-started/prerequisites/): Ensure you have the required tools and SDKs installed.
2. [Install the Aspire CLI](/get-started/install-cli/): Get the Aspire tooling set up on your development machine.
3. [Build your first app](/get-started/first-app/): Follow our quickstart guide to create your first Aspire application.
4. [Deploy your app](/get-started/deploy-first-app/): Learn how to deploy your Aspire resources.

## Explore key concepts

[Section titled “Explore key concepts”](#explore-key-concepts)

Ready to build distributed applications with confidence? Aspire streamlines your development workflow, making complex multi-service architectures simple to create, deploy, and debug.

What is Aspire?

Discover why Aspire is the fastest way to build production-ready cloud applications—unified tooling that eliminates complexity.

[Aspire explained](/get-started/what-is-aspire/)

The AppHost

Define your entire app architecture in code. No YAML, no configuration drift—just C# that describes everything from services to dependencies.

[See how it works](/get-started/app-host/)

Understanding resources

Stop writing boilerplate connection strings and configurations. Aspire resources automatically wire up services, databases, and cloud integrations.

[Learn resource modeling](/get-started/resources/)

Deployment & app topology

Deploy anywhere with confidence. Your local dev setup automatically translates to Kubernetes, Azure, or any cloud—no manual manifest writing.

[Deploy all the things](/get-started/pipelines/)

# Interaction service (Preview)

> Use the interaction service API to prompt users for input, request confirmation, and display messages in the Aspire dashboard or CLI during publish and deploy.

The interaction service (`Aspire.Hosting.IInteractionService`) allows you to prompt users for input, request confirmation, and display messages. The interaction service works in two different contexts:

* **Aspire dashboard**: When running `aspire run` or launching the AppHost directly, interactions appear as dialogs and notifications in the dashboard UI.
* **Aspire CLI**: When running `aspire publish` or `aspire deploy`, interactions are prompted through the command-line interface.

This is useful for scenarios where you need to gather information from the user or provide feedback on the status of operations, regardless of how the application is being launched or deployed.

## The `IInteractionService` API

[Section titled “The IInteractionService API”](#the-iinteractionservice-api)

The `IInteractionService` interface is retrieved from the `DistributedApplication` dependency injection container. `IInteractionService` can be injected into types created from DI or resolved from `IServiceProvider`, which is usually available on a context argument passed to events.

When you request `IInteractionService`, be sure to check if it’s available for usage. If you attempt to use the interaction service when it’s not available (`IInteractionService.IsAvailable` returns `false`), an exception is thrown.

```csharp
var interactionService = serviceProvider.GetRequiredService<IInteractionService>();
if (interactionService.IsAvailable)
{
    var result = await interactionService.PromptConfirmationAsync(
        title: "Delete confirmation",
        message: "Are you sure you want to delete the data?");


    if (result.Data)
    {
        // Run your resource/command logic.
    }
}
```

The interaction service has several methods that you use to interact with users or display messages. The behavior of these methods depends on the execution context:

* **Dashboard context** (`aspire run` or direct AppHost launch): Interactions appear as modal dialogs, notifications, and form inputs in the [Aspire dashboard web interface](/dashboard/overview/).
* **CLI context** (`aspire publish` or `aspire deploy`): Interactions are prompted through the command-line interface with text-based prompts and responses.

The following sections describe how to use these APIs effectively in both contexts:

| Method                    | Description                                                                                      | Contexts supported |
| ------------------------- | ------------------------------------------------------------------------------------------------ | ------------------ |
| `PromptMessageBoxAsync`   | Displays a modal dialog box with a message and buttons for user interaction.                     | Dashboard only     |
| `PromptNotificationAsync` | Displays a non-modal notification in the dashboard as a message bar.                             | Dashboard only     |
| `PromptConfirmationAsync` | Displays a confirmation dialog with options for the user to confirm or cancel an action.         | Dashboard only     |
| `PromptInputAsync`        | Prompts the user for a single input value, such as text or secret.                               | Dashboard, CLI     |
| `PromptInputsAsync`       | Prompts the user for multiple input values in a single dialog (dashboard) or sequentially (CLI). | Dashboard, CLI     |

Caution

During `aspire publish` and `aspire deploy` operations, only `PromptInputAsync` and `PromptInputsAsync` are available. Other interaction methods (`PromptMessageBoxAsync`, `PromptNotificationAsync`, and `PromptConfirmationAsync`) will throw an exception if called in CLI contexts.

## Where to use the interaction service

[Section titled “Where to use the interaction service”](#where-to-use-the-interaction-service)

Any of the available callback-based extension methods of `IResourceBuilder<T>` can use the interaction service to prompt users for input or confirmation. Use the interaction service in these scenarios:

* **Custom resource types**: Gather input from users or confirm actions when you create custom resource types. Resource types are free to define dashboard interactions, such as prompting for user input or displaying messages.

* **Custom resource commands**: Add commands to resources in the Aspire dashboard or CLI. Use the interaction service to prompt users for input or confirmation when these commands run. When you chain a call to `WithCommand` on a target `IResourceBuilder<T>`, your callback can use the interaction service to gather input or confirm actions. For more information, see [Custom resource commands](/fundamentals/custom-resource-commands/).

* **Publish and deploy workflows**: During `aspire publish` or `aspire deploy` operations, use the interaction service to gather deployment-specific configuration and confirm destructive operations through the CLI.

These approaches help you create interactive, user-friendly experiences for local development, dashboard interactions, and deployment workflows.

Tip

This article demonstrates the interaction service in the context of a `WithCommand` callback with a `FakeResource` type, but the same principles apply to other extension methods that support user interactions.

For example:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddFakeResource("fake-resource")
       .WithCommand("msg-dialog", "Example Message Dialog", async context =>
{
    var interactionService = context.ServiceProvider.GetRequiredService<IInteractionService>();


    // Use interaction service...


    return CommandResults.Success();
});
```

For CLI specific contexts, the interaction service is retrieved from either the `PublishingContext` or `PipelineStepContext` depending on the operation being performed.

## Display messages

[Section titled “Display messages”](#display-messages)

There are several ways to display messages to the user:

* **Dialog messages**: Show important information in a dialog box.
* **Notification messages**: Display less critical information in a notification.

Note

Message display methods (`PromptMessageBoxAsync` and `PromptNotificationAsync`) are only available in dashboard contexts. These methods throw an exception if called during `aspire publish` or `aspire deploy` operations.

### Display a dialog message box

[Section titled “Display a dialog message box”](#display-a-dialog-message-box)

Dialog messages provide important information that requires user attention.

The `IInteractionService.PromptMessageBoxAsync` method displays a message with customizable response options.

AppHost.cs

```csharp
var interactionService = context.ServiceProvider.GetRequiredService<IInteractionService>();
var result = await interactionService.PromptMessageBoxAsync(
    "Simple Message Box: Example",
    """
    ##### 🤓 Nice!


    It's worth noting that **Markdown** is _supported_
    (and demonstrated here) in the message body.


    Cool, [📖 learn more](https://learn.microsoft.com/dotnet/aspire/extensibility/interaction-service)...
    """,
    new MessageBoxInteractionOptions
    {
        EnableMessageMarkdown = true,
        PrimaryButtonText = "Awesome"
    }
);


if (result.Canceled)
{
    return CommandResults.Failure("User cancelled.");
}


return result.Data
    ? CommandResults.Success()
    : CommandResults.Failure("The user doesn't like the example");
```

**Dashboard view:**

![Aspire dashboard interface showing a message dialog with a title, message, and buttons.](/_astro/interaction-service-message-dialog.CqL5zwsR_ZozTCU.webp)

**CLI view:**

The `PromptMessageBoxAsync` method only works in the dashboard context. If you call it during `aspire publish` or `aspire deploy`, the method throws an exception and doesn’t display a message in the CLI.

### Display a notification message

[Section titled “Display a notification message”](#display-a-notification-message)

Notification messages provide non-modal notifications.

Tip

In the dashboard, notification messages appear stacked at the top, so you can show several messages at once. You can display notifications one after another by awaiting each dismissal before showing the next. Or, you can display multiple notifications at the same time without waiting for each to be dismissed.

The `PromptNotificationAsync` method displays informational messages with optional action links in the dashboard context. You don’t have to await the result of a notification message if you don’t need to. This is especially useful for notifications, since you might want to display a notification and continue without waiting for user to dismiss it.

AppHost.cs

```csharp
var interactionService = context.ServiceProvider.GetRequiredService<IInteractionService>();
// Demonstrating various notification types with different intents
var tasks = new List<Task>
{
    interactionService.PromptNotificationAsync(
        title: "Confirmation",
        message: "Are you sure you want to proceed?",
        options: new NotificationInteractionOptions
        {
            Intent = MessageIntent.Confirmation
        }),
    interactionService.PromptNotificationAsync(
        title: "Success",
        message: "Your operation completed successfully.",
        options: new NotificationInteractionOptions
        {
            Intent = MessageIntent.Success,
            LinkText = "View Details",
            LinkUrl = "https://learn.microsoft.com/dotnet/aspire/success"
        }),
    interactionService.PromptNotificationAsync(
        title: "Warning",
        message: "Your SSL certificate will expire soon.",
        options: new NotificationInteractionOptions
        {
            Intent = MessageIntent.Warning,
            LinkText = "Renew Certificate",
            LinkUrl = "https://portal.azure.com/certificates"
        }),
    interactionService.PromptNotificationAsync(
        title: "Information",
        message: "There is an update available for your application.",
        options: new NotificationInteractionOptions
        {
            Intent = MessageIntent.Information,
            LinkText = "Update Now",
            LinkUrl = "https://learn.microsoft.com/dotnet/aspire"
        }),
    interactionService.PromptNotificationAsync(
        title: "Error",
        message: "An error occurred while processing your request.",
        options: new NotificationInteractionOptions
        {
            Intent = MessageIntent.Error,
            LinkText = "Troubleshoot",
            LinkUrl = "https://learn.microsoft.com/dotnet/aspire/troubleshoot"
        })
};


await Task.WhenAll(tasks);


return CommandResults.Success();
```

The previous example demonstrates several ways to use the notification API. Each approach displays different types of notifications, all of which are invoked in parallel and displayed in the dashboard around the same time.

**Dashboard view:**

![Aspire dashboard interface showing multiple notification messages stacked near the top of the page. There are five notifications displayed, each with a different type of notification.](/_astro/interaction-service-message-bar.xH0MqOiU_1RxCxR.webp)

**CLI view:**

The `PromptNotificationAsync` method isn’t available in CLI contexts. If you call it during `aspire publish` or `aspire deploy`, it throws an exception.

## Prompt for user confirmation

[Section titled “Prompt for user confirmation”](#prompt-for-user-confirmation)

Use the interaction service when you need the user to confirm an action before proceeding. The `PromptConfirmationAsync` method displays a confirmation prompt in the dashboard context. Confirmation prompts are essential for destructive operations or actions that have significant consequences. They help prevent accidental actions and give users a chance to reconsider their decisions.

### Prompt for confirmation before destructive operations

[Section titled “Prompt for confirmation before destructive operations”](#prompt-for-confirmation-before-destructive-operations)

For operations that can’t be undone, such as deleting resources, always prompt for confirmation:

AppHost.cs

```csharp
var interactionService = context.ServiceProvider.GetRequiredService<IInteractionService>();
// Prompt for confirmation before resetting database
var resetConfirmation = await interactionService.PromptConfirmationAsync(
    title: "Confirm Reset",
    message: "Are you sure you want to reset the `development-database`? This action **cannot** be undone.",
    options: new MessageBoxInteractionOptions
    {
        Intent = MessageIntent.Confirmation,
        PrimaryButtonText = "Reset",
        SecondaryButtonText = "Cancel",
        ShowSecondaryButton = true,
        EnableMessageMarkdown = true
    });


if (resetConfirmation.Data is true)
{
    // Perform the reset operation...


    return CommandResults.Success();
}
else
{
    return CommandResults.Failure("Database reset canceled by user.");
}
```

**Dashboard view:**

![Aspire dashboard interface showing a confirmation dialog with a title, message, and buttons for confirming or canceling the operation.](/_astro/interaction-service-confirmation.D7ZckGyI_Z1vcqCW.webp)

**CLI view:**

The `PromptConfirmationAsync` method isn’t available in CLI contexts. If you call it during `aspire publish` or `aspire deploy`, the method throws an exception.

## Prompt for user input

[Section titled “Prompt for user input”](#prompt-for-user-input)

The interaction service API allows you to prompt users for input in various ways. You can collect single values or multiple values, with support for different input types including text, secrets, choices, booleans, and numbers. The presentation adapts automatically to the execution context.

| Type         | Dashboard                 | CLI prompt            |
| ------------ | ------------------------- | --------------------- |
| `Text`       | Textbox                   | Text prompt           |
| `SecretText` | Textbox with masked input | Masked text prompt    |
| `Choice`     | Dropdown box of options   | Choice prompt         |
| `Boolean`    | Checkbox                  | Boolean choice prompt |
| `Number`     | Number textbox            | Text prompt           |

### Prompt the user for input values

[Section titled “Prompt the user for input values”](#prompt-the-user-for-input-values)

You can prompt for a single value using the `PromptInputAsync` method, or collect multiple pieces of information with `PromptInputsAsync`. In the dashboard, multiple inputs appear together in a single dialog. In the CLI, each input is requested one after another.

Caution

It’s possible to create wizard-like flows using the interaction service. By chaining multiple prompts together—handling the results from one prompt before moving to the next—you can guide users through a series of related questions, making it easier to collect all the necessary information.

Consider the following example, which prompts the user for multiple input values:

AppHost.cs

```csharp
var interactionService = context.ServiceProvider.GetRequiredService<IInteractionService>();
var loggerService = context.ServiceProvider.GetRequiredService<ResourceLoggerService>();
var logger = loggerService.GetLogger(fakeResource);


var inputs = new List<InteractionInput>
{
    new()
    {
        Name = "Application Name",
        InputType = InputType.Text,
        Required = true,
        Placeholder = "my-app"
    },
    new()
    {
        Name = "Environment",
        InputType = InputType.Choice,
        Required = true,
        Options =
        [
            new("dev", "Development"),
            new("staging", "Staging"),
            new("test", "Testing")
        ]
    },
    new()
    {
        Name = "Instance Count",
        InputType = InputType.Number,
        Required = true,
        Placeholder = "1"
    },
    new()
    {
        Name = "Enable Monitoring",
        InputType = InputType.Boolean,
        Required = false
    }
};


var appConfigurationInput = await interactionService.PromptInputsAsync(
    title: "Application Configuration",
    message: "Configure your application deployment settings:",
    inputs: inputs);


if (!appConfigurationInput.Canceled)
{
    // Process the collected input values
    var appName = appConfigurationInput.Data[0].Value;
    var environment = appConfigurationInput.Data[1].Value;
    var instanceCount = int.Parse(appConfigurationInput.Data[2].Value ?? "1");
    var enableMonitoring = bool.Parse(appConfigurationInput.Data[3].Value ?? "false");


    logger.LogInformation("""
        Application Name: {AppName}
        Environment: {Environment}
        Instance Count: {InstanceCount}
        Monitoring Enabled: {EnableMonitoring}
        """,
        appName, environment, instanceCount, enableMonitoring);


    // Use the collected values as needed
    return CommandResults.Success();
}
else
{
    return CommandResults.Failure("User canceled application configuration input.");
}
```

**Dashboard view:**

This renders on the dashboard as shown in the following image:

![Aspire dashboard interface showing a multiple input dialog with labels, input fields, and buttons for confirming or canceling the input.](/_astro/interaction-service-multiple-input.ChPUbUjX_9IjYB.webp)

Imagine you fill out the dialog with the following values:

![Aspire dashboard interface showing a multiple input dialog with filled input fields and buttons for confirming or canceling the input.](/_astro/interaction-service-multiple-input-filled.D6kbxHXN_dJxh2.webp)

After you select the **Ok** button, the resource logs display the following output:

![Aspire dashboard interface showing logs with the input values entered in the multiple input dialog.](/_astro/interaction-service-multiple-input-logs.BGity84-_1HYdjW.webp)

**CLI view:**

In the CLI context, the same inputs are requested sequentially:

```plaintext
aspire deploy


Step 1: Analyzing model.


       ✓ DONE: Analyzing the distributed application model for publishing and deployment capabilities. 00:00:00
       Found 1 resources that support deployment. (FakeResource)


✅ COMPLETED: Analyzing model. completed successfully


══════════════════════════════════════════════════════════════════════════════════════════════════════════════
Configure your application deployment settings:
Application Name: example-app
Environment:  Staging
Instance Count: 3
Enable Monitoring: [y/n] (n): y
✓ DEPLOY COMPLETED: Deploying completed successfully
```

Depending on the input type, the CLI might display additional prompts. For example, the `Enable Monitoring` input is a boolean choice, so the CLI prompts for a yes/no response. If you enter `y`, it enables monitoring; if you enter `n`, it disables monitoring. For the environment input, the CLI displays a list of available environments for selection:

```plaintext
Configure your application deployment settings:
Application Name: example-app
Environment:


> Development
  Staging
  Testing


(Type to search)
```

#### Load input options dynamically

[Section titled “Load input options dynamically”](#load-input-options-dynamically)

The interaction service supports dynamic inputs so you can populate options based on earlier responses. This enables cascading dropdowns and other dependent prompts in both the dashboard and CLI experiences.

To configure a dynamic input, set the `InteractionInput.DynamicLoading` property to an instance of `InputLoadOptions`. `InputLoadOptions` has a range of properties:

* **LoadCallback**: A callback function that populates or refreshes the input options. This function is invoked when the input needs to be loaded or refreshed. You can access the current values of other inputs through the `context.AllInputs` dictionary.
* **DependsOnInputs**: A list of input names that the dynamic input depends on. When any of these inputs change, the `LoadCallback` is triggered to refresh the options for the dynamic input. If no dependencies are specified then the callback is triggered when the interaction starts.
* **AlwaysLoadOnStart**: If set to `true`, the `LoadCallback` is always called when the interaction starts, even if the dynamic input has dependencies.

```csharp
var inputs = new List<InteractionInput>
{
    new()
    {
        Name = "DatabaseType",
        InputType = InputType.Choice,
        Label = "Database Type",
        Required = true,
        Options =
        [
            KeyValuePair.Create("postgres", "PostgreSQL"),
            KeyValuePair.Create("mysql", "MySQL"),
            KeyValuePair.Create("sqlserver", "SQL Server")
        ]
    },


    new()
    {
        Name = "DatabaseVersion",
        InputType = InputType.Choice,
        Label = "Database Version",
        Required = true,
        DynamicLoading = new InputLoadOptions
        {
            LoadCallback = async context =>
            {
                var dbType = context.AllInputs["DatabaseType"].Value;
                context.Input.Options = await GetAvailableVersionsAsync(dbType);
            },
            DependsOnInputs = ["DatabaseType"]
        }
    }
};


var result = await interactionService.PromptInputsAsync(
    title: "Database configuration",
    message: "Select a database type and version",
    inputs: inputs);


if (!result.Canceled)
{
    var version = result.Data["DatabaseVersion"].Value;
    // Use version-specific configuration...
}
```

In the preceding example, the `DatabaseVersion` input is dynamically populated based on the selected `DatabaseType`.

#### Input validation

[Section titled “Input validation”](#input-validation)

Basic input validation is available by configuring `InteractionInput`. It provides options for requiring a value, or the maximum text length of `Text` or `SecretText` fields.

For complex scenarios, you can provide custom validation logic using the `InputsDialogInteractionOptions.ValidationCallback` property:

```csharp
// Multiple inputs with custom validation
var databaseInputs = new List<InteractionInput>
{
    new()
    {
        Name = "Database Name",
        InputType = InputType.Text,
        Required = true,
        Placeholder = "myapp-db"
    },
    new()
    {
        Name = "Username",
        InputType = InputType.Text,
        Required = true,
        Placeholder = "admin"
    },
    new()
    {
        Name = "Password",
        InputType = InputType.SecretText,
        Required = true,
        Placeholder = "Enter a strong password"
    },
    new()
    {
        Name = "Confirm password",
        InputType = InputType.SecretText,
        Required = true,
        Placeholder = "Confirm your password"
    }
};


var validationOptions = new InputsDialogInteractionOptions
{
    ValidationCallback = async context =>
    {
        var passwordInput = context.Inputs.FirstOrDefault(i => i.Label == "Password");
        var confirmPasswordInput = context.Inputs.FirstOrDefault(i => i.Label == "Confirm password");


        // Validate password strength
        if (passwordInput?.Value is { Length: < 8 })
        {
            context.AddValidationError(passwordInput, "Password must be at least 8 characters long");
        }


        // Validate password confirmation
        if (passwordInput?.Value != confirmPasswordInput?.Value)
        {
            context.AddValidationError(confirmPasswordInput!, "Passwords do not match");
        }


        await Task.CompletedTask;
    }
};


var dbResult = await interactionService.PromptInputsAsync(
    title: "Database configuration",
    message: "Configure your PostgreSQL database connection:",
    inputs: databaseInputs,
    options: validationOptions);


if (!dbResult.Canceled && dbResult.Data != null)
{
    // Use the validated configuration
}
```

Prompting the user for a password and confirming they match is referred to as “dual independent verification” input. This approach is common in scenarios where you want to ensure the user enters the same password twice to avoid typos or mismatches.

### Best practices for user input

[Section titled “Best practices for user input”](#best-practices-for-user-input)

When prompting for user input, consider these best practices:

1. **Group related inputs**: Use multiple input prompts to collect related configuration values. In the dashboard, these appear in a single dialog; in the CLI, they’re requested sequentially but grouped conceptually.
2. **Provide clear labels and placeholders**: Help users understand what information is expected, regardless of context.
3. **Use appropriate input types**: Choose the right input type for the data you’re collecting (secret for passwords, choice for predefined options, etc.). Both contexts support these input types appropriately.
4. **Implement validation**: Validate user input and provide clear error messages when validation fails. Both contexts support validation feedback.
5. **Make required fields clear**: Mark required fields and provide appropriate defaults for optional ones.
6. **Handle cancellation**: Always check if the user canceled the input prompt and handle it gracefully. Users can cancel in both dashboard and CLI contexts.

## Interaction contexts

[Section titled “Interaction contexts”](#interaction-contexts)

The interaction service behaves differently depending on how your Aspire solution is launched:

### Dashboard context

[Section titled “Dashboard context”](#dashboard-context)

When you run your application using `aspire run` or by directly launching the AppHost project, interactions appear in the Aspire dashboard web interface:

* **Modal dialogs**: Message boxes and input prompts appear as overlay dialogs that require user interaction.
* **Notification messages**: Informational messages appear as dismissible banners at the top of the dashboard.
* **Rich UI**: Full support for interactive form elements, validation, and visual feedback.
* **All methods available**: All interaction service methods are supported in dashboard contexts.

### CLI context

[Section titled “CLI context”](#cli-context)

When you run `aspire publish` or `aspire deploy`, interactions are prompted through the command-line interface:

* **Text prompts**: Only input prompts (`PromptInputAsync` and `PromptInputsAsync`) are available and appear as text-based prompts in the terminal.
* **Sequential input**: Multiple inputs are requested one at a time rather than in a single dialog.
* **Limited functionality**: Message boxes, notifications, and confirmation dialogs aren’t available and throws exceptions if called.

Caution

The interaction service adapts automatically to dashboard and CLI contexts. In CLI mode, only input-related methods—`PromptInputAsync` and `PromptInputsAsync`—are supported. Calling `PromptMessageBoxAsync`, `PromptNotificationAsync`, or `PromptConfirmationAsync` in CLI operations like `aspire publish` or `aspire deploy` results in an exception.

# Resource annotations

> Learn about annotations in Aspire, how they work, and how to create custom annotations for extending resource behavior.

Annotations are a key extensibility mechanism in Aspire that allow you to attach metadata and behavior to resources. They provide a way to customize how resources are configured, deployed, and managed throughout the application lifecycle. This article explains how annotations work and how to use them effectively in your Aspire applications.

## What are annotations

[Section titled “What are annotations”](#what-are-annotations)

Annotations in Aspire are objects that implement the `IResourceAnnotation` interface. They’re attached to resources to provide additional metadata, configuration, or behavior. Annotations are consumed by various parts of the Aspire stack, including:

* The dashboard for displaying custom URLs and commands.
* Deployment tools for generating infrastructure as code.
* The hosting layer for configuring runtime behavior.
* Testing infrastructure for resource inspection.

Every annotation is associated with a specific resource and can contain any data or behavior needed to extend that resource’s functionality.

## How annotations work

[Section titled “How annotations work”](#how-annotations-work)

When you add a resource to your app model, you can attach annotations using various extension methods. These annotations are stored with the resource and can be retrieved and processed by different components of the system.

Here’s a simple example of how annotations are used:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis("cache")
    .WithCommand("clear-cache", "Clear Cache",
        async context => new ExecuteCommandResult { Success = true })
    .WithUrl("admin", "http://localhost:8080/admin");


builder.Build().Run();
```

In this example:

* `WithCommand` adds a `ResourceCommandAnnotation` that defines a custom command.
* `WithUrl` adds a `ResourceUrlAnnotation` that defines a custom URL.

## Built-in annotation types

[Section titled “Built-in annotation types”](#built-in-annotation-types)

Aspire includes many built-in annotation types for common scenarios. This section covers *some* of the more commonly used annotations, but there are many more available for specific use cases.

### `EndpointAnnotation`

[Section titled “EndpointAnnotation”](#endpointannotation)

The `EndpointAnnotation` defines network endpoints for resources. It contains information about ports, protocols, and endpoint configuration.

AppHost.cs

```csharp
var api = builder.AddProject<Projects.Api>("api")
    .WithEndpoint(callback: endpoint =>
    {
        endpoint.Port = 5000;
        endpoint.IsExternal = true;
        endpoint.Protocol = Protocol.Tcp;
        endpoint.Transport = "http";
    });
```

### `ResourceUrlAnnotation`

[Section titled “ResourceUrlAnnotation”](#resourceurlannotation)

The `ResourceUrlAnnotation` defines custom URLs that appear in the dashboard, often pointing to management interfaces or documentation.

AppHost.cs

```csharp
var database = builder.AddPostgres("postgres")
    .WithUrl("admin", "https://localhost:5050");
```

### `EnvironmentCallbackAnnotation`

[Section titled “EnvironmentCallbackAnnotation”](#environmentcallbackannotation)

The `EnvironmentCallbackAnnotation` allows you to modify environment variables at runtime based on the state of other resources.

AppHost.cs

```csharp
// This is typically used internally by WithReference
var app = builder.AddProject<Projects.MyApp>("app")
    .WithReference(database);
```

### `ContainerMountAnnotation`

[Section titled “ContainerMountAnnotation”](#containermountannotation)

The `ContainerMountAnnotation` defines volume mounts for containerized resources.

AppHost.cs

```csharp
var postgres = builder.AddPostgres("postgres")
    .WithDataVolume(); // Adds a ContainerMountAnnotation
```

### `PublishingCallbackAnnotation`

[Section titled “PublishingCallbackAnnotation”](#publishingcallbackannotation)

The `PublishingCallbackAnnotation` allows you to register callbacks that execute during the publishing process. This is useful for performing custom operations when resources are being published.

AppHost.cs

```csharp
var api = builder.AddProject<Projects.Api>("api")
    .WithPublishingCallback(async context =>
    {
        // Custom logic during publishing
        await CustomPublishLogicAsync(context);
    });
```

For more information, see `WithPublishingCallback`.

### `DeployingCallbackAnnotation`

[Section titled “DeployingCallbackAnnotation”](#deployingcallbackannotation)

The `DeployingCallbackAnnotation` allows you to register callbacks that execute during the deployment process. This annotation is used internally by deployment tools to customize resource deployment behavior.

AppHost.cs

```csharp
var api = builder.AddProject<Projects.Api>("api");


api.Resource.Annotations.Add(
    new DeployingCallbackAnnotation(async context =>
    {
        // Custom deployment logic
        await ConfigureDeploymentAsync(context);
    });
);
```

For more information about publishing and deploying Aspire apps, see [publishing and deploying](/deployment/overview/).

## Creating custom annotations

[Section titled “Creating custom annotations”](#creating-custom-annotations)

Custom annotations in Aspire are designed to capture resource-specific metadata and behavior that can be leveraged throughout the application lifecycle. They’re commonly used by:

* **Extension methods** to infer user intent and configure resource behavior.
* **Deployment tools** to generate deployment-specific configuration.
* **Lifecycle hooks** to query the app model and make runtime decisions.
* **Development tools** like the dashboard to display resource information.

Custom annotations should focus on a single concern and provide clear value to consumers of the resource metadata.

### 1. Define the annotation class

[Section titled “1. Define the annotation class”](#1-define-the-annotation-class)

Start by creating a class that implements `IResourceAnnotation`. Focus on capturing specific metadata that other components need to reason about your resource:

ServiceMetricsAnnotation.cs

```csharp
public sealed class ServiceMetricsAnnotation : IResourceAnnotation
{
    public string MetricsPath { get; set; } = "/metrics";
    public int Port { get; set; } = 9090;
    public bool Enabled { get; set; } = true;
    public string[] AdditionalLabels { get; set; } = [];
}
```

### 2. Create extension methods

[Section titled “2. Create extension methods”](#2-create-extension-methods)

Create fluent extension methods that follow Aspire’s builder pattern. These methods should make it easy for AppHost authors to configure your annotation:

ServiceMetricsExtensions.cs

```csharp
public static class ServiceMetricsExtensions
{
    public static IResourceBuilder<T> WithMetrics<T>(
        this IResourceBuilder<T> builder,
        string path = "/metrics",
        int port = 9090,
        params string[] labels)
        where T : class, IResource
    {
        var annotation = new ServiceMetricsAnnotation
        {
            MetricsPath = path,
            Port = port,
            Enabled = true,
            AdditionalLabels = labels
        };


        return builder.WithAnnotation(annotation);
    }


    public static IResourceBuilder<T> WithoutMetrics<T>(
        this IResourceBuilder<T> builder)
        where T : class, IResource
    {
        return builder.WithAnnotation(new ServiceMetricsAnnotation { Enabled = false });
    }
}
```

The extension methods serve as the primary API surface for your annotation. They should:

* Follow naming conventions (start with `With` for additive operations).
* Provide sensible defaults.
* Return the builder for method chaining.
* Include comprehensive XML documentation.

### 3. Use the custom annotation

[Section titled “3. Use the custom annotation”](#3-use-the-custom-annotation)

Once defined, annotations integrate seamlessly into the AppHost model:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api")
    .WithMetrics("/api/metrics", 9090, "environment:production", "service:api");
```

## Testing with annotations

[Section titled “Testing with annotations”](#testing-with-annotations)

When writing tests, you can inspect annotations to verify resource configuration:

ResourceAnnotationsTests.cs

```csharp
[Fact]
public async Task Resource_Should_Have_Expected_Annotations()
{
    var appHost = await DistributedApplicationTestingBuilder
        .CreateAsync<Projects.MyApp_AppHost>();


    await using var app = await appHost.BuildAsync();


    var resource = app.Resources.GetResource("my-resource");


    // Assert that specific annotations exist
    Assert.NotEmpty(resource.Annotations.OfType<ServiceMetricsAnnotation>());


    // Assert annotation properties
    var metricsConfig = resource.Annotations
        .OfType<ServiceMetricsAnnotation>()
        .First();


    Assert.True(metricsConfig.Enabled);
    Assert.Equal("/metrics", metricsConfig.MetricsPath);
}
```

For more information, see [Testing with Aspire](/testing/overview/).

## Best practices

[Section titled “Best practices”](#best-practices)

When working with annotations, consider these best practices:

### Use meaningful names

[Section titled “Use meaningful names”](#use-meaningful-names)

Choose descriptive names for your annotation classes and properties:

DatabaseConnectionPoolAnnotation.cs

```csharp
// Good
public sealed class DatabaseConnectionPoolAnnotation : IResourceAnnotation
```

DbAnnotation.cs

```csharp
// Avoid
public sealed class DbAnnotation : IResourceAnnotation
```

### Follow the builder pattern

[Section titled “Follow the builder pattern”](#follow-the-builder-pattern)

Create fluent extension methods that follow Aspire’s builder pattern:

AppHost.cs

```csharp
var resource = builder.AddMyResource("name")
    .WithCustomBehavior()
    .WithAnotherFeature();
```

### Document your annotations

[Section titled “Document your annotations”](#document-your-annotations)

Provide XML documentation for custom annotations and extension methods:

CachingExtensions.cs

```csharp
/// <summary>
/// Configures custom caching behavior for the resource.
/// </summary>
/// <param name="builder">The resource builder.</param>
/// <param name="ttl">The time-to-live for cached items.</param>
/// <returns>The resource builder for chaining.</returns>
public static IResourceBuilder<T> WithCaching<T>(
    this IResourceBuilder<T> builder,
    TimeSpan ttl)
    where T : class, IResource { /*...*/ }
```

### Keep annotations simple

[Section titled “Keep annotations simple”](#keep-annotations-simple)

Annotations should be focused on a single responsibility:

RetryPolicyAnnotation.cs

```csharp
// Good - single responsibility
public sealed class RetryPolicyAnnotation : IResourceAnnotation
{
    public int MaxRetries { get; set; }
    public TimeSpan Delay { get; set; }
}
```

ConfigAnnotation.cs

```csharp
// Avoid - multiple responsibilities
public sealed class ConfigAnnotation : IResourceAnnotation
{
    public RetryPolicy RetryPolicy { get; set; }
    public LoggingSettings Logging { get; set; }
    public SecuritySettings Security { get; set; }
}
```

# Aspire app lifecycle guide

> Understand the lifecycle of Aspire applications from development to deployment.

This guide provides a high-level overview of the lifecycle phases of an Aspire application, from development through local deployment to production release. By using the same `AppHost` configuration across all phases, you ensure consistency and reduce configuration drift between environments. The example in this guide demonstrates how Aspire orchestrates containerized applications with persistent storage and CI/CD automation using the [Docker Integration](/integrations/compute/docker/) and GitHub.

## App lifecycle

[Section titled “App lifecycle”](#app-lifecycle)

The Aspire application lifecycle consists of three main phases:

1. **Inner-Loop Development** - Local development and debugging with `aspire run`
2. **Local Deployment** - Deployment to your defined compute environment(s) with `aspire deploy`. This example shows containerized deployment to Docker Desktop.
3. **Publish Release (CI/CD)** - Automated build & publish pipeline. This example shows using GitHub Actions to build and push images and publish release artifacts for deployment later.

**Each phase uses the same `AppHost` configuration but serves different purposes in the development and deployment workflows.**

### Example

[Section titled “Example”](#example)

Consider [this example](https://github.com/BethMassi/VolumeMount/). You have a distributed application that consists of a Blazor web project that relies on a SQL Server database with a persistent data volume as well as a persistent writable file volume to capture user file uploads. You want to distribute your Blazor app as a Docker container image via the GitHub Container Registry. You need the [Aspire.Hosting.Docker](/integrations/compute/docker/) and [Aspire.Hosting.SqlServer](/integrations/databases/sql-server/sql-server-get-started/) integrations.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Docker Compose environment
var compose = builder.AddDockerComposeEnvironment("volumemount-env")
    .WithProperties(env =>
    {
        env.DashboardEnabled = true;
    })
    .ConfigureComposeFile(composeFile =>
     {
         // Add the blazor file volume to the top-level volumes section
         composeFile.AddVolume(new Volume
                               {
                                   Name = "volumemount-blazor-uploads",
                                   Driver = "local"
                               });
     });


// Add container registry
var endpoint = builder.AddParameter("registry-endpoint");
var repository = builder.AddParameter("registry-repository");
builder.AddContainerRegistry("container-registry", endpoint, repository);


//Add SQL Server with data volume
var sqlPassword = builder.AddParameter("sqlserver-password", secret: true);
var sqlserver = builder.AddSqlServer("sqlserver", password: sqlPassword)
    .WithDataVolume("volumemount-sqlserver-data")
    .WithLifetime(ContainerLifetime.Persistent);


var sqlDatabase = sqlserver.AddDatabase("sqldb");


//Add the Blazor web app with reference to the database
//Deploy as a docker image with a volume mount for user upload files
var blazorweb = builder.AddProject<Projects.VolumeMount_BlazorWeb>("blazorweb")
        .WithExternalHttpEndpoints()
        .WithReference(sqlDatabase)
        .WaitFor(sqlDatabase)
        //Deploy the Web project as a Docker Compose service with a volume mount for files
        .PublishAsDockerComposeService((resource, service) =>
        {
            service.AddVolume(new Volume
            {
                Name = "volumemount-blazor-uploads",
                Source = "volumemount-blazor-uploads",
                Target = "/app/wwwroot/uploads",
                Type = "volume",
                ReadOnly = false
            });


            // Override the entrypoint to allow write permissions to the volume
            // then run the default entrypoint as app user
            service.User = "root";
            service.Command = new List<string>
            {
                "/bin/sh",
                "-c",
                "chown -R app:app /app/wwwroot/uploads && chmod -R 755 /app/wwwroot/uploads && exec su app -c 'dotnet /app/VolumeMount.BlazorWeb.dll'"
            };


        });


builder.Build().Run();
```

## Phase 1: Inner-Loop Development

[Section titled “Phase 1: Inner-Loop Development”](#phase-1-inner-loop-development)

### What is `aspire run`?

[Section titled “What is aspire run?”](#what-is-aspire-run)

The `aspire run` command starts your Aspire application in **development mode**. This is the inner-loop development experience where you write code, test changes, and debug your application locally.

When you run `aspire run`:

1. **Aspire dashboard launches** - A web-based dashboard starts, and its URL (often an HTTPS login URL like `https://localhost:<port>/login?...`) is printed to the console.
2. **Resources start** - All resources defined in your `AppHost.cs` are orchestrated.
3. **Live debugging** - You can attach debuggers, set breakpoints, and modify code with hot reload.
4. **Telemetry & logs** - Dashboard provides real-time logs, metrics, and distributed traces.

This command searches the current directory structure for AppHost projects to build and run:

Aspire CLI

```bash
aspire run
```

[Command reference: `aspire run`](/reference/cli/commands/aspire-run/)

The console will display the dashboard URL with a login token:

Aspire CLI

```bash
Dashboard:  https://localhost:17244/login?t=9db79f2885dae24ee06c6ef10290b8b2


    Logs:  /home/vscode/.aspire/cli/logs/apphost-5932-2025-08-25-18-37-31.log


        Press CTRL+C to stop the apphost and exit.
```

In the example above, when resources start with the run command:

* SQL Server container starts in Docker with persistent volume
* Blazor Web project runs as a .NET process (**not containerized**)
* Database is automatically created and migrated (containerized)

## Phase 2: Local Deployment

[Section titled “Phase 2: Local Deployment”](#phase-2-local-deployment)

### What is `aspire deploy`?

[Section titled “What is aspire deploy?”](#what-is-aspire-deploy)

The `aspire deploy` command creates a **fully containerized deployment** of your application in the [compute environment(s)](/deployment/overview/#compute-environments) you define. This simulates a production-like environment on your local machine. In this example, local containers and volumes are created on Docker Desktop using the [Docker Integration](/integrations/compute/docker/). It requires all parameters to be set.

Note

Aspire will prompt you for parameters the first time you deploy and save them for later use. For more info, see [External Parameters](https://aspire.dev/fundamentals/external-parameters).

When you run `aspire deploy` Aspire will:

1. Build and push container images for projects
2. Generate `docker-compose.yaml` in `./aspire-output/` directory
3. Start all containers using Docker Compose
4. Create and mount persistent volumes

In this example, the following gets deployed:

**Containers:**

* `aspire-volumemount-env` - Docker Compose stack
* `sqlserver` - SQL Server with persistent data volume
* `blazorweb` - Blazor Web app with persistent file uploads volume
* `volumemount-env-dashboard` - Monitoring dashboard

**Volumes:**

* `volumemount-sqlserver-data` - Stores database files (`.mdf`, `.ldf`)
* `volumemount-blazor-uploads` - Stores user-uploaded images

Note

You will need a GitHub personal access token to access the GitHub Container Registry. See [Authenticating to the GitHub Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-to-the-container-registry)

You can login to your GitHub Container Registry before deploying.

```bash
export GITHUB_TOKEN=<YOUR PERSONAL ACCESS TOKEN>
echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin


aspire deploy
```

[Command reference: `aspire deploy`](/reference/cli/commands/aspire-deploy/)

## Phase 3: Publish Release (CI/CD)

[Section titled “Phase 3: Publish Release (CI/CD)”](#phase-3-publish-release-cicd)

You can create a workflow that automates the process of building and pushing the image, and publishing of deployment artifacts using the [Aspire CLI](/reference/cli/overview/) in a CI/CD pipeline. The Aspire CLI can be used to build your app, push images, and publish artifacts. This allows you to deploy the app later via standard Docker Compose.

In [this example](https://github.com/BethMassi/VolumeMount/blob/main/.github/workflows/aspire-build-push.yml), the workflow runs on every push to `main`, does a checkout, and then performs these steps:

1. **Setup Environment** - Install .NET
2. **Install Aspire CLI** - Install the Aspire CLI
3. **Build and Push Container Images** - Build app and push image to GitHub Container Registry with `aspire do push`
4. **Publish Docker Compose Artifacts** - Generate deployment files with `aspire publish`
5. **Upload Artifacts** - Store deployment files for download

#### Step 1: Setup Environment

[Section titled “Step 1: Setup Environment”](#step-1-setup-environment)

```yaml
- name: Setup .NET
  uses: actions/setup-dotnet@v4
  with:
    dotnet-version: '10.0.x'
```

#### Step 2: Install Aspire CLI

[Section titled “Step 2: Install Aspire CLI”](#step-2-install-aspire-cli)

```yaml
- name: Install Aspire CLI
  run: |
    echo "Installing Aspire CLI from install script..."
    curl -sSL https://aspire.dev/install.sh | bash
    echo "$HOME/.aspire/bin" >> $GITHUB_PATH
```

#### Step 3. Build App, Create & Push Image to GHCR

[Section titled “Step 3. Build App, Create & Push Image to GHCR”](#step-3-build-app-create--push-image-to-ghcr)

```yaml
- name: Login to GHCR
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}


- name: Build and Push images with Aspire
  env:
    Parameters__registry_endpoint: ghcr.io
    Parameters__registry_repository: your-org/your-repo
  run: aspire do push
```

Note

Replace `your-org/your-repo` with your actual GitHub organization and repository name, or use `${{ github.repository_owner }}/${{ github.event.repository.name }}` for automatic values. *Values must be lowercase.*

The `aspire do push` command does the following:

* Analyzes your `AppHost.cs` configuration

* Restores dependencies and builds the project

* Builds Docker container images for project resources

* Tags images with configured registry endpoint and repository

* Pushes images to GitHub Container Registry (ghcr.io)

* Uses parameters defined in `AppHost.cs`:

  * Environment `Parameters__registry_endpoint` maps to `registry-endpoint` parameter
  * Environment `Parameters__registry_repository` maps to `registry-repository` parameter

[Command reference: `aspire do`](/reference/cli/commands/aspire-do/)

#### Step 4: Publish Docker Compose Artifacts

[Section titled “Step 4: Publish Docker Compose Artifacts”](#step-4-publish-docker-compose-artifacts)

```yaml
- name: Prepare Docker Compose with Aspire
  run: |
    aspire publish \
      --project VolumeMount.AppHost/VolumeMount.AppHost.csproj \
      --output-path ./aspire-output
```

The `aspire publish` command does the following:

* Analyzes your `AppHost.cs` configuration
* Generates `docker-compose.yaml` file with all service definitions
* Creates `.env` template file for environment variables
* Packages configuration needed for deployment
* Outputs artifacts to `./aspire-output/` directory

```plaintext
aspire-output/
├── docker-compose.yaml    # Service definitions for all containers
└── .env                   # Template for required environment variables
```

[Command reference: `aspire publish`](/reference/cli/commands/aspire-publish/)

#### Step 5: Upload Deployment Artifacts

[Section titled “Step 5: Upload Deployment Artifacts”](#step-5-upload-deployment-artifacts)

```yaml
- name: Upload Aspire artifacts
  uses: actions/upload-artifact@v4
  with:
    name: aspire-deployment-files
    path: ./aspire-output/
    retention-days: 30
    include-hidden-files: true
```

In this example, artifacts are available for download from the Actions workflow run for 30 days. Hidden files are included so that the `.env` file is also available in the artifacts.

### Deploying to Production

[Section titled “Deploying to Production”](#deploying-to-production)

After the workflow completes, you have everything needed for production deployment:

1. **Download Artifacts** from GitHub Actions workflow run:

   * `docker-compose.yaml` - Complete service definitions
   * `.env` - Environment variable template

2. **Configure Environment Variables** in `.env`. For example:

   ```bash
   BLAZORWEB_IMAGE=ghcr.io/bethmassi/volumemount/blazorweb:latest
   BLAZORWEB_PORT=8080
   SQLSERVER_PASSWORD=YourSecurePassword
   ```

3. **Deploy with Docker Compose**:

   ```bash
   docker compose up -d
   ```

4. **Verify Deployment**:

   ```bash
   docker compose ps
   docker compose logs -f
   ```

## Lifecycle Summary

[Section titled “Lifecycle Summary”](#lifecycle-summary)

| Phase            | Command                              | Purpose                        | Environment                                          | App                     | Database  |
| ---------------- | ------------------------------------ | ------------------------------ | ---------------------------------------------------- | ----------------------- | --------- |
| **Development**  | `aspire run`                         | Inner-loop coding & debugging  | Local machine                                        | App process (i.e. .NET) | Container |
| **Local Deploy** | `aspire deploy`                      | Test containerized app locally | Registered compute environment (i.e. Docker Desktop) | Container               | Container |
| **Release**      | CI/CD workflow (i.e. GitHub Actions) | Publish to staging/ production | Cloud/Server                                         | Container               | Container |

The `AppHost.cs` file is the **single source of truth** for your application architecture. Each phase above uses the exact same `AppHost` configuration. This eliminates configuration drift between development and deployment. It defines things your distributed application needs like:

* **Services & Dependencies** - Projects, containers, and their relationships
* **Configuration** - Connection strings, secrets, and parameters
* **Volumes** - Persistent storage for databases and files
* **Networking** - Endpoints, ports, and service communication
* **Deployment** - Container registry, image tags, and publish settings

For more information, see [AppHost configuration](/app-host/configuration/).

## Next steps

[Section titled “Next steps”](#next-steps)

* Learn more about [Service discovery](/fundamentals/service-discovery/)
* Explore [Telemetry](/fundamentals/telemetry/) options
* Understand [Health checks](/fundamentals/health-checks/)

# Custom resource commands

> Learn how to create custom resource commands in Aspire.

Each resource in the Aspire app model is represented as an `IResource` and when added to the distributed application builder, it’s the generic-type parameter of the `IResourceBuilder<T>` interface. You use the *resource builder* API to chain calls, configuring the underlying resource, and in some situations, you might want to add custom commands to the resource. Some common scenario for creating a custom command might be running database migrations or seeding/resetting a database. In this article, you learn how to add a custom command to a Redis resource that clears the cache.

Caution

These [Aspire dashboard](/dashboard/overview/) commands are only available when running the dashboard locally. They’re not available when running the dashboard in Azure Container Apps.

## Add custom commands to a resource

[Section titled “Add custom commands to a resource”](#add-custom-commands-to-a-resource)

Start by creating a new Aspire Starter App from the available templates. After creating this solution, add a new class named *RedisResourceBuilderExtensions.cs* to the AppHost project. Replace the contents of the file with the following code:

RedisResourceBuilderExtensions.cs

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;
using StackExchange.Redis;


namespace Aspire.Hosting;


internal static class RedisResourceBuilderExtensions
{
    public static IResourceBuilder<RedisResource> WithClearCommand(
        this IResourceBuilder<RedisResource> builder)
    {
        var commandOptions = new CommandOptions
        {
            UpdateState = OnUpdateResourceState,
            IconName = "AnimalRabbitOff",
            IconVariant = IconVariant.Filled
        };


        builder.WithCommand(
            name: "clear-cache",
            displayName: "Clear Cache",
            executeCommand: context => OnRunClearCacheCommandAsync(builder, context),
            commandOptions: commandOptions);


        return builder;
    }


    private static async Task<ExecuteCommandResult> OnRunClearCacheCommandAsync(
        IResourceBuilder<RedisResource> builder,
        ExecuteCommandContext context)
    {
        var connectionString = await builder.Resource.GetConnectionStringAsync() ??
            throw new InvalidOperationException(
                $"Unable to get the '{context.ResourceName}' connection string.");


        await using var connection = ConnectionMultiplexer.Connect(connectionString);
        var database = connection.GetDatabase();
        await database.ExecuteAsync("FLUSHALL");


        return CommandResults.Success();
    }


    private static ResourceCommandState OnUpdateResourceState(
        UpdateCommandStateContext context)
    {
        var logger = context.ServiceProvider.GetRequiredService<ILogger<Program>>();
        if (logger.IsEnabled(LogLevel.Information))
        {
            logger.LogInformation(
                "Updating resource state: {ResourceSnapshot}",
                context.ResourceSnapshot);
        }


        return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy
            ? ResourceCommandState.Enabled
            : ResourceCommandState.Disabled;
    }
}
```

The preceding code:

* Shares the `Aspire.Hosting` namespace so that it’s visible to the AppHost project.
* Is a `static class` so that it can contain extension methods.
* It defines a single extension method named `WithClearCommand`, extending the `IResourceBuilder<RedisResource>` interface.
* The `WithClearCommand` method registers a command named `clear-cache` that clears the cache of the Redis resource.
* The `WithClearCommand` method returns the `IResourceBuilder<RedisResource>` instance to allow chaining.

The `WithCommand` API adds the appropriate annotations to the resource, which are consumed in the [Aspire dashboard](/dashboard/overview/). The dashboard uses these annotations to render the command in the UI. Before getting too far into those details, let’s ensure that you first understand the parameters of the `WithCommand` method:

* `name`: The name of the command to invoke.
* `displayName`: The name of the command to display in the dashboard.
* `executeCommand`: The `Func<ExecuteCommandContext, Task<ExecuteCommandResult>>` to run when the command is invoked, which is where the command logic is implemented.
* `updateState`: The `Func<UpdateCommandStateContext, ResourceCommandState>` callback is invoked to determine the “enabled” state of the command, which is used to enable or disable the command in the dashboard.
* `iconName`: The name of the icon to display in the dashboard. The icon is optional, but when you do provide it, it should be a valid [Fluent UI Blazor icon name](https://www.fluentui-blazor.net/Icon#explorer).
* `iconVariant`: The variant of the icon to display in the dashboard, valid options are `Regular` (default) or `Filled`.

## Execute command logic

[Section titled “Execute command logic”](#execute-command-logic)

The `executeCommand` delegate is where the command logic is implemented. This parameter is defined as a `Func<ExecuteCommandContext, Task<ExecuteCommandResult>>`. The `ExecuteCommandContext` provides the following properties:

* `ExecuteCommandContext.ServiceProvider`: The `IServiceProvider` instance that’s used to resolve services.
* `ExecuteCommandContext.ResourceName`: The name of the resource instance that the command is being executed on.
* `ExecuteCommandContext.CancellationToken`: The `CancellationToken` that’s used to cancel the command execution.

In the preceding example, the `executeCommand` delegate is implemented as an `async` method that clears the cache of the Redis resource. It delegates out to a private class-scoped function named `OnRunClearCacheCommandAsync` to perform the actual cache clearing. Consider the following code:

RedisResourceBuilderExtensions.cs

```csharp
private static async Task<ExecuteCommandResult> OnRunClearCacheCommandAsync(
    IResourceBuilder<RedisResource> builder,
    ExecuteCommandContext context)
{
    var connectionString = await builder.Resource.GetConnectionStringAsync() ??
        throw new InvalidOperationException(
            $"Unable to get the '{context.ResourceName}' connection string.");


    await using var connection = ConnectionMultiplexer.Connect(connectionString);


    var database = connection.GetDatabase();


    await database.ExecuteAsync("FLUSHALL");


    return CommandResults.Success();
}
```

The preceding code:

* Retrieves the connection string from the Redis resource.
* Connects to the Redis instance.
* Gets the database instance.
* Executes the `FLUSHALL` command to clear the cache.
* Returns a `CommandResults.Success()` instance to indicate that the command was successful.

## Update command state logic

[Section titled “Update command state logic”](#update-command-state-logic)

The `updateState` delegate is where the command state is determined. This parameter is defined as a `Func<UpdateCommandStateContext, ResourceCommandState>`. The `UpdateCommandStateContext` provides the following properties:

* `UpdateCommandStateContext.ServiceProvider`: The `IServiceProvider` instance that’s used to resolve services.
* `UpdateCommandStateContext.ResourceSnapshot`: The snapshot of the resource instance that the command is being executed on.

The immutable snapshot is an instance of `CustomResourceSnapshot`, which exposes all sorts of valuable details about the resource instance. Consider the following code:

RedisResourceBuilderExtensions.cs

```csharp
private static ResourceCommandState OnUpdateResourceState(
    UpdateCommandStateContext context)
{
    var logger = context.ServiceProvider.GetRequiredService<ILogger<Program>>();


    if (logger.IsEnabled(LogLevel.Information))
    {
        logger.LogInformation(
            "Updating resource state: {ResourceSnapshot}",
            context.ResourceSnapshot);
    }


    return context.ResourceSnapshot.HealthStatus is HealthStatus.Healthy
        ? ResourceCommandState.Enabled
        : ResourceCommandState.Disabled;
}
```

The preceding code:

* Retrieves the logger instance from the service provider.
* Logs the resource snapshot details.
* Returns `ResourceCommandState.Enabled` if the resource is healthy; otherwise, it returns `ResourceCommandState.Disabled`.

## Test the custom command

[Section titled “Test the custom command”](#test-the-custom-command)

To test the custom command, update your AppHost project’s *AppHost.cs* file to include the following code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithClearCommand();


var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice");


builder.AddProject<Projects.AspireApp_Web>("webfrontend")
    .WithExternalHttpEndpoints()
    .WithReference(cache)
    .WaitFor(cache)
    .WithReference(apiService)
    .WaitFor(apiService);


builder.Build().Run();
```

The preceding code calls the `WithClearCommand` extension method to add the custom command to the Redis resource. Run the app and navigate to the Aspire dashboard. You should see the custom command listed under the Redis resource. On the **Resources** page of the dashboard, select the ellipsis button under the **Actions** column:

![Aspire dashboard: Redis cache resource with custom command displayed.](/_astro/custom-clear-cache-command.BVsgCVU0_ZPaohk.webp)

The preceding image shows the **Clear cache** command that was added to the Redis resource. The icon displays as a rabbit crossed out to indicate that the speed of the dependent resource is being cleared.

Select the **Clear cache** command to clear the cache of the Redis resource. The command should execute successfully, and the cache should be cleared:

![Aspire dashboard: Redis cache resource with custom command executed.](/_astro/custom-clear-cache-command-succeeded.CfpOtcBZ_Z1wPzpN.webp)

## Programmatically execute commands

[Section titled “Programmatically execute commands”](#programmatically-execute-commands)

In addition to executing commands through the [Aspire dashboard](/dashboard/overview/), you can also execute commands programmatically using the `ResourceCommandService`. This service is useful when you need to:

* Execute commands from within your application code
* Automate command execution as part of a workflow
* Build custom tooling that needs to control resources

The most common scenario is to call commands from within other custom command implementations. The `ExecuteCommandContext` provides access to the `IServiceProvider`, which you can use to retrieve the `ResourceCommandService`.

### Execute commands from a custom command

[Section titled “Execute commands from a custom command”](#execute-commands-from-a-custom-command)

The following example shows how to create a custom command that executes other commands. In this case, a “reset-all” command clears the cache and restarts a database:

AppHost.cs

```csharp
using Aspire.Hosting.ApplicationModel;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;


var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
    .WithClearCommand(); // Defines a "clear-cache" command as shown earlier


var database = builder.AddPostgres("postgres")
    .WithCommand("restart", "Restart Database", async (context, ct) =>
    {
        // Restart database implementation
        return CommandResults.Success();
    });


var api = builder.AddProject<Projects.Api>("api")
    .WithReference(cache)
    .WithReference(database)
    .WithCommand("reset-all", "Reset Everything", async (context, ct) =>
    {
        var logger = context.ServiceProvider.GetRequiredService<ILogger<Program>>();
        var commandService = context.ServiceProvider.GetRequiredService<ResourceCommandService>();


        logger.LogInformation("Starting full system reset...");


        var clearResult = await commandService.ExecuteCommandAsync(
            resource: cache.Resource,
            commandName: "clear-cache",
            cancellationToken: ct);


        var restartResult = await commandService.ExecuteCommandAsync(
            resource: database.Resource,
            commandName: "restart",
            cancellationToken: ct);


        if (!clearResult.Success || !restartResult.Success)
        {
            return CommandResults.Failure("System reset failed");
        }


        logger.LogInformation("System reset completed successfully");
        return CommandResults.Success();
    });


builder.Build().Run();
```

In this example:

* The `context` parameter provides access to `ServiceProvider`
* The `ResourceCommandService` is retrieved from the service provider
* Commands are executed on resource instances using `cache.Resource` and `database.Resource`
* Each command result is checked for success before proceeding

### Execute a command by resource ID

[Section titled “Execute a command by resource ID”](#execute-a-command-by-resource-id)

You can also execute a command using the resource ID or resource name. The resource ID is the unique identifier for a resource instance, while the resource name is the display name (which must be unique to use this approach):

```csharp
var result = await commandService.ExecuteCommandAsync(
    resourceId: "cache",
    commandName: "clear-cache",
    cancellationToken: cancellationToken);


if (result.Success)
{
    logger.LogInformation("Command executed successfully");
}
else if (result.Canceled)
{
    logger.LogWarning("Command was canceled");
}
else
{
    logger.LogError("Command failed: {ErrorMessage}", result.ErrorMessage);
}
```

The `resourceId` parameter can be either:

* The unique ID of the resource (e.g., `cache-abcdwxyz` for a resource with replicas)
* The display name (e.g., `cache`) if there are no duplicate names

### Execute commands on resources with replicas

[Section titled “Execute commands on resources with replicas”](#execute-commands-on-resources-with-replicas)

When executing a command on a resource with multiple replicas using the `IResource` overload, the command runs in parallel on all instances:

```csharp
// For a resource with replicas, the command executes on all instances
var result = await commandService.ExecuteCommandAsync(
    resource: cache.Resource,
    commandName: "clear-cache",
    cancellationToken: cancellationToken);
```

The behavior when executing on multiple replicas:

* The command runs in parallel on all instances
* If all commands succeed, the result indicates success
* If any commands fail, the result includes details about the failures
* If all non-successful commands were canceled, the result indicates cancellation

### Handle command execution results

[Section titled “Handle command execution results”](#handle-command-execution-results)

The `ExecuteCommandResult` class provides information about the command execution:

* **`Success`**: A boolean indicating whether the command was successful.
* **`ErrorMessage`**: An optional string property with an error message if the command was unsuccessful.
* **`Canceled`**: A boolean indicating whether the command was canceled by the user.

You can use these properties to handle different execution outcomes in your application logic. The `CommandResults` helper class provides factory methods to create result instances:

```csharp
// In your command implementation
return CommandResults.Success();
// or
return CommandResults.Failure("Error occurred during execution");
// or
return CommandResults.Canceled();
```

# Define custom resource URLs

> Learn how to create custom URLs for Aspire resources.

In Aspire, resources that expose endpoints only configure host and port, which aren’t known until run time. If you need to access a specific path on one of these endpoints—especially from the [dashboard](/dashboard/overview/)—you can define custom resource URLs. You can also add custom URLs that aren’t tied to any endpoint. All custom URLs are only available in “run” mode, since they’re meant for dashboard use. This article demonstrates how to define custom URLs.

## Default endpoint behavior

[Section titled “Default endpoint behavior”](#default-endpoint-behavior)

By default, Aspire project resources rely on existing configurations such as Kestrel or launch profiles to determine the host and port of a resource for a configured endpoint—and the endpoints are always displayed on the dashboard.

Likewise, you can explicitly expose endpoints using the `WithEndpoint` API. This API allows you to specify the host and port for a resource, which is then used to create the default URL for that resource. The default URL is typically in the format `<scheme>://<host>:<port>`. To omit the host port, use one of the following methods:

* `WithHttpEndpoint`
* `WithHttpsEndpoint`

For more information, see [Endpoint extension methods](/fundamentals/networking-overview/#endpoint-extension-methods).

## Supported resource types

[Section titled “Supported resource types”](#supported-resource-types)

Custom resource URLs are supported for the following resource types:

* `ContainerResource`
* `ExecutableResource`
* `ProjectResource`

## Customize resource URLs

[Section titled “Customize resource URLs”](#customize-resource-urls)

Use the appropriate `WithUrl` overload, `WithUrls`, or `WithUrlForEndpoint` APIs on any supported resource builder to define custom URLs for a resource. The following example demonstrates how to set a custom URL for a project resource:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.AspireApp_Api>("api");


api.WithUrl("/admin", "Admin Portal");


builder.Build().Run();
```

Tip

There’s an overload that accepts a `string` allowing you to pass any URL. This is useful for defining custom URLs that aren’t directly related to the resource’s endpoint.

The preceding code assigns a project reference to the `api` variable, which is then used to create a custom URL for the `Admin Portal` route. The `WithUrl` method takes a `ReferenceExpression` and a display name as parameters. The resulting URL is available in the dashboard.

### Customize endpoint URL

[Section titled “Customize endpoint URL”](#customize-endpoint-url)

Both [Scalar](https://scalar.com/) and [Swagger](https://swagger.io/tools/swagger-ui/) are common API services that enhance the usability of endpoints. These services are accessed via URLs tied to declared endpoints.

To customize the URL for the first associated resource endpoint, use the `WithUrlForEndpoint` method. If you want to add a separate URL (even for the same endpoint) you need to call the `WithUrl` overload that takes a `ReferenceExpression` or interpolated string, or call `WithUrls` and add the URL to the `Urls` list on the context.

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.AspireApp_Api>("api")
    .WithUrlForEndpoint("https", url =>
    {
        url.DisplayText = "Scalar (HTTPS)";
        url.Url = "/scalar";
    });


builder.Build().Run();
```

The preceding example assumes that the `api` project resource has an `https` endpoint configured. The `WithUrlForEndpoint` method updates the `ResourceUrlAnnotation` associated with the endpoint. In this case, it assigns the display text to `Scalar (HTTPS)` and assigns the relative `/scalar` path to the URL.

When the resource is started, the URL is available in the dashboard.

Alternatively, you could use the overload that accepts a `Func<EndpointReference, ResourceUrlAnnotation>` as a callback. This allows you to specify deep-links on target `EndpointReference` instances.

### Customize multiple resource URLs

[Section titled “Customize multiple resource URLs”](#customize-multiple-resource-urls)

To customize multiple URLs for a resource, use the `WithUrls` method. This method allows you to specify multiple URLs for a resource, each with its own display text. The following example demonstrates how to set multiple URLs for a project resource:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.AspireApp_Api>("api")
    .WithUrls(context =>
    {
        foreach (var url in context.Urls)
        {
            if (string.IsNullOrEmpty(url.DisplayText))
            {
                url.DisplayText = $"API ({url.Endpoint?.Scheme?.ToUpper()})";
            }
        }
    });


builder.Build().Run();
```

The preceding code iterates through the URLs defined for the `api` project resource and assigns a display text with scheme.

Tip

The `ResourceUrlsCallbackContext` exposes an extension method that enables you to easily access the underlying resource named endpoints. Call the `GetEndpoint` API on a context instance to achieve this.

## URL customization lifecycle

[Section titled “URL customization lifecycle”](#url-customization-lifecycle)

URL customization callbacks run during the application model lifecycle, specifically during the `BeforeResourceStartedEvent` event processing. URLs associated with endpoints become active and appear on the dashboard once the endpoint itself becomes active. URLs not associated with endpoints become active only when the resource enters the “Running” state. This ensures that all custom URLs are accurately represented and available when the application resources are fully operational.

# External parameters

> Learn how to express parameters such as secrets, connection strings, and other configuration values that might vary between environments.

Environments provide context for the application to run in. Parameters express the ability to ask for an external value when running the app. Parameters can be used to provide values to the app when running locally, or to prompt for values when deploying. They can be used to model a wide range of scenarios including secrets, connection strings, and other configuration values that might vary between environments.

## Parameter values

[Section titled “Parameter values”](#parameter-values)

Parameter values are read from the `Parameters` section of the AppHost’s configuration and are used to provide values to the app while running locally. When you run or publish the app, if the value isn’t configured you’re prompted to provide it.

Consider the following example AppHost *AppHost.cs* file:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a parameter named "example-parameter-name"
var parameter = builder.AddParameter("example-parameter-name");


builder.AddProject<Projects.ApiService>("api")
       .WithEnvironment("ENVIRONMENT_VARIABLE_NAME", parameter);
```

The preceding code adds a parameter named `example-parameter-name` to the AppHost. The parameter is then passed to the `Projects.ApiService` project as an environment variable named `ENVIRONMENT_VARIABLE_NAME`.

### Configure parameter values

[Section titled “Configure parameter values”](#configure-parameter-values)

Adding parameters to the builder is only one aspect of the configuration. You must also provide the value for the parameter. The value can be provided in the AppHost configuration file, set as a user secret, or configured in any [other standard configuration](https://learn.microsoft.com/dotnet/core/extensions/configuration). When parameter values aren’t found, they’re prompted for when you run or publish the app.

Consider the following AppHost configuration file *appsettings.json*:

appsettings.json

```json
{
  "Parameters": {
    "example-parameter-name": "local-value"
  }
}
```

The preceding JSON configures a parameter in the `Parameters` section of the AppHost configuration. In other words, that AppHost is able to find the parameter as it’s configured. For example, you could walk up to the `IDistributedApplicationBuilder.Configuration` and access the value using the `Parameters:example-parameter-name` key:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var key = $"Parameters:example-parameter-name";
var value = builder.Configuration[key]; // value = "local-value"
```

Caution

However, you don’t need to access this configuration value yourself in the AppHost. Instead, the `ParameterResource` is used to pass the parameter value to dependent resources. Most often as an environment variable.

### Set parameter values using environment variables

[Section titled “Set parameter values using environment variables”](#set-parameter-values-using-environment-variables)

Parameters can be set using environment variables, which is particularly useful in CI/CD pipelines and deployment scenarios. The environment variable name follows the pattern `Parameters__{parameter_name}`, using double underscores (`__`) to separate the configuration section from the parameter name and a single underscore to represent dashes.

Note

The double underscore (`__`) syntax is a standard .NET configuration convention for representing nested configuration keys in environment variables, where colons (`:`) in configuration paths are replaced with double underscores.

Consider the following example AppHost *AppHost.cs* file:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Define container registry parameters
var endpoint = builder.AddParameter("registry-endpoint");
var repository = builder.AddParameter("registry-repository");


builder.AddContainerRegistry("container-registry", endpoint, repository);


builder.Build().Run();
```

These parameters can be provided via environment variables:

* `Parameters__registry_endpoint` - Registry URL (e.g., `ghcr.io`)
* `Parameters__registry_repository` - Repository path (e.g., `username/reponame`)

#### Example: GitHub Actions workflow

[Section titled “Example: GitHub Actions workflow”](#example-github-actions-workflow)

The following example shows how to set parameters as environment variables in a GitHub Actions workflow:

.github/workflows/deploy.yml

```yaml
- name: Login to GHCR
  uses: docker/login-action@v3
  with:
    registry: ghcr.io
    username: ${{ github.actor }}
    password: ${{ secrets.GITHUB_TOKEN }}


- name: Push images with Aspire
  env:
    Parameters__registry_endpoint: ghcr.io
    Parameters__registry_repository: your-org/your-repo
  run: aspire do push
```

#### How parameters are resolved

[Section titled “How parameters are resolved”](#how-parameters-are-resolved)

Aspire resolves parameter values in the following order:

1. **Environment variables** - Values set using the `Parameters__*` syntax
2. **Configuration files** - Values from *appsettings.json*, user secrets, or other configuration sources
3. **User prompts** - If no value is found, the dashboard or CLI prompts for the value

This resolution order allows you to override configuration file values with environment variables, making it easy to adapt your application to different environments without modifying configuration files.

### Prompt for parameter values in the dashboard

[Section titled “Prompt for parameter values in the dashboard”](#prompt-for-parameter-values-in-the-dashboard)

If your code adds parameters but doesn’t set them, you’ll see a prompt to configure their values in the Aspire dashboard. The **Unresolved parameters** message appears, and you can select **Enter values** to resolve the problem:

![Screenshot of the Aspire dashboard warning that appears when there are unresolved parameters.](/_astro/dashboard-unresolved-parameters-message.DQDS6G8__hYBS9.webp)

When you select **Enter values**, Aspire displays a form that you can use to configure values for each of the missing parameters.

You can also control how the dashboard displays these parameters, by using these methods:

* `WithDescription`: Use this method to provide a text description that helps users understand the purpose of the parameter. To provide a formatted description in [Markdown](https://www.markdownguide.org/basic-syntax/), use the `enableMarkdown: true` parameter.
* `WithCustomInput`: Use this method to provide a callback method that customizes the parameter dialog. For example, in this callback you can customize the default value, input type, label, and placeholder text.

This code shows how to set a description and use the callback:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


#pragma warning disable ASPIREINTERACTION001 // Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
var externalServiceUrl = builder.AddParameter("external-service-url")
    .WithDescription("The URL of the external service.")
    .WithCustomInput(p => new()
    {
        InputType = InputType.Text,
        Value = "https://example.com",
        Name = p.Name,
        Placeholder = $"Enter value for {p.Name}",
        Description = p.Description
    });
var externalService = builder.AddExternalService("external-service", externalServiceUrl);
#pragma warning restore ASPIREINTERACTION001


builder.Build().Run();
```

The code renders this control in the dashboard:

![Screenshot of the Aspire dashboard parameter completion dialog with customizations.](/_astro/customized-parameter-ui.DOINN_Y9_4ApQW.webp)

Note

The dashboard parameter dialog includes a **Save to user secret** checkbox. Select this option to store sensitive values in your AppHost’s user secrets for extra protection. For more information about secret parameter values, see [Secret values](#secret-values).

### Parameter representation in the manifest

[Section titled “Parameter representation in the manifest”](#parameter-representation-in-the-manifest)

Aspire uses a deployment manifest to represent the app’s resources and their relationships. Parameters are represented in the manifest as a new primitive called `parameter.v0`:

```json
{
  "resources": {
    "example-parameter-name": {
      "type": "parameter.v0",
      "value": "{value.inputs.value}",
      "inputs": {
        "value": {
          "type": "string"
        }
      }
    }
  }
}
```

## Secret values

[Section titled “Secret values”](#secret-values)

Parameters can be used to model secrets. When a parameter is marked as a secret, it serves as a hint to the manifest that the value should be treated as a secret. When you publish the app, the value is prompted for and stored in a secure location. When you run the app locally, the value is read from the `Parameters` section of the AppHost configuration.

Consider the following example AppHost *AppHost.cs* file:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a secret parameter named "secret"
var secret = builder.AddParameter("secret", secret: true);


builder.AddProject<Projects.ApiService>("api")
       .WithEnvironment("SECRET", secret);


builder.Build().Run();
```

Now consider the following AppHost configuration file *appsettings.json*:

appsettings.json

```json
{
  "Parameters": {
    "secret": "local-secret"
  }
}
```

The manifest representation is as follows:

```json
{
  "resources": {
    "value": {
      "type": "parameter.v0",
      "value": "{value.inputs.value}",
      "inputs": {
        "value": {
          "type": "string",
          "secret": true
        }
      }
    }
  }
}
```

## Add parameters from configuration

[Section titled “Add parameters from configuration”](#add-parameters-from-configuration)

In some scenarios, you might want to read parameter values directly from a specific configuration key rather than following the standard `Parameters:*` pattern. The `AddParameterFromConfiguration` method allows you to specify a custom configuration key for a parameter.

### API signature

[Section titled “API signature”](#api-signature)

```csharp
public static IResourceBuilder<ParameterResource> AddParameterFromConfiguration(
    this IDistributedApplicationBuilder builder,
    string name,
    string configurationKey,
    bool secret = false
);
```

### Parameters

[Section titled “Parameters”](#parameters)

* `name` - The name of the parameter resource
* `configurationKey` - The configuration key to read the value from
* `secret` - Optional flag indicating whether the parameter should be treated as a secret (default: `false`)

### Example usage

[Section titled “Example usage”](#example-usage)

Consider a scenario where you have configuration values stored in a custom section:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Read from a custom configuration key
var dbPassword = builder.AddParameterFromConfiguration(
    "db-password",
    "CustomConfig:Database:Password",
    secret: true);


builder.AddProject<Projects.ApiService>("api")
       .WithEnvironment("DB_PASSWORD", dbPassword);


builder.Build().Run();
```

The corresponding configuration file would look like:

appsettings.json

```json
{
  "CustomConfig": {
    "Database": {
      "Password": "your-secure-password"
    }
  }
}
```

This method is useful when:

* You need to integrate with existing configuration structures
* Your configuration follows a different pattern than the standard `Parameters:*` convention
* You want to read values from specific configuration sections

## Connection string values

[Section titled “Connection string values”](#connection-string-values)

Parameters can be used to model connection strings. When you publish the app, the value is prompted for and stored in a secure location. When you run the app locally, the value is read from the `ConnectionStrings` section of the AppHost configuration.

Danger

Always use `AddParameter` to pass secrets to resources. Never include passwords or other sensitive data like connection strings in source code.

If you’re connecting to a local database, and want to use Integrated Security or passwordless authentication, you don’t need to worry about securing your connection strings. If you’re using a password, store the connection string securely using app secrets.

Consider the following example AppHost *AppHost.cs* file:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddConnectionString("redis");


builder.AddProject<Projects.WebApplication>("api")
       .WithReference(redis)
       .WaitFor(redis);


builder.Build().Run();
```

Note

Using `WaitFor` with a connection string will implicitly wait for the resource that the connection string connects to.

Now consider the following AppHost configuration file *appsettings.json*:

appsettings.json

```json
{
  "ConnectionStrings": {
    "redis": "local-connection-string"
  }
}
```

### Build connection strings with reference expressions

[Section titled “Build connection strings with reference expressions”](#build-connection-strings-with-reference-expressions)

If you want to construct a connection string from parameters and ensure that it’s handled correctly in both development and production, use `AddConnectionString` with a `ReferenceExpression`.

For example, if you have a secret parameter that stores a small part of a connection string, use this code to insert it:

AppHost.cs

```csharp
var secretKey = builder.AddParameter("secretkey", secret: true);


var connectionString = builder.AddConnectionString(
    "composedconnectionstring",
    ReferenceExpression.Create($"Endpoint=https://api.contoso.com/v1;Key={secretKey}"));


builder.AddProject<Projects.AspireReferenceExpressions_CatalogAPI>("catalogapi")
       .WithReference(connectionString)
       .WaitFor(connectionString);
```

You can also use reference expressions to append text to connection strings created by Aspire resources. For example, when you add a PostgreSQL resource to your Aspire solution, the database server runs in a container and a connection string is formulated for it. In the following code, the extra property `Include Error Details` is appended to that connection string before it’s passed to consuming projects:

AppHost.cs

```csharp
var postgres = builder.AddPostgres("postgres");
var database = postgres.AddDatabase("db");


var pgConnectionString = builder.AddConnectionString(
    "pgdatabase",
    ReferenceExpression.Create($"{database};Include Error Details=true"));


builder.AddProject<Projects.AspireReferenceExpressions_CustomerAPI>("customerapi")
       .WithReference(pgConnectionString)
       .WaitFor(pgConnectionString);
```

## Parameter example

[Section titled “Parameter example”](#parameter-example)

To express a parameter, consider the following example code:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddSqlServer("sql")
                .PublishAsConnectionString()
                .AddDatabase("db");


var insertionRows = builder.AddParameter("insertionRows");


builder.AddProject<Projects.Parameters_ApiService>("api")
       .WithEnvironment("InsertionRows", insertionRows)
       .WithReference(db);


builder.Build().Run();
```

The following steps are performed:

1. Adds a SQL Server resource named `sql` and publishes it as a connection string.
2. Adds a database named `db`.
3. Adds a parameter named `insertionRows`.
4. Adds a project named `api` and associates it with the `Projects.Parameters_ApiService` project resource type-parameter.
5. Passes the `insertionRows` parameter to the `api` project.
6. References the `db` database.

The value for the `insertionRows` parameter is read from the `Parameters` section of the AppHost configuration file *appsettings.json*:

appsettings.json

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Aspire.Hosting.Dcp": "Warning"
    }
  },
  "Parameters": {
    "insertionRows": "1"
  }
}
```

The `Parameters_ApiService` project consumes the `insertionRows` parameter. Consider the *Program.cs* example file:

Program.cs

```csharp
using Microsoft.EntityFrameworkCore;


var builder = WebApplication.CreateBuilder(args);


int insertionRows = builder.Configuration.GetValue<int>("InsertionRows", 1);


builder.AddServiceDefaults();


builder.AddSqlServerDbContext<MyDbContext>("db");


var app = builder.Build();


app.MapGet("/", async (MyDbContext context) =>
{
    // You wouldn't normally do this on every call,
    // but doing it here just to make this simple.
    context.Database.EnsureCreated();


    for (var i = 0; i < insertionRows; i++)
    {
        var entry = new Entry();
        await context.Entries.AddAsync(entry);
    }


    await context.SaveChangesAsync();


    var entries = await context.Entries.ToListAsync();


    return new
    {
        totalEntries = entries.Count,
        entries
    };
});


app.Run();
```

# Health checks

> Explore Aspire health checks

Health checks provide availability and state information about an app. Health checks are often exposed as HTTP endpoints, but can also be used internally by the app to write logs or perform other tasks based on the current health. Health checks are typically used in combination with an external monitoring service or container orchestrator to check the status of an app.

In Aspire, health checks operate in two main contexts:

* **AppHost resource health checks** - Run in the AppHost project to determine resource readiness for orchestration and dependency management. These checks control when dependent resources start and are displayed in the Aspire dashboard.
* **Application health check endpoints** - Run within individual applications and services to expose `/health` and `/alive` endpoints for monitoring and load balancing decisions.

The data reported by health checks can be used for various scenarios:

* Influence decisions made by container orchestrators, load balancers, API gateways, and other management services. For instance, if the health check for a containerized app fails, it might be skipped by a load balancer routing traffic.
* Verify that underlying dependencies are available, such as a database or cache, and return an appropriate status message.
* Trigger alerts or notifications when an app isn’t responding as expected.

## Aspire health check endpoints

[Section titled “Aspire health check endpoints”](#aspire-health-check-endpoints)

Aspire exposes two default health check HTTP endpoints in **Development** environments when the `AddServiceDefaults` and `MapDefaultEndpoints` methods are called from the *Program.cs* file:

* The `/health` endpoint indicates if the app is running normally where it’s ready to receive requests. All health checks must pass for app to be considered ready to accept traffic after starting.

  HTTP

  ```http
  GET /health
  ```

  The `/health` endpoint returns an HTTP status code 200 and a `text/plain` value of `Healthy` when the app is *healthy*.

* The `/alive` indicates if an app is running or has crashed and must be restarted. Only health checks tagged with the *live* tag must pass for app to be considered alive.

  HTTP

  ```http
  GET /alive
  ```

  The `/alive` endpoint returns an HTTP status code 200 and a `text/plain` value of `Healthy` when the app is *alive*.

The `AddServiceDefaults` and `MapDefaultEndpoints` methods also apply various configurations to your app beyond just health checks, such as OpenTelemetry and [service discovery](/fundamentals/service-discovery/) configurations.

### Non-development environments

[Section titled “Non-development environments”](#non-development-environments)

In non-development environments, the `/health` and `/alive` endpoints are disabled by default. If you need to enable them, its recommended to protect these endpoints with various routing features, such as host filtering and/or authorization. For more information, see [Health checks in ASP.NET Core](https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks#use-health-checks-routing).

Additionally, it may be advantageous to configure request timeouts and output caching for these endpoints to prevent abuse or denial-of-service attacks. To do so, consider the following modified `AddDefaultHealthChecks` method:

Extensions.cs

```csharp
public static IHostApplicationBuilder AddDefaultHealthChecks(
    this IHostApplicationBuilder builder)
{
    builder.Services.AddRequestTimeouts(
        configure: static timeouts =>
            timeouts.AddPolicy("HealthChecks", TimeSpan.FromSeconds(5)));


    builder.Services.AddOutputCache(
        configureOptions: static caching =>
            caching.AddPolicy("HealthChecks",
            build: static policy => policy.Expire(TimeSpan.FromSeconds(10))));


    builder.Services.AddHealthChecks()
        // Add a default liveness check to ensure app is responsive
        .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);


    return builder;
}
```

The preceding code:

* Adds a timeout of 5 seconds to the health check requests with a policy named `HealthChecks`.
* Adds a 10-second cache to the health check responses with a policy named `HealthChecks`.

Now consider the updated `MapDefaultEndpoints` method:

Extensions.cs

```csharp
public static WebApplication MapDefaultEndpoints(
    this WebApplication app)
{
    var healthChecks = app.MapGroup("");


    healthChecks
        .CacheOutput("HealthChecks")
        .WithRequestTimeout("HealthChecks");


    // All health checks must pass for app to be
    // considered ready to accept traffic after starting
    healthChecks.MapHealthChecks("/health");


    // Only health checks tagged with the "live" tag
    // must pass for app to be considered alive
    healthChecks.MapHealthChecks("/alive", new()
    {
        Predicate = static r => r.Tags.Contains("live")
    });


    return app;
}
```

The preceding code:

* Groups the health check endpoints under the `/` path.
* Caches the output and specifies a request time with the corresponding `HealthChecks` policy.

In addition to the updated `AddDefaultHealthChecks` and `MapDefaultEndpoints` methods, you must also add the corresponding services for both request timeouts and output caching.

In the appropriate consuming app’s entry point (usually the *Program.cs* file), add the following code:

```csharp
// Wherever your services are being registered.
// Before the call to Build().
builder.Services.AddRequestTimeouts();
builder.Services.AddOutputCache();


var app = builder.Build();


// Wherever your app has been built, before the call to Run().
app.UseRequestTimeouts();
app.UseOutputCache();


app.Run();
```

For more information, see [Request timeouts middleware in ASP.NET Core](https://learn.microsoft.com/aspnet/core/performance/timeouts) and [Output caching middleware in ASP.NET Core](https://learn.microsoft.com/aspnet/core/performance/caching/output).

## Integration health checks

[Section titled “Integration health checks”](#integration-health-checks)

Aspire integrations can also register additional health checks for your app. These health checks contribute to the returned status of the `/health` and `/alive` endpoints. For example, the Aspire PostgreSQL integration automatically adds a health check to verify the following conditions:

* A database connection could be established.
* A database query could be executed successfully.

If either of these operations fail, the corresponding health check also fails.

### Configure health checks

[Section titled “Configure health checks”](#configure-health-checks)

You can disable health checks for a given integration using one of the available configuration options. Aspire integrations support [Microsoft.Extensions.Configurations](https://learn.microsoft.com/dotnet/api/microsoft.extensions.configuration) to apply settings through config files such as *appsettings.json*:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "DisableHealthChecks": true
    }
  }
}
```

You can also use an inline delegate to configure health checks:

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<MyDbContext>(
    "postgresdb",
    static settings => settings.DisableHealthChecks  = true);
```

## AppHost resource health checks

[Section titled “AppHost resource health checks”](#apphost-resource-health-checks)

AppHost resource health checks are different from the health check endpoints described earlier. These health checks are configured in the AppHost project and determine the readiness of resources from the orchestrator’s perspective. They’re particularly important for controlling when dependent resources start via the `WaitFor` functionality and are displayed in the Aspire dashboard.

### Resource readiness with health checks

[Section titled “Resource readiness with health checks”](#resource-readiness-with-health-checks)

When a resource has health checks configured, the AppHost uses them to determine if the resource is ready before starting dependent resources. If no health checks are registered for a resource, the AppHost waits for the resource to be in the `Running` state.

### HTTP health checks for resources

[Section titled “HTTP health checks for resources”](#http-health-checks-for-resources)

For resources that expose HTTP endpoints, you can add health checks that poll specific paths:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogApi = builder.AddContainer("catalog-api", "catalog-api")
                        .WithHttpEndpoint(targetPort: 8080)
                        .WithHttpHealthCheck("/health");


builder.AddProject<Projects.WebApp>("webapp")
       .WithReference(catalogApi)
       .WaitFor(catalogApi); // Waits for /health to return HTTP 200
```

The `WithHttpHealthCheck` method can also be applied to project resources:

C# — AppHost.cs

```csharp
var backend = builder.AddProject<Projects.Backend>("backend")
                     .WithHttpHealthCheck("/health");


builder.AddProject<Projects.Frontend>("frontend")
       .WithReference(backend)
       .WaitFor(backend);
```

### Custom resource health checks

[Section titled “Custom resource health checks”](#custom-resource-health-checks)

You can create custom health checks for more complex readiness scenarios. Start by defining the health check in the AppHost’s service collection, then associate it with resources:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var startAfter = DateTime.Now.AddSeconds(30);


builder.Services.AddHealthChecks().AddCheck("mycheck", () =>
    {
        return DateTime.Now > startAfter
            ? HealthCheckResult.Healthy()
            : HealthCheckResult.Unhealthy();
    });


var pg = builder.AddPostgres("pg")
    .WithHealthCheck("mycheck");


builder.AddProject<Projects.MyApp>("myapp")
    .WithReference(pg)
    .WaitFor(pg); // Waits for both the Postgres container to be running
                  // AND the custom "mycheck" health check to be healthy
```

The `AddCheck` method registers the health check, and `WithHealthCheck` associates it with specific resources. For more details about creating and registering custom health checks, see [Create health checks](https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks#create-health-checks).

### Dashboard integration

[Section titled “Dashboard integration”](#dashboard-integration)

Resource health check status is displayed in the Aspire dashboard, providing real-time visibility into resource readiness. When resources are waiting for health checks to pass, the dashboard shows the current status and any failure details.

![Screenshot of the Aspire dashboard showing health check status for resources](/_astro/health-checks-dashboard-status._tRmRb8I_Z2o93uh.webp)

# Custom HTTP commands

> Learn how to create custom HTTP commands in Aspire.

In Aspire, you can add custom HTTP commands to resources using the `WithHttpCommand` API. This API extends existing functionality, where you provide [custom commands on resources](/fundamentals/custom-resource-commands/). This feature enables a command on a resource that sends an HTTP request to a specified endpoint and path. This is useful for scenarios such as triggering database migrations, clearing caches, or performing custom actions on resources through HTTP requests.

To implement custom HTTP commands, you define a command on a resource and a corresponding HTTP endpoint that handles the request. This article provides an overview of how to create and configure custom HTTP commands in Aspire.

## HTTP command APIs

[Section titled “HTTP command APIs”](#http-command-apis)

The available APIs provide extensive capabilities with numerous parameters to customize the HTTP command. To add an HTTP command to a resource, use the `WithHttpCommand` extension method on the resource builder. There are two overloads available:

The `WithHttpCommand` API provides two overloads to add custom HTTP commands to resources in Aspire. These APIs are designed to offer flexibility and cater to different use cases when defining HTTP commands.

1. **Overload with `endpointName`:**

   This version is ideal when you have a predefined endpoint name that the HTTP command should target. It simplifies the configuration by directly associating the command with a specific endpoint. This is useful in scenarios where the endpoint is static and well-known during development.

2. **Overload with `endpointSelector`:**

   This version provides more dynamic behavior by allowing you to specify a callback (`endpointSelector`) to determine the endpoint at runtime. This is useful when the endpoint might vary based on the resource’s state or other contextual factors. It offers greater flexibility for advanced scenarios where the endpoint can’t be hardcoded.

Both overloads allow you to customize the HTTP command extensively, providing an `HttpCommandOptions` subclass of the `CommandOptions` type, including specifying the HTTP method, configure the request, handling the response, and define UI-related properties like display name, description, and icons. The choice between the two depends on whether the endpoint is static or dynamic in your use case.

These APIs are designed to integrate seamlessly with the Aspire ecosystem, enabling developers to extend resource functionality with minimal effort while maintaining control over the behavior and presentation of the commands.

## Considerations when registering HTTP commands

[Section titled “Considerations when registering HTTP commands”](#considerations-when-registering-http-commands)

Since HTTP commands are exposed via HTTP endpoints, consider potential security risks. Limit these endpoints to development or staging environments when possible. Always validate incoming requests to ensure they originate from trusted sources. For more information, see [ASP.NET Core security](https://learn.microsoft.com/aspnet/core/security).

Use the `HttpCommandOptions.PrepareRequest` callback to enhance security by adding authentication headers or other measures. A common approach is to use a shared secret, [external parameter](/fundamentals/external-parameters/), or token known only to the AppHost and resource. This shared value can be used to validate requests and prevent unauthorized access.

## Add a custom HTTP command

[Section titled “Add a custom HTTP command”](#add-a-custom-http-command)

In your *AppHost.cs* file, you add a custom HTTP command using the `WithHttpCommand` API on an `IResourceBuilder<T>` where `T` is an `IResourceWithEndpoints`. Here’s an example of how to do this:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


var apiCacheInvalidationKey = builder.AddParameter("ApiCacheInvalidationKey", secret: true);


var api = builder.AddProject<Projects.AspireApp_Api>("api")
    .WithReference(cache)
    .WaitFor(cache)
    .WithEnvironment("ApiCacheInvalidationKey", apiCacheInvalidationKey)
    .WithHttpCommand(
        path: "/cache/invalidate",
        displayName: "Invalidate cache",
        commandOptions: new HttpCommandOptions()
        {
            Description = """
                Invalidates the API cache. All cached values are cleared!
                """,
            PrepareRequest = (context) =>
            {
                var key = apiCacheInvalidationKey.Resource.GetValueAsync(context.CancellationToken);
                context.Request.Headers.Add("X-CacheInvalidation-Key", $"Key: {key}");
                return Task.CompletedTask;
            },
            IconName = "DocumentLightning",
            IsHighlighted = true
        });


builder.Build().Run();
```

The preceding code:

* Creates a new distributed application builder.

* Adds a Redis cache named `cache` to the application.

* Adds a parameter named `ApiCacheInvalidationKey` to the application. This parameter is marked as a secret, meaning its value is treated securely.

* Adds a project named `AspireApp_Api` to the application.

* Adds a reference to the Redis cache and waits for it to be ready before proceeding.

* Configures an HTTP command for the project with the following:

  * `path`: Specifies the URL path for the HTTP command (`/cache/invalidate`).

  * `displayName`: Sets the name of the command as it appears in the UI (`Invalidate cache`).

  * `commandOptions`: An optional instance of `HttpCommandOptions` that configures the command’s behavior and appearance in the UI:

    * `Description`: Provides a description of the command that’s shown in the UI.
    * `PrepareRequest`: A callback function that configures the HTTP request before sending it. In this case, it adds a custom (`X-CacheInvalidation-Key`) header with the value of the `ApiCacheInvalidationKey` parameter.
    * `IconName`: Specifies the icon to be used for the command in the UI (`DocumentLightning`).
    * `IsHighlighted`: Indicates whether the command should be highlighted in the UI.

* Finally, the application is built and run.

To search for your own icons, browse the [Fluent UI: Icons catalog](https://storybooks.fluentui.dev/react/?path=/docs/icons-catalog--docs).

The HTTP endpoint is responsible for invalidating the cache. When the command is executed, it sends an HTTP request to the specified path (`/cache/invalidate`) with the configured parameters. Since there’s an added security measure, the request includes the `X-CacheInvalidation-Key` header with the value of the `ApiCacheInvalidationKey` parameter. This ensures that only authorized requests can trigger the cache invalidation process.

### Example HTTP endpoint

[Section titled “Example HTTP endpoint”](#example-http-endpoint)

The preceding AppHost code snippet defined a custom HTTP command that sends a request to the `/cache/invalidate` endpoint. The ASP.NET Core minimal API project defines an HTTP endpoint that handles the cache invalidation request. Consider the following code snippet from the project’s *Program.cs* file:

Program.cs

```csharp
app.MapPost("/cache/invalidate", static async (
    [FromHeader(Name = "X-CacheInvalidation-Key")] string? header,
    ICacheService registry,
    IConfiguration config) =>
{
    var hasValidHeader = config.GetValue<string>("ApiCacheInvalidationKey") is { } key
        && header == $"Key: {key}";


    if (hasValidHeader is false)
    {
        return Results.Unauthorized();
    }


    await registry.ClearAllAsync();


    return Results.Ok();
});
```

The preceding code:

* Assumes that the `app` variable is an instance of `IApplicationBuilder` and is set up to handle HTTP requests.
* Maps an HTTP POST endpoint at the path `/cache/invalidate`.
* The endpoint expects a header named `X-CacheInvalidation-Key` to be present in the request.
* It retrieves the value of the `ApiCacheInvalidationKey` parameter from the configuration.
* If the header value doesn’t match the expected key, it returns an unauthorized response.
* If the header is valid, it calls the `ClearAllAsync` method on the `ICacheService` to clear all cached items.
* Finally, it returns an HTTP OK response.

### Example dashboard experiences

[Section titled “Example dashboard experiences”](#example-dashboard-experiences)

The sample AppHost and corresponding ASP.NET Core minimal API projects demonstrate both sides of the HTTP command implementation. When you run the AppHost, the dashboard’s **Resources** page displays the custom HTTP command as a button. When you specify that the command should be highlighted (`isHighlighted: true`), the button appears on the **Actions** column of the **Resources** page. This allows users to easily trigger the command from the dashboard, as shown in the following screenshot:

![Aspire dashboard: Resources page showing a highlighted custom HTTP command.](/_astro/custom-http-command-highlighted.KpyBlFyo_ZKJumt.webp)

If you’re to omit the `isHighlighted` parameter, or set it to `false`, the command appears nested under the horizontal ellipsis menu (three dots) in the **Actions** column of the **Resources** page. This allows users to access the command without cluttering the UI with too many buttons. The following screenshot shows the same command appearing in the ellipsis menu:

![Aspire dashboard: Resources page showing a custom HTTP command in the ellipsis menu.](/_astro/custom-http-command.Csyb3ZED_Zdots7.webp)

When the user selects the button, the command is executed, and the HTTP request is sent to the specified endpoint. The dashboard provides feedback on the command’s execution status, allowing users to monitor the results. When it’s starting, a toast notification appears:

![Aspire dashboard: Toast notification showing the custom HTTP command is starting.](/_astro/custom-http-command-starting.CGp7008W_Z1GSx4F.webp)

When the command completes, the dashboard updates the status and provides feedback on whether it was successful or failed. The following screenshot shows a successful execution of the command:

![Aspire dashboard: Toast notification showing the custom HTTP command succeeded.](/_astro/custom-http-command-succeeded.Ccd5OMwA_Z5ivRu.webp)

# Launch profiles

> Learn how Aspire integrates with .NET launch profiles.

Aspire makes use of *launch profiles* defined in both the AppHost and service projects to simplify the process of configuring multiple aspects of the debugging and publishing experience for Aspire-based distributed applications.

## Launch profile basics

[Section titled “Launch profile basics”](#launch-profile-basics)

When creating a new .NET application from a template developers will often see a `Properties` directory which contains a file named *launchSettings.json*. The launch settings file contains a list of *launch profiles*. Each launch profile is a collection of related options which defines how you would like `dotnet` to start your application.

The code below is an example of launch profiles in a *launchSettings.json* file for an **ASP.NET Core** application.

JSON — launchSettings.json

```json
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5130",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "https://localhost:7106;http://localhost:5130",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

The *launchSettings.json* file above defines two *launch profiles*, `http` and `https`. Each has its own set of environment variables, launch URLs and other options. When launching a .NET Core application developers can choose which launch profile to use.

```bash
dotnet run --launch-profile https
```

If no launch profile is specified, then the first launch profile is selected by default. It is possible to launch a .NET Core application without a launch profile using the `--no-launch-profile` option. Some fields from the *launchSettings.json* file are translated to environment variables. For example, the `applicationUrl` field is converted to the `ASPNETCORE_URLS` environment variable which controls which address and port ASP.NET Core binds to.

When a .NET application is launched with a launch profile a special environment variable called `DOTNET_LAUNCH_PROFILE` is populated with the name of the launch profile that was used when launching the process.

## Launch profiles for Aspire AppHost

[Section titled “Launch profiles for Aspire AppHost”](#launch-profiles-for-aspire-apphost)

In Aspire, the AppHost is just a .NET application. As a result it has a `launchSettings.json` file just like any other application. Here is an example of the `launchSettings.json` file generated when creating a new Aspire project from the starter template (`dotnet new aspire-starter`).

JSON — launchSettings.json

```json
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:17134;http://localhost:15170",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "https://localhost:21030",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "https://localhost:22057"
      }
    },
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:15170",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "DOTNET_ENVIRONMENT": "Development",
        "ASPIRE_DASHBOARD_OTLP_ENDPOINT_URL": "http://localhost:19240",
        "ASPIRE_RESOURCE_SERVICE_ENDPOINT_URL": "http://localhost:20154"
      }
    }
  }
}
```

The Aspire templates have a very similar set of *launch profiles* to a regular ASP.NET Core application. When the Aspire app project launches, it starts a `DistributedApplication` and hosts a web-server which is used by the Aspire Dashboard to fetch information about resources which are being orchestrated by Aspire.

## AppHost launch profiles and service projects

[Section titled “AppHost launch profiles and service projects”](#apphost-launch-profiles-and-service-projects)

In Aspire the AppHost is responsible for coordinating the launch of multiple service projects. When you run the AppHost either via the command line or from Visual Studio (or other development environment) a launch profile is selected for the AppHost. In turn, the AppHost will attempt to find a matching launch profile in the service projects it is launching and use those options to control the environment and default networking configuration for the service project.

When the AppHost launches a service project it doesn’t simply launch the service project using the `--launch-profile` option. Therefore, there will be no `DOTNET_LAUNCH_PROFILE` environment variable set for service projects. This is because Aspire modifies the `ASPNETCORE_URLS` environment variable (derived from the `applicationUrl` field in the launch profile) to use a different port. By default, Aspire inserts a reverse proxy in front of the ASP.NET Core application to allow for multiple instances of the application using the `WithReplicas` method.

Other settings such as options from the `environmentVariables` field are passed through to the application without modification.

## Control launch profile selection

[Section titled “Control launch profile selection”](#control-launch-profile-selection)

Ideally, it’s possible to align the launch profile names between the AppHost and the service projects to make it easy to switch between configuration options on all projects coordinated by the AppHost at once. However, it may be desirable to control launch profile that a specific project uses. The `AddProject` extension method provides a mechanism to do this.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.InventoryService>(
    "inventoryservice",
    launchProfileName: "mylaunchprofile");
```

The preceding code shows that the `inventoryservice` resource (a .NET project) is launched using the options from the `mylaunchprofile` launch profile. The launch profile precedence logic is as follows:

1. Use the launch profile specified by `launchProfileName` argument if specified.
2. Use the launch profile with the same name as the AppHost (determined by reading the `DOTNET_LAUNCH_PROFILE` environment variable).
3. Use the default (first) launch profile in *launchSettings.json*.
4. Don’t use a launch profile.

To force a service project to launch without a launch profile the `launchProfileName` argument on the `AddProject` method can be set to null.

## Launch profiles and endpoints

[Section titled “Launch profiles and endpoints”](#launch-profiles-and-endpoints)

When adding an ASP.NET Core project to the AppHost, Aspire will parse the *launchSettings.json* file selecting the appropriate launch profile and automatically generate endpoints in the application model based on the URL(s) present in the `applicationUrl` field. To modify the endpoints that are automatically injected the `WithEndpoint` extension method.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.InventoryService>("inventoryservice")
       .WithEndpoint("https", endpoint => endpoint.IsProxied = false);
```

The preceding code shows how to disable the reverse proxy that Aspire deploys in front for the .NET Core application and instead allows the .NET Core application to respond directly on requests over HTTP(S).

# Inner-loop networking overview

> Learn how Aspire handles networking and endpoints, and how you can use them in your app code.

One of the advantages of developing with Aspire is that it enables you to develop, test, and debug cloud-native apps locally. Inner-loop networking is a key aspect of Aspire that allows your apps to communicate with each other in your development environment. In this article, you learn how Aspire handles various networking scenarios with proxies, endpoints, endpoint configurations, and launch profiles.

## Networking in the inner loop

[Section titled “Networking in the inner loop”](#networking-in-the-inner-loop)

The inner loop is the process of developing and testing your app locally before deploying it to a target environment. Aspire provides several tools and features to simplify and enhance the networking experience in the inner loop, such as:

* **Launch profiles**: Launch profiles are configuration files that specify how to run your app locally. You can use launch profiles (such as the *launchSettings.json* file) to define the endpoints, environment variables, and launch settings for your app.
* **Kestrel configuration**: Kestrel configuration allows you to specify the endpoints that the Kestrel web server listens on. You can configure Kestrel endpoints in your app settings, and Aspire automatically uses these settings to create endpoints.
* **Endpoints/Endpoint configurations**: Endpoints are the connections between your app and the services it depends on, such as databases, message queues, or APIs. Endpoints provide information such as the service name, host port, scheme, and environment variable. You can add endpoints to your app either implicitly (via launch profiles) or explicitly by calling `WithEndpoint`.
* **Proxies**: Aspire automatically launches a proxy for each service binding you add to your app, and assigns a port for the proxy to listen on. The proxy then forwards the requests to the port that your app listens on, which might be different from the proxy port. This way, you can avoid port conflicts and access your app and services using consistent and predictable URLs.

## How endpoints work

[Section titled “How endpoints work”](#how-endpoints-work)

A service binding in Aspire involves two integrations: a **service** representing an external resource your app requires (for example, a database, message queue, or API), and a **binding** that establishes a connection between your app and the service and provides necessary information.

Aspire supports two service binding types: **implicit**, automatically created based on specified launch profiles defining app behavior in different environments, and **explicit**, manually created using `WithEndpoint`.

Upon creating a binding, whether implicit or explicit, Aspire launches a lightweight reverse proxy on a specified port, handling routing and load balancing for requests from your app to the service. The proxy is an Aspire implementation detail, requiring no configuration or management concern.

To help visualize how endpoints work, consider the Aspire starter templates inner-loop networking diagram:

![Aspire Starter Application template inner loop networking diagram.](/_astro/networking-proxies-1x.Bi77RELV_Z1ljKei.webp)

## How container networks are managed

[Section titled “How container networks are managed”](#how-container-networks-are-managed)

When you add one or more container resources, Aspire creates a dedicated container bridge network to enable service discovery between containers. This bridge network is a virtual network that lets containers communicate with each other and provides a DNS server for container-to-container service discovery using DNS names.

The network’s lifetime depends on the container resources:

* If all containers have a session lifetime, the network is also session-based and is cleaned up when the AppHost process ends.
* If any container has a persistent lifetime, the network is persistent and remains running after the AppHost process terminates. Aspire reuses this network on subsequent runs, allowing persistent containers to keep communicating even when the AppHost isn’t running.

For more information on container lifetimes, see [Persistent container lifetimes](/app-host/persistent-containers/).

Here are the naming conventions for container networks:

* **Session networks**: `aspire-session-network-<unique-id>-<app-host-name>`
* **Persistent networks**: `aspire-persistent-network-<project-hash>-<app-host-name>`

Each AppHost instance gets its own network resources. The only differences are the network’s lifetime and name; service discovery works the same way for both.

Containers register themselves on the network using their resource name. Aspire uses this name for service discovery between containers. For example, a `pgadmin` container can connect to a database resource named `postgres` using `postgres:5432`.

Note

Host services, such as projects or other executables, don’t use container networks. They rely on exposed container ports for service discovery and communication with containers. For more details on service discovery, see [service discovery](/fundamentals/service-discovery/).

## Launch profiles

[Section titled “Launch profiles”](#launch-profiles)

When you call `AddProject`, the AppHost looks for *Properties/launchSettings.json* to determine the default set of endpoints. The AppHost selects a specific launch profile using the following rules:

1. An explicit `launchProfileName` argument passed when calling `AddProject`.
2. The `DOTNET_LAUNCH_PROFILE` environment variable. For more information, see [.NET environment variables](https://learn.microsoft.com/dotnet/core/tools/dotnet-environment-variables).
3. The first launch profile defined in *launchSettings.json*.

Consider the following *launchSettings.json* file:

launchSettings.json

```json
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "inspectUri": "{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}",
      "applicationUrl": "https://localhost:7239;http://localhost:5066",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

For the remainder of this article, imagine that you’ve created an `IDistributedApplicationBuilder` assigned to a variable named `builder` with the `DistributedApplication.CreateBuilder` API:

```csharp
var builder = DistributedApplication.CreateBuilder(args);
```

To specify the **http** and **https** launch profiles, configure the `applicationUrl` values for both in the *launchSettings.json* file. These URLs are used to create endpoints for this project. This is the equivalent of:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_Frontend>("frontend")
       .WithHttpEndpoint(port: 5066)
       .WithHttpsEndpoint(port: 7239);
```

Caution

If there’s no *launchSettings.json* (or launch profile), there are no bindings by default.

For more information, see [Launch profiles](/fundamentals/launch-profiles/).

## Kestrel configured endpoints

[Section titled “Kestrel configured endpoints”](#kestrel-configured-endpoints)

Aspire supports Kestrel endpoint configuration. For example, consider an *appsettings.json* file for a project that defines a Kestrel endpoint with the HTTPS scheme and port 5271:

appsettings.Development.json

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Kestrel": {
    "Endpoints": {
      "Https": {
        "Url": "https://*:5271"
      }
    }
  }
}
```

The preceding configuration specifies an `Https` endpoint. The `Url` property is set to `https://*:5271`, which means the endpoint listens on all interfaces on port 5271. For more information, see [Configure endpoints for the ASP.NET Core Kestrel web server](https://learn.microsoft.com/aspnet/core/fundamentals/servers/kestrel/endpoints).

With the Kestrel endpoint configured, the project should remove any configured `applicationUrl` from the *launchSettings.json* file.

Note

If the `applicationUrl` is present in the *launchSettings.json* file and the Kestrel endpoint is configured, the AppHost will throw an exception.

When you add a project resource, there’s an overload that lets you specify that the Kestrel endpoint should be used instead of the *launchSettings.json* file:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_ApiService>(
    name: "apiservice",
    configure: static project =>
    {
        project.ExcludeLaunchProfile = true;
        project.ExcludeKestrelEndpoints = false;
    })
    .WithHttpsEndpoint();
```

For more information, see `AddProject`.

## Ports and proxies

[Section titled “Ports and proxies”](#ports-and-proxies)

When defining a service binding, the host port is *always* given to the proxy that sits in front of the service. This allows single or multiple replicas of a service to behave similarly. Additionally, all resource dependencies that use the `WithReference` API rely of the proxy endpoint from the environment variable.

Consider the following method chain that calls `AddProject`, `WithHttpEndpoint`, and then `WithReplicas`:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_Frontend>("frontend")
       .WithHttpEndpoint(port: 5066)
       .WithReplicas(2);
```

The preceding code results in the following networking diagram:

![Aspire frontend app networking diagram with specific host port and two replicas.](/_astro/proxy-with-replicas-1x.BGWR1mXN_1M08yY.webp)

The preceding diagram depicts the following:

* A web browser as an entry point to the app.
* A host port of 5066.
* The frontend proxy sitting between the web browser and the frontend service replicas, listening on port 5066.
* The `frontend_0` frontend service replica listening on the randomly assigned port 65001.
* The `frontend_1` frontend service replica listening on the randomly assigned port 65002.

Without the call to `WithReplicas`, there’s only one frontend service. The proxy still listens on port 5066, but the frontend service listens on a random port:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_Frontend>("frontend")
       .WithHttpEndpoint(port: 5066);
```

There are two ports defined:

* A host port of 5066.
* A random proxy port that the underlying service will be bound to.

![Aspire frontend app networking diagram with specific host port and random port.](/_astro/proxy-host-port-and-random-port-1x.BUrbCq37_Db7wx.webp)

The preceding diagram depicts the following:

* A web browser as an entry point to the app.
* A host port of 5066.
* The frontend proxy sitting between the web browser and the frontend service, listening on port 5066.
* The frontend service listening on random port of 65001.

The underlying service is fed this port via `ASPNETCORE_URLS` for project resources. Other resources access to this port by specifying an environment variable on the service binding:

AppHost.cs

```csharp
builder.AddNpmApp("frontend", "../NodeFrontend", "watch")
       .WithHttpEndpoint(port: 5067, env: "PORT");
```

The previous code makes the random port available in the `PORT` environment variable. The app uses this port to listen to incoming connections from the proxy. Consider the following diagram:

![Aspire frontend app networking diagram with specific host port and environment variable port.](/_astro/proxy-with-env-var-port-1x.la53RVXR_1gWqcJ.webp)

The preceding diagram depicts the following:

* A web browser as an entry point to the app.
* A host port of 5067.
* The frontend proxy sitting between the web browser and the frontend service, listening on port 5067.
* The frontend service listening on an environment 65001.

Tip

To avoid an endpoint being proxied, set the `IsProxied` property to `false` when calling the `WithEndpoint` extension method. For more information, see [Endpoint extensions: additional considerations](#additional-considerations).

## Omit the host port

[Section titled “Omit the host port”](#omit-the-host-port)

When you omit the host port, Aspire generates a random port for both host and service port. This is useful when you want to avoid port conflicts and don’t care about the host or service port. Consider the following code:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_Frontend>("frontend")
       .WithHttpEndpoint();
```

In this scenario, both the host and service ports are random, as shown in the following diagram:

![Aspire frontend app networking diagram with random host port and proxy port.](/_astro/proxy-with-random-ports-1x.BX4ey4e4_ZnILKL.webp)

The preceding diagram depicts the following:

* A web browser as an entry point to the app.
* A random host port of 65000.
* The frontend proxy sitting between the web browser and the frontend service, listening on port 65000.
* The frontend service listening on a random port of 65001.

## Container ports

[Section titled “Container ports”](#container-ports)

When you add a container resource, Aspire automatically assigns a random port to the container. To specify a container port, configure the container resource with the desired port:

AppHost.cs

```csharp
builder.AddContainer("frontend", "mcr.microsoft.com/dotnet/samples", "aspnetapp")
           .WithHttpEndpoint(port: 8000, targetPort: 8080);
```

The preceding code:

* Creates a container resource named `frontend`, from the `mcr.microsoft.com/dotnet/samples:aspnetapp` image.
* Exposes an `http` endpoint by binding the host to port 8000 and mapping it to the container’s port 8080.

Consider the following diagram:

![Aspire frontend app networking diagram with a docker host.](/_astro/proxy-with-docker-port-mapping-1x.CEavizhj_NT9G0.webp)

## Endpoint extension methods

[Section titled “Endpoint extension methods”](#endpoint-extension-methods)

Any resource that implements the `IResourceWithEndpoints` interface can use the `WithEndpoint` extension methods. There are several overloads of this extension, allowing you to specify the scheme, container port, host port, environment variable name, and whether the endpoint is proxied.

There’s also an overload that allows you to specify a delegate to configure the endpoint. This is useful when you need to configure the endpoint based on the environment or other factors. Consider the following code:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_ApiService>("apiService")
       .WithEndpoint(
            endpointName: "admin",
            callback: static endpoint =>
       {
           endpoint.Port = 17003;
           endpoint.UriScheme = "http";
           endpoint.Transport = "http";
       });
```

The preceding code provides a callback delegate to configure the endpoint. The endpoint is named `admin` and configured to use the `http` scheme and transport, as well as the 17003 host port. The consumer references this endpoint by name, consider the following `AddHttpClient` call:

```csharp
builder.Services.AddHttpClient<WeatherApiClient>(
    client => client.BaseAddress = new Uri("http://_admin.apiservice"));
```

The `Uri` is constructed using the `admin` endpoint name prefixed with the `_` sentinel. This is a convention to indicate that the `admin` segment is the endpoint name belonging to the `apiservice` service. For more information, see [Service discovery](/fundamentals/service-discovery/).

### Additional considerations

[Section titled “Additional considerations”](#additional-considerations)

When calling the `WithEndpoint` extension method, the `callback` overload exposes the raw `EndpointAnnotation`, which allows the consumer to customize many aspects of the endpoint.

The `AllocatedEndpoint` property allows you to get or set the endpoint for a service. The `IsExternal` and `IsProxied` properties determine how the endpoint is managed and exposed: `IsExternal` decides if it should be publicly accessible, while `IsProxied` ensures DCP manages it, allowing for internal port differences and replication.

Tip

If you’re hosting an external executable that runs its own proxy and encounters port binding issues due to DCP already binding the port, try setting the `IsProxied` property to `false`. This prevents DCP from managing the proxy, allowing your executable to bind the port successfully.

The `Name` property identifies the service, whereas the `Port` and `TargetPort` properties specify the desired and listening ports, respectively.

For network communication, the `Protocol` property supports **TCP** and **UDP**, with potential for more in the future, and the `Transport` property indicates the transport protocol (**HTTP**, **HTTP2**, **HTTP3**). Lastly, if the service is URI-addressable, the `UriScheme` property provides the URI scheme for constructing the service URI.

For more information, see the available properties of the [EndpointAnnotation properties](https://learn.microsoft.com/dotnet/api/aspire.hosting.applicationmodel.endpointannotation#properties).

## Endpoint filtering

[Section titled “Endpoint filtering”](#endpoint-filtering)

All Aspire project resource endpoints follow a set of default heuristics. Some endpoints are included in `ASPNETCORE_URLS` at runtime, some are published as `HTTP/HTTPS_PORTS`, and some configurations are resolved from Kestrel configuration. Regardless of the default behavior, you can filter the endpoints that are included in environment variables by using the `WithEndpointsInEnvironment` extension method:

AppHost.cs

```csharp
builder.AddProject<Projects.Networking_ApiService>("apiservice")
    .WithHttpsEndpoint() // Adds a default "https" endpoint
    .WithHttpsEndpoint(port: 19227, name: "admin")
    .WithEndpointsInEnvironment(
        filter: static endpoint =>
        {
            return endpoint.Name is not "admin";
        });
```

The preceding code adds a default HTTPS endpoint, as well as an `admin` endpoint on port 19227. However, the `admin` endpoint is excluded from the environment variables. This is useful when you want to expose an endpoint for internal use only.

# Persist Aspire project data using volumes or bind mounts

> Learn about Aspire configurations that persist data across restarts by using volumes and bind mounts in containers.

Every time you start and stop an Aspire project, the app also creates and destroys the app resource containers. Any data or files stored in those containers during a debugging session is lost for subsequent sessions. Many development teams prefer to keep this data across debugging sessions so that, for example, they don’t have to repopulate a database with sample data for each run.

In this article, you learn how to configure Aspire projects to persist data across app launches. A continuous set of data during local development is useful in many scenarios. Various Aspire resource container types are able to leverage volumes and bind mounts, such as PostgreSQL, Redis and Azure Storage.

## When to persist project data

[Section titled “When to persist project data”](#when-to-persist-project-data)

Suppose you have an Aspire solution with a database resource. By default, data is saved in the container for that resource. Because all the resource containers are destroyed when you stop your app, you lose that data and won’t see it the next time you run the solution. This setup creates problems when you want to persist data in a database or storage services between app launches for testing or debugging. For example, you may want to:

* Work with a continuous set of data in a database during an extended development session across multiple restarts.
* Test or debug a changing set of files in an Azure Blob Storage emulator.
* Maintain cached data or messages in a Redis instance across app launches.

You can accomplish these goals using volumes or bind mounts. These objects store data outside the container in a directory on the container host, so it’s not destroyed with the container. This way, you decide which services retain data between launches of your Aspire project.

Note

Volumes and bind mounts are features of your container runtime: Docker or Podman. Aspire includes methods that make it easy to work with those features.

## Compare volumes and bind mounts

[Section titled “Compare volumes and bind mounts”](#compare-volumes-and-bind-mounts)

Both volumes and bind mounts store data in a directory on the container host. Because this directory is outside the container, data isn’t destroyed when the container stops. Volumes and bind mounts, however behave differently:

* **Volumes**: The container runtime creates and controls volumes. Volumes are isolated from the core functionality of the container host.
* **Bind mounts**: The container runtime mounts a file or directory on the host machine. Both the container and the host machine can access the contents of the bind mount.

Volumes are more secure and portable than bind mounts. They also perform better and you should use them wherever possible. Use bind mounts only if you need to access or modify the data from your host machine.

## Use volumes

[Section titled “Use volumes”](#use-volumes)

Volumes are the recommended way to persist data generated by containers and they’re supported on both Windows and Linux. Volumes can store data from multiple containers at a time, offer high performance, and are easy to back up or migrate. With Aspire, you configure a volume for each resource container using the `WithVolume` method, which accepts three parameters:

* **`name`**: An optional name for the volume.
* **`target`**: The target path in the container of the data you want to persist.
* **`isReadOnly`**: A Boolean flag that indicates whether the data in the volume can be changed. The default value is `false`.

For the remainder of this article, imagine that you’re exploring a `Program` class in an Aspire [AppHost project](/get-started/app-host/) that’s already defined the distributed app builder bits:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// TODO:
//   Consider various code snippets for configuring
//   volumes here and persistent passwords.


builder.Build().Run();
```

The first code snippet to consider uses the `WithVolume` API to configure a volume for a SQL Server resource. The following code demonstrates how to configure a volume for a SQL Server resource in an Aspire AppHost project:

```csharp
var sql = builder.AddSqlServer("sql")
                 .WithVolume(target: "/var/opt/mssql")
                 .AddDatabase("sqldb");
```

In this example `/var/opt/mssql` sets the path to the database files in the container.

All Aspire container resources can utilize volumes, and some provide convenient APIs for adding named volumes derived from resources. Using the `WithDataVolume` method as an example, the following code is functionally equivalent to the previous example but more succinct:

```csharp
var sql = builder.AddSqlServer("sql")
                 .WithDataVolume()
                 .AddDatabase("sqldb");
```

With the AppHost project being named `VolumeMount.AppHost`, the `WithDataVolume` method automatically creates a named volume as `VolumeMount.AppHost-sql-data` and is mounted to the `/var/opt/mssql` path in the SQL Server container. The naming convention is as follows:

* `{appHostProjectName}-{resourceName}-data`: The volume name is derived from the AppHost project name and the resource name.

## Use bind mounts

[Section titled “Use bind mounts”](#use-bind-mounts)

Bind mounts enable access to the data from both within the container and from processes on the host machine. For example, once a bind mount is established, you can copy a file into it on your host computer. The file is then available at the bound path within the container for your resource. With Aspire, you configure a bind mount for each resource container using the `WithBindMount` method, which accepts three parameters:

* **`source`**: The path to the folder on the host machine to mount in the container.
* **`target`**: The target path in the container for the folder.
* **`isReadOnly`**: A Boolean flag that indicates whether the data in the bind mount can be changed. The default value is `false`.

Consider this code snippet, which uses the `WithBindMount` API to configure a bind mount for a SQL Server resource:

```csharp
var sql = builder.AddSqlServer("sql")
                 .WithBindMount(source: @"C:\SqlServer\Data", target: "/var/opt/mssql")
                 .AddDatabase("sqldb");
```

In this example:

* `source: @"C:\SqlServer\Data"` sets the folder on the host computer that will be bound.
* `target: "/var/opt/mssql"` sets the path to the database files in the container.

As for volumes, some Aspire container resources provide convenient APIs for adding bind mounts. Using the `WithDataBindMount` method as an example, the following code is functionally equivalent to the previous example but more succinct:

```csharp
var sql = builder.AddSqlServer("sql")
                 .WithDataBindMount(source: @"C:\SqlServer\Data")
                 .AddDatabase("sqldb");
```

## Create persistent passwords

[Section titled “Create persistent passwords”](#create-persistent-passwords)

Named volumes require a consistent password between app launches. Aspire conveniently provides random password generation functionality. Consider the previous example once more, where a password is generated automatically:

```csharp
var sql = builder.AddSqlServer("sql")
                 .WithDataVolume()
                 .AddDatabase("sqldb");
```

Since the `password` parameter isn’t provided when calling `AddSqlServer`, Aspire automatically generates a password for the SQL Server resource.

Caution

This isn’t a persistent password! Instead, it changes every time the AppHost runs.

To create a *persistent* password, you must override the generated password. To do this, run the following command in your AppHost project directory to set a local password in your .NET user secrets:

.NET CLI

```bash
dotnet user-secrets set Parameters:sql-password <password>
```

The naming convention for these secrets is important to understand. The password is stored in configuration with the `Parameters:sql-password` key. The naming convention follows this pattern:

* `Parameters:{resourceName}-password`: In the case of the SQL Server resource (which was named `"sql"`), the password is stored in the configuration with the key `Parameters:sql-password`.

The same pattern applies to the other server-based resource types, such as those shown in the following table:

| Resource type | Hosting package                                                                          | Example resource name | Override key                     |
| ------------- | ---------------------------------------------------------------------------------------- | --------------------- | -------------------------------- |
| MySQL         | [📦 Aspire.Hosting.MySql](https://www.nuget.org/packages/Aspire.Hosting.MySql)           | `mysql`               | `Parameters:mysql-password`      |
| Oracle        | [📦 Aspire.Hosting.Oracle](https://www.nuget.org/packages/Aspire.Hosting.Oracle)         | `oracle`              | `Parameters:oracle-password`     |
| PostgreSQL    | [📦 Aspire.Hosting.PostgreSQL](https://www.nuget.org/packages/Aspire.Hosting.PostgreSQL) | `postgresql`          | `Parameters:postgresql-password` |
| RabbitMQ      | [📦 Aspire.Hosting.RabbitMq](https://www.nuget.org/packages/Aspire.Hosting.RabbitMq)     | `rabbitmq`            | `Parameters:rabbitmq-password`   |
| SQL Server    | [📦 Aspire.Hosting.SqlServer](https://www.nuget.org/packages/Aspire.Hosting.SqlServer)   | `sql`                 | `Parameters:sql-password`        |

By overriding the generated password, you can ensure that the password remains consistent between app launches. An alternative approach is to use the `AddParameter` method to create a parameter that can be used as a password. The following code demonstrates how to create a persistent password for a SQL Server resource:

```csharp
var sqlPassword = builder.AddParameter("sql-password", secret: true);


var sql = builder.AddSqlServer("sql", password: sqlPassword)
                 .WithDataVolume()
                 .AddDatabase("sqldb");
```

The `AddParameter` method is used to create a parameter named `sql-password` that’s considered a secret. The `AddSqlServer` method is then called with the `password` parameter to set the password for the SQL Server resource. For more information, see [External parameters](/fundamentals/external-parameters/).

## Next steps

[Section titled “Next steps”](#next-steps)

You can apply the volume concepts in the preceding code to a variety of services, including seeding a database with data that will persist across app launches. Try combining these techniques with the resource implementations demonstrated in the following tutorials:

* [Tutorial: Connect an ASP.NET Core app to SQL Server using Aspire and Entity Framework Core](/integrations/databases/efcore/sql-server/sql-server-get-started/)
* [Aspire orchestration overview](/get-started/app-host/)

# Service defaults

> Learn about the Aspire service defaults project.

In this article, you learn about the Aspire service defaults project, a set of extension methods that:

* Connect telemetry, health checks, and service discovery to your app.
* Are customizable and extensible.

Cloud-native applications often require extensive configurations to ensure they work across different environments reliably and securely. Aspire provides many helper methods and tools to streamline the management of configurations for OpenTelemetry, health checks, environment variables, and more.

## Explore the service defaults project

[Section titled “Explore the service defaults project”](#explore-the-service-defaults-project)

When you either **Enlist in Aspire orchestration** or create a new Aspire project, the *YourAppName.ServiceDefaults.csproj* project is added to your solution. For example, when building an API, you call the `AddServiceDefaults` method in the *Program.cs* file of your apps:

```csharp
builder.AddServiceDefaults();
```

The `AddServiceDefaults` method handles the following tasks:

* Configures OpenTelemetry metrics and tracing.
* Adds default health check endpoints.
* Adds service discovery functionality.
* Configures `HttpClient` to work with service discovery.

For more information, see [Provided extension methods](#provided-extension-methods) for details on the `AddServiceDefaults` method.

Caution

The Aspire service defaults project is specifically designed for sharing the *Extensions.cs* file and its functionality. Don’t include other shared functionality or models in this project. Use a conventional shared class library project for those purposes.

## Project characteristics

[Section titled “Project characteristics”](#project-characteristics)

The *YourAppName.ServiceDefaults* project is a .NET 10.0 library that contains the following XML:

YourAppName.ServiceDefaults.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsAspireSharedProject>true</IsAspireSharedProject>
  </PropertyGroup>


  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />


    <PackageReference Include="Microsoft.Extensions.Http.Resilience" Version="10.0.0" />
    <PackageReference Include="Microsoft.Extensions.ServiceDiscovery" Version="10.0.0" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.12.0" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.12.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.12.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.12.0" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" Version="1.12.0" />
  </ItemGroup>


</Project>
```

The service defaults project template imposes a `FrameworkReference` dependency on `Microsoft.AspNetCore.App`.

Tip

If you don’t want to take a dependency on `Microsoft.AspNetCore.App`, you can create a custom service defaults project. For more information, see [Custom service defaults](#custom-service-defaults).

The `IsAspireSharedProject` property is set to `true`, which indicates that this project is a shared project. The Aspire tooling uses this project as a reference for other projects added to an Aspire solution. When you enlist the new project for orchestration, it automatically references the *YourAppName.ServiceDefaults* project and updates the *Program.cs* file to call the `AddServiceDefaults` method.

## Provided extension methods

[Section titled “Provided extension methods”](#provided-extension-methods)

The *YourAppName.ServiceDefaults* project exposes a single *Extensions.cs* file that contains several opinionated extension methods:

* `AddServiceDefaults`: Adds service defaults functionality.
* `ConfigureOpenTelemetry`: Configures OpenTelemetry metrics and tracing.
* `AddDefaultHealthChecks`: Adds default health check endpoints.
* `MapDefaultEndpoints`: Maps the health checks endpoint to `/health` and the liveness endpoint to `/alive`.

### Add service defaults functionality

[Section titled “Add service defaults functionality”](#add-service-defaults-functionality)

The `AddServiceDefaults` method defines default configurations with the following opinionated functionality:

Extensions.cs

```csharp
public static TBuilder AddServiceDefaults<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
{
    builder.ConfigureOpenTelemetry();


    builder.AddDefaultHealthChecks();


    builder.Services.AddServiceDiscovery();


    builder.Services.ConfigureHttpClientDefaults(http =>
    {
        // Turn on resilience by default
        http.AddStandardResilienceHandler();


        // Turn on service discovery by default
        http.AddServiceDiscovery();
    });


    // Uncomment the following to restrict the allowed schemes for service discovery.
    // builder.Services.Configure<ServiceDiscoveryOptions>(options =>
    // {
    //     options.AllowedSchemes = ["https"];
    // });


    return builder;
}
```

The preceding code:

* Configures OpenTelemetry metrics and tracing, by calling the `ConfigureOpenTelemetry` method.

* Adds default health check endpoints, by calling the `AddDefaultHealthChecks` method.

* Adds [service discovery](/fundamentals/service-discovery/) functionality, by calling the `AddServiceDiscovery` method.

* Configures `HttpClient` defaults, by calling the `ConfigureHttpClientDefaults` method—which is based on [Build resilient HTTP apps: Key development patterns](https://learn.microsoft.com/dotnet/core/resilience/http-resilience):

  * Adds the standard HTTP resilience handler, by calling the `AddStandardResilienceHandler` method.
  * Specifies that the `IHttpClientBuilder` should use service discovery, by calling the `AddServiceDiscovery` method.

* Returns the `IHostApplicationBuilder` instance to allow for method chaining.

### OpenTelemetry configuration

[Section titled “OpenTelemetry configuration”](#opentelemetry-configuration)

Telemetry is a critical part of any cloud-native application. Aspire provides a set of opinionated defaults for OpenTelemetry, which are configured with the `ConfigureOpenTelemetry` method:

Extensions.cs

```csharp
public static TBuilder ConfigureOpenTelemetry<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
{
    builder.Logging.AddOpenTelemetry(logging =>
    {
        logging.IncludeFormattedMessage = true;
        logging.IncludeScopes = true;
    });


    builder.Services.AddOpenTelemetry()
        .WithMetrics(metrics =>
        {
            metrics.AddAspNetCoreInstrumentation()
                .AddHttpClientInstrumentation()
                .AddRuntimeInstrumentation();
        })
        .WithTracing(tracing =>
        {
            tracing.AddSource(builder.Environment.ApplicationName)
                .AddAspNetCoreInstrumentation(tracing =>
                    // Exclude health check requests from tracing
                    tracing.Filter = context =>
                        !context.Request.Path.StartsWithSegments(HealthEndpointPath)
                            && !context.Request.Path.StartsWithSegments(AlivenessEndpointPath)
                )
                // Uncomment the following line to enable gRPC instrumentation (requires the OpenTelemetry.Instrumentation.GrpcNetClient package)
                //.AddGrpcClientInstrumentation()
                .AddHttpClientInstrumentation();
        });


    builder.AddOpenTelemetryExporters();


    return builder;
}
```

The `ConfigureOpenTelemetry` method:

* Adds Aspire telemetry logging to include formatted messages and scopes.

* Adds OpenTelemetry metrics and tracing that include:

  * Runtime instrumentation metrics.
  * ASP.NET Core instrumentation metrics.
  * HttpClient instrumentation metrics.
  * In a development environment, the `AlwaysOnSampler` is used to view all traces.
  * Tracing details for ASP.NET Core, gRPC and HTTP instrumentation.

* Adds OpenTelemetry exporters, by calling `AddOpenTelemetryExporters`.

The `AddOpenTelemetryExporters` method is defined privately as follows:

Extensions.cs

```csharp
private static TBuilder AddOpenTelemetryExporters<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
{
    var useOtlpExporter = !string.IsNullOrWhiteSpace(builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);


    if (useOtlpExporter)
    {
        builder.Services.AddOpenTelemetry().UseOtlpExporter();
    }


    // Uncomment the following lines to enable the Azure Monitor exporter (requires the Azure.Monitor.OpenTelemetry.AspNetCore package)
    //if (!string.IsNullOrEmpty(builder.Configuration["APPLICATIONINSIGHTS_CONNECTION_STRING"]))
    //{
    //    builder.Services.AddOpenTelemetry()
    //       .UseAzureMonitor();
    //}


    return builder;
}
```

The `AddOpenTelemetryExporters` method adds OpenTelemetry exporters based on the following conditions:

* If the `OTEL_EXPORTER_OTLP_ENDPOINT` environment variable is set, the OpenTelemetry exporter is added.
* Optionally consumers of Aspire service defaults can uncomment some code to enable the Prometheus exporter, or the Azure Monitor exporter.

### Health checks configuration

[Section titled “Health checks configuration”](#health-checks-configuration)

Health checks are used by various tools and systems to assess the readiness of your app. Aspire provides a set of opinionated defaults for health checks, which are configured with the `AddDefaultHealthChecks` method:

Extensions.cs

```csharp
public static TBuilder AddDefaultHealthChecks<TBuilder>(this TBuilder builder) where TBuilder : IHostApplicationBuilder
{
    builder.Services.AddHealthChecks()
        // Add a default liveness check to ensure app is responsive
        .AddCheck("self", () => HealthCheckResult.Healthy(), ["live"]);


    return builder;
}
```

The `AddDefaultHealthChecks` method adds a default liveness check to ensure the app is responsive. The call to `AddHealthChecks` registers the `HealthCheckService`.

#### Web app health checks configuration

[Section titled “Web app health checks configuration”](#web-app-health-checks-configuration)

To expose health checks in a web app, Aspire automatically determines the type of project being referenced within the solution, and adds the appropriate call to `MapDefaultEndpoints`:

Extensions.cs

```csharp
public static WebApplication MapDefaultEndpoints(this WebApplication app)
{
    // Adding health checks endpoints to applications in non-development environments has security implications.
    // See https://aka.ms/dotnet/aspire/healthchecks for details before enabling these endpoints in non-development environments.
    if (app.Environment.IsDevelopment())
    {
        // All health checks must pass for app to be considered ready to accept traffic after starting
        app.MapHealthChecks(HealthEndpointPath);


        // Only health checks tagged with the "live" tag must pass for app to be considered alive
        app.MapHealthChecks(AlivenessEndpointPath, new HealthCheckOptions
        {
            Predicate = r => r.Tags.Contains("live")
        });
    }


    return app;
}
```

The `MapDefaultEndpoints` method:

* Allows consumers to optionally uncomment some code to enable the Prometheus endpoint.
* Maps the health checks endpoint to `/health`.
* Maps the liveness endpoint to `/alive` route where the health check tag contains `live`.

Note

Starting with Aspire 9.2, the starter template has been updated to include a call to `WithHttpsHealthCheck` for ASP.NET Core projects. To keep the request trace logs cleaner during development, traces for the configured health endpoints (`/health` and `/alive`) are now excluded by default in the **Service Defaults** project template.

## Custom service defaults

[Section titled “Custom service defaults”](#custom-service-defaults)

If the default service configuration provided by the project template is not sufficient for your needs, you have the option to create your own service defaults project. This is especially useful when your consuming project, such as a Worker project or WinForms project, cannot or does not want to have a `FrameworkReference` dependency on `Microsoft.AspNetCore.App`.

To do this, create a new .NET 9.0 class library project and add the necessary dependencies to the project file, consider the following example:

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <OutputType>Library</OutputType>
    <TargetFramework>net9.0</TargetFramework>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Hosting" />
    <PackageReference Include="Microsoft.Extensions.ServiceDiscovery" />
    <PackageReference Include="Microsoft.Extensions.Http.Resilience" />
    <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" />
    <PackageReference Include="OpenTelemetry.Extensions.Hosting" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Http" />
    <PackageReference Include="OpenTelemetry.Instrumentation.Runtime" />
  </ItemGroup>
</Project>
```

Then create an extensions class that contains the necessary methods to configure the app defaults:

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTelemetry.Logs;
using OpenTelemetry.Metrics;
using OpenTelemetry.Trace;


namespace Microsoft.Extensions.Hosting;


public static class AppDefaultsExtensions
{
    public static IHostApplicationBuilder AddAppDefaults(
        this IHostApplicationBuilder builder)
    {
        builder.ConfigureAppOpenTelemetry();


        builder.Services.AddServiceDiscovery();


        builder.Services.ConfigureHttpClientDefaults(http =>
        {
            // Turn on resilience by default
            http.AddStandardResilienceHandler();


            // Turn on service discovery by default
            http.AddServiceDiscovery();
        });


        return builder;
    }


    public static IHostApplicationBuilder ConfigureAppOpenTelemetry(
        this IHostApplicationBuilder builder)
    {
        builder.Logging.AddOpenTelemetry(logging =>
        {
            logging.IncludeFormattedMessage = true;
            logging.IncludeScopes = true;
        });


        builder.Services.AddOpenTelemetry()
            .WithMetrics(static metrics =>
            {
                metrics.AddRuntimeInstrumentation();
            })
            .WithTracing(tracing =>
            {
                if (builder.Environment.IsDevelopment())
                {
                    // We want to view all traces in development
                    tracing.SetSampler(new AlwaysOnSampler());
                }


                tracing.AddGrpcClientInstrumentation()
                       .AddHttpClientInstrumentation();
            });


        builder.AddOpenTelemetryExporters();


        return builder;
    }


    private static IHostApplicationBuilder AddOpenTelemetryExporters(
        this IHostApplicationBuilder builder)
    {
        var useOtlpExporter =
            !string.IsNullOrWhiteSpace(
                builder.Configuration["OTEL_EXPORTER_OTLP_ENDPOINT"]);


        if (useOtlpExporter)
        {
            builder.Services.Configure<OpenTelemetryLoggerOptions>(
                logging => logging.AddOtlpExporter());
            builder.Services.ConfigureOpenTelemetryMeterProvider(
                metrics => metrics.AddOtlpExporter());
            builder.Services.ConfigureOpenTelemetryTracerProvider(
                tracing => tracing.AddOtlpExporter());
        }


        return builder;
    }
}
```

This is only an example, and you can customize the `AppDefaultsExtensions` class to meet your specific needs.

## Next steps

[Section titled “Next steps”](#next-steps)

This code is derived from the Aspire Starter Application template and is intended as a starting point. You’re free to modify this code however you deem necessary to meet your needs. It’s important to know that service defaults project and its functionality are automatically applied to all project resources in an Aspire solution.

# Service discovery

> Understand essential service discovery concepts in Aspire.

In this article, you learn how service discovery works within an Aspire project. Aspire includes functionality for configuring service discovery at development and testing time. Service discovery functionality works by providing configuration in the format expected by the *configuration-based endpoint resolver* from the Aspire AppHost project to the individual service projects added to the application model. For more information, see [Service discovery in .NET](https://learn.microsoft.com/dotnet/core/extensions/service-discovery).

## Implicit service discovery by reference

[Section titled “Implicit service discovery by reference”](#implicit-service-discovery-by-reference)

Configuration for service discovery is only added for services that are referenced by a given project. For example, consider the following AppHost program:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalog = builder.AddProject<Projects.CatalogService>("catalog");
var basket = builder.AddProject<Projects.BasketService>("basket");


var frontend = builder.AddProject<Projects.MyFrontend>("frontend")
                      .WithReference(basket)
                      .WithReference(catalog);
```

In the preceding example, the *frontend* project references the *catalog* project and the *basket* project. The two `WithReference` calls instruct the Aspire project to pass service discovery information for the referenced projects (*catalog*, and *basket*) into the *frontend* project.

## Named endpoints

[Section titled “Named endpoints”](#named-endpoints)

Some services expose multiple, named endpoints. Named endpoints can be resolved by specifying the endpoint name in the host portion of the HTTP request URI, following the format `scheme://_endpointName.serviceName`. For example, if a service named “basket” exposes an endpoint named “dashboard”, then the URI `https+http://_dashboard.basket` can be used to specify this endpoint, for example:

```csharp
builder.Services.AddHttpClient<BasketServiceClient>(
    static client => client.BaseAddress = new("https+http://basket"));


builder.Services.AddHttpClient<BasketServiceDashboardClient>(
    static client => client.BaseAddress = new("https+http://_dashboard.basket"));
```

In the preceding example, two `HttpClient` classes are added, one for the core basket service and one for the basket service’s dashboard.

### Named endpoints using configuration

[Section titled “Named endpoints using configuration”](#named-endpoints-using-configuration)

With the configuration-based endpoint resolver, named endpoints can be specified in configuration by prefixing the endpoint value with `_endpointName.`, where `endpointName` is the endpoint name. For example, consider this *appsettings.json* configuration which defined a default endpoint (with no name) and an endpoint named “dashboard”:

```json
{
  "Services": {
    "basket": {
      "https": "https://10.2.3.4:8080" /* the https endpoint, requested via https://basket */,
      "dashboard": "https://10.2.3.4:9999" /* the "dashboard" endpoint, requested via https://_dashboard.basket */
    }
  }
}
```

In the preceding JSON:

* The default endpoint, when resolving `https://basket` is `10.2.3.4:8080`.
* The “dashboard” endpoint, resolved via `https://_dashboard.basket` is `10.2.3.4:9999`.

### Named endpoints in Aspire

[Section titled “Named endpoints in Aspire”](#named-endpoints-in-aspire)

Named endpoints can also be exposed by code in the App Host. For instance the previous example can be modeled as:

```csharp
var basket = builder.AddProject<Projects.BasketService>("basket")
    .WithHttpsEndpoint(port: 9999, name: "dashboard");
```

### Named endpoints in Kubernetes using DNS SRV

[Section titled “Named endpoints in Kubernetes using DNS SRV”](#named-endpoints-in-kubernetes-using-dns-srv)

When deploying to Kubernetes, the DNS SRV service endpoint resolver can be used to resolve named endpoints. For example, the following resource definition will result in a DNS SRV record being created for an endpoint named “default” and an endpoint named “dashboard”, both on the service named “basket”.

```yml
apiVersion: v1
kind: Service
metadata:
  name: basket
spec:
  selector:
    name: basket-service
  clusterIP: None
  ports:
    - name: default
      port: 8080
    - name: dashboard
      port: 9999
```

To configure a service to resolve the “dashboard” endpoint on the “basket” service, add the DNS SRV service endpoint resolver to the host builder as follows:

```csharp
builder.Services.AddServiceDiscoveryCore();
builder.Services.AddDnsSrvServiceEndpointProvider();
```

For more information, see `AddServiceDiscoveryCore` and `AddDnsSrvServiceEndpointProvider`.

The special port name “default” is used to specify the default endpoint, resolved using the URI `https://basket`.

As in the previous example, add service discovery to an `HttpClient` for the basket service:

```csharp
builder.Services.AddHttpClient<BasketServiceClient>(
    static client => client.BaseAddress = new("https://basket"));
```

Similarly, the “dashboard” endpoint can be targeted as follows:

```csharp
builder.Services.AddHttpClient<BasketServiceDashboardClient>(
    static client => client.BaseAddress = new("https://_dashboard.basket"));
```

# Telemetry

> Learn about essential telemetry concepts for Aspire including logging, tracing, and metrics.

One of the primary objectives of Aspire is to ensure that apps are straightforward to debug and diagnose. Aspire integrations automatically set up logging, tracing, and metrics configurations—sometimes known as the pillars of observability—using the [.NET OpenTelemetry SDK](https://github.com/open-telemetry/opentelemetry-dotnet).

## The three pillars of observability

[Section titled “The three pillars of observability”](#the-three-pillars-of-observability)

* **[Logging](https://learn.microsoft.com/dotnet/core/diagnostics/logging-tracing)** — Log events describe what’s happening as an app runs. A baseline set is enabled for Aspire integrations by default and more extensive logging can be enabled on-demand to diagnose particular problems.

* **[Tracing](https://learn.microsoft.com/dotnet/core/diagnostics/distributed-tracing)** — Traces correlate log events that are part of the same logical activity (for example, the handling of a single request), even if they’re spread across multiple machines or processes.

* **[Metrics](https://learn.microsoft.com/dotnet/core/diagnostics/metrics)** — Metrics expose the performance and health characteristics of an app as simple numerical values. As a result, they have low performance overhead and many services configure them as always-on telemetry. This also makes them suitable for triggering alerts when potential problems are detected.

Together, these types of telemetry allow you to gain insights into your application’s behavior and performance using various monitoring and analysis tools. Depending on the backing service, some integrations may only support some of these features.

## Aspire OpenTelemetry integration

[Section titled “Aspire OpenTelemetry integration”](#aspire-opentelemetry-integration)

The [.NET OpenTelemetry SDK](https://github.com/open-telemetry/opentelemetry-dotnet) includes features for gathering data from several .NET APIs, including `ILogger`, `Activity`, `Meter`, and `Instrument<T>`. These APIs correspond to telemetry features like logging, tracing, and metrics.

Aspire projects define OpenTelemetry SDK configurations in the service defaults project. By default, the `ConfigureOpenTelemetry` method enables logging, tracing, and metrics for the app. It also adds exporters for these data points so they can be collected by other monitoring tools.

For more information, see [Service defaults](/fundamentals/service-defaults/).

## Export OpenTelemetry data for monitoring

[Section titled “Export OpenTelemetry data for monitoring”](#export-opentelemetry-data-for-monitoring)

Aspire enables export of telemetry data to a data store or reporting tool. The telemetry export mechanism relies on the [OpenTelemetry Protocol (OTLP)](https://opentelemetry.io/docs/specs/otel/protocol), which serves as a standardized approach for transmitting telemetry data through REST or gRPC.

The `ConfigureOpenTelemetry` method registers exporters to provide your telemetry data to other monitoring tools, such as Prometheus or Azure Monitor.

For more information, see [OpenTelemetry configuration](/fundamentals/service-defaults/#opentelemetry-configuration).

## OpenTelemetry environment variables

[Section titled “OpenTelemetry environment variables”](#opentelemetry-environment-variables)

OpenTelemetry has a [list of known environment variables](https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/) that configure the most important behavior for collecting and exporting telemetry. OpenTelemetry SDKs, including the .NET SDK, support reading these variables.

Aspire projects launch with environment variables that configure the name and ID of the app in exported telemetry and set the address endpoint of the OTLP server to export data. For example:

* `OTEL_SERVICE_NAME=myfrontend`
* `OTEL_RESOURCE_ATTRIBUTES=service.instance.id=1a5f9c1e-e5ba-451b-95ee-ced1ee89c168`
* `OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318`

These environment variables are automatically set in local development.

## Local development workflow

[Section titled “Local development workflow”](#local-development-workflow)

When you create an Aspire project, the Aspire dashboard provides a UI for viewing app telemetry by default. Telemetry data is sent to the dashboard using OTLP, and the dashboard implements an OTLP server to receive telemetry data and store it in memory.

### Telemetry flow in local development

[Section titled “Telemetry flow in local development”](#telemetry-flow-in-local-development)

When you start an Aspire project with debugging (pressing `F5`), the following workflow occurs:

1. **Dashboard and DCP start** — The Aspire dashboard and developer control plane (DCP) start

2. **App configuration runs** — The AppHost project runs its configuration:

   * OpenTelemetry environment variables are automatically added to .NET projects
   * DCP provides the service name (`OTEL_SERVICE_NAME`) and ID (`OTEL_RESOURCE_ATTRIBUTES`) for exported telemetry
   * The OTLP endpoint is an HTTP/2 port started by the dashboard, set in `OTEL_EXPORTER_OTLP_ENDPOINT`
   * Small export intervals (`OTEL_BSP_SCHEDULE_DELAY`, `OTEL_BLRP_SCHEDULE_DELAY`, `OTEL_METRIC_EXPORT_INTERVAL`) ensure data is quickly available in the dashboard

3. **Resources start** — The DCP starts configured projects, containers, and executables

4. **Telemetry flows** — Once started, apps send telemetry to the dashboard

5. **Dashboard displays** — The dashboard displays near real-time telemetry of all Aspire projects

All of these steps happen internally, so in most cases you simply need to run the app to see this process in action.

## Deployment

[Section titled “Deployment”](#deployment)

Aspire deployment environments should configure OpenTelemetry environment variables that make sense for their environment. For example, `OTEL_EXPORTER_OTLP_ENDPOINT` should be configured to the environment’s local OTLP collector or monitoring service.

Note

Aspire telemetry works best in environments that support OTLP. OTLP exporting is disabled if `OTEL_EXPORTER_OTLP_ENDPOINT` isn’t configured.

For more information, see [Aspire deployments](/deployment/overview/).

## See also

[Section titled “See also”](#see-also)

* [Service defaults](/fundamentals/service-defaults/)
* [Dashboard overview](/dashboard/overview/)
* [OpenTelemetry Protocol specification](https://opentelemetry.io/docs/specs/otel/protocol)
* [.NET OpenTelemetry SDK](https://github.com/open-telemetry/opentelemetry-dotnet)

# Aspireify an existing app

> Learn how to add Aspire orchestration to your existing application using aspire init.

Select your application's primary language

C#  Python  JavaScript

This guide shows you how to add Aspire orchestration to an existing application, whether it’s written in C#, Python, JavaScript, or a mix of these languages. Instead of starting from scratch, you’ll use the `aspire init` command to incrementally adopt Aspire in your current project.

Definition

**Aspireify** (verb): To transform an existing application into a distributed, observable, and orchestrated system by adding Aspire—no cape required, just a few commands!

## Why add Aspire to an existing app?

[Section titled “Why add Aspire to an existing app?”](#why-add-aspire-to-an-existing-app)

As distributed applications grow, coordinating multiple services becomes a tangled web of configuration files, hard-coded URLs, and fragile startup scripts. You’re juggling connection strings across environments, manually wiring service dependencies, and struggling to trace issues across your microservices. Development setup becomes a ritual of precision—start the database, then the cache, then service A before service B—and any misstep sends you back to square one.

Aspire cuts through this complexity with a unified orchestration layer that treats your entire application as a cohesive system. Define your services and their relationships once in code ([the AppHost](/get-started/app-host/)), and Aspire handles service discovery, injects configuration automatically, and provides a dashboard with logs, traces, and metrics out of the box. Whether you’re orchestrating C#, Python, or JavaScript services—or all three together—you get the same consistent experience from development through deployment.

The best part? You can adopt Aspire incrementally. Start with orchestration, add observability when you’re ready, integrate external services as needed. Your existing codebase stays largely unchanged, and you can reverse course if Aspire isn’t the right fit.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

Before you begin, ensure you have the following prerequisites installed based on your application’s language:

### Common requirements

[Section titled “Common requirements”](#common-requirements)

* [.NET SDK 10.0 or later](/get-started/prerequisites/) — Required for the Aspire AppHost, regardless of your application’s language.
* [Aspire CLI installed](/get-started/install-cli/) — For orchestration and deployment commands.
* An existing application to add Aspire to.

### Language-specific requirements

[Section titled “Language-specific requirements”](#language-specific-requirements)

**For C# applications:**

* A solution with one or more .NET or ASP.NET Core projects (`.csproj`)
* Visual Studio 2022 17.13 or later, Visual Studio Code, or JetBrains Rider (optional)

**Example project types:**

* ASP.NET Core Minimal API
* ASP.NET Core Razor Pages or Blazor applications
* Console applications
* Worker services
* gRPC services
* Azure Functions

**For Python applications:**

* [Python 3.10 or later](https://www.python.org/downloads/) installed
* [uv](https://docs.astral.sh/uv/) (recommended) or pip for package management
* An existing Python application

**Example application types:**

* FastAPI web applications
* Flask web applications
* Django applications
* Python scripts or worker processes
* Streamlit or other Python web frameworks

**For JavaScript/TypeScript applications:**

* [Node.js 22 or later](https://nodejs.org/) installed
* npm, yarn, or pnpm for package management
* An existing JavaScript/TypeScript application

**Example application types:**

* React, Vue, or Svelte applications (especially Vite-based)
* Node.js/Express APIs
* Next.js applications
* Angular applications
* TypeScript backend services

Polyglot applications

If your application uses multiple languages, ensure you have all the relevant prerequisites installed. The Aspire AppHost can orchestrate services across different languages simultaneously.

## Overview of the process

[Section titled “Overview of the process”](#overview-of-the-process)

Adding Aspire to an existing application follows these key steps:

1. **Initialize Aspire support** — Use `aspire init` to add the AppHost (orchestration layer)
2. **Add your applications** — Register C#, Python, and JavaScript applications in the AppHost
3. **Configure telemetry (optional)** — Add OpenTelemetry instrumentation for observability
4. **Add integrations (optional)** — Connect to databases, caches, and message queues
5. **Run and verify** — Test your application with Aspire orchestration

## Initialize Aspire support

[Section titled “Initialize Aspire support”](#initialize-aspire-support)

The `aspire init` command is the starting point for adding Aspire to your existing application. This command analyzes your project structure and adds an AppHost that orchestrates your services.

1. Navigate to your project directory:

   Navigate to your solution directory

   ```bash
   cd /path/to/your-solution
   ```

   Navigate to your project root

   ```bash
   cd /path/to/your-project
   ```

   Navigate to your workspace root

   ```bash
   cd /path/to/your-workspace
   ```

2. Run `aspire init` to initialize Aspire support:

   Initialize Aspire

   ```bash
   aspire init
   ```

   The `aspire init` command runs in **interactive mode** by default. It will:

   * Detect your existing solution structure
   * Create a project-based AppHost (an *AppHost* project with `AppHost.cs`)
   * Analyze your projects and suggest which ones to add to the orchestration
   * Install necessary Aspire packages

   - Detect your existing project structure
   - Create a file-based AppHost (`apphost.cs`)
   - Analyze your Python applications and suggest which ones to add to the orchestration
   - Install necessary Aspire packages

   * Detect your existing workspace structure
   * Create a file-based AppHost (`apphost.cs`)
   * Analyze your JavaScript/Node.js applications and suggest which ones to add to the orchestration
   * Install necessary Aspire packages

   For more details on the `aspire init` command and its options, see the [CLI reference: `aspire init`](/reference/cli/commands/aspire-init/).

### What does `aspire init` create?

[Section titled “What does aspire init create?”](#what-does-aspire-init-create)

After running `aspire init`, your solution will have a project-based AppHost:

* ExampleEcommerce.sln (updated)

* src/

  * **ExampleEcommerce.AppHost/** (new) orchestration project

    * **ExampleEcommerce.AppHost.csproj** project file
    * **AppHost.cs** orchestration code

  * Api/

    * ExampleEcommerce.Api.csproj

    * Program.cs

    * Controllers/

      * …

  * Web/

    * ExampleEcommerce.Web.csproj

    * Program.cs

    * Pages/

      * …

  * OrderProcessor/

    * ExampleEcommerce.OrderProcessor.csproj
    * Worker.cs

A typical e-commerce solution with a web frontend, API service, and background worker.

After running `aspire init`, your project will have a file-based AppHost:

* my-saas-app/

  * **apphost.cs** (new) orchestration code

  * **apphost.run.json** (new) configuration

  * api/

    * main.py

    * routers/

      * …

    * models/

      * …

    * pyproject.toml

  * frontend/

    * app.py

    * templates/

      * …

    * static/

      * …

    * requirements.txt

  * worker/

    * tasks.py
    * celery\_config.py
    * requirements.txt

A typical SaaS application with FastAPI backend, Flask frontend, and Celery worker.

After running `aspire init`, your project will have a file-based AppHost:

* my-store/

  * **apphost.cs** (new) orchestration code

  * **apphost.run.json** (new) configuration

  * packages/

    * api/

      * src/

        * server.js

        * routes/

          * …

      * package.json

    * web/

      * src/

        * App.tsx

        * components/

          * …

      * package.json

      * vite.config.ts

    * admin/

      * src/

        * main.ts

        * views/

          * …

      * package.json

  * package.json (workspace root)

A typical monorepo with Node.js API, React storefront, and admin dashboard.

The `AppHost.cs` file in your new AppHost project initially contains a minimal starter:

AppHost.cs — Initial state after aspire init

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// TODO: Add resources here


builder.Build().Run();
```

The `apphost.cs` file initially contains a minimal starter:

apphost.cs — Initial state after aspire init

```csharp
#:sdk Aspire.AppHost.Sdk@13.1.0


var builder = DistributedApplication.CreateBuilder(args);


// TODO: Add resources here


builder.Build().Run();
```

The `apphost.cs` file initially contains a minimal starter:

apphost.cs — Initial state after aspire init

```csharp
#:sdk Aspire.AppHost.Sdk@13.1.0


var builder = DistributedApplication.CreateBuilder(args);


// TODO: Add resources here


builder.Build().Run();
```

This is your starting point. In the next section, you’ll add your applications and configure their relationships.

## Add your applications to the AppHost

[Section titled “Add your applications to the AppHost”](#add-your-applications-to-the-apphost)

Once you have an AppHost, you need to register your existing applications. First, install the appropriate hosting packages for your application types, then add your resources to the AppHost.

### Install hosting packages

[Section titled “Install hosting packages”](#install-hosting-packages)

For C# projects, if you’re using project-based orchestration (`.csproj` files), no additional packages are needed. The base Aspire SDK includes support for `AddProject<T>` (or `AddCSharpApp` for file-based apps).

For Python applications, install the Python hosting package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Python package

  ```bash
  aspire add python
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > python (Aspire.Hosting.Python)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Python@*
  ```

This package provides methods like `AddUvicornApp`, `AddPythonApp`, and `AddPythonModule`.

For JavaScript/TypeScript applications, install the JavaScript hosting package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.JavaScript package

  ```bash
  aspire add javascript
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > javascript (Aspire.Hosting.JavaScript)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.JavaScript@*
  ```

This package provides methods like `AddViteApp`, `AddNodeApp`, and `AddJavaScriptApp`.

### Model your resources in the AppHost

[Section titled “Model your resources in the AppHost”](#model-your-resources-in-the-apphost)

Now update your `AppHost.cs` file in the AppHost project to register your applications as resources. Resources are the building blocks of your distributed application—each service, container, or infrastructure resource becomes something Aspire can orchestrate.

Now update your `apphost.cs` file to register your applications as resources. Resources are the building blocks of your distributed application—each service, container, or infrastructure resource becomes something Aspire can orchestrate.

For C# projects, use `AddProject` to reference your existing C# projects:

AppHost.cs — Complete e-commerce example

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.ExampleEcommerce_Api>("api")
    .WithHttpHealthCheck("/health");


var web = builder.AddProject<Projects.ExampleEcommerce_Web>("web")
    .WithExternalHttpEndpoints()
    .WithReference(api)
    .WaitFor(api);


var orderProcessor = builder.AddProject<Projects.ExampleEcommerce_OrderProcessor>("orderprocessor")
    .WithReference(api);


builder.Build().Run();
```

**Key methods:**

* `AddProject<T>` - Adds a .NET project from your solution
* `WithHttpHealthCheck` - Monitors service health via HTTP endpoint
* `WithReference` - Enables service-to-service communication
* `WaitFor` - Ensures proper startup order

Aspire provides several methods for Python applications:

apphost.cs — Complete SaaS example

```csharp
#:sdk Aspire.AppHost.Sdk@13.1.0
#:package Aspire.Hosting.Python@13.1.0


var builder = DistributedApplication.CreateBuilder(args);


// FastAPI backend
var api = builder.AddUvicornApp("api", "./api", "main:app")
    .WithUv()
    .WithHttpHealthCheck("/health");


// Flask frontend
var frontend = builder.AddUvicornApp("frontend", "./frontend", "app:app")
    .WithUv()
    .WithExternalHttpEndpoints()
    .WithReference(api)
    .WaitFor(api);


// Celery worker
var worker = builder.AddPythonApp("worker", "./worker", "celery")
    .WithUv()
    .WithArgs("worker", "-A", "tasks")
    .WithReference(api);


builder.Build().Run();
```

**Key methods:**

* `AddUvicornApp` - For FastAPI, Flask, and other ASGI/WSGI frameworks
* `AddPythonApp` - For standalone Python scripts
* `WithUv()` - Use uv for fast package management (recommended)
* `WithPip()` - Use traditional pip for package management

For JavaScript applications, use the appropriate method based on your application type:

apphost.cs — Complete monorepo example

```csharp
#:sdk Aspire.AppHost.Sdk@13.1.0
#:package Aspire.Hosting.JavaScript@13.1.0


var builder = DistributedApplication.CreateBuilder(args);


// Node.js API
var api = builder.AddNodeApp("api", "./packages/api", "src/server.js")
    .WithNpm()
    .WithHttpHealthCheck("/health");


// React storefront
var web = builder.AddViteApp("web", "./packages/web")
    .WithExternalHttpEndpoints()
    .WithReference(api)
    .WaitFor(api);


// Admin dashboard
var admin = builder.AddViteApp("admin", "./packages/admin")
    .WithExternalHttpEndpoints()
    .WithReference(api)
    .WaitFor(api);


builder.Build().Run();
```

**Key methods:**

* `AddViteApp` - For Vite-based applications (React, Vue, Svelte)
* `AddNodeApp` - For Node.js applications
* `AddJavaScriptApp` - For generic JavaScript applications with npm/yarn/pnpm
  * `WithNpm()` / `WithYarn()` / `WithPnpm()` - Specify package manager
* `WithRunScript` - Specify which npm script to run during development

Passing arguments to scripts

Unlike the deprecated `AddNpmApp` API in Aspire 9, the new JavaScript hosting methods (`AddJavaScriptApp`, `AddViteApp`, `AddNodeApp`) do not support an `args` constructor parameter. You have two options to pass arguments to your scripts:

**Option 1: Use `WithArgs` to pass arguments directly**

apphost.cs — Pass arguments using WithArgs

```csharp
builder.AddViteApp("frontend", "./frontend")
    .WithArgs("--no-open");
```

**Option 2: Define custom scripts in `package.json` with arguments**

package.json

```json
{
  "scripts": {
    "dev": "vite",
    "dev:no-open": "vite --no-open"
  }
}
```

apphost.cs — Reference custom script

```csharp
builder.AddViteApp("frontend", "./frontend")
    .WithRunScript("dev:no-open");
```

Option 2 keeps all script configuration in `package.json`, making your scripts more discoverable and easier to run outside of Aspire (e.g., `npm run dev:no-open`).

Tip

You can mix and match languages! The examples above show single-language scenarios, but Aspire excels at orchestrating polyglot applications. Add C#, Python, and JavaScript resources to the same AppHost to create truly cross-language solutions.

### Connect services

[Section titled “Connect services”](#connect-services)

The calls to `WithReference` establish service dependencies and enable service discovery:

AppHost.cs — Connect .NET services

```csharp
// Omitted for brevity...


var api = builder.AddProject<Projects.YourApi>("api");


var web = builder.AddProject<Projects.YourWeb>("web")
    .WithReference(api);  // Web can call API


var worker = builder.AddProject<Projects.YourWorker>("worker")
    .WithReference(api);  // Worker can call API


// Omitted for brevity...
```

apphost.cs — Connect Python services

```csharp
// Omitted for brevity...


var api = builder.AddUvicornApp("api", "../python-api", "main:app")
    .WithUv();


var worker = builder.AddPythonApp("worker", "../python-worker", "worker.py")
    .WithReference(api);  // Worker gets API_HTTP and API_HTTPS env vars


// Omitted for brevity...
```

apphost.cs — Connect JavaScript services

```csharp
// Omitted for brevity...


var api = builder.AddNodeApp("api", "../node-api", "server.js")
    .WithNpm();


var frontend = builder.AddViteApp("frontend", "../react-frontend")
    .WithReference(api);  // Frontend gets API_HTTP and API_HTTPS env vars


// Omitted for brevity...
```

When you call `WithReference`, you’re declaring a dependency between resources. Aspire handles the rest—automatically injecting configuration at runtime and during deployment so your services can communicate seamlessly, whether running locally or in production.

## Add telemetry configuration (optional)

[Section titled “Add telemetry configuration (optional)”](#add-telemetry-configuration-optional)

ServiceDefaults provide a standardized way to add observability, resilience, and health checks to .NET services. This step is optional but recommended for production applications.

1. During the `aspire init` process, you may be prompted to add ServiceDefaults. If you chose not to add it initially, you can add it later using the Aspire CLI or manually.

2. To add ServiceDefaults to a project manually:

   .NET CLI — Add ServiceDefaults to your project

   ```bash
   dotnet new aspire-servicedefaults -n YourProject.ServiceDefaults
   dotnet sln add YourProject.ServiceDefaults
   dotnet add YourProject reference YourProject.ServiceDefaults
   ```

3. Update your project’s `Program.cs` to use ServiceDefaults:

   Program.cs — Add ServiceDefaults

   ```csharp
   var builder = WebApplication.CreateBuilder(args);


   // Add Aspire ServiceDefaults for observability and resilience
   builder.AddServiceDefaults();


   // ... your existing service configuration ...


   var app = builder.Build();


   // Map Aspire ServiceDefaults endpoints
   app.MapDefaultEndpoints();


   // ... your existing middleware ...


   app.Run();
   ```

For more information on ServiceDefaults, see [Service Defaults](/fundamentals/service-defaults/).

Python applications can send telemetry to the Aspire dashboard using OpenTelemetry:

1. Install OpenTelemetry packages in your Python application:

   Install OpenTelemetry packages

   ```bash
   uv add opentelemetry-api opentelemetry-sdk opentelemetry-exporter-otlp-proto-grpc
   uv add opentelemetry-instrumentation-fastapi  # For FastAPI
   # Or for Flask:
   # uv add opentelemetry-instrumentation-flask
   ```

2. Configure OpenTelemetry in your Python application:

   Python — Configure OpenTelemetry

   ```python
   import os
   from opentelemetry import trace, metrics
   from opentelemetry.sdk.trace import TracerProvider
   from opentelemetry.sdk.metrics import MeterProvider
   from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
   from opentelemetry.exporter.otlp.proto.grpc.metric_exporter import OTLPMetricExporter
   from opentelemetry.sdk.resources import Resource
   from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor


   # Get OTLP endpoint from environment (injected by Aspire)
   otlp_endpoint = os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT")


   # Configure tracing and metrics
   resource = Resource.create({"service.name": "api"})
   trace.set_tracer_provider(TracerProvider(resource=resource))
   metrics.set_meter_provider(MeterProvider(resource=resource))


   # Instrument your FastAPI app
   FastAPIInstrumentor.instrument_app(app)
   ```

JavaScript/Node.js applications can also send telemetry using OpenTelemetry:

1. Install OpenTelemetry packages:

   Install OpenTelemetry packages

   ```bash
   npm install @opentelemetry/api @opentelemetry/sdk-node \
     @opentelemetry/auto-instrumentations-node \
     @opentelemetry/exporter-trace-otlp-grpc \
     @opentelemetry/exporter-metrics-otlp-grpc
   ```

2. Create a telemetry configuration file:

   JavaScript — telemetry.js

   ```javascript
   const { NodeSDK } = require('@opentelemetry/sdk-node');
   const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
   const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-grpc');
   const { OTLPMetricExporter } = require('@opentelemetry/exporter-metrics-otlp-grpc');
   const { PeriodicExportingMetricReader } = require('@opentelemetry/sdk-metrics');
   const { resourceFromAttributes } = require('@opentelemetry/resources');
   const { ATTR_SERVICE_NAME } = require('@opentelemetry/semantic-conventions');


   const otlpEndpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';


   // Create resource with service name
   const resource = resourceFromAttributes({
       [ATTR_SERVICE_NAME]: 'frontend',
   });


   const sdk = new NodeSDK({
     resource: resource,
     traceExporter: new OTLPTraceExporter({ url: otlpEndpoint }),
     metricReader: new PeriodicExportingMetricReader({
       exporter: new OTLPMetricExporter({ url: otlpEndpoint })
     }),
     instrumentations: [getNodeAutoInstrumentations()]
   });


   sdk.start();
   ```

3. Import the telemetry configuration at the top of your application entry point:

   JavaScript — app.js

   ```javascript
   // This must be first!
   require('./telemetry');


   const express = require('express');
   // ... rest of your app
   ```

## Add integrations (optional)

[Section titled “Add integrations (optional)”](#add-integrations-optional)

Aspire provides integration libraries that simplify working with common services like Redis, PostgreSQL, RabbitMQ, and more. These integrations handle configuration, health checks, and telemetry automatically.

When you add a hosting integration (like Redis) to your AppHost and reference it from a dependent resource, Aspire automatically injects the necessary configuration. This includes connection strings, URLs, environment variables, and other service-specific settings—eliminating manual connection string management across your services.

1. Identify which services in your application could benefit from Aspire integrations. Common candidates include:

   * Databases (PostgreSQL, SQL Server, MongoDB)
   * Caching (Redis, Valkey)
   * Messaging (RabbitMQ, Azure Service Bus, Kafka)
   * Storage (Azure Blob Storage, AWS S3)

2. Use the `aspire add` command to add integration packages to your AppHost:

   Add a Redis integration

   ```bash
   aspire add redis
   ```

   This command adds the necessary NuGet packages and helps you configure the integration.

3. Update your AppHost to reference the integration and share it across all your services:

   apphost.cs — Add Redis integration for polyglot apps

   ```csharp
   var builder = DistributedApplication.CreateBuilder(args);


   // Add Redis resource
   var cache = builder.AddRedis("cache");


   // Share Redis with .NET API
   var api = builder.AddProject<Projects.YourApi>("api")
       .WithReference(cache)
       .WithHttpHealthCheck("/health");


   // Share Redis with Python worker
   var pythonWorker = builder.AddPythonApp("worker", "../python-worker", "worker.py")
       .WithReference(cache);  // Python gets CACHE_HOST, CACHE_PORT env vars


   // Share Redis with Node.js service
   var nodeService = builder.AddNodeApp("service", "../node-service", "index.js")
       .WithReference(cache);  // Node.js gets CACHE_HOST, CACHE_PORT env vars


   builder.Build().Run();
   ```

4. Configure the integration in each language:

   Add Redis client to .NET project

   ```bash
   dotnet add YourApi package Aspire.StackExchange.Redis
   ```

   Program.cs — Configure Redis client

   ```csharp
   var builder = WebApplication.CreateBuilder(args);
   builder.AddRedisClient("cache");
   ```

   Add Redis client to Python project

   ```bash
   uv add redis
   ```

   Python — Configure Redis client

   ```python
   import os
   import redis


   # Aspire injects CACHE_HOST and CACHE_PORT
   redis_client = redis.Redis(
       host=os.getenv("CACHE_HOST"),
       port=int(os.getenv("CACHE_PORT")),
       decode_responses=True
   )
   ```

   Add Redis client to Node.js project

   ```bash
   npm install redis
   ```

   JavaScript — Configure Redis client

   ```javascript
   const redis = require('redis');


   // Aspire injects CACHE_HOST and CACHE_PORT
   const client = redis.createClient({
     socket: {
       host: process.env.CACHE_HOST,
       port: process.env.CACHE_PORT
     }
   });
   ```

Browse available integrations in the [Integrations section](/integrations/gallery/).

## Run and verify

[Section titled “Run and verify”](#run-and-verify)

Now that you’ve added Aspire to your application, it’s time to run it and see the orchestration in action.

1. From your solution directory, run the application using the Aspire CLI:

   Run your application with Aspire

   ```bash
   aspire run
   ```

   The Aspire CLI will:

   * Find your AppHost (file-based `apphost.cs`)
   * Build your solution
   * Launch all orchestrated services
   * Start the Aspire dashboard

2. The dashboard URL will appear in your terminal output:

   Example output

   ```bash
   🔍  Finding apphosts...
   apphost.cs


   Dashboard:  https://localhost:17068/login?t=ea559845d54cea66b837dc0ff33c3bd3


        Logs:  ~/.aspire/cli/logs/apphost-13024-2025-11-19-12-00-00.log


               Press CTRL+C to stop the apphost and exit.
   ```

3. Open the dashboard in your browser using the provided URL. You’ll see:

   * All your orchestrated resources and their status
   * Real-time logs from each service
   * Traces and metrics for observability
   * Environment variables and configuration

4. Verify that your services are running correctly by:

   * Checking the **Resources** page for service health
   * Accessing your application endpoints
   * Reviewing logs and traces in the dashboard

5. Stop the application by pressing ⌘+C `⌘+C` Control + C `CtrlC` Control + C `CtrlC` in your terminal.

Tip

The [Aspire dashboard](/dashboard/explore/) provides valuable insights even if you haven’t added ServiceDefaults or integrations yet. You’ll see basic information about your services, their startup order, and their endpoints.

### Bonus content

[Section titled “Bonus content”](#bonus-content)

If you’re currently using Docker Compose to orchestrate your services, Aspire can replace it while providing additional benefits:

* Docker compose: approach

  docker-compose.yml

  ```yaml
  1
  services:
  2
     postgres:
  3
        image: postgres:latest
  4
        environment:
  5
           - POSTGRES_PASSWORD=postgres
  6
           - POSTGRES_DB=mydb
  7
        ports:
  8
           - "5432:5432"
  9


  10
     api:
  11
        build: ./api
  12
        ports:
  13
           - "8080:8080"
  14
        environment:
  15
           - DATABASE_URL=postgres://postgres:postgres@postgres:5432/mydb
  16
        depends_on:
  17
           - postgres
  18


  19
     web:
  20
        build: ./web
  21
        ports:
  22
           - "3000:3000"
  23
        environment:
  24
           - API_URL=http://api:8080
  25
        depends_on:
  26
           - api
  ```

* Aspire's approach

  apphost.cs

  ```csharp
  1
  var builder = DistributedApplication.CreateBuilder(args);
  2


  3
  var db = builder.AddPostgres("postgres")
  4
      .AddDatabase("mydb");
  5


  6
  var api = builder.AddProject<Projects.Api>("api")
  7
      .WithReference(db);
  8


  9
  var web = builder.AddProject<Projects.Web>("web")
  10
      .WithExternalHttpEndpoints()
  11
      .WithReference(api)
  12
      .WaitFor(api);
  13


  14
  builder.Build().Run();
  ```

**Key advantages of Aspire over Docker Compose:**

* **Literally, less verbose** — Yet, more expressive and powerful.
* **No manual URL configuration** — Services discover each other automatically.
* **Type-safe references** — Compile-time checking for service dependencies.
* **Built-in dashboard** — Observability without additional tools like Prometheus/Grafana.
* **Development and deployment** — Same orchestration code works locally and can generate Docker Compose or deploy anywhere.
* **Integration libraries** — Pre-built support for databases, caches, message queues with best practices.
* **Language-agnostic** — Works with C#, Python, JavaScript, many more, and containerized services.

Note

Aspire can even generate Docker Compose files for you! When you deploy with `aspire deploy`, you can target Docker Compose as a deployment option. See [Deploy your first Aspire app](/get-started/deploy-first-app/) for more details.

## Next steps

[Section titled “Next steps”](#next-steps)

Congratulations! You’ve successfully added Aspire to your existing application. Here are some recommended next steps:

* **Add more integrations** — Explore [Aspire integrations](/integrations/gallery/) to simplify working with databases, caches, and message queues

* **Configure observability** — Enhance your application’s telemetry:

  * Learn about [Service Defaults](/fundamentals/service-defaults/)

  - See [Standalone dashboard for Python](/dashboard/standalone-for-python/)

  * See [Standalone dashboard for Node.js](/dashboard/standalone-for-nodejs/)

* **Deploy your app** — Follow the [Deploy your first app](/get-started/deploy-first-app/) tutorial to deploy your Aspire application

* **Explore the dashboard** — Learn more about the [Aspire dashboard](/dashboard/overview/) and its features

* **Learn about polyglot features**:

  * [Python support in Aspire](/whats-new/aspire-13/#python-as-a-first-class-citizen)
  * [JavaScript support in Aspire](/whats-new/aspire-13/#javascript-as-a-first-class-citizen)

# What is the AppHost?

> Learn how to define your application's architecture using Aspire's AppHost.

Aspire’s AppHost is the code-first place where you declare your application’s services and their relationships. Instead of managing scattered configuration files, you describe the architecture in code. Aspire then handles local orchestration so you can focus on building features.

Select your API platform

C#  Python  Node.js  Go  Java

## Defining your architecture

[Section titled “Defining your architecture”](#defining-your-architecture)

Consider a simple three-tier architecture where the front end talks to an API, and the API talks to a database:

```
architecture-beta

  service db(logos:postgresql)[PostgreSQL]
  service api(logos:dotnet)[API service]
  service frontend(logos:react)[React front end]

  api:R --> L:db
  frontend:R --> L:api
```

This architecture demonstrates a **.NET API** connecting to a **PostgreSQL database**, with a **React front end** consuming the API. The .NET API uses ASP.NET Core and connects to PostgreSQL using Entity Framework or a connection string. The React front end is built with Vite and communicates with the API over HTTP.

To build this architecture step-by-step, see the [Build your first app](/get-started/first-app/?lang=csharp) quickstart.

```
architecture-beta

  service db(logos:postgresql)[PostgreSQL]
  service api(logos:python)[API service]
  service frontend(logos:react)[React front end]

  api:R --> L:db
  frontend:R --> L:api
```

This architecture demonstrates a **Python API** (using FastAPI/Uvicorn) connecting to a **PostgreSQL database**, with a **React front end** consuming the API. The Python API uses frameworks like FastAPI or Flask and connects to PostgreSQL using libraries like psycopg2 or SQLAlchemy. The React front end is built with Vite and communicates with the API over HTTP.

To build this architecture step-by-step, see the [Build your first app](/get-started/first-app/?lang=python) quickstart.

Tip

The Python integration is provided by the [CommunityToolkit.Aspire.Hosting.Python.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Python.Extensions) NuGet package. Learn more in the [Python integration](/integrations/frameworks/python/) documentation.

```
architecture-beta

  service db(logos:postgresql)[PostgreSQL]
  service api(logos:nodejs-icon)[API service]
  service frontend(logos:react)[React front end]

  api:R --> L:db
  frontend:R --> L:api
```

This architecture demonstrates a **Node.js API** connecting to a **PostgreSQL database**, with a **React front end** consuming the API. The Node.js API uses frameworks like Express or Fastify and connects to PostgreSQL using libraries like pg or Prisma. The React front end is built with Vite and communicates with the API over HTTP.

Tip

The JavaScript/Node.js integration is provided by the [Aspire.Hosting.JavaScript](https://www.nuget.org/packages/Aspire.Hosting.JavaScript) NuGet package. Learn more in the [JavaScript integration](/integrations/frameworks/javascript/) documentation.

```
architecture-beta

  service db(logos:postgresql)[PostgreSQL]
  service api(logos:go)[API service]
  service frontend(logos:react)[React front end]

  api:R --> L:db
  frontend:R --> L:api
```

This architecture demonstrates a **Go API** connecting to a **PostgreSQL database**, with a **React front end** consuming the API. The Go API uses the standard library’s `net/http` package or frameworks like Gin or Echo and connects to PostgreSQL using libraries like pgx or database/sql. The React front end is built with Vite and communicates with the API over HTTP.

Tip

The Go integration is provided by the [CommunityToolkit.Aspire.Hosting.Golang](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Golang) NuGet package. Learn more in the [Go integration](/integrations/frameworks/go-apps/) documentation.

```
architecture-beta

  service db(logos:postgresql)[PostgreSQL]
  service api(logos:java)[API service]
  service frontend(logos:react)[React front end]

  api:R --> L:db
  frontend:R --> L:api
```

This architecture demonstrates a **Java API** (using Spring Boot) connecting to a **PostgreSQL database**, with a **React front end** consuming the API. The Java API uses Spring Boot with Spring Data JPA and connects to PostgreSQL using JDBC or Spring Data. The React front end is built with Vite and communicates with the API over HTTP.

Tip

The Java integration is provided by the [CommunityToolkit.Aspire.Hosting.Java](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Java) NuGet package. Learn more in the [Java integration](/integrations/frameworks/java/) documentation.

You can represent that architecture in an AppHost like this:

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddUvicornApp("api", "../api", "main:app")
    .WithUv()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddNodeApp("api", "../api", "server.js")
    .WithNpm()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddGolangApp("api", "../api")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddSpringApp("api", "../api", "otel.jar")
    .WithHttpEndpoint(port: 8080)
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

The AppHost models your distributed application declaratively. Each tab above shows the same three-tier architecture—**PostgreSQL database**, **API service**, and **React front end**—but with different API implementations. Switching tabs changes only the API resource type:

Uses `AddProject<Projects.Api>()` to reference a .NET project.

Uses `AddUvicornApp()` with `WithUv()` for ASGI apps like FastAPI.

Uses `AddNodeApp()` with `WithNpm()` for Node.js applications.

Uses `AddGolangApp()` for Go applications.

Uses `AddSpringApp()` for Spring Boot applications.

In all cases, the PostgreSQL database and React front end remain identical. Aspire’s `WithReference()` method establishes dependencies between resources, and `WaitFor()` ensures services start in the correct order.

Aspire presents the same, consistent model regardless of the language or framework used: services, resources, and the connections between them.

### Dissecting the AppHost code

[Section titled “Dissecting the AppHost code”](#dissecting-the-apphost-code)

Below we highlight the key parts of a typical AppHost to explain what each step does.

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


14 collapsed lines
// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


15 collapsed lines
// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddUvicornApp("api", "../api", "main:app")
    .WithUv()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


15 collapsed lines
// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddNodeApp("api", "../api", "server.js")
    .WithNpm()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


15 collapsed lines
// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddGolangApp("api", "../api")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


15 collapsed lines
// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddSpringApp("api", "../api", "otel.jar")
    .WithHttpEndpoint(port: 8080)
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

In the non-collapsed lines you:

1. Create the distributed application builder with `DistributedApplication.CreateBuilder(args)`.
2. Call `Build()` to materialize the configuration into a runnable AppHost.
3. Call `Run()` to start orchestration; services launch in dependency order.

The AppHost is the blueprint for your distributed application—Aspire manages the rest.

#### Adding a PostgreSQL resource

[Section titled “Adding a PostgreSQL resource”](#adding-a-postgresql-resource)

With the builder ready, define resources and services. The snippet below shows how to add a PostgreSQL server and a database:

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


10 collapsed lines
// Add API service and reference the database
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


11 collapsed lines
// Add API service and reference the database
var api = builder.AddUvicornApp("api", "../api", "main:app")
    .WithUv()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


11 collapsed lines
// Add API service and reference the database
var api = builder.AddNodeApp("api", "../api", "server.js")
    .WithNpm()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


11 collapsed lines
// Add API service and reference the database
var api = builder.AddGolangApp("api", "../api")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


11 collapsed lines
// Add API service and reference the database
var api = builder.AddSpringApp("api", "../api", "otel.jar")
    .WithHttpEndpoint(port: 8080)
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

How this works:

* `AddPostgres("db")` registers a PostgreSQL container named `db`.
  * This returns an `IResourceBuilder<PostgresServerResource>` so you can chain configuration fluent-style.
* `.AddDatabase("appdata")` creates a database named `appdata` on that server.
* `.WithDataVolume()` provisions a volume so data persists across container restarts.

Learn more about the official [PostgreSQL integration](/integrations/databases/postgres/postgres-get-started/).

#### Adding an API resource and declaring a dependency

[Section titled “Adding an API resource and declaring a dependency”](#adding-an-api-resource-and-declaring-a-dependency)

Next, register the API service and wire it to the PostgreSQL resource:

AppHost.cs

```cs
6 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(postgres)
    .WaitFor(postgres);


5 collapsed lines
// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
6 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddUvicornApp("api", "../api", "main:app")
    .WithUv()
    .WithReference(postgres)
    .WaitFor(postgres);


5 collapsed lines
// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
6 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddNodeApp("api", "../api", "server.js")
    .WithNpm()
    .WithReference(postgres)
    .WaitFor(postgres);


5 collapsed lines
// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
6 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddGolangApp("api", "../api")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(postgres)
    .WaitFor(postgres);


5 collapsed lines
// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
6 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddSpringApp("api", "../api", "otel.jar")
    .WithHttpEndpoint(port: 8080)
    .WithReference(postgres)
    .WaitFor(postgres);


5 collapsed lines
// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

What this does:

* `AddProject<Projects.Api>("api")` registers the API project as a service named `api`.
* `WithReference(postgres)` injects connection details (host, port, credentials, connection string) into the API configuration.
* `WaitFor(postgres)` delays the API startup until PostgreSQL is healthy, avoiding brittle startup timing issues.

- `AddUvicornApp("api", "../api", "main:app")` registers a Uvicorn-based Python app as a service named `api`, pointing to the `main:app` entry point.
- `WithUv()` configures the app to use the [uv](https://docs.astral.sh/uv/) package manager for dependency installation.
- `WithReference(postgres)` injects connection details into the API configuration.
- `WaitFor(postgres)` delays the API startup until PostgreSQL is healthy.

* `AddNodeApp("api", "../api", "server.js")` registers a Node.js app as a service named `api`, with `server.js` as the entry point.
* `WithNpm()` configures the app to use npm for dependency installation.
* `WithReference(postgres)` injects connection details into the API configuration.
* `WaitFor(postgres)` delays the API startup until PostgreSQL is healthy.

- `AddGolangApp("api", "../api")` registers a Go app as a service named `api`.
- `WithHttpEndpoint(env: "PORT")` configures the port and sets the PORT environment variable.
- `WithReference(postgres)` injects connection details into the API configuration.
- `WaitFor(postgres)` delays the API startup until PostgreSQL is healthy.

* `AddSpringApp("api", "../api", "../agents/opentelemetry-javaagent.jar")` registers a Spring Boot app as a service named `api`, specifying the OpenTelemetry agent path.
* `WithHttpEndpoint(port: 8080)` exposes the Spring Boot app on port 8080.
* `WithReference(postgres)` injects connection details into the API configuration.
* `WaitFor(postgres)` delays the API startup until PostgreSQL is healthy.

Now that the `api` service is defined, you can attach the front end.

#### Adding a front end resource

[Section titled “Adding a front end resource”](#adding-a-front-end-resource)

Register the front end project, declare its dependency on the API, and let the AppHost provide the API address automatically.

Note

This example uses a Node.js (React) front end, but Aspire treats front ends as executable services—any language or framework works.

AppHost.cs

```cs
11 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
12 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddUvicornApp("api", "../api", "main:app")
    .WithUv()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
12 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddNodeApp("api", "../api", "server.js")
    .WithNpm()
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
12 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddGolangApp("api", "../api")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

AppHost.cs

```cs
12 collapsed lines
var builder = DistributedApplication.CreateBuilder(args);


// Add database resource
var postgres = builder.AddPostgres("db")
    .AddDatabase("appdata")
    .WithDataVolume();


// Add API service and reference the database
var api = builder.AddSpringApp("api", "../api", "otel.jar")
    .WithHttpEndpoint(port: 8080)
    .WithReference(postgres)
    .WaitFor(postgres);


// Add frontend service and reference the API
builder.AddViteApp("frontend", "../frontend")
    .WithHttpEndpoint(env: "PORT")
    .WithReference(api);


builder.Build().Run();
```

Key points:

* `.AddViteApp("front end", "../frontend")` registers the (Vite-based) front end project as a service named `front end`.
* `.WithHttpEndpoint(env: "PORT", targetPort: 3000)` exposes the app on port `3000`; the `PORT` environment variable can override it.
* `.WithReference(api)` injects the API base address into the front end configuration.

In short: define the backend first (DB → API), then point the UI at the API. The AppHost captures the dependency graph, connection flows, and startup order.

#### Configuration and networking

[Section titled “Configuration and networking”](#configuration-and-networking)

These dependencies and connections are automatically managed by Aspire. The AppHost generates configuration values like connection strings and endpoints, injecting them into services as needed. in the AppHost when you add resources, you name them (e.g., `db`, `api`, `front end`); Aspire uses these names for DNS resolution, so services can communicate using predictable addresses. Consuming services also rely on these names for configuration injection.

```
architecture-beta

  service db(logos:postgresql)[pg]
  service epr(iconoir:server-connection)[Endpoint Reference]
  service api(logos:dotnet)[api]
  service ctr(iconoir:server-connection)[Connection String Reference]
  service frontend(logos:react)[front end]

  db:L <-- R:ctr
  ctr:L <-- R:api
  api:L <-- R:epr
  epr:L <-- R:frontend
```

The .NET API receives a **ConnectionStringReference** from PostgreSQL and publishes an **EndpointReference** that the React front end consumes. This creates a clear dependency chain: `PostgreSQL → .NET API → React front end`.

```
architecture-beta

  service db(logos:postgresql)[pg]
  service epr(iconoir:server-connection)[Endpoint Reference]
  service api(logos:python)[api]
  service ctr(iconoir:server-connection)[Connection String Reference]
  service frontend(logos:react)[front end]

  db:L <-- R:ctr
  ctr:L <-- R:api
  api:L <-- R:epr
  epr:L <-- R:frontend
```

The Python API receives a **ConnectionStringReference** from PostgreSQL and publishes an **EndpointReference** that the React front end consumes. This creates a clear dependency chain: `PostgreSQL → Python API → React front end`.

```
architecture-beta

  service db(logos:postgresql)[pg]
  service epr(iconoir:server-connection)[Endpoint Reference]
  service api(logos:nodejs-icon)[api]
  service ctr(iconoir:server-connection)[Connection String Reference]
  service frontend(logos:react)[front end]

  db:L <-- R:ctr
  ctr:L <-- R:api
  api:L <-- R:epr
  epr:L <-- R:frontend
```

The Node.js API receives a **ConnectionStringReference** from PostgreSQL and publishes an **EndpointReference** that the React front end consumes. This creates a clear dependency chain: `PostgreSQL → Node.js API → React front end`.

```
architecture-beta

  service db(logos:postgresql)[pg]
  service epr(iconoir:server-connection)[Endpoint Reference]
  service api(logos:go)[api]
  service ctr(iconoir:server-connection)[Connection String Reference]
  service frontend(logos:react)[front end]

  db:L <-- R:ctr
  ctr:L <-- R:api
  api:L <-- R:epr
  epr:L <-- R:frontend
```

The Go API receives a **ConnectionStringReference** from PostgreSQL and publishes an **EndpointReference** that the React front end consumes. This creates a clear dependency chain: `PostgreSQL → Go API → React front end`.

```
architecture-beta

  service db(logos:postgresql)[pg]
  service epr(iconoir:server-connection)[Endpoint Reference]
  service api(logos:java)[api]
  service ctr(iconoir:server-connection)[Connection String Reference]
  service frontend(logos:react)[front end]

  db:L <-- R:ctr
  ctr:L <-- R:api
  api:L <-- R:epr
  epr:L <-- R:frontend
```

The Java API receives a **ConnectionStringReference** from PostgreSQL and publishes an **EndpointReference** that the React front end consumes. This creates a clear dependency chain: `PostgreSQL → Java API → React front end`.

**How these resources communicate**

1. `pg` publishes a `ConnectionStringReference` (host, port, database, user, password)—a strongly typed bundle Aspire understands.
2. `api` declares a dependency on that reference; Aspire injects the connection string into its config with a unique configuration-flow process that injects settings values, including secrets, parameters, and connection strings for both local runs and deployments.
3. `api` then publishes an `EndpointReference` (its base URL) after its HTTP endpoint is allocated.
4. `front end` depends on that endpoint; Aspire injects the API base URL so no hard-coded addresses are needed.

Tip

Aspire replaces ad-hoc run scripts, scattered environment variables, and fragile copy-pasted connection strings with a single, declarative source of truth. By modeling services, resources, and their dependencies in code, it delivers typed configuration (endpoints, credentials, connection strings) directly where needed—reducing setup drift, accelerating onboarding, and letting you evolve the architecture without rewriting glue.

## How the AppHost works

[Section titled “How the AppHost works”](#how-the-apphost-works)

When you run the AppHost, Aspire performs these core responsibilities:

1. **Service discovery**: Aspire discovers services and resources declared in the AppHost.
2. **Dependency resolution**: Services start in the correct order based on declared dependencies.
3. **Configuration injection**: Connection strings, endpoints, and other config values are injected automatically.
4. **Health monitoring**: Aspire observes service health and can restart services when necessary.

Dive deeper into Aspire’s orchestration and the [Resource model](/architecture/resource-model/).

## AppHost structure

[Section titled “AppHost structure”](#apphost-structure)

The template AppHost is structured in the following ways:

* File-based AppHost

  * **AspireApp.AppHost**

    * apphost.cs dev-time orchestrator
    * apphost.run.json

* Project-based AppHost

  * **AspireApp.AppHost**

    * Properties

      * launchSettings.json

    * appsettings.Development.json

    * appsettings.json

    * AspireApp.AppHost.csproj

    * AppHost.cs dev-time orchestrator

## AppHost lifecycle events

[Section titled “AppHost lifecycle events”](#apphost-lifecycle-events)

You can hook into lifecycle events to run custom logic during startup and resource allocation.

1. `BeforeStartEvent`: Raised before the AppHost begins starting services.
2. `AfterEndpointsAllocatedEvent`: Raised after endpoints are allocated for services.
3. `AfterResourcesCreatedEvent`: Raised after all resources are created.

For finer-grained lifecycle control, see the [well-known lifecycle events](/architecture/resource-model/#well-known-lifecycle-events).

## Best practices

[Section titled “Best practices”](#best-practices)

* Keep the AppHost minimal to start; add complexity only as required.
* Define explicit dependencies with `.WithReference(...)` to make wiring obvious.
* Use separate configurations for development, testing, and production.
* Pick clear, descriptive names for resources to make debugging and logging easier.

# Aspire SDK

> Learn about the Aspire SDK and how it simplifies orchestrating Aspire applications.

The Aspire SDK is intended for [AppHost projects](/get-started/app-host/), which serve as the orchestrator for Aspire applications. These projects are designated by their usage of the `Aspire.AppHost.Sdk` in the project file. The SDK provides features that simplify the development of Aspire apps.

The [📦 Aspire.AppHost.Sdk](https://www.nuget.org/packages/Aspire.AppHost.Sdk) is used for building Aspire apps.

* Project file

  The `Aspire.AppHost.Sdk` is defined in the top-level `Project` node’s `Sdk` attribute:

  XML — \*.csproj file

  ```xml
  <Project Sdk="Aspire.AppHost.Sdk/13.1">


      <PropertyGroup>
          <OutputType>Exe</OutputType>
          <TargetFramework>net10.0</TargetFramework>
          <!-- Omitted for brevity -->
      </PropertyGroup>


      <!-- Omitted for brevity -->
  </Project>
  ```

* File-based app

  The `Aspire.AppHost.Sdk` is defined in a file-based app’s source file using the `#:sdk` directive:

  C# — file-based app

  ```csharp
  #:sdk Aspire.AppHost.Sdk@13.1.0


  var builder = DistributedApplication.CreateBuilder(args);


  // Omitted for brevity
  ```

The preceding example defines the top-level SDK as `Aspire.AppHost.Sdk`. The project also references the [📦 Aspire.Hosting.AppHost](https://www.nuget.org/packages/Aspire.Hosting.AppHost) package which brings in a number of Aspire-related dependencies.

## SDK Features

[Section titled “SDK Features”](#sdk-features)

The Aspire SDK provides several key features.

### Project references

[Section titled “Project references”](#project-references)

Each `ProjectReference` in the AppHost project isn’t treated as standard project references. Instead, they enable the AppHost to execute these projects as part of its orchestration. Each project reference triggers a generator to create a `class` that represents the project as an `IProjectMetadata`. This metadata is used to populate the named projects in the generated `Projects` namespace. When you call the `AddProject` API, the `Projects` namespace is used to reference the project—passing the generated class as a generic-type parameter.

Tip

To prevent a project from being treated as an Aspire resource in the AppHost, set the `IsAspireProjectResource` attribute on the `ProjectReference` element to `false`, as shown in the following example:

```xml
<ProjectReference Include="..\MyProject\MyProject.csproj" IsAspireProjectResource="false" />
```

Otherwise, by default, the `ProjectReference` is treated as Aspire project resource.

#### Customizing generated project names

[Section titled “Customizing generated project names”](#customizing-generated-project-names)

When you reference a project in the AppHost, the Aspire SDK generates a strongly-typed class in the `Projects` namespace. By default, the generated class name is based on the project’s name. However, if you have multiple projects with the same name or want to customize the generated type name, you can use the `AspireProjectMetadataTypeName` attribute.

For example, if you have two microservices with the same project name (like `Presentation.Api`), you can differentiate them by setting custom names:

```xml
<ItemGroup>
  <ProjectReference Include="..\Microservice1\Presentation.Api\Presentation.Api.csproj"
                    AspireProjectMetadataTypeName="MicroService1" />
  <ProjectReference Include="..\Microservice2\Presentation.Api\Presentation.Api.csproj"
                    AspireProjectMetadataTypeName="MicroService2" />
</ItemGroup>
```

This generates `Projects.MicroService1` and `Projects.MicroService2` classes, allowing you to reference each project distinctly in your AppHost:

```csharp
var microservice1 = builder.AddProject<Projects.MicroService1>("micro1");
var microservice2 = builder.AddProject<Projects.MicroService2>("micro2");
```

### Orchestrator dependencies

[Section titled “Orchestrator dependencies”](#orchestrator-dependencies)

The Aspire SDK dynamically adds references to the [Aspire dashboard](/dashboard/overview/) and other AppHost dependencies, such as the developer control plane (DCP) packages. These dependencies are specific to the platform that the AppHost is built on.

When the AppHost project runs, the orchestrator relies on these dependencies to provide the necessary functionality to the AppHost. For more information, see [Aspire orchestration overview](/get-started/app-host/).

# Aspire templates

> Learn about the Aspire templates and how to use them to create new apps.

Aspire provides a number of project templates to help you create new apps. You can use these templates to create full Aspire solutions, or add individual projects to existing Aspire solutions.

The Aspire templates are available in the [📦 Aspire.ProjectTemplates](https://www.nuget.org/packages/Aspire.ProjectTemplates) NuGet package.

## Available templates

[Section titled “Available templates”](#available-templates)

The Aspire templates allow you to create new apps pre-configured with the Aspire solutions structure and default settings. These projects also provide a unified debugging experience across the different resources of your app.

Aspire templates are available in two categories: solution templates and project templates. Solution templates create a new Aspire solution with multiple projects, while project templates create individual projects that can be added to an existing Aspire solution.

### Solution templates

[Section titled “Solution templates”](#solution-templates)

The following Aspire solution templates are available (assume the solution is named *AspireSample*):

* **Aspire Empty App**: A minimal Aspire project that includes the following:

  * **AspireSample.AppHost**: An orchestrator project designed to connect and configure the different projects and services of your app.
  * **AspireSample.ServiceDefaults**: An Aspire shared project to manage configurations that are reused across the projects in your solution related to [resilience](https://learn.microsoft.com/dotnet/core/resilience/http-resilience), [service discovery](/fundamentals/service-discovery/), and [telemetry](/fundamentals/telemetry/).

* **Aspire Starter App**: In addition to the AppHost and ServiceDefaults projects, the Aspire Starter App also includes the following:

  * **AspireSample.ApiService**: An [ASP.NET Core Minimal API](https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis) project is used to provide data to the frontend. This project depends on the shared ServiceDefaults project.
  * **AspireSample.Web**: An [ASP.NET Core Blazor App](https://learn.microsoft.com/aspnet/core/blazor) project with default Aspire service configurations, this project depends on the ServiceDefaults project.
  * **AspireSample.Test**: Either an MSTest, NUnit, or xUnit test project with project references to the AppHost and an example *WebTests.cs* file demonstrating an integration test.

* **Aspire Starter App with ASP.NET Core and React**: This template includes the AppHost and ServiceDefaults projects, plus:

  * **AspireSample.ApiService**: An [ASP.NET Core Minimal API](https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis) project that provides data to the frontend.
  * **AspireSample.Web**: A React-based frontend application with TypeScript configured to work with the Aspire app.

* **Aspire Starter App with FastAPI and React**: This template provides a Python-based starter app with the following projects:

  * **AspireSample.AppHost**: The orchestrator project for managing the app’s services.
  * **AspireSample.ApiService**: A [FastAPI](https://fastapi.tiangolo.com/) Python backend service that provides data to the frontend.
  * **AspireSample.Web**: A React-based frontend application with TypeScript.

  For more information on getting started with Python in Aspire, see [Build your first app](/get-started/first-app/?lang=python).

### Project templates

[Section titled “Project templates”](#project-templates)

The following Aspire project templates are available:

* **Aspire AppHost**: A standalone AppHost project that can be used to orchestrate and manage the different projects and services of your app.

* **Aspire Test projects**: These project templates are used to create test projects for your Aspire app, and they’re intended to represent functional and integration tests. The test projects include the following templates:

  * **MSTest**: A project that contains MSTest integration of an Aspire AppHost project.
  * **NUnit**: A project that contains NUnit integration of an Aspire AppHost project.
  * **xUnit**: A project that contains xUnit.net integration of an Aspire AppHost project.

  For more information on the test templates, see [Testing overview](/testing/overview/).

* **Aspire Service Defaults**: A standalone ServiceDefaults project that can be used to manage configurations that are reused across the projects in your solution related to [resilience](https://learn.microsoft.com/dotnet/core/resilience/http-resilience), [service discovery](/fundamentals/service-discovery/), and [telemetry](/fundamentals/telemetry/).

Caution

The service defaults project template takes a `FrameworkReference` dependency on `Microsoft.AspNetCore.App`. This may not be ideal for some project types. For more information, see [Aspire service defaults](/fundamentals/service-defaults/).

## Install the Aspire templates

[Section titled “Install the Aspire templates”](#install-the-aspire-templates)

The Aspire templates are included with the Aspire workload. To install the templates, run the following command:

.NET CLI

```bash
dotnet new install Aspire.ProjectTemplates
```

Tip

To install a specific version of the Aspire templates, use the `::{version}` syntax. For example, to install version 13.1.0, run the following command:

.NET CLI

```bash
dotnet new install Aspire.ProjectTemplates::13.1.0
```

## Create solutions and projects using templates

[Section titled “Create solutions and projects using templates”](#create-solutions-and-projects-using-templates)

To create an Aspire solution or project, use Visual Studio, Visual Studio Code, or the Aspire CLI, and base it on the available templates. Explore additional Aspire templates in the [Aspire samples](https://github.com/dotnet/aspire-samples) repository.



Select your development environment

Aspire CLI  Visual Studio Code  Visual Studio

To create an Aspire project using Visual Studio, search for *Aspire* in the Visual Studio new project window and select your desired template.

![Visual Studio: Aspire templates showing various Aspire project templates available for selection.](/_astro/vs-create-dotnet-aspire-proj.Bs3fXwMj_Z2gCdiV.webp)

Follow the prompts to configure your project or solution from the template, and then select **Create**.

To create an Aspire project using Visual Studio Code, search for *Aspire* in the Visual Studio Code new project window and select your desired template.

![Visual Studio Code: Aspire templates showing various Aspire project templates available for selection.](/_astro/code-extension-create-aspire-project.CANwZRkS.png)

Select the desired location, enter a name, and select **Create**.

To create an Aspire solution or project using the Aspire CLI, use the `aspire new` command and specify which template you would like to create.

For detailed information about the `aspire new` command and all available options, see the [aspire new command reference](/reference/cli/commands/aspire-new/).

Consider the following examples:

To create an empty AppHost project:

Aspire CLI

```bash
aspire new aspire-apphost-singlefile
```

To create an Aspire starter app (ASP.NET Core/Blazor), which is a full solution with a sample UI and backing API:

Aspire CLI

```bash
aspire new aspire-starter
```

To create an Aspire starter app with ASP.NET Core and React:

Aspire CLI

```bash
aspire new aspire-ts-cs-starter
```

To create an Aspire starter app with FastAPI and React:

Aspire CLI

```bash
aspire new aspire-py-starter
```

Tip

The `aspire new` command runs in interactive mode by default. When you don’t provide options like `--name` or `--output`, the command prompts you for these values. To run non-interactively, provide all required options:

Aspire CLI

```bash
aspire new aspire-starter --name MyApp --output ./projects
```

You need to trust the ASP.NET Core localhost certificate before running the app. Run the following command:

.NET CLI

```bash
dotnet dev-certs https --trust
```

For more information, see [Troubleshoot untrusted localhost certificate](https://learn.microsoft.com/dotnet/aspire/troubleshooting/untrusted-localhost-certificate). For in-depth details about troubleshooting localhost certificates on Linux, see [ASP.NET Core: GitHub repository issue #32842](https://github.com/dotnet/aspnetcore/issues/32842).

# Aspire Visual Studio Code extension

> Learn how to use the Aspire Visual Studio Code extension to create, configure, run, and deploy Aspire solutions.

The Aspire Visual Studio Code extension provides a set of commands and tools to streamline your work with Aspire within Visual Studio Code. The extension includes commands to create projects, add integrations, configure solutions, and manage deployments. The extension requires the Aspire CLI and provides similar functionality on the Visual Studio Code command palette.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

Before you can use the Aspire Visual Studio Code extension, you need:

* The [Aspire CLI](/reference/cli/overview/) installed and available on your PATH

## Install the Aspire extension

[Section titled “Install the Aspire extension”](#install-the-aspire-extension)

To install the Aspire VS Code extension:

1. Open VS Code.
2. Open the **Extensions** view by selecting **View** > **Extensions** or pressing Command + Shift + X `CmdShiftX` Control + Shift + X `CtrlShiftX` Control + Shift + X `CtrlShiftX` .
3. Search for “aspire” in the Extensions marketplace.
4. Select the **Aspire** extension published by **Microsoft**.
5. Select **Install**.

![A screenshot of VS Code showing how to install the Aspire extension from the Extensions marketplace.](/_astro/install-aspire-code-extension.CFhzei-A.png)

Alternatively, you can install the extension directly from the [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=microsoft-aspire.aspire-vscode).

## Access extension commands

[Section titled “Access extension commands”](#access-extension-commands)

All Aspire extension commands are available from the VS Code Command Palette:

1. Open the Command Palette by pressing Command + Shift + P `CmdShiftP` Control + Shift + P `CtrlShiftP` Control + Shift + P `CtrlShiftP` .
2. Type “Aspire” to filter and display all available Aspire commands.
3. Select the desired command from the list.

All commands are grouped under the **Aspire** category in the Command Palette for easy discovery.

## Available commands

[Section titled “Available commands”](#available-commands)

The Aspire VS Code extension provides the following commands:

| Command                               | Description                                                                                                                                      | Availability |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------ |
| Aspire: New Aspire project            | Create a new Aspire apphost or starter app from a template.                                                                                      | Available    |
| Aspire: Add an integration            | Add a hosting integration (`Aspire.Hosting.*`) to the Aspire apphost.                                                                            | Available    |
| Aspire: Configure launch.json         | Adds the default Aspire debugger launch configuration to your workspace’s `launch.json`, which will detect and run the apphost in the workspace. | Available    |
| Aspire: Manage configuration settings | Manage configuration settings including feature flags.                                                                                           | Available    |
| Aspire: Open Aspire terminal          | Open an Aspire VS Code terminal for working with Aspire projects.                                                                                | Available    |
| Aspire: Publish deployment artifacts  | Generates deployment artifacts for an Aspire apphost.                                                                                            | Preview      |
| Aspire: Deploy app                    | Deploy the contents of an Aspire apphost to its defined deployment targets.                                                                      | Preview      |
| Aspire: Update integrations           | Update hosting integrations and Aspire SDK in the apphost.                                                                                       | Preview      |

## Create a new Aspire app

[Section titled “Create a new Aspire app”](#create-a-new-aspire-app)

To create a new Aspire app using the extension:

1. Open the Command Palette ( Command + Shift + P `CmdShiftP` Control + Shift + P `CtrlShiftP` Control + Shift + P `CtrlShiftP` ).
2. Run the **Aspire: New Aspire project** command.
3. Select the desired template.
4. Specify the project name and location.

![A screenshot of VS Code showing how to create a new Aspire solution by using the Aspire extension with template options displayed.](/_astro/code-extension-create-aspire-project.CANwZRkS.png)

The extension creates the project and opens it in VS Code.

## Add an integration to the Aspire solution

[Section titled “Add an integration to the Aspire solution”](#add-an-integration-to-the-aspire-solution)

Aspire integrations provide pre-configured connections to various cloud services and dependencies. To add an integration:

1. Open the Command Palette.
2. Run the **Aspire: Add an integration** command.
3. Browse or search for the desired integration package.
4. Select the integration to add it to your AppHost project.

The extension adds the appropriate NuGet package reference to your AppHost project.

Note

The **Add an integration** command adds a hosting integration to the AppHost project. It doesn’t add the corresponding client integration to any consuming projects.

## Configure an Aspire solution

[Section titled “Configure an Aspire solution”](#configure-an-aspire-solution)

The Aspire extension includes several commands that configure the behavior of Aspire and the Aspire CLI during development:

### Configure launch.json for debugging

[Section titled “Configure launch.json for debugging”](#configure-launchjson-for-debugging)

To run and debug your Aspire application in VS Code, you need to configure the `launch.json` file:

1. Open the Command Palette.
2. Run the **Aspire: Configure launch.json** command.
3. The extension adds a default Aspire debugger configuration to your workspace’s `launch.json` file.

The default configuration looks like this:

.vscode/launch.json

```json
{
  "type": "aspire",
  "request": "launch",
  "name": "Aspire: Launch Default AppHost",
  "program": "${workspaceFolder}"
}
```

You can customize the `program` field to point to a specific AppHost project file. For example:

.vscode/launch.json

```json
{
  "type": "aspire",
  "request": "launch",
  "name": "Aspire: Launch MyAppHost",
  "program": "${workspaceFolder}/MyAppHost/MyAppHost.csproj"
}
```

### Manage configuration settings

[Section titled “Manage configuration settings”](#manage-configuration-settings)

The **Aspire: Manage configuration settings** command executes `aspire config` request options and displays the results in the VS Code terminal. Use `get` and `set` commands to configure the Aspire CLI. Use the `list` command to show current configuration values.

## Run an Aspire solution in development mode

[Section titled “Run an Aspire solution in development mode”](#run-an-aspire-solution-in-development-mode)

To run your Aspire application in development mode:

1. Ensure you have configured `launch.json` as described in the [Configure launch.json for debugging](#configure-launchjson-for-debugging) section.
2. Open the Run and Debug view by selecting **View** > **Run** or pressing Command + Shift + D `CmdShiftD` Control + Shift + D `CtrlShiftD` Control + Shift + D `CtrlShiftD` .
3. Select your Aspire launch configuration from the dropdown.
4. Select the green **Start Debugging** button or press F5 `F5` F5 `F5` F5 `F5` .

The extension builds and starts the AppHost project, launches the Aspire dashboard in your browser, and enables debugging for all resources in your solution.

Alternatively, you can open an Aspire VS Code terminal using `Aspire: Open Aspire terminal` and run `aspire run --start-debug-session` to start a VS Code debug session.

### Run or debug from the editor

[Section titled “Run or debug from the editor”](#run-or-debug-from-the-editor)

When an AppHost project is detected in your workspace, you can also run or debug it directly from the editor. Use the run buttons in the editor title bar when viewing an AppHost file.

## Publish deployment artifacts

[Section titled “Publish deployment artifacts”](#publish-deployment-artifacts)

Caution

This feature is in **Preview**.

The **Aspire: Publish deployment artifacts** command generates deployment artifacts for your Aspire AppHost. This command serializes resources to disk, allowing them to be consumed by deployment tools.

To publish deployment artifacts:

1. Open the Command Palette.
2. Run the **Aspire: Publish deployment artifacts** command.
3. Select the output location for the generated artifacts.

The command invokes registered publishing callback annotations to generate artifacts such as:

* Bicep files for Azure resources.
* Docker Compose YAML files.
* Kubernetes Helm charts.

For more information about Aspire publishing, see [Aspire publishing and deployment overview](/deployment/overview/).

## Deploy an Aspire solution

[Section titled “Deploy an Aspire solution”](#deploy-an-aspire-solution)

Caution

This feature is in **Preview**.

The **Aspire: Deploy app host** command deploys the contents of an Aspire AppHost to its defined deployment targets.

To deploy an Aspire solution:

1. Open the Command Palette.
2. Run the **Aspire: Deploy app host** command.
3. Follow the prompts to select deployment targets and provide any required configuration.

The command publishes deployment artifacts and then invokes deployment callback annotations to deploy resources to the specified targets.

For more information about Aspire deployment, see [Aspire publishing and deployment overview](/deployment/overview/).

## Open Aspire terminal

[Section titled “Open Aspire terminal”](#open-aspire-terminal)

The **Aspire: Open Aspire terminal** command opens a terminal window configured for working with Aspire projects. This terminal provides easy access to Aspire CLI commands and is preconfigured with the appropriate environment variables.

## Feedback and issues

[Section titled “Feedback and issues”](#feedback-and-issues)

To report issues or request features for the Aspire VS Code extension:

1. Visit the [Aspire GitHub repository](https://github.com/dotnet/aspire/issues).
2. Create a new issue and add the `area-extension` label.

# Configure the MCP server

> Learn how to use AI assistants with Aspire for agentic development.

Aspire provides powerful integrations with AI assistants through the Model Context Protocol (MCP). This enables *agentic development* — a workflow where AI assistants can directly interact with your Aspire application to help you build, debug, and monitor your distributed applications.

## Get started with `aspire mcp init`

[Section titled “Get started with aspire mcp init”](#get-started-with-aspire-mcp-init)

The easiest way to configure the Aspire MCP server is using the Aspire CLI. The `aspire mcp init` command automatically detects your AI development environment and creates the necessary configuration files.

1. Open a terminal in your Aspire project directory (the folder containing your AppHost).

2. Run the following command:

   Aspire CLI

   ```bash
   aspire mcp init
   ```

3. The command detects supported agent environments (such as VS Code with GitHub Copilot, or other MCP-compatible tools) and creates the appropriate configuration files.

That’s it! The Aspire CLI handles all the configuration details for you, including setting up the MCP server connection and any required authentication.

Tip

If you don’t already have an `AGENTS.md` file in your project, one will be created for you. This file contains instructions that help your AI coding agent perform better when working with an Aspire-enabled codebase.

## Understanding the configuration

[Section titled “Understanding the configuration”](#understanding-the-configuration)

When you run `aspire mcp init`, the CLI creates configuration files appropriate for your detected environment. Here are examples of the configuration files created for different AI assistants:

* VS Code

  Creates or updates `.vscode/mcp.json`:

  .vscode/mcp.json

  ```json
  {
    "servers": {
      "aspire": {
        "type": "stdio",
        "command": "aspire",
        "args": [
          "mcp",
          "start"
        ]
      },
      "playwright": {
        "type": "stdio",
        "command": "npx",
        "args": [
          "-y",
          "@playwright/mcp@latest"
        ]
      }
    }
  }
  ```

* Copilot CLI

  Creates or updates `~/.copilot/mcp-config.json`:

  \~/.copilot/mcp-config.json

  ```json
  {
    "mcpServers": {
      "aspire": {
        "type": "local",
        "command": "aspire",
        "args": [
          "mcp",
          "start"
        ]
      },
      "playwright": {
        "type": "local",
        "command": "npx",
        "args": [
          "-y",
          "@playwright/mcp@latest"
        ],
        "tools": [
          "*"
        ]
      }
    }
  }
  ```

* Claude Code

  Creates or updates `.mcp.json`:

  .mcp.json

  ```json
  {
    "mcpServers": {
      "aspire": {
        "command": "aspire",
        "args": [
          "mcp",
          "start"
        ]
      },
      "playwright": {
        "command": "npx",
        "args": [
          "-y",
          "@playwright/mcp@latest"
        ]
      }
    }
  }
  ```

  Note

  On Windows, commands like `npx` require a `cmd.exe /c` prefix to work correctly. This affects cross-platform portability of MCP configurations. See [GitHub issue #14000](https://github.com/anthropics/claude-code/issues/14000) for more details.

* OpenCode

  Creates or updates `opencode.jsonc`:

  opencode.jsonc

  ```jsonc
  {
    "mcp": {
      "aspire": {
        "type": "local",
        "command": [
          "aspire",
          "mcp",
          "start"
        ],
        "enabled": true
      },
      "playwright": {
        "type": "local",
        "command": [
          "npx",
          "-y",
          "@playwright/mcp@latest"
        ],
        "enabled": true
      }
    }
  }
  ```

## Your first prompts

[Section titled “Your first prompts”](#your-first-prompts)

Once you’ve configured the MCP server, start your preferred agentic coding environment. The Aspire MCP server will automatically start and connect, giving your AI assistant access to your running Aspire application.

Try asking your AI assistant:

> “Are all my resources running?”

> “Analyze HTTP requests performance for RESOURCE\_NAME.”

> “Restart unhealthy resources.”

* VS Code

  [](/mcp-vscode-list-resources.mp4)   Pause video

* Claude Code

* Copilot CLI

* OpenCode

## Tools

[Section titled “Tools”](#tools)

The Aspire MCP server provides the following tools:

* `list_resources` - Lists all resources, including their state, health status, source, endpoints, and commands.
* `list_console_logs` - Lists console logs for a resource.
* `list_structured_logs` - Lists structured logs, optionally filtered by resource name.
* `list_traces` - Lists distributed traces. Traces can be filtered using an optional resource name parameter.
* `list_trace_structured_logs` - Lists structured logs for a trace.
* `execute_resource_command` - Executes a resource command. This tool accepts parameters for the resource name and command name.
* `list_apphosts` - Lists all AppHost connections currently detected by the Aspire MCP server, showing which AppHosts are within the working directory scope and which are outside.
* `select_apphost` - Selects which AppHost to use when multiple AppHosts are running. The path can be a fully qualified path or a workspace root relative path.
* `list_integrations` - Lists available Aspire hosting integrations. These are NuGet packages that can be added to an Aspire AppHost project to integrate with various services like databases, message brokers, and cloud services.
* `get_integration_docs` - Gets documentation for a specific Aspire hosting integration package. Use this tool to get detailed information about how to use an integration within the AppHost.

By default all resources, console logs and telemetry is accessible by Aspire MCP. Resources and associated telemetry can be excluded from MCP results by annotating the resource in the app host with `ExcludeFromMcp()`.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiservice = builder.AddProject<Projects.AspireApp_ApiService>("apiservice")
    .ExcludeFromMcp();


builder.AddProject<Projects.AspireApp_Web>("webfrontend")
    .WithExternalHttpEndpoints()
    .WithReference(apiService);


builder.Build().Run();
```

## Supported AI assistants

[Section titled “Supported AI assistants”](#supported-ai-assistants)

The `aspire mcp init` command supports the following AI assistants:

* [VS Code](https://code.visualstudio.com/docs/copilot/customization/mcp-servers)
* [Copilot CLI](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli#add-an-mcp-server)
* [Claude Code](https://docs.claude.com/en/docs/claude-code/mcp)
* [OpenCode](https://opencode.ai/docs/mcp-servers/)

Note

The Aspire MCP server uses the STDIO transport protocol and may work with other agentic coding environments that support this MCP communication protocol.

## Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

Aspire MCP is designed to work seamlessly with AI assistants, but you may encounter some setup challenges depending on your environment. If you run into issues, check the [open MCP issues on GitHub](https://github.com/dotnet/aspire/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-mcp) for known problems and solutions.

## Limitations

[Section titled “Limitations”](#limitations)

Aspire MCP is a powerful tool, but there are a few things to keep in mind when using it.

### Data size

[Section titled “Data size”](#data-size)

AI models have limits on how much data they can process at once. Aspire MCP may limit the amount of data returned from tools when necessary.

* Large data fields (e.g., long exception stack traces) may be truncated.
* Requests involving large collections of telemetry may be shortened by omitting older items.

## See also

[Section titled “See also”](#see-also)

* [aspire mcp command](/reference/cli/commands/aspire-mcp/)
* [aspire mcp init command](/reference/cli/commands/aspire-mcp-init/)
* [aspire mcp start command](/reference/cli/commands/aspire-mcp-start/)
* [GitHub Copilot in the Dashboard](/dashboard/copilot/)

# Deploy your first Aspire app

> Learn how to deploy your first Aspire application to the cloud.

Select your programming language to get started

C#  Python  JavaScript (coming soon)

In this tutorial, you take the app you created in the [Build your first Aspire app](/get-started/first-app/) quickstart and deploy it. This can be broken down into several key steps:

1. [Add deployment package](#add-deployment-package) — Add the hosting package for your target.
2. [Update your AppHost](#update-your-apphost) — Configure the environment API.
3. [Deploy your app](#deploy-your-app) — Deploy using the Aspire CLI.
4. [Verify your deployment](#verify-your-deployment) — Ensure your app is running as expected.
5. [Clean up resources](#clean-up-resources) — Remove any deployed resources to avoid incurring costs.

The following diagram shows the architecture of the sample app you’re deploying:

```
architecture-beta
    group api-docker(logos:docker-icon)[API container]
    group f-docker(logos:docker-icon)[Front end container]

    service api(logos:dotnet)[API service] in api-docker
    service http(iconoir:server-connection)[https]
    service frontend(aspire:blazor)[Blazor front end] in f-docker

    frontend:L --> R:http
    http:L --> R:api
```

The ASP.NET Core Blazor & Minimal API starter template consists of two resources, each deployed as a separate container.

```
architecture-beta
  group docker(logos:docker-icon)[Python and static site server container]  

  service api(logos:fastapi)[API service] in docker
  service http(iconoir:server-connection)[https] in docker
  service frontend(logos:react)[React front end] in docker

  frontend:L --> R:http
  http:L --> R:api
```

The React (Vite) & FastAPI starter template consists of two resources that are deployed as a single container. The FastAPI server hosts both the API and the static frontend files generated by React.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

Depending on where you want to deploy your Aspire app, ensure you have the following prerequisites installed and configured:

* Docker Compose

  ![Docker logo](/_astro/docker.CnL-arqo_4GkmT.svg)

  * [Docker Desktop](https://www.docker.com/products/docker-desktop) installed and running.
  * [Podman (alternative to Docker)](https://podman.io/getting-started/installation) installed and running. For more information, see [OCI-compatible container runtime](/get-started/prerequisites/#install-an-oci-compliant-container-runtime).

* Azure

  ![Azure logo](/_astro/azure-icon.Be9vXxEg_2qTdxK.webp)

  * An [Azure account](https://azure.microsoft.com/free/) with an active subscription.
  * [Azure CLI](https://learn.microsoft.com/cli/azure/install-azure-cli) installed and configured. You should be logged in using `az login`.

## Add deployment package

[Section titled “Add deployment package”](#add-deployment-package)

In the root directory of your Aspire solution that you created in the previous quickstart, add the appropriate hosting deployment package by running the following command in your terminal:

* Docker Compose

  [Docker Compose](https://docs.docker.com/compose/) is a tool for defining and running multi-container Docker applications. It allows you to use a YAML file to configure your application’s services, networks, and volumes, making it easier to manage and deploy complex applications locally or in various environments.

  Aspire CLI — Add Docker Compose

  ```bash
  aspire add docker
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result for the [📦 Aspire.Hosting.Docker](https://www.nuget.org/packages/Aspire.Hosting.Docker) version you want to add.

* Azure

  Aspire CLI — Add Azure App Containers

  ```bash
  aspire add azure-appcontainers
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result for the [📦 Aspire.Hosting.Azure.AppContainers](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppContainers) version you want to add.

## Update your AppHost

[Section titled “Update your AppHost”](#update-your-apphost)

In the AppHost, chain a call to the appropriate environment API method to configure the deployment environment for your target.

* Docker Compose

  C# — AppHost.cs project-based orchestrator

  ```csharp
  var builder = DistributedApplication.CreateBuilder(args);


  // Add the following line to configure the Docker Compose environment
  builder.AddDockerComposeEnvironment("env");


  var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice")
      .WithHttpHealthCheck("/health");


  builder.AddProject<Projects.AspireApp_Web>("webfrontend")
      .WithExternalHttpEndpoints()
      .WithHttpHealthCheck("/health")
      .WithReference(apiService)
      .WaitFor(apiService);


  builder.Build().Run();
  ```

  C# — apphost.cs file-based orchestrator

  ```csharp
  #:sdk Aspire.AppHost.Sdk@13.1.0
  #:package Aspire.Hosting.JavaScript@13.1.0
  #:package Aspire.Hosting.Python@13.1.0
  #:package Aspire.Hosting.Docker@13.1.0-preview.1.25616.3


  var builder = DistributedApplication.CreateBuilder(args);


  // Add the following line to configure the Docker Compose environment
  builder.AddDockerComposeEnvironment("env");


  var app = builder.AddUvicornApp("app", "./app", "main:app")
      .WithUv()
      .WithExternalHttpEndpoints()
      .WithHttpHealthCheck("/health");


  var frontend = builder.AddViteApp("frontend", "./frontend")
      .WithReference(app)
      .WaitFor(app);


  app.PublishWithContainerFiles(frontend, "./static");


  builder.Build().Run();
  ```

  * `AddDockerComposeEnvironment` — Configures the Docker Compose environment for deployment. This call implicitly adds support for containerizing resources in the AppHost as part of deployment.
  * `WithExternalHttpEndpoints` — Exposes HTTP endpoints for the resource when deployed.

* Azure

  C# — AppHost.cs project-based orchestrator

  ```csharp
  var builder = DistributedApplication.CreateBuilder(args);


  // Add the following line to configure the Azure App Container environment
  builder.AddAzureContainerAppEnvironment("env");


  var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice")
      .WithHttpHealthCheck("/health");


  builder.AddProject<Projects.AspireApp_Web>("webfrontend")
      .WithExternalHttpEndpoints()
      .WithHttpHealthCheck("/health")
      .WithReference(apiService)
      .WaitFor(apiService);


  builder.Build().Run();
  ```

  C# — apphost.cs file-based orchestrator

  ```csharp
  #:sdk Aspire.AppHost.Sdk@13.1.0
  #:package Aspire.Hosting.JavaScript@13.1.0
  #:package Aspire.Hosting.Python@13.1.0
  #:package Aspire.Hosting.Azure.AppContainers@13.1.0


  var builder = DistributedApplication.CreateBuilder(args);


  // Add the following line to configure the Azure App Container environment
  builder.AddAzureContainerAppEnvironment("env");


  var app = builder.AddUvicornApp("app", "./app", "main:app")
      .WithUv()
      .WithExternalHttpEndpoints()
      .WithHttpHealthCheck("/health");


  var frontend = builder.AddViteApp("frontend", "./frontend")
      .WithReference(app)
      .WaitFor(app);


  app.PublishWithContainerFiles(frontend, "./static");


  builder.Build().Run();
  ```

  * `AddAzureContainerAppEnvironment` — Configures the Azure App Container environment for deployment. This call implicitly adds support for containerizing resources in the AppHost as part of deployment.
  * `WithExternalHttpEndpoints` — Exposes HTTP endpoints for the resource when deployed.

CLI protip

After installing a new deployment package, you can run `aspire do diagnostics` in your terminal to see the available deploy steps. For more information, see the [aspire do diagnostics](/reference/cli/commands/aspire-do/) reference docs.

## Deploy your app

[Section titled “Deploy your app”](#deploy-your-app)

Now that you’ve added the deployment package and updated your AppHost, you can deploy your Aspire app.

* Docker Compose

  Deploying to Docker Compose builds the container images and starts the services locally using Docker Compose.

  Aspire CLI — Deploy your app

  ```bash
  aspire deploy
  ```

  Consider the following example output:

  Example output for deploying ASP.NET Core/Blazor app to Docker Compose

  Aspire CLI - Deploy ASP.NET Core/Blazor app with Docker Compose

  ```bash
  14:28:15 (pipeline execution) → Starting pipeline execution...
  14:28:15 (build-prereq) → Starting build-prereq...
  14:28:15 (publish-env) → Starting publish-env...
  14:28:15 (deploy-prereq) → Starting deploy-prereq...
  14:28:15 (build-prereq) ✓ build-prereq completed successfully
  14:28:15 (deploy-prereq) i [INF] Initializing deployment for environment 'Production'
  14:28:15 (publish-env) i [INF] Generating Compose output
  14:28:15 (deploy-prereq) i [INF] Setting default deploy tag 'aspire-deploy-20251107202815' for compute resource(s).
  14:28:15 (deploy-prereq) ✓ deploy-prereq completed successfully
  14:28:15 (build-webfrontend) → Starting build-webfrontend...
  14:28:15 (build-apiservice) → Starting build-apiservice...
  14:28:15 (publish-env) → Writing the Docker Compose file to the output path.
  14:28:15 (build-webfrontend) i [INF] Building container image for resource webfrontend
  14:28:15 (build-apiservice) i [INF] Building container image for resource apiservice
  14:28:15 (build-webfrontend) i [INF] Building image: webfrontend
  14:28:15 (publish-env) ✓ Docker Compose file written successfully to .\AspireApp\AspireApp.AppHost\aspire-output\docker-compose.yaml. (0.0s)
  14:28:15 (publish-env) ✓ publish-env completed successfully
  14:28:15 (publish) → Starting publish...
  14:28:15 (publish) ✓ publish completed successfully
  14:28:28 (build-webfrontend) i [INF] Building image for webfrontend completed
  14:28:28 (build-apiservice) i [INF] Building image: apiservice
  14:28:28 (build-webfrontend) ✓ build-webfrontend completed successfully
  14:28:32 (build-apiservice) i [INF] Building image for apiservice completed
  14:28:32 (build-apiservice) ✓ build-apiservice completed successfully
  14:28:32 (build) → Starting build...
  14:28:32 (build) ✓ build completed successfully
  14:28:32 (prepare-env) → Starting prepare-env...
  14:28:32 (prepare-env) ✓ prepare-env completed successfully
  14:28:32 (docker-compose-up-env) → Starting docker-compose-up-env...
  14:28:32 (docker-compose-up-env) → Running docker compose up for env
  14:28:35 (docker-compose-up-env) ✓ Service env is now running with Docker Compose locally (2.3s)
  14:28:35 (docker-compose-up-env) ✓ docker-compose-up-env completed successfully
  14:28:35 (print-env-dashboard-summary) → Starting print-env-dashboard-summary...
  14:28:35 (print-webfrontend-summary) → Starting print-webfrontend-summary...
  14:28:35 (print-env-dashboard-summary) i [INF] Successfully deployed env-dashboard to http://localhost:54633.
  14:28:35 (print-webfrontend-summary) i [INF] Successfully deployed webfrontend to http://localhost:54463.
  14:28:35 (print-env-dashboard-summary) ✓ print-env-dashboard-summary completed successfully
  14:28:35 (print-webfrontend-summary) ✓ print-webfrontend-summary completed successfully
  14:28:35 (deploy) → Starting deploy...
  14:28:35 (deploy) ✓ deploy completed successfully
  14:28:35 (pipeline execution) ✓ Completed successfully
  ------------------------------------------------------------
  ✓ 13/13 steps succeeded • Total time: 20.0s


  Steps Summary:
  19.9 s  ✓ pipeline execution
  17.6 s  ✓ build-apiservice
  12.9 s  ✓ build-webfrontend
  2.3 s  ✓ docker-compose-up-env
  0.0 s  ✓ publish-env
  0.0 s  ✓ deploy-prereq
  0.0 s  ✓ build-prereq
  0.0 s  ✓ build
  0.0 s  ✓ prepare-env
  0.0 s  ✓ print-env-dashboard-summary
  0.0 s  ✓ print-webfrontend-summary
  0.0 s  ✓ deploy
  0.0 s  ✓ publish


  ✓ PIPELINE SUCCEEDED
  ------------------------------------------------------------
  ```

  Example output for deploying Python/React app to Docker Compose

  Aspire CLI - Deploy Python/React app with Docker Compose

  ```bash
  13:23:29 (pipeline execution) → Starting pipeline execution...
  13:23:29 (publish-env) → Starting publish-env...
  13:23:29 (build-prereq) → Starting build-prereq...
  13:23:29 (deploy-prereq) → Starting deploy-prereq...
  13:23:29 (build-prereq) ✓ build-prereq completed successfully
  13:23:29 (deploy-prereq) i [INF] Initializing deployment for environment 'Production'
  13:23:29 (publish-env) i [INF] Generating Compose output
  13:23:29 (deploy-prereq) i [INF] Setting default deploy tag 'aspire-deploy-20251107192329' for compute resource(s).
  13:23:29 (deploy-prereq) ✓ deploy-prereq completed successfully
  13:23:29 (build-frontend) → Starting build-frontend...
  13:23:29 (build-frontend) i [INF] Building container image for resource frontend
  13:23:29 (build-frontend) i [INF] Building image: frontend
  13:23:29 (publish-env) → Writing the Docker Compose file to the output path.
  13:23:29 (publish-env) ✓ Docker Compose file written successfully to ./aspire-app/aspire-output/docker-compose.yaml. (0.0s)
  13:23:29 (publish-env) ✓ publish-env completed successfully
  13:23:29 (publish) → Starting publish...
  13:23:29 (publish) ✓ publish completed successfully
  13:23:51 (build-frontend) i [INF] docker buildx for frontend:5ee04da8ac438e73afdb5ab3a7b551d3be1a5feb succeeded.
  13:23:51 (build-frontend) i [INF] Building image for frontend completed
  13:23:51 (build-frontend) ✓ build-frontend completed successfully
  13:23:51 (build-app) → Starting build-app...
  13:23:51 (build-app) i [INF] Building container image for resource app
  13:23:51 (build-app) i [INF] Building image: app
  13:24:07 (build-app) i [INF] docker buildx for app:5d592d0c1d2f417b0c14c4c4a9efb4f0760be8e4 succeeded.
  13:24:07 (build-app) i [INF] Building image for app completed
  13:24:07 (build-app) ✓ build-app completed successfully
  13:24:07 (build) → Starting build...
  13:24:07 (build) ✓ build completed successfully
  13:24:07 (prepare-env) → Starting prepare-env...
  13:24:07 (prepare-env) ✓ prepare-env completed successfully
  13:24:07 (docker-compose-up-env) → Starting docker-compose-up-env...
  13:24:07 (docker-compose-up-env) → Running docker compose up for env
  13:24:13 (docker-compose-up-env) ✓ Service env is now running with Docker Compose locally (5.6s)
  13:24:13 (docker-compose-up-env) ✓ docker-compose-up-env completed successfully
  13:24:13 (print-env-dashboard-summary) → Starting print-env-dashboard-summary...
  13:24:13 (print-app-summary) → Starting print-app-summary...
  13:24:13 (print-env-dashboard-summary) i [INF] Successfully deployed env-dashboard to http://localhost:54633.
  13:24:13 (print-app-summary) i [INF] Successfully deployed app to http://localhost:54463.
  13:24:13 (print-env-dashboard-summary) ✓ print-env-dashboard-summary completed successfully
  13:24:13 (print-app-summary) ✓ print-app-summary completed successfully
  13:24:13 (deploy) → Starting deploy...
  13:24:13 (deploy) ✓ deploy completed successfully
  13:24:13 (pipeline execution) ✓ Completed successfully
  ------------------------------------------------------------
  ✓ 13/13 steps succeeded • Total time: 44.1s


  Steps Summary:
  44.0 s  ✓ pipeline execution
  22.2 s  ✓ build-frontend
  16.3 s  ✓ build-app
  5.6 s  ✓ docker-compose-up-env
  0.0 s  ✓ publish-env
  0.0 s  ✓ deploy-prereq
  0.0 s  ✓ build-prereq
  0.0 s  ✓ print-env-dashboard-summary
  0.0 s  ✓ print-app-summary
  0.0 s  ✓ deploy
  0.0 s  ✓ build
  0.0 s  ✓ prepare-env
  0.0 s  ✓ publish


  ✓ PIPELINE SUCCEEDED
  ------------------------------------------------------------
  ```

* Azure

  When deploying to Azure, the `aspire deploy` command is interactive. To avoid prompts (for example, when running in CI/CD), set the following environment variables:

  * `Azure__SubscriptionId`: Target Azure subscription ID.
  * `Azure__Location`: Azure region (for example, eastus).
  * `Azure__ResourceGroup`: Resource group name to create or reuse.

  Deploying to Azure App Containers builds the container images and deploys the services to Azure App Containers.

  Aspire CLI — Deploy your app

  ```bash
  aspire deploy
  ```

  Consider the following example output:

  Example output for deploying ASP.NET Core/Blazor app to Azure App Containers

  Aspire CLI - Deploy ASP.NET Core/Blazor app to Azure App Containers

  ```bash
  09:19:34 (pipeline execution) → Starting pipeline execution...
  09:19:34 (deploy-prereq) → Starting deploy-prereq...
  09:19:34 (build-prereq) → Starting build-prereq...
  09:19:34 (build-prereq) ✓ build-prereq completed successfully
  09:19:34 (deploy-prereq) i [INF] Initializing deployment for environment 'Production'
  09:19:34 (deploy-prereq) i [INF] Deployment state will be loaded from:
    %USERPROFILE%\.aspire\deployments\{AppHost:Sha}\production.json
  09:19:34 (deploy-prereq) i [INF] Setting default deploy tag 'aspire-deploy-20251110151934' for compute resource(s).
  09:19:34 (deploy-prereq) ✓ deploy-prereq completed successfully
  09:19:34 (validate-azure-login) → Starting validate-azure-login...
  09:19:34 (build-webfrontend) → Starting build-webfrontend...
  09:19:34 (build-apiservice) → Starting build-apiservice...
  09:19:34 (build-apiservice) i [INF] Building container image for resource apiservice
  09:19:34 (build-webfrontend) i [INF] Building container image for resource webfrontend
  09:19:34 (build-apiservice) i [INF] Building image: apiservice
  09:19:36 (validate-azure-login) ✓ Azure CLI authentication validated successfully
  09:19:36 (create-provisioning-context) → Starting create-provisioning-context...
  09:19:36 (create-provisioning-context) i [INF] Using DefaultAzureCredential for provisioning.
  09:19:38 (create-provisioning-context) i [INF] Default subscription: {SUB_NAME} subscription (/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
  09:19:38 (create-provisioning-context) i [INF] Tenant: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  09:19:38 (create-provisioning-context) i [INF] Using existing resource group pinesharp-rg.
  09:19:39 (create-provisioning-context) ✓ create-provisioning-context completed successfully
  09:19:39 (provision-env) → Starting provision-env...
  09:19:39 (provision-env) → Deploying env
  09:19:39 (provision-env) ✓ Using existing deployment for env (0.1s)
  09:19:39 (provision-env) ✓ provision-env completed successfully
  09:19:39 (login-to-acr-env) → Starting login-to-acr-env...
  09:19:39 (login-to-acr-env) → Logging in to envacrdwu3vj6ylvngg
  09:19:41 (login-to-acr-env) i [INF] Start processing HTTP request POST https://envacrdwu3vj6ylvngg.azurecr.io/oauth2/exchange
  09:19:41 (login-to-acr-env) i [INF] Sending HTTP request POST https://envacrdwu3vj6ylvngg.azurecr.io/oauth2/exchange
  09:19:41 (login-to-acr-env) i [INF] Received HTTP response headers after 224.2336ms - 200
  09:19:41 (login-to-acr-env) i [INF] End processing HTTP request after 234.3842ms - 200
  09:19:43 (login-to-acr-env) i [INF] Docker login to envacrdwu3vj6ylvngg.azurecr.io succeeded.
  09:19:43 (login-to-acr-env) ✓ Successfully logged in to envacrdwu3vj6ylvngg.azurecr.io (3.5s)
  09:19:43 (login-to-acr-env) ✓ login-to-acr-env completed successfully
  09:19:44 (build-apiservice) i [INF] Building image for apiservice completed
  09:19:44 (build-webfrontend) i [INF] Building image: webfrontend
  09:19:44 (build-apiservice) ✓ build-apiservice completed successfully
  09:19:44 (push-apiservice) → Starting push-apiservice...
  09:19:44 (push-apiservice) → Pushing apiservice to envacrdwu3vj6ylvngg
  09:19:45 (push-apiservice) i [INF] Docker tag for apiservice -> envacrdwu3vj6ylvngg.azurecr.io/apiservice:aspire-deploy-20251110151934 succeeded.
  09:19:54 (build-webfrontend) i [INF] Building image for webfrontend completed
  09:19:54 (build-webfrontend) ✓ build-webfrontend completed successfully
  09:19:54 (push-webfrontend) → Starting push-webfrontend...
  09:19:54 (push-webfrontend) → Pushing webfrontend to envacrdwu3vj6ylvngg
  09:19:55 (push-webfrontend) i [INF] Docker tag for webfrontend -> envacrdwu3vj6ylvngg.azurecr.io/webfrontend:aspire-deploy-20251110151934 succeeded.
  09:21:04 (push-apiservice) i [INF] Docker push for envacrdwu3vj6ylvngg.azurecr.io/apiservice:aspire-deploy-20251110151934 succeeded.
  09:21:04 (push-apiservice) ✓ Successfully pushed apiservice to envacrdwu3vj6ylvngg.azurecr.io/apiservice:aspire-deploy-20251110151934 (79.7s)
  09:21:04 (push-apiservice) ✓ push-apiservice completed successfully
  09:21:04 (provision-apiservice-containerapp) → Starting provision-apiservice-containerapp...
  09:21:04 (provision-apiservice-containerapp) → Deploying apiservice-containerapp
  09:21:04 (push-webfrontend) i [INF] Docker push for envacrdwu3vj6ylvngg.azurecr.io/webfrontend:aspire-deploy-20251110151934 succeeded.
  09:21:04 (push-webfrontend) ✓ Successfully pushed webfrontend to envacrdwu3vj6ylvngg.azurecr.io/webfrontend:aspire-deploy-20251110151934 (70.9s)
  09:21:04 (push-webfrontend) ✓ push-webfrontend completed successfully
  09:21:04 (provision-webfrontend-containerapp) → Starting provision-webfrontend-containerapp...
  09:21:04 (provision-webfrontend-containerapp) → Deploying webfrontend-containerapp
  09:21:44 (provision-webfrontend-containerapp) ✓ Successfully provisioned webfrontend-containerapp (39.9s)
  09:21:44 (provision-webfrontend-containerapp) ✓ provision-webfrontend-containerapp completed successfully
  09:21:44 (print-webfrontend-summary) → Starting print-webfrontend-summary...
  09:21:44 (print-webfrontend-summary) i [INF] Successfully deployed webfrontend to https://webfrontend.nicesea-f33ccead.centralus.azurecontainerapps.io
  09:21:44 (print-webfrontend-summary) ✓ print-webfrontend-summary completed successfully
  09:21:49 (provision-apiservice-containerapp) ✓ Successfully provisioned apiservice-containerapp (45.4s)
  09:21:49 (provision-apiservice-containerapp) ✓ provision-apiservice-containerapp completed successfully
  09:21:49 (provision-azure-bicep-resources) → Starting provision-azure-bicep-resources...
  09:21:49 (provision-azure-bicep-resources) ✓ provision-azure-bicep-resources completed successfully
  09:21:49 (print-dashboard-url-env) → Starting print-dashboard-url-env...
  09:21:49 (print-apiservice-summary) → Starting print-apiservice-summary...
  09:21:49 (print-apiservice-summary) i [INF] Successfully deployed apiservice to Azure Container Apps environment env. No public endpoints were configured.
  09:21:49 (print-apiservice-summary) ✓ print-apiservice-summary completed successfully
  09:21:49 (print-dashboard-url-env) ✓ Dashboard available at dashboard URL
  09:21:49 (deploy) → Starting deploy...
  09:21:49 (deploy) ✓ deploy completed successfully
  09:21:49 (pipeline execution) ✓ Completed successfully
  ------------------------------------------------------------
  ✓ 18/18 steps succeeded • Total time: 134.8s


  Steps Summary:
  134.8 s  ✓ pipeline execution
  79.7 s  ✓ push-apiservice
  70.9 s  ✓ push-webfrontend
  45.4 s  ✓ provision-apiservice-containerapp
  39.9 s  ✓ provision-webfrontend-containerapp
  19.1 s  ✓ build-webfrontend
  9.7 s  ✓ build-apiservice
  3.5 s  ✓ login-to-acr-env
  3.2 s  ✓ create-provisioning-context
  1.5 s  ✓ validate-azure-login
  0.1 s  ✓ provision-env
  0.0 s  ✓ deploy-prereq
  0.0 s  ✓ print-dashboard-url-env
  0.0 s  ✓ print-apiservice-summary
  0.0 s  ✓ print-webfrontend-summary
  0.0 s  ✓ provision-azure-bicep-resources
  0.0 s  ✓ build-prereq
  0.0 s  ✓ deploy


  ✓ PIPELINE SUCCEEDED
  ------------------------------------------------------------
  ```

  Example output for deploying Python/React app to Azure App Containers

  Aspire CLI - Deploy Python/React app to Azure App Containers

  ```bash
  09:24:18 (pipeline execution) → Starting pipeline execution...
  09:24:18 (deploy-prereq) → Starting deploy-prereq...
  09:24:18 (build-prereq) → Starting build-prereq...
  09:24:18 (deploy-prereq) i [INF] Initializing deployment for environment 'Production'
  09:24:18 (build-prereq) ✓ build-prereq completed successfully
  09:24:18 (deploy-prereq) i [INF] Deployment state will be loaded from:
    $HOME/.aspire/deployments/{AppHost:Sha256}/production.json
  09:24:18 (deploy-prereq) i [INF] Setting default deploy tag 'aspire-deploy-20251110152418' for compute resource(s).
  09:24:18 (deploy-prereq) ✓ deploy-prereq completed successfully
  09:24:18 (validate-azure-login) → Starting validate-azure-login...
  09:24:18 (build-frontend) → Starting build-frontend...
  09:24:18 (build-frontend) i [INF] Building container image for resource frontend
  09:24:18 (build-frontend) i [INF] Building image: frontend
  09:24:19 (validate-azure-login) ✓ Azure CLI authentication validated successfully
  09:24:19 (create-provisioning-context) → Starting create-provisioning-context...
  09:24:19 (create-provisioning-context) i [INF] Using DefaultAzureCredential for provisioning.
  09:24:21 (create-provisioning-context) i [INF] Default subscription: {SUB_NAME} subscription (/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
  09:24:21 (create-provisioning-context) i [INF] Tenant: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  09:24:21 (create-provisioning-context) i [INF] Using existing resource group pinethon-rg.
  09:24:22 (create-provisioning-context) ✓ create-provisioning-context completed successfully
  09:24:22 (provision-env) → Starting provision-env...
  09:24:22 (provision-env) → Deploying env
  09:24:22 (provision-env) ✓ Using existing deployment for env (0.0s)
  09:24:22 (provision-env) ✓ provision-env completed successfully
  09:24:22 (login-to-acr-env) → Starting login-to-acr-env...
  09:24:22 (login-to-acr-env) → Logging in to envacrkolahqusw5xw6
  09:24:22 (build-frontend) i [INF] docker buildx for frontend:2288f09e7ab91348b0092685454d4864f32f778f succeeded.
  09:24:22 (build-frontend) i [INF] Building image for frontend completed
  09:24:22 (build-frontend) ✓ build-frontend completed successfully
  09:24:22 (build-app) → Starting build-app...
  09:24:22 (build-app) i [INF] Building container image for resource app
  09:24:22 (build-app) i [INF] Building image: app
  09:24:23 (login-to-acr-env) i [INF] Start processing HTTP request POST https://envacrkolahqusw5xw6.azurecr.io/oauth2/exchange
  09:24:23 (login-to-acr-env) i [INF] Sending HTTP request POST https://envacrkolahqusw5xw6.azurecr.io/oauth2/exchange
  09:24:24 (login-to-acr-env) i [INF] Received HTTP response headers after 341.5701ms - 200
  09:24:24 (login-to-acr-env) i [INF] End processing HTTP request after 351.3163ms - 200
  09:24:25 (login-to-acr-env) i [INF] Docker login to envacrkolahqusw5xw6.azurecr.io succeeded.
  09:24:25 (login-to-acr-env) ✓ Successfully logged in to envacrkolahqusw5xw6.azurecr.io (3.2s)
  09:24:25 (login-to-acr-env) ✓ login-to-acr-env completed successfully
  09:24:27 (build-app) i [INF] docker buildx for app:023f0ae2975b959c9ce3f3a45c13a739c0841b16 succeeded.
  09:24:27 (build-app) i [INF] Building image for app completed
  09:24:27 (build-app) ✓ build-app completed successfully
  09:24:27 (push-app) → Starting push-app...
  09:24:27 (push-app) → Pushing app to envacrkolahqusw5xw6
  09:24:28 (push-app) i [INF] Docker tag for app:023f0ae2975b959c9ce3f3a45c13a739c0841b16 -> envacrkolahqusw5xw6.azurecr.io/app:aspire-deploy-20251110152418 succeeded.
  09:25:06 (push-app) i [INF] Docker push for envacrkolahqusw5xw6.azurecr.io/app:aspire-deploy-20251110152418 succeeded.
  09:25:06 (push-app) ✓ Successfully pushed app to envacrkolahqusw5xw6.azurecr.io/app:aspire-deploy-20251110152418 (38.5s)
  09:25:06 (push-app) ✓ push-app completed successfully
  09:25:06 (provision-app-containerapp) → Starting provision-app-containerapp...
  09:25:06 (provision-app-containerapp) → Deploying app-containerapp
  09:25:29 (provision-app-containerapp) ✓ Successfully provisioned app-containerapp (23.6s)
  09:25:29 (provision-app-containerapp) ✓ provision-app-containerapp completed successfully
  09:25:29 (print-app-summary) → Starting print-app-summary...
  09:25:29 (provision-azure-bicep-resources) → Starting provision-azure-bicep-resources...
  09:25:29 (provision-azure-bicep-resources) ✓ provision-azure-bicep-resources completed successfully
  09:25:29 (print-dashboard-url-env) → Starting print-dashboard-url-env...
  09:25:29 (print-app-summary) i [INF] Successfully deployed app to {DEPLOY_URL}
  09:25:29 (print-app-summary) ✓ print-app-summary completed successfully
  09:25:29 (print-dashboard-url-env) ✓ Dashboard available at dashboard URL
  09:25:29 (deploy) → Starting deploy...
  09:25:29 (deploy) ✓ deploy completed successfully
  09:25:29 (pipeline execution) ✓ Completed successfully
  ------------------------------------------------------------
  ✓ 15/15 steps succeeded • Total time: 71.6s


  Steps Summary:
  71.5 s  ✓ pipeline execution
  38.5 s  ✓ push-app
  23.6 s  ✓ provision-app-containerapp
  4.8 s  ✓ build-frontend
  4.7 s  ✓ build-app
  3.2 s  ✓ login-to-acr-env
  3.1 s  ✓ create-provisioning-context
  1.3 s  ✓ validate-azure-login
  0.0 s  ✓ provision-env
  0.0 s  ✓ deploy-prereq
  0.0 s  ✓ print-app-summary
  0.0 s  ✓ build-prereq
  0.0 s  ✓ print-dashboard-url-env
  0.0 s  ✓ provision-azure-bicep-resources
  0.0 s  ✓ deploy


  ✓ PIPELINE SUCCEEDED
  ------------------------------------------------------------
  ```

When you call `aspire deploy`, the Aspire CLI builds the container images for your resources, pushes them to the target environment (if applicable), and deploys the resources according to the configuration in your AppHost.

Common pitfall...

If you call `aspire deploy` and you see output similar to the following, be sure that you’ve actually [updated your AppHost](#update-your-apphost) to include the appropriate environment API for your target. This output indicates that there are no deploy steps configured for your target environment.

Aspire CLI - Empty deployment output

```bash
14:17:26 (pipeline execution) → Starting pipeline execution...
14:17:26 (deploy) → Starting deploy...
14:17:26 (deploy) ✓ deploy completed successfully
14:17:26 (pipeline execution) ✓ Completed successfully
------------------------------------------------------------
✓ 2/2 steps succeeded • Total time: 0.0s


Steps Summary:
0.0 s  ✓ pipeline execution
0.0 s  ✓ deploy


✓ PIPELINE SUCCEEDED
------------------------------------------------------------
```

Additional information about this command can be found in the [`aspire deploy`](/reference/cli/commands/aspire-deploy/) reference docs.

### Post deployment output

[Section titled “Post deployment output”](#post-deployment-output)

After a deployment, the Aspire CLI writes to the provided output path (or the default output path if none is provided) a set of files based on your deployment target. This may include files such as Docker Compose files, Kubernetes manifests, or cloud provider-specific configuration files.

* Docker Compose

  * aspire-output

    * .env
    * .env.Production
    * docker-compose.yaml

  The `aspire-output` directory contains the generated environment variables and the Docker Compose configuration. The best part is, these files are opaque to you as a developer—you don’t need to write them yourself!

  The `.env.Production` file contains the name of the app image:

  ./aspire-output/.env.Production

  ```dotenv
  # Container image name for apiservice
  APISERVICE_IMAGE=apiservice:latest


  # Default container port for apiservice
  APISERVICE_PORT=8080


  # Container image name for webfrontend
  WEBFRONTEND_IMAGE=webfrontend:latest


  # Default container port for webfrontend
  WEBFRONTEND_PORT=8080
  ```

  Finally, the `docker-compose.yaml` file defines the services for both the API and front end:

  ./aspire-output/docker-compose.yaml

  ```yaml
  services:
    env-dashboard:
      image: "mcr.microsoft.com/dotnet/nightly/aspire-dashboard:latest"
      expose:
      - "18888"
      - "18889"
      networks:
      - "aspire"
      restart: "always"
    apiservice:
      image: "${APISERVICE_IMAGE}"
      environment:
      OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES: "true"
      OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES: "true"
      OTEL_DOTNET_EXPERIMENTAL_OTLP_RETRY: "in_memory"
      ASPNETCORE_FORWARDEDHEADERS_ENABLED: "true"
      HTTP_PORTS: "${APISERVICE_PORT}"
      OTEL_EXPORTER_OTLP_ENDPOINT: "http://env-dashboard:18889"
      OTEL_EXPORTER_OTLP_PROTOCOL: "grpc"
      OTEL_SERVICE_NAME: "apiservice"
      expose:
      - "${APISERVICE_PORT}"
      networks:
      - "aspire"
    webfrontend:
      image: "${WEBFRONTEND_IMAGE}"
      environment:
      OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES: "true"
      OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES: "true"
      OTEL_DOTNET_EXPERIMENTAL_OTLP_RETRY: "in_memory"
      ASPNETCORE_FORWARDEDHEADERS_ENABLED: "true"
      HTTP_PORTS: "${WEBFRONTEND_PORT}"
      APISERVICE_HTTP: "http://apiservice:${APISERVICE_PORT}"
      services__apiservice__http__0: "http://apiservice:${APISERVICE_PORT}"
      APISERVICE_HTTPS: "https://apiservice:${APISERVICE_PORT}"
      OTEL_EXPORTER_OTLP_ENDPOINT: "http://env-dashboard:18889"
      OTEL_EXPORTER_OTLP_PROTOCOL: "grpc"
      OTEL_SERVICE_NAME: "webfrontend"
      ports:
      - "${WEBFRONTEND_PORT}"
      depends_on:
      apiservice:
          condition: "service_started"
      networks:
      - "aspire"
  networks:
    aspire:
      driver: "bridge"
  ```

  * aspire-output

    * .env
    * .env.Production
    * app.Dockerfile
    * docker-compose.yaml

  The `aspire-output` directory contains the generated environment variables, an `app.Dockerfile`, and the Docker Compose configuration. The best part is, these files are opaque to you as a developer—you don’t need to write them yourself!

  The `.env.Production` file contains the name of the app image:

  ./aspire-output/.env.Production

  ```dotenv
  APP_IMAGE=app:5d592d0c1d2f417b0c14c4c4a9efb4f0760be8e4
  ```

  The `app.Dockerfile` is generated as a multi-stage Dockerfile to build the Python and also serve the React front end using Uvicorn:

  ./aspire-output/app.Dockerfile

  ```dockerfile
  ARG FRONTEND_IMAGENAME=frontend:50f0ed07a5b8f57b3213e99d96b2e8ff68a1d5d7


  FROM ghcr.io/astral-sh/uv:python3.13-bookworm-slim AS builder


  # Enable bytecode compilation and copy mode for the virtual environment
  ENV UV_COMPILE_BYTECODE=1
  ENV UV_LINK_MODE=copy


  WORKDIR /app


  # Copy pyproject.toml to install dependencies
  COPY pyproject.toml /app/


  # Install dependencies and generate lock file
  # Uses BuildKit cache mount to speed up repeated builds
  RUN --mount=type=cache,target=/root/.cache/uv \
      uv sync --no-install-project --no-dev


  # Copy the rest of the application source and install the project
  COPY . /app
  RUN --mount=type=cache,target=/root/.cache/uv \
      uv sync --no-dev


  FROM ${FRONTEND_IMAGENAME} AS frontend_stage


  FROM python:3.13-slim-bookworm AS app


  COPY --from=frontend_stage /app/dist /app/./static


  # ------------------------------
  # 🚀 Runtime stage
  # ------------------------------
  # Create non-root user for security
  RUN groupadd --system --gid 999 appuser && useradd --system --gid 999 --uid 999 --create-home appuser


  # Copy the application and virtual environment from builder
  COPY --from=builder --chown=appuser:appuser /app /app


  # Add virtual environment to PATH and set VIRTUAL_ENV
  ENV PATH=/app/.venv/bin:${PATH}
  ENV VIRTUAL_ENV=/app/.venv
  ENV PYTHONDONTWRITEBYTECODE=1
  ENV PYTHONUNBUFFERED=1


  # Use the non-root user to run the application
  USER appuser


  # Set working directory
  WORKDIR /app


  # Run the application
  ENTRYPOINT ["uvicorn"]
  ```

  Finally, the `docker-compose.yaml` file defines the services for both the API and front end:

  ./aspire-output/docker-compose.yaml

  ```yaml
  services:
    env-dashboard:
      image: "mcr.microsoft.com/dotnet/nightly/aspire-dashboard:latest"
      expose:
      - "18888"
      - "18889"
      networks:
      - "aspire"
      restart: "always"
    app:
      image: "${APP_IMAGE}"
      command:
      - "main:app"
      - "--host"
      - "0.0.0.0"
      - "--port"
      - "8000"
      environment:
      OTEL_TRACES_EXPORTER: "otlp"
      OTEL_LOGS_EXPORTER: "otlp"
      OTEL_METRICS_EXPORTER: "otlp"
      OTEL_PYTHON_LOGGING_AUTO_INSTRUMENTATION_ENABLED: "true"
      PORT: "8000"
      OTEL_EXPORTER_OTLP_ENDPOINT: "http://env-dashboard:18889"
      OTEL_EXPORTER_OTLP_PROTOCOL: "grpc"
      OTEL_SERVICE_NAME: "app"
      ports:
      - "8000"
      networks:
      - "aspire"
  networks:
    aspire:
      driver: "bridge"
  ```

* Azure

  After deploying to Azure App Containers, the Aspire CLI saves the deployment state file to your local machine.

  * %USERPROFILE%

    * .aspire/deployments/\[AppHost-Sha256]/production.json

  - $HOME

    * .aspire/deployments/\[AppHost-Sha256]/production.json

  AppHost SHA256

  The deployment state is saved in a directory named after the SHA256 hash of your full AppHost path. This ensures that deployments for different applications or versions are kept separate.

## Verify your deployment

[Section titled “Verify your deployment”](#verify-your-deployment)

To verify that your application is running as expected after deployment, follow the instructions for your chosen deployment target below.

* Docker Compose

  When deploying to Docker Compose, the `aspire deploy` command displays the URLs where your services are running. Look for the `print-*-summary` steps in the deployment output, which show the localhost URLs for each service that has been configured with `WithExternalHttpEndpoints`.

  In the deployment output, you’ll see lines similar to the following:

  Aspire CLI - Deployment summary

  ```bash
  14:28:35 (print-env-dashboard-summary) i [INF] Successfully deployed env-dashboard to http://localhost:54633.
  14:28:35 (print-webfrontend-summary) i [INF] Successfully deployed webfrontend to http://localhost:54463.
  ```

  Open your web browser and navigate to the URL shown for your web frontend (for example, `http://localhost:54463`) to see your deployed application.

  ![Deployed ASP.NET Core/Blazor application running in Docker Compose](/_astro/csharp-starter.BqsExNMR.png)

  The front end displays the weather forecast data in the ASP.NET Core Blazor application.

  In the deployment output, you’ll see lines similar to the following:

  Aspire CLI - Deployment summary

  ```bash
  13:24:13 (print-env-dashboard-summary) i [INF] Successfully deployed env-dashboard to http://localhost:54633.
  13:24:13 (print-app-summary) i [INF] Successfully deployed app to http://localhost:54463.
  ```

  Open your web browser and navigate to the URL shown for your app (for example, `http://localhost:54463`) to see your deployed application.

  ![Deployed Python/React application running in Docker Compose](/_astro/python-starter-dark.C71FfuaJ.png)

  The front end displays the weather forecast data in a stunning React template. In this example, both the API service and the React front end are running within the same Docker container.

* Azure

  When deploying to Azure App Containers, you can verify that your ASP.NET Core/Blazor application is running by navigating to the URL provided in the deployment output. Look for a line similar to the following in the output:

  Aspire CLI - Deployment summary

  ```bash
  09:21:44 (print-webfrontend-summary) i [INF] Successfully deployed webfrontend to
      https://{NAME}.{LOCATION}.azurecontainerapps.io
  ```

  Open your web browser and navigate to the provided URL to see your deployed application.

  ![Deployed ASP.NET Core/Blazor application running in Docker Compose](/_astro/csharp-starter.BqsExNMR.png)

  The front end displays the weather forecast data in the ASP.NET Core Blazor application.

  when deploying to Azure App Containers, you can verify that your Python/React application is running by navigating to the URL provided in the deployment output. Look for a line similar to the following in the output:

  Aspire CLI - Deployment summary

  ```bash
  09:25:29 (print-app-summary) i [INF] Successfully deployed app to
      https://{NAME}.{LOCATION}.azurecontainerapps.io
  ```

  Open your web browser and navigate to the provided URL to see your deployed application.

  ![Deployed Python/React application running in Docker Compose](/_astro/python-starter-dark.C71FfuaJ.png)

  The front end displays the weather forecast data in a stunning React template. In this example, both the API service and the React front end are running within the same Docker container.

## Clean up resources

[Section titled “Clean up resources”](#clean-up-resources)

After deploying your application, it’s important to clean up resources to avoid incurring unnecessary costs or consuming local system resources.

* Docker Compose

  To clean up resources after deploying with Docker Compose, you can stop and remove the running containers using the following command:

  Aspire CLI - Stop and remove containers

  ```bash
  aspire do docker-compose-down-env
  ```

* Azure

  To clean up resources after deploying to Azure, you can use the Azure CLI to delete the resource group that contains your application. This will remove all resources within the resource group.

  Azure CLI - Delete resource group

  ```bash
  az group delete --name <RESOURCE_GROUP_NAME> --yes --no-wait
  ```

For a deep-dive into the related foundational concepts, see [Pipelines and app topology](/get-started/pipelines/).

You’ve just built your first Aspire app and deployed it to production—congratulations! 🎉 Now you might be wondering: “How do I make sure all these services actually work together correctly?” That’s where integration testing comes in. Aspire makes it easy to test your entire application stack, including service-to-service communication and resource dependencies. Ready to learn how? [Write your first test](/testing/write-your-first-test/)

# Dev Containers in Visual Studio Code

> Learn how to use Aspire with Dev Containers in Visual Studio Code for containerized development environments.

The [Dev Containers Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) provides a way for development teams to develop within a containerized environment where all dependencies are preconfigured. With Aspire 9.1, there’s added logic to better support working with Aspire within a Dev Container environment by automatically configuring port forwarding.

Before Aspire 9.1, it was possible to use Aspire within a Dev Container, however more manual configuration was required.

## Dev Containers vs. GitHub Codespaces

[Section titled “Dev Containers vs. GitHub Codespaces”](#dev-containers-vs-github-codespaces)

Using Dev Containers in Visual Studio Code is similar to using GitHub Codespaces. With the release of Aspire 9.1, support for both Dev Containers in Visual Studio Code and GitHub Codespaces was enhanced. Although the experiences are similar, there are some differences. For more information on using Aspire with GitHub Codespaces, see [Aspire and GitHub Codespaces](/get-started/github-codespaces/).

## Quick start using template repository

[Section titled “Quick start using template repository”](#quick-start-using-template-repository)

To configure Dev Containers in Visual Studio Code, use the `.devcontainer/devcontainer.json` file in your repository. The simplest way to get started is by creating a new repository from our [template repository](https://github.com/dotnet/aspire-devcontainer). Consider the following steps:

1. [Create a new repository](https://github.com/new?template_name=aspire-devcontainer\&template_owner=dotnet) using our template.

   ![Screenshot showing how to create a new repository from the Aspire devcontainer template on GitHub.](/_astro/new-repository-from-template.DzKY1yxg_Z296gKN.webp)

   Once you provide the details and select **Create repository**, the repository is created and shown in GitHub.

2. Clone the repository to your local developer workstation using the following command:

   ```bash
   git clone https://github.com/<org>/<username>/<repository>
   ```

3. Open the repository in Visual Studio Code. After a few moments Visual Studio Code detects the `.devcontainer/devcontainer.json` file and prompts to open the repository inside a container. Select whichever option is most appropriate for your workflow.

   ![Screenshot showing VS Code prompt to open the repository inside a container.](/_astro/reopen-in-container.C-E3PhC8_Z2mFpbp.webp)

   After a few moments, the list of files become visible and the local build of the dev container will be completed.

   ![Screenshot showing the dev container build completed notification in VS Code.](/_astro/devcontainer-build-completed.C15_I-ch_Z2h6SO9.webp)

4. Open a new terminal window in Visual Studio Code ( Command + Shift + Backslash `CmdShift\` Control + Shift + Backslash `CtrlShift\` Control + Shift + Backslash `CtrlShift\` ) and create a new Aspire project using the Aspire CLI.

   ```bash
   aspire new aspire-starter -n HelloAspire
   ```

   After a few moments, the project will be created and initial dependencies restored.

5. Open the `HelloAspire.AppHost/AppHost.cs` file in the editor and select the run button on the top right corner of the editor window.

   ![Screenshot showing the run button in the VS Code editor toolbar.](/_astro/vscode-run-button.BO2KYDRT_Z1damRb.webp)

   Visual Studio Code builds and starts the Aspire AppHost and automatically opens the Aspire Dashboard. Because the endpoints hosted in the container are using a self-signed certificate the first time, you access an endpoint for a specific Dev Container you’re presented with a certificate error.

   ![Screenshot showing the browser certificate error when accessing the dashboard.](/_astro/browser-certificate-error.mzi7yndO_ZkkKE0.webp)

   The certificate error is expected. Once you’ve confirmed that the URL being requested corresponds to the dashboard in the Dev Container you can ignore this warning.

   ![Screenshot of the Aspire dashboard running successfully in the Dev Container.](/_astro/aspire-dashboard-in-devcontainer.Cj1UT7EB_ZPr304.webp)

   Aspire automatically configures forwarded ports so that when you select on the endpoints in the Aspire dashboard they’re tunneled to processes and nested containers within the Dev Container.

6. Commit changes to the GitHub repository.

   After successfully creating the Aspire project and verifying that it launches and you can access the dashboard, it’s a good idea to commit the changes to the repository.

## Manually configuring devcontainer.json

[Section titled “Manually configuring devcontainer.json”](#manually-configuring-devcontainerjson)

The preceding walkthrough demonstrates the streamlined process of creating a Dev Container using the Aspire Dev Container template. If you already have an existing repository and wish to utilize Dev Container functionality with Aspire, add a `devcontainer.json` file to the `.devcontainer` folder within your repository:

* .devcontainer

  * devcontainer.json

The [template repository](https://github.com/dotnet/aspire-devcontainer) contains a copy of the `devcontainer.json` file that you can use as a starting point, which should be sufficient for Aspire.

## Dev Container scenarios

[Section titled “Dev Container scenarios”](#dev-container-scenarios)

The basic Aspire Dev Container template works well for simple scenarios, but you might need additional configuration depending on your specific requirements. The following sections provide examples for various common scenarios.

### Stateless .NET apps only

[Section titled “Stateless .NET apps only”](#stateless-net-apps-only)

For simple Aspire projects that only use .NET project resources without external containers or complex orchestration, you can use a minimal Dev Container configuration:

```json
{
  "name": "Aspire - Simple",
  "image": "mcr.microsoft.com/devcontainers/dotnet:9.0-bookworm",
  "onCreateCommand": "dotnet new install Aspire.ProjectTemplates --force",
  "postStartCommand": "dotnet dev-certs https --trust",
  "customizations": {
    "vscode": {
      "extensions": ["ms-dotnettools.csdevkit"]
    }
  }
}
```

This minimal configuration is suitable for Aspire apps that orchestrate only .NET services without external dependencies.

### Adding Node.js resources

[Section titled “Adding Node.js resources”](#adding-nodejs-resources)

If your Aspire app includes Node.js resources, add the Node.js feature to your Dev Container:

```json
{
  "name": "Aspire with Node.js",
  "image": "mcr.microsoft.com/devcontainers/dotnet:9.0-bookworm",
  "features": {
    "ghcr.io/devcontainers/features/node:1": {
      "version": "lts"
    }
  },
  "onCreateCommand": "dotnet new install Aspire.ProjectTemplates --force",
  "postStartCommand": "dotnet dev-certs https --trust",
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-dotnettools.csdevkit",
        "ms-vscode.vscode-typescript-next"
      ]
    }
  }
}
```

This configuration provides both .NET and Node.js development capabilities within the same container environment.

### Container orchestration with Docker-in-Docker

[Section titled “Container orchestration with Docker-in-Docker”](#container-orchestration-with-docker-in-docker)

When your Aspire app orchestrates container resources, you need Docker-in-Docker (DinD) support. Here’s a basic configuration:

```json
{
  "name": "Aspire with Containers",
  "image": "mcr.microsoft.com/devcontainers/dotnet:9.0-bookworm",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest",
      "enableNonRootDocker": true,
      "moby": true
    }
  },
  "hostRequirements": {
    "cpus": 4,
    "memory": "16gb",
    "storage": "32gb"
  },
  "onCreateCommand": "dotnet new install Aspire.ProjectTemplates --force",
  "postStartCommand": "dotnet dev-certs https --trust",
  "customizations": {
    "vscode": {
      "extensions": ["ms-dotnettools.csdevkit", "ms-azuretools.vscode-docker"]
    }
  }
}
```

#### Advanced container networking

[Section titled “Advanced container networking”](#advanced-container-networking)

If you encounter networking issues between containers or need IPv6 support, you can add additional network configuration:

```json
{
  "name": "Aspire with Advanced Networking",
  "image": "mcr.microsoft.com/devcontainers/dotnet:9.0-bookworm",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest",
      "enableNonRootDocker": true,
      "moby": true
    }
  },
  "runArgs": [
    "--sysctl",
    "net.ipv6.conf.all.disable_ipv6=0",
    "--sysctl",
    "net.ipv6.conf.default.forwarding=1",
    "--sysctl",
    "net.ipv6.conf.all.forwarding=1"
  ],
  "hostRequirements": {
    "cpus": 8,
    "memory": "32gb",
    "storage": "64gb"
  },
  "onCreateCommand": "dotnet new install Aspire.ProjectTemplates --force",
  "postStartCommand": "dotnet dev-certs https --trust",
  "customizations": {
    "vscode": {
      "extensions": ["ms-dotnettools.csdevkit", "ms-azuretools.vscode-docker"]
    }
  }
}
```

Docker-in-Docker considerations

* Docker-in-Docker requires higher resource allocation including increased CPU, memory, and storage.
* The advanced networking configuration above includes IPv6 forwarding settings that may be needed for complex container-to-container communication scenarios.
* This configuration works with Docker Desktop but may have limitations with Rancher Desktop.
* Network connectivity between containers might require additional configuration depending on your specific use case.

### Dapr integration examples

[Section titled “Dapr integration examples”](#dapr-integration-examples)

For Aspire apps that integrate with Dapr, you can set up Dapr components in your Dev Container. For more information, see [Aspire Dapr integration](/integrations/frameworks/dapr/).

#### Basic Dapr setup

[Section titled “Basic Dapr setup”](#basic-dapr-setup)

```json
{
  "name": "Aspire with Dapr",
  "image": "mcr.microsoft.com/devcontainers/dotnet:9.0-bookworm",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "enableNonRootDocker": true
    },
    "ghcr.io/dapr/cli/dapr-cli:0": {}
  },
  "onCreateCommand": "dotnet new install Aspire.ProjectTemplates --force",
  "postCreateCommand": "dotnet dev-certs https --trust && dapr init",
  "customizations": {
    "vscode": {
      "extensions": ["ms-dotnettools.csdevkit", "ms-azuretools.vscode-dapr"]
    }
  }
}
```

#### Dapr with external backends

[Section titled “Dapr with external backends”](#dapr-with-external-backends)

For more complex Dapr scenarios that use external backends (Redis, PostgreSQL), you can use Docker Compose:

```json
{
  "name": "Aspire with Dapr and Backends",
  "image": "mcr.microsoft.com/devcontainers/dotnet:9.0-bookworm",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "enableNonRootDocker": true
    },
    "ghcr.io/dapr/cli/dapr-cli:0": {}
  },
  "runArgs": ["--sysctl", "net.ipv6.conf.all.disable_ipv6=0"],
  "onCreateCommand": "dotnet new install Aspire.ProjectTemplates --force",
  "postCreateCommand": [
    "dotnet dev-certs https --trust",
    "docker compose up -d",
    "dapr init"
  ],
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-dotnettools.csdevkit",
        "ms-azuretools.vscode-dapr",
        "ms-azuretools.vscode-docker"
      ]
    }
  }
}
```

## Common considerations

[Section titled “Common considerations”](#common-considerations)

When using Dev Containers with Aspire, keep the following considerations in mind:

**Resource requirements**

* **Basic .NET apps**: Standard Dev Container resources are sufficient for simple scenarios.
* **Container orchestration**: A minimum of 8 CPUs, 32GB memory, and 64GB storage is recommended.
* **Complex scenarios with Dapr/Kubernetes**: Higher resource allocation is recommended for optimal performance.

**Networking**

* IPv6 configuration may be required for container-to-container communication.
* Port forwarding is automatically handled by Aspire 9.1 and later versions.
* External service connectivity depends on your container runtime configuration.

**Performance**

* Docker-in-Docker scenarios incur performance overhead compared to native Docker.
* Consider using Docker outside of Docker (DooD) for production workflows.
* Local development and deployment scenarios may require different configurations.

**Security**

* Dev Containers run with elevated privileges when using Docker-in-Docker.
* SSL certificate trust is handled automatically in most scenarios.
* Consider security implications when exposing ports in cloud environments.

# Build your first Aspire app

> Learn how to build your first Aspire solution using the Aspire starter templates for C#, Python, and JavaScript.

Select your programming language to get started

C#  Python  JavaScript (coming soon)

In this quickstart, you’ll create and run your first Aspire application using the Aspire CLI. Before you begin, make sure you’ve completed the [prerequisites](/get-started/prerequisites/) and [installed the Aspire CLI](/get-started/install-cli/). This guide walks you through generating a new Aspire solution from a template, running the application locally with Aspire’s dev-time orchestration, and exploring the Aspire dashboard. After completing this quickstart, consider [deploying your apps](/get-started/deploy-first-app/).

This starter template uses modern C#:

* [Minimal APIs](https://learn.microsoft.com/aspnet/core/fundamentals/minimal-apis) for lightweight HTTP APIs
* [Blazor](https://learn.microsoft.com/aspnet/core/blazor) for interactive web UIs using C#
* [Service defaults](/fundamentals/service-defaults/) for shared configuration of observability and resilience

The following diagram shows the architecture of the sample app you’re creating:

```
architecture-beta

  service api(logos:dotnet)[API service]
  service frontend(aspire:blazor)[Blazor front end]

  frontend:L --> R:api
```

This starter template combines a modern Python and JavaScript stack:

* [FastAPI](https://fastapi.tiangolo.com/) for building APIs with Python
* [Uv](https://docs.astral.sh/uv/) for Python package installation and environment management
* [React](https://react.dev/) for building user interfaces with JavaScript

The following diagram shows the architecture of the sample app you’re creating:

```
architecture-beta
  service api(logos:fastapi)[API service]
  service frontend(logos:react)[React front end]

  frontend:L --> R:api
```

## Create a new app

[Section titled “Create a new app”](#create-a-new-app)

To create your first Aspire application, use the [Aspire CLI](/get-started/install-cli/) to generate a new solution from a *starter* template. These template include multiple projects, such as an API service, a web frontend, and an [Aspire AppHost](/get-started/app-host/).

1. Create a new Aspire solution from a template:

   Create a new aspire solution

   ```bash
   aspire new aspire-starter -n AspireApp -o AspireApp
   ```

   Create a new aspire solution

   ```bash
   aspire new aspire-py-starter -n aspire-app -o aspire-app
   ```

   Create a new aspire solution

   ```bash
   aspire new aspire-js-starter -n aspire-app -o aspire-app
   ```

   The template provides several projects, including an API service, web frontend, and AppHost.

   CLI flags

   The following flags are used in the command:

   * `-n`: specifies the name of the solution.
   * `-o`: specifies the output directory.

   For further CLI reference, see [`aspire new`](/reference/cli/commands/aspire-new/) command information.

   If prompted for additional selections, use the Up Arrow `↑` Up Arrow `↑` Up Arrow `↑` and Down Arrow `↓` Down Arrow `↓` Down Arrow `↓` keys to navigate the options. Press Return `Return` Enter `Enter` Enter `Enter` to confirm your selection.

## Review the template code

[Section titled “Review the template code”](#review-the-template-code)

1. Examine the created template structure. The Aspire CLI creates a new folder with the name you provided in the current directory. This folder contains the solution file and several projects, including:

   * AspireApp.sln

   * AspireApp.ApiService mock weather data API

     * Properties/

       * …

     * appsettings.Development.json

     * appsettings.json

     * AspireApp.ApiService.csproj

     * Program.cs

   * **AspireApp.AppHost** dev-time orchestrator

     * Properties/

       * …

     * appsettings.Development.json

     * appsettings.json

     * AspireApp.AppHost.csproj

     * AppHost.cs

   * AspireApp.ServiceDefaults

     * Extensions.cs
     * AspireApp.ServiceDefaults.csproj

   * AspireApp.Web ASP.NET Core Blazor front end

     * Properties/

       * …

     * wwwroot/

       * …

     * appsettings.Development.json

     * appsettings.json

     * AspireApp.Web.csproj

     * Program.cs

     * WeatherApiClient.cs

   - aspire-app/

     * app/ FastAPI mock weather data API

       * .dockerignore
       * .python-version
       * main.py
       * pyproject.toml
       * telemetry.py

     * frontend/ Vite + React web front end

       * .dockerignore

       * public/

         * Aspire.png
         * github.svg

       * src/

         * App.css
         * App.tsx
         * index.css
         * main.tsx
         * vite-env.d.ts

       * .gitignore

       * eslint.config.js

       * index.html

       * package-lock.json

       * package.json

       * tsconfig.app.json

       * tsconfig.json

       * tsconfig.node.json

       * vite.config.ts

     * **apphost.cs** dev-time orchestrator

     * apphost.run.json

     * NuGet.config

   This solution structure is based on the Aspire templates. If they’re not installed already, the CLI will install them for you.

2. Explore the AppHost code that orchestrates your app.

   The [AppHost](/get-started/app-host/) is the heart of your Aspire application—it defines which services run, how they connect, and in what order they start. Let’s look at the generated code:

   C# — AppHost.cs project-based orchestrator

   ```csharp
   var builder = DistributedApplication.CreateBuilder(args);


   var apiService = builder.AddProject<Projects.AspireApp_ApiService>("apiservice")
       .WithHttpHealthCheck("/health");


   builder.AddProject<Projects.AspireApp_Web>("webfrontend")
       .WithExternalHttpEndpoints()
       .WithHttpHealthCheck("/health")
       .WithReference(apiService)
       .WaitFor(apiService);


   builder.Build().Run();
   ```

   *What’s happening here?*

   * `CreateBuilder` creates the distributed application builder
   * `AddProject` registers your API service and web frontend
   * `WithReference` creates a connection between services (the web app can call the API)
   * `WaitFor` ensures services start in the correct order
   * `WithHttpHealthCheck` monitors service health

   C# — apphost.cs file-based orchestrator

   ```csharp
   #:sdk Aspire.AppHost.Sdk@13.1.0
   #:package Aspire.Hosting.JavaScript@13.1.0
   #:package Aspire.Hosting.Python@13.1.0


   var builder = DistributedApplication.CreateBuilder(args);


   var app = builder.AddUvicornApp("app", "./app", "main:app")
       .WithUv()
       .WithExternalHttpEndpoints()
       .WithHttpHealthCheck("/health");


   var frontend = builder.AddViteApp("frontend", "./frontend")
       .WithReference(app)
       .WaitFor(app);


   app.PublishWithContainerFiles(frontend, "./static");


   builder.Build().Run();
   ```

   *What’s happening here?*

   * `AddUvicornApp` adds a Uvicorn-based Python app
   * `AddUv` adds a Uv environment setup task: `uv sync`
   * `AddViteApp` registers your React frontend
   * `WithReference` connects the frontend to the API
   * `WaitFor` ensures the API starts before the frontend
   * `PublishWithContainerFiles` bundles the frontend for production deployment

   Code-first orchestration

   Your application topology is defined in code, making it easy to understand, modify, and version control. Learn more about the [AppHost](/get-started/app-host/).

## Run the app

[Section titled “Run the app”](#run-the-app)

1. Change to the *output* directory:

   Change directories

   ```bash
   cd ./AspireApp
   ```

   Change directories

   ```bash
   cd ./aspire-app
   ```

2. Call `aspire run` to start dev-time orchestration:

   Run dev-time orchestration

   ```bash
   aspire run
   ```

   When you run this command, the Aspire CLI:

   * Automatically finds the AppHost
   * Builds your solution
   * Launches dev-time orchestration

   Once the dashboard is ready, its URL (with a login token—highlighted in the example output below) appears in your terminal. The dashboard provides a live, real-time view of your running resources and their current states.

   Example output

   ```bash
   🔍  Finding apphosts...
   AspireApp.AppHost/AspireApp.AppHost.csproj


   🗄  Created settings file at '.aspire/settings.json'.


        AppHost:  AspireApp.AppHost/AspireApp.AppHost.csproj


      Dashboard:  https://localhost:17068/login?t=ea559845d54cea66b837dc0ff33c3bd3


           Logs:  %USERPROFILE%/.aspire/cli/logs/apphost-13024-2025-10-31-19-40-58.log


                  Press CTRL+C to stop the apphost and exit.
   ```

   Example output

   ```bash
   🔍  Finding apphosts...
   apphost.cs


   🗄  Created settings file at '.aspire/settings.json'.


        AppHost:  apphost.cs


      Dashboard:  https://localhost:17213/login?t=2b4a2ebc362b7fef9b5ccf73e702647b


           Logs:  $HOME/.aspire/cli/logs/apphost-27732-2025-10-31-19-21-27.log


                  Press CTRL+C to stop the apphost and exit.
   ```

   For further CLI reference, see [`aspire run`](/reference/cli/commands/aspire-run/) command information.

3. Explore the running distributed application. From the dashboard, open the `HTTPS` endpoint from each resource.

   ![Aspire dashboard Resources page displaying two running resources: apiservice and webfrontend. Both are marked as Running with green check icons. The table lists columns for Name, State, Start time, Source, URLs, and Actions.](/_astro/csharp-aspire-dashboard-dark.CWXsrW49.png)

   ![Aspire dashboard Resources page displaying two running and two finished resources: apiservice and webfrontend. Two resources are marked as Running with green check icons while the two dependent resources show as Finished with gray stop icons. The table lists columns for Name, State, Start time, Source, URLs, and Actions.](/_astro/python-aspire-dashboard-dark.rL3Up_g8.png)

   To learn more, see [Aspire dashboard overview](/dashboard/overview/).

## Stop the app

[Section titled “Stop the app”](#stop-the-app)

1. Stop the AppHost and close the dashboard by pressing ⌘+C `⌘+C` Control + C `CtrlC` Control + C `CtrlC` in your terminal.

   Stop dev-time orchestration

   ```bash
   🛑  Stopping Aspire.
   ```

   **🥳 Congratulations! You’ve created your first Aspire app.**

You might be eager to deploy this app next—and we’ll show you how Aspire handles that—but you’re probably also wondering: “How do I *test* all this?” Great question! Aspire doesn’t just orchestrate locally and deploy, it also helps you test service and resource integrations too. Ready to dive in? [Write your first test](/testing/write-your-first-test/) 💜

# Aspire and GitHub Codespaces

> Learn how to use Aspire with GitHub Codespaces for cloud-based development.

[GitHub Codespaces](https://github.com/features/codespaces) offers a cloud-hosted development environment based on Visual Studio Code. It can be accessed directly from a web browser or through Visual Studio Code locally, where Visual Studio Code acts as a client connecting to a cloud-hosted backend. With Aspire 9.1, comes logic to better support GitHub Codespaces including:

* Automatically configure port forwarding with the correct protocol.
* Automatically translate URLs in the Aspire dashboard.

Before Aspire 9.1 it was still possible to use Aspire within a GitHub Codespace, however more manual configuration was required.

## GitHub Codespaces vs. Dev Containers

[Section titled “GitHub Codespaces vs. Dev Containers”](#github-codespaces-vs-dev-containers)

GitHub Codespaces builds upon Visual Studio Code and the [Dev Containers specification](https://containers.dev/implementors/spec/). In addition to supporting GitHub Codespaces, Aspire 9.1 enhances support for using Visual Studio Code and locally hosted Dev Containers. While the experiences are similar, there are some differences. For more information, see [Aspire and Visual Studio Code Dev Containers](/get-started/dev-containers/).

## Quick start using template repository

[Section titled “Quick start using template repository”](#quick-start-using-template-repository)

To configure GitHub Codespaces for Aspire, use the `.devcontainer/devcontainer.json` file in your repository. The simplest way to get started is by creating a new repository from our [template repository](https://github.com/dotnet/aspire-devcontainer). Consider the following steps:

1. [Create a new repository](https://github.com/new?template_name=aspire-devcontainer\&template_owner=dotnet) using our template.

   ![Screenshot showing how to create a new repository from the Aspire devcontainer template on GitHub.](/_astro/new-repository-from-template.DzKY1yxg_Z296gKN.webp)

   Once you provide the details and select **Create repository**, the repository is created and shown in GitHub.

2. From the new repository, select on the Code button and select the Codespaces tab and then select **Create codespace on main**.

   ![Screenshot showing how to create a new codespace from the repository on GitHub.](/_astro/create-codespace-from-repository.DtjMF-kt_1WJGvI.webp)

   After you select **Create codespace on main**, you navigate to a web-based version of Visual Studio Code. Before you use the Codespace, the containerized development environment needs to be prepared. This process happens automatically on the server and you can review progress by selecting the **Building codespace** link on the notification in the bottom right of the browser window.

   ![Screenshot showing the building codespace notification in VS Code.](/_astro/building-codespace-image.CtqfHAOS_qr8L3.webp)

   When the container image has finished being built the **Terminal** prompt appears which signals that the environment is ready to be interacted with.

   ![Screenshot showing the terminal prompt ready for use in the codespace.](/_astro/codespace-terminal.B_N4WAAY_Z1Xc5ke.webp)

   At this point, the Aspire templates have been installed and the ASP.NET Core developer certificate has been added and accepted.

3. Create a new Aspire project using the starter template.

   ```bash
   dotnet new aspire-starter --name HelloAspire
   ```

   This results in many files and folders being created in the repository, which are visible in the **Explorer** panel on the left side of the window.

   ![Screenshot of the VS Code Explorer panel showing the newly created Aspire project structure.](/_astro/codespaces-explorer-panel.DUYHgzdT_ZzJUKY.webp)

4. Launch the AppHost via the `HelloAspire.AppHost/AppHost.cs` file, by selecting the **Run project** button near the top-right corner of the **Tab bar**.

   ![Screenshot showing how to launch the AppHost using the Run project button in VS Code.](/_astro/codespace-launch-apphost.DlB98lsf_Z27TyX.webp)

   After a few moments the **Debug Console** panel is displayed, and it includes a link to the Aspire dashboard exposed on a GitHub Codespaces endpoint with the authentication token.

   ![Screenshot of the Debug Console showing the Aspire dashboard URL with authentication token.](/_astro/codespaces-debug-console.rCTIdKgm_Z8kaxG.webp)

5. Open the Aspire dashboard by selecting the dashboard URL in the **Debug Console**. This opens the Aspire dashboard in a separate tab within your browser.

   You notice on the dashboard that all HTTP/HTTPS endpoints defined on resources have had their typical `localhost` address translated to a unique fully qualified subdomain on the `app.github.dev` domain.

   ![Screenshot of the Aspire dashboard showing translated URLs using GitHub Codespaces domains.](/_astro/codespaces-translated-urls.CLq_Qd3S_1oVwsk.webp)

   Traffic to each of these endpoints is automatically forwarded to the underlying process or container running within the Codespace. This includes development time tools such as PgAdmin and Redis Insight.

   Note

   In addition to the authentication token embedded within the URL of the dashboard link of the **Debug Console**, endpoints also require authentication via your GitHub identity to avoid port forwarded endpoints being accessible to everyone. For more information on port forwarding in GitHub Codespaces, see [Forwarding ports in your codespace](https://docs.github.com/codespaces/developing-in-a-codespace/forwarding-ports-in-your-codespace?tool=webui).

6. Commit changes to the GitHub repository.

   GitHub Codespaces doesn’t automatically commit your changes to the branch you’re working on in GitHub. You have to use the **Source Control** panel to stage and commit the changes and push them back to the repository.

   Working in a GitHub Codespace is similar to working with Visual Studio Code on your own machine. You can checkout different branches and push changes just like you normally would. In addition, you can easily spin up multiple Codespaces simultaneously if you want to quickly work on another branch without disrupting your existing debug session. For more information, see [Developing in a codespace](https://docs.github.com/codespaces/developing-in-a-codespace/developing-in-a-codespace?tool=webui).

7. Clean up your Codespace.

   GitHub Codespaces are temporary development environments and while you might use one for an extended period of time, they should be considered a disposable resource that you recreate as needed (with all of the customization/setup contained within the `devcontainer.json` and associated configuration files).

   To delete your GitHub Codespace, visit the GitHub Codespaces page. This shows you a list of all of your Codespaces. From here you can perform management operations on each Codespace, including deleting them.

   GitHub charges for the use of Codespaces. For more information, see [Managing the cost of GitHub Codespaces in your organization](https://docs.github.com/codespaces/managing-codespaces-for-your-organization/choosing-who-owns-and-pays-for-codespaces-in-your-organization).

   Note

   Aspire supports the use of Dev Containers in Visual Studio Code independent of GitHub Codespaces. For more information on how to use Dev Containers locally, see [Aspire and Dev Containers in Visual Studio Code](/get-started/dev-containers/).

## Manually configuring devcontainer.json

[Section titled “Manually configuring devcontainer.json”](#manually-configuring-devcontainerjson)

The preceding walkthrough demonstrates the streamlined process of creating a GitHub Codespace using the Aspire Devcontainer template. If you already have an existing repository and wish to utilize Devcontainer functionality with Aspire, add a `devcontainer.json` file to the `.devcontainer` folder within your repository:

* .devcontainer

  * devcontainer.json

The [template repository](https://github.com/dotnet/aspire-devcontainer) contains a copy of the `devcontainer.json` file that you can use as a starting point, which should be sufficient for Aspire.

## Speed up Codespace creation

[Section titled “Speed up Codespace creation”](#speed-up-codespace-creation)

Creating a GitHub Codespace can take some time as it prepares the underlying container image. To expedite this process, you can utilize *prebuilds* to significantly reduce the creation time to approximately 30-60 seconds (exact timing might vary). For more information on GitHub Codespaces prebuilds, see [GitHub Codespaces prebuilds](https://docs.github.com/codespaces/prebuilding-your-codespaces/about-github-codespaces-prebuilds).

# Install Aspire CLI

> Learn how to install the Aspire CLI as a native executable or .NET global tool to manage your cloud-native applications.

Aspire provides a command-line interface (CLI) tool to help you create and manage Aspire-based apps. The CLI streamlines your development workflow with an interactive-first experience. This guide shows you how to install the Aspire CLI on your system. The Aspire CLI requires the [.NET 10.0 SDK](https://dotnet.microsoft.com/download/dotnet/10.0).

Before installing the Aspire CLI, ensure you have the [required prerequisites](/get-started/prerequisites/) set up.

## Install the Aspire CLI

[Section titled “Install the Aspire CLI”](#install-the-aspire-cli)

To install the Aspire CLI download and run the install script:

Download and install

You can download and run the installation script in a single command to install the Aspire CLI:

* Bash

  ```bash
  curl -sSL https://aspire.dev/install.sh | bash
  ```

* PowerShell

  ```powershell
  irm https://aspire.dev/install.ps1 | iex
  ```

The script installs the latest stable release of Aspire CLI. See [Validation](#validation) to verify the installation.

### Two-step installation process

[Section titled “Two-step installation process”](#two-step-installation-process)

Alternatively, you can download the script and run it as a two-step process:

1. Open a terminal.

2. Download the script and save it as a file:

   * Bash

     ```bash
     curl -sSL https://aspire.dev/install.sh -o aspire-install.sh
     ```

   * PowerShell

     ```powershell
     irm https://aspire.dev/install.ps1 -OutFile aspire-install.ps1
     ```

3. Run the script to install the stable release build of Aspire.

   You should see output similar to the following snippet:

   * Bash

     Output

     ```txt
     Downloading from:
     https://aka.ms/dotnet/9/aspire/ga/daily/aspire-cli-linux-x64.tar.gz
     Aspire CLI successfully installed to: /home/username/.aspire/bin/aspire
     Added /home/username/.aspire/bin to PATH for current session Added
     /home/username/.aspire/bin to PATH in /home/username/.bashrc The aspire
     cli is now available for use in this and new sessions.
     ```

   * PowerShell

     Output

     ```txt
     Downloading from: https://aka.ms/dotnet/9/aspire/ga/daily/aspire-cli-win-x64.zip
     Aspire CLI successfully installed to:
     C:\Users\name\.aspire\bin\aspire.exe Added C:\Users\username\.aspire\bin
     to PATH for current session Added C:\Users\username\.aspire\bin to user
     PATH environment variable The aspire cli is now available for use in
     this and new sessions.
     ```

## Validation

[Section titled “Validation”](#validation)

To validate that the Aspire CLI is installed, use `aspire --version` to query Aspire CLI for a version number:

Aspire CLI

```bash
aspire --version
```

Consider the following example of running the command:

If that command works, you’re presented with the version of the Aspire CLI tool:

Aspire CLI — Output

```bash
13.0.0+{commitSHA}
```

The `+{commitSHA}` suffix indicates the specific commit from which the Aspire CLI was built. This suffix is included in pre-release builds and may not be present in stable releases.

Learn more by reading the [Aspire CLI reference](/reference/cli/overview/) documentation.

Troubleshooting

If you’re not seeing a version number, it’s possible that your terminal session needs to be restarted to pick up the changes to your PATH environment variable. Simply close and reopen your terminal, then try running the `aspire --version` command again.

## See also

[Section titled “See also”](#see-also)

* [aspire-install script reference](/reference/cli/install-script/)
* [`aspire` command reference](/reference/cli/commands/aspire/)

# Pipelines and app topology

> Learn how Aspire's unified app topology works across development and production environments.

When you compose your distributed app in Aspire’s **AppHost**, you’re not just defining services for local development and orchestration—you’re also setting up the foundation for deployment. The same composition you use to run and debug locally is leveraged when you publish your app, ensuring consistency from development through to production.

## Reusable app topology

[Section titled “Reusable app topology”](#reusable-app-topology)

Aspire doesn’t get in the way of your existing deployment workflows. Instead, it provides a consistent way to define your application architecture that can be deployed across different environments and platforms.

Continuing from the three-tier architecture example, you can deploy the same app topology to various environments, whether it’s a local machine, a cloud provider, or your own servers.

```
architecture-beta

  service db(logos:postgresql)[PostgreSQL]
  service api(logos:dotnet)[API Service]
  service frontend(logos:react)[Frontend]

  api:R --> L:db
  frontend:R --> L:api
```

This table shows how you can deploy the same resources across different platforms:

| Resource    | Local                                          | AWS                         | Azure                 | On-Premises |
| ----------- | ---------------------------------------------- | --------------------------- | --------------------- | ----------- |
| Frontend    | `npm run dev`                                  | Elastic Container Service   | Container Apps        | Custom      |
| API Service | `dotnet run --project ../<API_PROJECT>.csproj` | AWS Lambda                  | Functions             | Custom      |
| PostgreSQL  | `docker.io/library/postgres`                   | Relational Database Service | Database for Postgres | Custom      |

Tip

Aspire’s AppHost allows you to define your app’s architecture in a way that is platform-agnostic, meaning you can run the same code locally or deploy it to any environment without changes.

Aspire uses a pipeline-based deployment system that enables extensible, composable deployment workflows. This system allows you to customize how your applications are deployed while maintaining consistency across different environments.

Note

Pipeline-based deployment is an experimental feature in Aspire 13. APIs and functionality may change in future releases.

## Overview

[Section titled “Overview”](#overview)

The pipeline deployment system provides a flexible, concurrent model for deploying cloud applications. Pipelines break deployment into discrete, well-defined steps that can be optimized for performance and reliability while maintaining clear visibility into the deployment process.

### Why pipelines matter

[Section titled “Why pipelines matter”](#why-pipelines-matter)

Modern cloud applications require sophisticated deployment orchestration to handle the complexity of distributed systems. Aspire’s pipeline system provides:

* **Intelligent concurrency**: Independent operations run in parallel, maximizing resource utilization and minimizing total deployment time
* **Granular control**: Each step can be executed, monitored, and retried independently with specific error reporting and targeted recovery capabilities
* **Smart dependency management**: Steps wait only for their actual dependencies, ensuring optimal execution order while maintaining correctness
* **Comprehensive observability**: Real-time progress reporting at both step and sub-task levels provides clear visibility into deployment operations
* **Flexible execution**: Run complete deployments or selective step execution based on your specific needs

### Core capabilities

[Section titled “Core capabilities”](#core-capabilities)

The pipeline deployment system enables several key capabilities:

* **Extend deployments**: Add custom deployment steps for specific resources or scenarios
* **Control execution order**: Declare dependencies between steps to ensure proper sequencing
* **Run selective steps**: Execute only specific steps and their dependencies for faster iterations
* **Parallelize operations**: Independent steps can run concurrently for improved performance
* **State persistence**: Cache deployment state and parameters across multiple deployment runs
* **Intelligent granularity**: Balance between fine-grained control and deployment efficiency

## Core concepts

[Section titled “Core concepts”](#core-concepts)

The pipeline system is built around several fundamental concepts that work together to provide flexible, efficient deployment orchestration.

### Pipeline steps

[Section titled “Pipeline steps”](#pipeline-steps)

A pipeline step represents a discrete unit of work in the application pipeline. Each step encapsulates a specific aspect of the deployment process, making the overall operation more manageable and debuggable.

Each step has:

* **Name**: A unique identifier for the step
* **Action**: The work to be performed during deployment
* **Dependencies**: Other steps that must complete before this step runs
* **Resource context**: Access to the application’s resource model and configuration

Pipeline steps operate at different levels of granularity. For example, when deploying a typical web application with a frontend, API service, database, and storage, the pipeline might include:

**Infrastructure steps** (can run in parallel):

* `provision-cosmosdb`: Provision the CosmosDB database
* `provision-storage`: Provision Azure Storage account
* `provision-aca-env`: Provision Azure Container Apps environment
* `provision-container-registry`: Set up the container image registry

**Build steps** (can run in parallel):

* `build-apiservice`: Build container image for the API service
* `build-webfrontend`: Build container image for the frontend

**Deployment steps** (depend on builds and infrastructure):

* `push-apiservice`: Push API service image to registry
* `push-webfrontend`: Push frontend image to registry
* `deploy-apiservice`: Deploy API service to compute platform
* `deploy-webfrontend`: Deploy frontend to compute platform

This granular approach allows the pipeline to maximize parallelism—databases can be provisioned while container images are building, and as soon as both the container registry and an image are ready, the image can be pushed immediately without waiting for other unrelated operations.

### Step execution phases

[Section titled “Step execution phases”](#step-execution-phases)

The pipeline system operates through three distinct phases:

1. #### Registration phase

   [Section titled “Registration phase”](#registration-phase)

   Steps are collected from two sources:

   * **Resource annotations**: Steps contributed by resources in your application model (e.g., a database resource contributes its provisioning step)
   * **Pipeline API calls**: Steps added directly through pipeline configuration in your AppHost

   This decentralized approach allows both framework components and user code to participate in the deployment process without requiring changes to a central configuration.

2. #### Resolution phase

   [Section titled “Resolution phase”](#resolution-phase)

   The pipeline system analyzes all registered steps to:

   * **Validate dependencies**: Ensure all referenced steps exist and no circular dependencies are present
   * **Calculate execution order**: Determine the optimal sequence that respects all dependency constraints
   * **Identify concurrency opportunities**: Group steps that can run in parallel

3. #### Execution phase

   [Section titled “Execution phase”](#execution-phase)

   Steps run according to the resolved plan:

   * **Parallel execution**: Independent steps start simultaneously
   * **Dependency waiting**: Steps wait only for their specific dependencies, not for unrelated operations
   * **Progress reporting**: Real-time status updates for both individual steps and overall pipeline progress
   * **Error isolation**: Failed steps don’t block unrelated operations

### Dependency management

[Section titled “Dependency management”](#dependency-management)

Dependencies in Aspire pipelines are explicit and purpose-driven, unlike traditional deployment systems where dependencies might be implicit or overly broad.

Steps declare their relationships using:

* `PipelineStep.DependsOn`: This step must run after another step completes successfully
* `PipelineStep.RequiredBy`: Another step must run after this step (inverse dependency declaration)

**Example dependency relationships:**

```
graph TD
    A[build-apiservice] --> C[push-apiservice]
    B[provision-container-registry] --> C
    C --> D[deploy-apiservice]
    E[provision-cosmosdb] --> D
    F[provision-identity] --> D
```

In this example:

* `push-apiservice` depends on both the image being built AND the registry being available
* `deploy-apiservice` can start as soon as its image is pushed, the database is provisioned, and managed identity is configured
* `provision-cosmosdb` and `build-apiservice` can run in parallel since they don’t depend on each other

The pipeline system validates dependencies to ensure:

* **No circular dependencies**: Step A cannot depend on Step B if Step B depends on Step A
* **All references exist**: All dependency declarations reference actual registered steps
* **Logical consistency**: The dependency graph represents a valid execution plan

## Deployment patterns

[Section titled “Deployment patterns”](#deployment-patterns)

Aspire’s pipeline system is designed around intelligent orchestration of deployment operations, ensuring that your applications deploy efficiently and reliably across different environments.

### Optimal granularity design

[Section titled “Optimal granularity design”](#optimal-granularity-design)

The pipeline system uses fine-grained steps to provide precise control and visibility while maintaining deployment efficiency:

**Resource-level granularity**: Each infrastructure resource (databases, storage accounts, container registries) is provisioned as a separate step, enabling:

* **Precise error reporting**: When a specific resource fails, you know exactly what went wrong
* **Targeted retry capabilities**: Retry only the failed resource without affecting successfully provisioned components
* **Progress transparency**: Clear visibility into which resources are provisioning and their current status
* **Flexible recovery**: Ability to fix issues and continue from the point of failure

**Operation-level organization**: Related operations are grouped logically while maintaining independence:

* **Build operations**: Multiple container images can build in parallel using available system resources
* **Push operations**: Images can be pushed to registries as soon as they’re built and the registry is available
* **Deployment operations**: Services deploy as soon as their dependencies (images, infrastructure) are ready

## Well-known steps

[Section titled “Well-known steps”](#well-known-steps)

Aspire registers a default set of well-known steps that serve as integration points for the deployment pipeline. These steps provide a standardized way for resources and applications to participate in common deployment workflows.

### Entry point steps

[Section titled “Entry point steps”](#entry-point-steps)

* **`WellKnownSteps.Deploy`**: The primary entry point for the `aspire deploy` command. This step orchestrates the complete deployment process including infrastructure provisioning, image building, and application deployment.

* **`WellKnownSteps.Publish`**: The entry point for the `aspire publish` command, which typically generates deployment artifacts without executing the actual deployment.

* **`WellKnownSteps.Build`**: The entry point for the `aspire do build` command, which builds container images for compute resources defined in the application.

* **`WellKnownSteps.Push`**: The entry point for the `aspire do push` command, which pushes container images to registries after they have been built.

### Prerequisite steps

[Section titled “Prerequisite steps”](#prerequisite-steps)

* **`WellKnownSteps.BuildPrereq`**: Defines steps that are pre-requisites for building, such as dependency resolution, environment setup, and build tool validation.

* **`WellKnownSteps.DeployPrereqs`**: Defines steps that are pre-requisites for deployment, such as authentication, environment validation, and prerequisite resource checks.

* **`WellKnownSteps.PublishPrereqs`**: Defines steps that are pre-requisites for publishing, such as build environment setup and artifact preparation.

* **`WellKnownSteps.PushPrereq`**: Defines steps that are pre-requisites for pushing container images, such as registry authentication and connection validation.

These well-known steps create a contract that allows different parts of the system to integrate predictably. For example, a custom authentication step can declare itself as required by `DeployPrereqs`, ensuring it runs before any deployment operations begin.

### Resource-contributed steps

[Section titled “Resource-contributed steps”](#resource-contributed-steps)

Resources in your application model can contribute their own pipeline steps through annotations. This pattern allows libraries and integrations to encapsulate their deployment logic without requiring changes to your application code.

**How resource-contributed steps work:**

1. **Annotation-based registration**: Resources use annotations to declare their pipeline steps
2. **Automatic discovery**: The pipeline system automatically discovers steps from all resources during the registration phase
3. **Dependency integration**: Resource steps can depend on well-known steps or other resource steps

**Example: Static site resource contributing steps**

A static site resource might contribute multiple related steps:

```
graph LR
    A[build-static-site] --> B[configure-storage-permissions]
    B --> C[upload-site-files]
    C --> D[configure-cdn]
```

Each step handles a specific aspect of static site deployment:

1. **Building site artifacts**: Compile, optimize, and prepare static files
2. **Configuring storage permissions**: Set up appropriate access controls
3. **Uploading files**: Transfer built artifacts to cloud storage
4. **Configuring CDN**: Set up content distribution and routing

This approach keeps deployment logic close to the resource definition while allowing the pipeline system to optimize execution order and handle dependencies automatically.

### Application-specific steps

[Section titled “Application-specific steps”](#application-specific-steps)

Applications can add custom steps directly through the pipeline API for scenarios that don’t belong to a particular resource but are specific to the application’s deployment requirements.

**Common application-specific step scenarios:**

* **Database migrations**: Running schema updates or data transformations
* **Smoke tests**: Validating deployed services before marking deployment as complete
* **Configuration updates**: Updating external services or third-party integrations
* **Notification workflows**: Sending deployment status updates to team communication channels

**Example: Adding a custom validation step**

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add custom deployment validation
builder.Pipeline.AddStep("validate-deployment", async context =>
{
    // Custom validation logic
    await ValidateApiHealth(context);
    await ValidateDatabaseConnection(context);
}, requiredBy: WellKnownPipelineSteps.Deploy);


// Define resources
var database = builder.AddPostgres("myapp-db");
var api = builder.AddProject<Api>("api").WithReference(database);
```

This pattern enables applications to extend the deployment process with custom logic while benefiting from the pipeline’s dependency management and execution coordination.

## Execution control

[Section titled “Execution control”](#execution-control)

The pipeline system provides sophisticated mechanisms for controlling how and when deployment steps are executed, giving you precise control over the deployment process.

### Running specific steps

[Section titled “Running specific steps”](#running-specific-steps)

The `aspire do` command allows you to execute individual steps and their dependencies, providing fine-grained control over the deployment process. This capability addresses several real-world deployment scenarios where running the entire pipeline isn’t necessary or desired.

**Use cases for selective step execution:**

* **Incremental deployments**: After making changes to only your frontend code, run just the frontend-related steps rather than rebuilding and redeploying your entire application
* **Troubleshooting and retry**: If a specific step fails (e.g., database provisioning times out), you can retry just that step and its dependents without repeating successful operations
* **Development workflows**: During development, you might want to provision infrastructure once, then repeatedly deploy code changes without reprovisioning resources
* **Selective operations**: Separate infrastructure provisioning from application deployment to align with organizational policies or approval processes

**How selective execution works:**

When you specify a step to run, the pipeline system automatically:

1. **Includes all dependencies**: Ensures prerequisite steps are executed in the correct order
2. **Skips unnecessary steps**: Avoids running steps that aren’t required for your target step
3. **Maintains consistency**: Validates that the deployment state remains coherent

**Example selective execution scenarios:**

```bash
# Provision only infrastructure resources
aspire do provision-infra


# Deploy only a specific service after code changes
aspire do deploy-apiservice


# Run database migrations without full redeployment
aspire do migrate-database
```

### Parallel execution and performance optimization

[Section titled “Parallel execution and performance optimization”](#parallel-execution-and-performance-optimization)

The pipeline system is designed to maximize deployment performance through intelligent parallel execution while maintaining correctness and reliability.

**Concurrency analysis and optimization:**

The system performs sophisticated dependency analysis to identify and leverage opportunities for parallelization:

* **Independent operations**: Steps with no dependencies on each other execute simultaneously, fully utilizing available system resources
* **Resource grouping**: Related operations (such as multiple image builds) are coordinated to use shared resources efficiently
* **Critical path optimization**: The system identifies the longest dependency chain and optimizes execution to minimize total deployment time
* **Resource-aware scheduling**: CPU-intensive, I/O-intensive, and network operations are balanced to avoid resource contention

**Real-world performance benefits:**

A typical web application deployment demonstrates the effectiveness of pipeline parallelization:

**Pipeline execution delivers optimal performance**: 5-7 minutes total

* Infrastructure provisioning (parallel): 3 minutes (limited by slowest resource)
* Image building (parallel): 2 minutes (limited by slowest build)
* Deployment operations: 2-3 minutes (respecting dependencies)

**Intelligent resource utilization:**

* **CPU-intensive operations** (container image building): Fully utilize available build capacity across multiple cores
* **I/O-intensive operations** (image pushing, file uploads): Execute concurrently with appropriate rate limiting to avoid overwhelming network resources
* **Cloud API operations** (resource provisioning): Run in parallel while respecting cloud provider rate limits and quotas

**Failure handling and resilience:**

The pipeline system provides robust failure handling during parallel execution:

1. **Immediate failure detection**: Failed steps are identified and reported quickly without waiting for unrelated operations to complete
2. **Smart dependency cascade prevention**: When a step fails, only its dependent steps are cancelled, allowing unrelated operations to continue
3. **Partial success preservation**: Successfully completed steps maintain their state and don’t need to be repeated during retry operations
4. **Error isolation**: Failures in one part of the pipeline are contained and don’t affect independent operations

The system maintains comprehensive logging and state information to support efficient debugging and recovery, ensuring that developers can quickly identify and resolve issues while preserving all successful work.

# Prerequisites

> Learn about essential tooling concepts for Aspire.

Ready to dive into Aspire? Before you begin, make sure your development environment is set up with a few essential tools. This guide walks you through everything you need to start building and running Aspire solutions with confidence.

1. #### Install the .NET SDK

   [Section titled “Install the .NET SDK”](#install-the-net-sdk)

   Aspire is built on .NET, a free, open-source, cross-platform framework for building modern apps and cloud services. You’ll need the [.NET 10.0 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) installed—no prior C# experience is required.

   Important

   The Aspire CLI requires the .NET 10.0 SDK to be installed on your machine. However, Aspire can run applications targeting .NET 8.0 or later.

   Follow the [installation instructions](https://dotnet.microsoft.com/download/dotnet/10.0) for your operating system (Windows, macOS, or Linux) to complete the setup.

2. #### Install an OCI-compliant container runtime

   [Section titled “Install an OCI-compliant container runtime”](#install-an-oci-compliant-container-runtime)

   Aspire can run containers using several OCI-compatible runtimes, including Docker Desktop and Podman.

   * [Docker Desktop](https://www.docker.com/products/docker-desktop) is the most popular container runtime among Aspire developers, offering a familiar and widely supported environment for building and running containers.

   * [Podman](https://podman.io/) is an open-source, daemonless alternative to Docker. It supports building and running Open Container Initiative (OCI) containers, making it a flexible choice for developers who prefer a lightweight solution.

     * Bash

       Set the ASPIRE\_CONTAINER\_RUNTIME environment variable to podman

       ```bash
       export ASPIRE_CONTAINER_RUNTIME=podman
       ```

     * PowerShell

       Set the ASPIRE\_CONTAINER\_RUNTIME environment variable to podman

       ```powershell
       [System.Environment]::SetEnvironmentVariable("ASPIRE_CONTAINER_RUNTIME", "podman", "User")
       ```

   * [Rancher Desktop](https://rancherdesktop.io/) has been reported by users as a successful alternative—particularly when configured to use the Docker CLI. However, Rancher Desktop is not an officially supported or regularly tested scenario for Aspire. If you encounter issues with Rancher Desktop, please let us know, but fixes may not be prioritized.

3. #### Install an integrated development environment (IDE)

   [Section titled “Install an integrated development environment (IDE)”](#install-an-integrated-development-environment-ide)

   Aspire supports multiple IDEs and code editors. You can choose the one that best fits your workflow:

   Visual Studio Code

   We recommend [Visual Studio Code](https://code.visualstudio.com/) for the best experience—a lightweight, cross-platform code editor with excellent Aspire support. Install the following extensions to get started:

   1. [C# extension](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp) for C# language support.
   2. [Aspire extension](/get-started/aspire-vscode-extension/) for Aspire-specific commands and features.

   Aspire also works well with:

   * [Visual Studio](https://visualstudio.microsoft.com/vs/): A full-featured IDE for C# development with debugging, IntelliSense, and Git support.
   * [JetBrains Rider](https://plugins.jetbrains.com/plugin/23289--net-aspire): A powerful, cross-platform C# IDE with advanced features like code analysis, refactoring, and debugging.



4. #### Consider alternatives to local installation

   [Section titled “Consider alternatives to local installation”](#consider-alternatives-to-local-installation)

   If you prefer not to install the prerequisites on your local machine, you can develop Aspire solutions using cloud-based options like [GitHub Codespaces](https://learn.microsoft.com/dotnet/aspire/get-started/github-codespaces) or [Dev Containers](https://learn.microsoft.com/dotnet/aspire/get-started/dev-containers). These options allow you to work in a cloud-based environment, eliminating the need for local installations, but may not provide the same performance as local installations.

   The Aspire team maintains a GitHub Codespaces (with preconfigured Dev Container) configuration to help you get started quickly:

   [![Open dotnet\&#x2F;aspire-devcontainer in GitHub Codespaces](https://github.com/codespaces/badge.svg "Open dotnet\&#x2F;aspire-devcontainer in GitHub Codespaces")](https://codespaces.new/dotnet/aspire-devcontainer)

# Understanding resources

> Learn about Aspire's resource model and how to work with different types of resources.

Aspire makes it easy to define everything your app needs—frontends, APIs, databases, and more—using the **AppHost**. Just describe your resources in code, and Aspire handles the connections for you.

## Types of resources

[Section titled “Types of resources”](#types-of-resources)

Resources can include:

* **AI Services**: Large Language Models, AI endpoints, and cognitive services.
* **Caches**: Redis, in-memory caches, and distributed caching solutions.
* **Containers**: Docker containers for databases, message brokers, and other services.
* **Databases**: SQL Server, PostgreSQL, MySQL, MongoDB, and other data stores.
* **Executables**: Console applications, scripts, and background services.
* **Frameworks**: Web applications, APIs, and microservices built with various frameworks.
* **Messaging Services**: Service Bus, RabbitMQ, Kafka, and other messaging systems.
* **Projects**: C# projects, Node.js applications, Python services, and more.
* **Storage**: Blob storage, file systems, and cloud storage services.

Explore Integrations

Resources are modeled in *hosting integrations*, which are reusable components that define how your app interacts with external services. Aspire provides a rich set of [built-in integrations for common services](../../integrations/gallery/?search=hosting), and you can easily create custom integrations to suit your needs.

## Resource dependencies

[Section titled “Resource dependencies”](#resource-dependencies)

Resources work together through **explicit dependencies** that you define in your AppHost. When you model these dependencies, Aspire automatically handles the wiring, startup order, and connection management—letting you focus on building your app instead of managing infrastructure.

For example, if your API service depends on a database and configures a wait strategy, Aspire can automatically inject the connection string and ensure the database is started before the API service.

1. Start the database first.
2. Wait for it to become healthy.
3. Inject the connection string into your API service.
4. Start your API service.

Discover how to model [Resource Hierarchies](/architecture/resource-hierarchies/) and represent complex app structures.

## Resource configuration

[Section titled “Resource configuration”](#resource-configuration)

You configure resources through a combination of **environment variables** (for mutable per-environment values), automatically injected **connection strings** that flow to dependent services, explicit **resource parameters** controlling ports, volumes, or other knobs, and custom **health checks** that let Aspire understand readiness beyond simple process status.

## Custom resources

[Section titled “Custom resources”](#custom-resources)

Under-the-hood, every integration is either a **Container** or **Executable**, meaning you can add *any* container image, codebase, script, or cloud resource to your AppHost. Creating reusable Aspire integrations is just like creating a reusable UI component. It can be as simple or complex as you need, and is fully shareable.

## Resource lifecycle

[Section titled “Resource lifecycle”](#resource-lifecycle)

Aspire manages the complete lifecycle of your resources during **local development**:

1. **Discovery**: Resources are discovered and their dependencies are analyzed.
2. **Startup**: Resources are started in dependency order, respecting their relationships.
3. **Health Monitoring**: Resource health and readiness are continuously monitored.
4. **Shutdown**: Resources are gracefully stopped when the application terminates.

Explore how [Built-In Resources and Lifecycle](/architecture/resource-model/#built-in-resources-and-lifecycle) work together to power your applications.

# What is Aspire?

> Learn how Aspire simplifies the development, deployment, and debugging of distributed applications.

Aspire streamlines building, running, debugging, and deploying distributed apps. Picture your app as a set of services, databases, and frontends—when they’re deployed, they all work together seamlessly, but every time you develop them they need to be individually started and connected. With Aspire, you get a unified toolchain that eliminates complex configs and makes local debugging effortless. Instantly launch and debug your entire app with a single command. Ready to deploy? Aspire lets you publish anywhere—Kubernetes, the cloud, or your own servers. It’s also fully extensible, so you can integrate your favorite tools and services with ease.

## Key benefits

[Section titled “Key benefits”](#key-benefits)

* **Unified Development Experience**: Launch and debug your entire distributed application with a single command.
* **Code-First Configuration**: Define your app’s architecture in code—no complex config files required.
* **Local Orchestration**: Automatically handle service startup, dependencies, and connections during development.
* **Deployment Flexibility**: Deploy to Kubernetes, cloud providers, or your own servers using the same architecture definition.
* **Extensible**: Integrate with your favorite tools and services through a rich ecosystem of integrations.

## How Aspire works

[Section titled “How Aspire works”](#how-aspire-works)

Aspire uses a **code-first approach** to define your application’s architecture. Instead of managing complex configuration files, you describe your services, databases, and dependencies directly in code. This approach provides several advantages:

* **Type Safety**: Catch configuration errors at compile time.
* **Statement Completion Support**: Get code completion and documentation while defining your architecture.
* **Version Control**: Your infrastructure definition lives alongside your code.
* **Refactoring**: Use familiar development tools to restructure your application architecture.

Discover how Aspire powers your applications through its [`AppHost`](/get-started/app-host/).

## Development vs production

[Section titled “Development vs production”](#development-vs-production)

Aspire bridges the gap between development and production environments:

* **Development**: Run services locally with automatic dependency management and service discovery
* **Production**: Deploy the same architecture definition to various cloud platforms and orchestrators
* **Consistency**: Ensure your local development environment matches your production topology

Aspire doesn’t replace your existing deployment workflows—it enhances them by providing a consistent way to define and manage your application architecture across environments.

Learn more about [Pipelines and App Topology](/get-started/pipelines/).

# GitHub Models integration

> Learn how to integrate Aspire with GitHub Models for AI model access and management.

![GitHub logo](/_astro/github-icon.Byy9PfGk.png)

[GitHub Models](https://docs.github.com/github-models) provides access to various AI models including OpenAI’s GPT models, DeepSeek, Microsoft’s Phi models, and other leading AI models, all accessible through GitHub’s infrastructure. The Aspire GitHub Models integration enables you to connect to GitHub Models from your applications for prototyping and production scenarios.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire GitHub Models hosting integration models GitHub Models resources as `GitHubModelResource`. To access these types and APIs, install the [📦 Aspire.Hosting.GitHub.Models](https://www.nuget.org/packages/Aspire.Hosting.GitHub.Models) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.GitHub.Models package

  ```bash
  aspire add github-models
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > github-models (Aspire.Hosting.GitHub.Models)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.GitHub.Models@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.GitHub.Models package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.GitHub.Models" Version="*" />
  ```

### Add a GitHub Model resource

[Section titled “Add a GitHub Model resource”](#add-a-github-model-resource)

To add a `GitHubModelResource` to your AppHost project, call the `AddGitHubModel` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var model = GitHubModel.OpenAI.OpenAIGpt4oMini;
var chat = builder.AddGitHubModel("chat", model);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(chat);


builder.Build().Run();
```

The preceding code adds a GitHub Model resource named `chat` using the `GitHubModel` constant for OpenAI’s GPT-4o-mini model. The `WithReference` method passes the connection information to the `ExampleProject` project.

Tip

Use the strongly-typed `GitHubModel` constants to avoid typos and ensure you’re using valid model identifiers. These constants are grouped by publisher (for example, `GitHubModel.OpenAI.OpenAIGpt4oMini`, `GitHubModel.Microsoft.Phi4MiniInstruct`, `GitHubModel.DeepSeek.DeepSeekV30324`).

### Specify an organization

[Section titled “Specify an organization”](#specify-an-organization)

For organization-specific requests, you can specify an organization parameter:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var organization = builder.AddParameter("github-org");
var model = GitHubModel.OpenAI.OpenAIGpt4oMini;
var chat = builder.AddGitHubModel("chat", model, organization);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(chat);


builder.Build().Run();
```

When an organization is specified, the token must be attributed to that organization in GitHub.

### Configure API key authentication

[Section titled “Configure API key authentication”](#configure-api-key-authentication)

The GitHub Models integration supports multiple ways to configure authentication:

#### Default API key parameter

[Section titled “Default API key parameter”](#default-api-key-parameter)

By default, the integration creates a parameter named `{resource_name}-gh-apikey` that automatically falls back to the `GITHUB_TOKEN` environment variable:

```csharp
var model = GitHubModel.OpenAI.OpenAIGpt4oMini;
var chat = builder.AddGitHubModel("chat", model);
```

Then in user secrets:

```json
{
  "Parameters": {
    "chat-gh-apikey": "YOUR_GITHUB_TOKEN_HERE"
  }
}
```

#### Custom API key parameter

[Section titled “Custom API key parameter”](#custom-api-key-parameter)

You can also specify a custom parameter for the API key:

```csharp
var apiKey = builder.AddParameter("my-api-key", secret: true);
var model = GitHubModel.OpenAI.OpenAIGpt4oMini;
var chat = builder.AddGitHubModel("chat", model)
                  .WithApiKey(apiKey);
```

Then in user secrets:

```json
{
  "Parameters": {
    "my-api-key": "YOUR_GITHUB_TOKEN_HERE"
  }
}
```

### Health checks

[Section titled “Health checks”](#health-checks)

You can add health checks to verify the GitHub Models endpoint accessibility and API key validity:

```csharp
var model = GitHubModel.OpenAI.OpenAIGpt4oMini;
var chat = builder.AddGitHubModel("chat", model)
                  .WithHealthCheck();
```

Caution

Because health checks are included in the rate limit of the GitHub Models API, use this health check sparingly, such as when debugging connectivity issues. The health check runs only once per application instance to minimize API usage.

### Available models

[Section titled “Available models”](#available-models)

GitHub Models supports various AI models. Use the strongly-typed `GitHubModel` constants for the most up-to-date list of available models. Some popular options include:

* `GitHubModel.OpenAI.OpenAIGpt4oMini`
* `GitHubModel.OpenAI.OpenAIGpt41Mini`
* `GitHubModel.DeepSeek.DeepSeekV30324`
* `GitHubModel.Microsoft.Phi4MiniInstruct`

Check the [GitHub Models documentation](https://docs.github.com/github-models) for more information about these models and their capabilities.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a GitHub Model resource using `WithReference`, the following connection properties are made available to the consuming project:

#### GitHub Model

[Section titled “GitHub Model”](#github-model)

The GitHub Model resource exposes the following connection properties:

| Property Name  | Description                                                                                    |
| -------------- | ---------------------------------------------------------------------------------------------- |
| `Uri`          | The GitHub Models inference endpoint URI, with the format `https://models.github.ai/inference` |
| `Key`          | The API key (PAT or GitHub App token) for authentication                                       |
| `ModelName`    | The model identifier for inference requests, for instance `openai/gpt-4o-mini`                 |
| `Organization` | The organization attributed to the request (available when configured)                         |

**Example properties:**

```plaintext
Uri: https://models.github.ai/inference
ModelName: openai/gpt-4o-mini
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `chat` becomes `CHAT_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire GitHub Models client integration, you can use either the Azure AI Inference client or the OpenAI client, depending on your needs and model compatibility.

### Using Azure AI Inference client

[Section titled “Using Azure AI Inference client”](#using-azure-ai-inference-client)

Install the [📦 Aspire.Azure.AI.Inference](https://www.nuget.org/packages/Aspire.Azure.AI.Inference) NuGet package in the client-consuming project:

* .NET CLI

  .NET CLI — Add Aspire.Azure.AI.Inference package

  ```bash
  dotnet add package Aspire.Azure.AI.Inference
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.AI.Inference@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.AI.Inference package reference

  ```xml
  <PackageReference Include="Aspire.Azure.AI.Inference" Version="*" />
  ```

#### Add a ChatCompletionsClient

[Section titled “Add a ChatCompletionsClient”](#add-a-chatcompletionsclient)

In the `Program.cs` file of your client-consuming project, use the `AddAzureChatCompletionsClient` method to register a `ChatCompletionsClient` for dependency injection:

```csharp
builder.AddAzureChatCompletionsClient("chat");
```

You can then retrieve the `ChatCompletionsClient` instance using dependency injection:

```csharp
public class ExampleService(ChatCompletionsClient client)
{
    public async Task<string> GetResponseAsync(string prompt)
    {
        var response = await client.GetChatCompletionsAsync(
            new[]
            {
                new ChatMessage(ChatRole.User, prompt)
            });


        return response.Value.Choices[0].Message.Content;
    }
}
```

#### Add ChatCompletionsClient with registered IChatClient

[Section titled “Add ChatCompletionsClient with registered IChatClient”](#add-chatcompletionsclient-with-registered-ichatclient)

If you’re using the Microsoft.Extensions.AI abstractions, you can register an `IChatClient`:

```csharp
builder.AddAzureChatCompletionsClient("chat")
       .AddChatClient();
```

Then use it in your services:

```csharp
public class StoryService(IChatClient chatClient)
{
    public async Task<string> GenerateStoryAsync(string prompt)
    {
        var response = await chatClient.GetResponseAsync(prompt);


        return response.Text;
    }
}
```

### Using OpenAI client

[Section titled “Using OpenAI client”](#using-openai-client)

For models compatible with the OpenAI API (such as `openai/gpt-4o-mini`), you can use the OpenAI client. Install the [📦 Aspire.OpenAI](https://www.nuget.org/packages/Aspire.OpenAI) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.OpenAI package

  ```bash
  dotnet add package Aspire.OpenAI
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.OpenAI@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.OpenAI package reference

  ```xml
  <PackageReference Include="Aspire.OpenAI" Version="*" />
  ```

#### Add an OpenAI client

[Section titled “Add an OpenAI client”](#add-an-openai-client)

```csharp
builder.AddOpenAIClient("chat");
```

You can then use the OpenAI client:

```csharp
public class ChatService(OpenAIClient client)
{
    public async Task<string> GetChatResponseAsync(string prompt)
    {
        var chatClient = client.GetChatClient(GitHubModel.OpenAI.OpenAIGpt4oMini);
        var response = await chatClient.CompleteChatAsync(
            new[]
            {
                new UserChatMessage(prompt)
            });


        return response.Value.Content[0].Text;
    }
}
```

#### Add OpenAI client with registered IChatClient

[Section titled “Add OpenAI client with registered IChatClient”](#add-openai-client-with-registered-ichatclient)

```csharp
builder.AddOpenAIClient("chat")
       .AddChatClient();
```

### Configuration

[Section titled “Configuration”](#configuration)

The GitHub Models integration supports configuration through user secrets, environment variables, or app settings. The integration automatically uses the `GITHUB_TOKEN` environment variable if available, or you can specify a custom API key parameter.

#### Authentication

[Section titled “Authentication”](#authentication)

The GitHub Models integration requires a GitHub personal access token with `models: read` permission. The token can be provided in several ways:

##### Environment variables in Codespaces and GitHub Actions

[Section titled “Environment variables in Codespaces and GitHub Actions”](#environment-variables-in-codespaces-and-github-actions)

When running an app in GitHub Codespaces or GitHub Actions, the `GITHUB_TOKEN` environment variable is automatically available and can be used without additional configuration. This token has the necessary permissions to access GitHub Models for the repository context.

```csharp
// No additional configuration needed in Codespaces/GitHub Actions
var model = GitHubModel.OpenAI.OpenAIGpt4oMini;
var chat = builder.AddGitHubModel("chat", model);
```

##### Personal access tokens for local development

[Section titled “Personal access tokens for local development”](#personal-access-tokens-for-local-development)

For local development, you need to create a [fine-grained personal access token](https://github.com/settings/tokens) with the `models: read` scope and configure it in user secrets:

```json
{
  "Parameters": {
    "chat-gh-apikey": "github_pat_YOUR_TOKEN_HERE"
  }
}
```

#### Connection string format

[Section titled “Connection string format”](#connection-string-format)

The connection string follows this format:

```plaintext
Endpoint=https://models.github.ai/inference;Key={api_key};Model={model_name};DeploymentId={model_name}
```

For organization-specific requests:

```plaintext
Endpoint=https://models.github.ai/orgs/{organization}/inference;Key={api_key};Model={model_name};DeploymentId={model_name}
```

### Rate limits and costs

[Section titled “Rate limits and costs”](#rate-limits-and-costs)

Caution

Each model has rate limits that vary by model and usage tier. Some models include costs if you exceed free tier limits. Check the [GitHub Models documentation](https://docs.github.com/github-models) for current rate limits and pricing information.

Tip

Use health checks sparingly to avoid consuming your rate limit allowance. The integration caches health check results to minimize API calls.

### Sample application

[Section titled “Sample application”](#sample-application)

The `dotnet/aspire` repo contains an example application demonstrating the GitHub Models integration. You can find the sample in the [Aspire GitHub repository](https://github.com/dotnet/aspire/tree/main/playground/GitHubModelsEndToEnd).

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

### Logging

[Section titled “Logging”](#logging)

The GitHub Models integration uses standard HTTP client logging categories:

* `System.Net.Http.HttpClient`
* `Microsoft.Extensions.Http`

### Tracing

[Section titled “Tracing”](#tracing)

HTTP requests to the GitHub Models API are automatically traced when using the Azure AI Inference or OpenAI clients.

## See also

[Section titled “See also”](#see-also)

* [GitHub Models](https://docs.github.com/github-models)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)
* [GitHub Models API documentation](https://docs.github.com/rest/models/inference)

# Ollama integration

> Learn how to use the Aspire Ollama hosting and client integration to host Ollama models using the Ollama container and accessing it via the OllamaSharp client.

⭐ Community Toolkit ![Ollama logo](/_astro/ollama-icon.4z_rvyfm_1rh0Aw.webp)

[Ollama](https://ollama.com) is a powerful, open source language model that can be used to generate text based on a given prompt. The Aspire Ollama integration provides a way to host Ollama models using the [`docker.io/ollama/ollama` container image](https://hub.docker.com/r/ollama/ollama) and access them via the [OllamaSharp](https://www.nuget.org/packages/OllamaSharp) client.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Ollama hosting integration models an Ollama server as the `OllamaResource` type, and provides the ability to add models to the server using the `AddModel` extension method, which represents the model as an `OllamaModelResource` type. To access these types and APIs, install the [📦 CommunityToolkit.Aspire.Hosting.Ollama](https://nuget.org/packages/CommunityToolkit.Aspire.Hosting.Ollama) NuGet package in the AppHost project:

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Ollama package

  ```bash
  aspire add communitytoolkit-ollama
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-ollama (CommunityToolkit.Aspire.Hosting.Ollama)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Ollama@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Ollama package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Ollama" Version="*" />
  ```

### Add Ollama resource

[Section titled “Add Ollama resource”](#add-ollama-resource)

In the AppHost project, register and consume the Ollama integration using the `AddOllama` extension method to add the Ollama container to the application builder. You can then add models to the container, which downloads and run when the container starts, using the `AddModel` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var ollama = builder.AddOllama("ollama");


var phi35 = ollama.AddModel("phi3.5");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(phi35);


builder.Build().Run();
```

Alternatively, if you want to use a model from the [Hugging Face](https://huggingface.co/) model hub, you can use the `AddHuggingFaceModel` extension method:

```csharp
var llama = ollama.AddHuggingFaceModel("llama", "bartowski/Llama-3.2-1B-Instruct-GGUF:IQ4_XS");
```

When Aspire adds a container image to the AppHost, as shown in the preceding example with the `docker.io/ollama/ollama` image, it creates a new Ollama instance on your local machine.

### Download the LLM

[Section titled “Download the LLM”](#download-the-llm)

When the Ollama container for this integration first spins up, it downloads the configured LLMs. The progress of this download displays in the **State** column for this integration on the Aspire dashboard.

Caution

Keep the Aspire orchestration app open until the download is complete, otherwise the download will be cancelled.

### Cache the LLM

[Section titled “Cache the LLM”](#cache-the-llm)

One or more LLMs are downloaded into the container which Ollama is running from, and by default this container is ephemeral. If you need to persist one or more LLMs across container restarts, you need to mount a volume into the container using the `WithDataVolume` method:

```csharp
var ollama = builder.AddOllama("ollama")
                    .WithDataVolume();


var llama = ollama.AddModel("llama3");
```

### Use GPUs when available

[Section titled “Use GPUs when available”](#use-gpus-when-available)

One or more LLMs are downloaded into the container which Ollama is running from, and by default this container runs on CPU. If you need to run the container with GPU support, you can enable it using the `WithGPUSupport()` extension method.

**Nvidia:**

```csharp
var ollama = builder.AddOllama("ollama")
                    .AddModel("llama3")
                    .WithGPUSupport();
```

**AMD:**

```csharp
var ollama = builder.AddOllama("ollama")
                    .AddModel("llama3")
                    .WithGPUSupport(OllamaGpuVendor.AMD);
```

For more information, see [GPU support in Docker Desktop](https://docs.docker.com/desktop/gpu/) and [GPU support in Podman](https://github.com/containers/podman/issues/19005).

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Ollama hosting integration automatically adds a health check for the Ollama server and model resources. For the Ollama server, a health check is added to verify that the Ollama server is running and that a connection can be established to it. For the Ollama model resources, a health check is added to verify that the model is running and that the model is available, meaning the resource will be marked as unhealthy until the model has been downloaded.

### Open WebUI support

[Section titled “Open WebUI support”](#open-webui-support)

The Ollama integration also provided support for running [Open WebUI](https://openwebui.com/) and having it communicate with the Ollama container:

```csharp
var ollama = builder.AddOllama("ollama")
                    .AddModel("llama3")
                    .WithOpenWebUI();
```

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire OllamaSharp integration, install the [📦 CommunityToolkit.Aspire.OllamaSharp](https://nuget.org/packages/CommunityToolkit.Aspire.OllamaSharp) NuGet package in the client-consuming project, that is, the project for the application that uses the Ollama client:

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.OllamaSharp package

  ```bash
  dotnet add package CommunityToolkit.Aspire.OllamaSharp
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.OllamaSharp@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.OllamaSharp package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.OllamaSharp" Version="*" />
  ```

### Add Ollama client API

[Section titled “Add Ollama client API”](#add-ollama-client-api)

In the `Program.cs` file of your client-consuming project, call the `AddOllamaClientApi` extension to register an `IOllamaClientApi` for use via the dependency injection container. If the resource provided in the AppHost, and referenced in the client-consuming project, is an `OllamaModelResource`, then the `AddOllamaClientApi` method will register the model as the default model for the `IOllamaClientApi`:

```csharp
builder.AddOllamaClientApi("llama3");
```

After adding `IOllamaClientApi` to the builder, you can get the `IOllamaClientApi` instance using dependency injection. For example, to retrieve your context object from service:

```csharp
public class ExampleService(IOllamaClientApi ollama)
{
    // Use ollama...
}
```

### Add keyed Ollama client API

[Section titled “Add keyed Ollama client API”](#add-keyed-ollama-client-api)

There might be situations where you want to register multiple `IOllamaClientApi` instances with different connection names. To register keyed Ollama clients, call the `AddKeyedOllamaClientApi` method:

```csharp
builder.AddKeyedOllamaClientApi(name: "chat");
builder.AddKeyedOllamaClientApi(name: "embeddings");
```

Then you can retrieve the `IOllamaClientApi` instances using dependency injection. For example, to retrieve the connection from an example service:

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] IOllamaClientApi chatOllama,
    [FromKeyedServices("embeddings")] IOllamaClientApi embeddingsOllama)
{
    // Use ollama...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Ollama client integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling the `AddOllamaClientApi` method:

```csharp
builder.AddOllamaClientApi("llama");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "llama": "Endpoint=http//localhost:1234;Model=llama3"
  }
}
```

### Integration with Microsoft.Extensions.AI

[Section titled “Integration with Microsoft.Extensions.AI”](#integration-with-microsoftextensionsai)

The [📦 Microsoft.Extensions.AI](https://www.nuget.org/packages/Microsoft.Extensions.AI) NuGet package provides an abstraction over the Ollama client API, using generic interfaces. OllamaSharp supports these interfaces, and they can be registered by chaining either the `IChatClient` or `IEmbeddingGenerator<string, Embedding<float>>` registration methods to the `AddOllamaClientApi` method.

To register an `IChatClient`, chain the `AddChatClient` method to the `AddOllamaClientApi` method:

```csharp
builder.AddOllamaClientApi("llama")
       .AddChatClient();
```

Similarly, to register an `IEmbeddingGenerator`, chain the `AddEmbeddingGenerator` method:

```csharp
builder.AddOllamaClientApi("llama")
       .AddEmbeddingGenerator();
```

After adding `IChatClient` to the builder, you can get the `IChatClient` instance using dependency injection. For example, to retrieve your context object from service:

```csharp
public class ExampleService(IChatClient chatClient)
{
    // Use chat client...
}
```

### Add keyed Microsoft.Extensions.AI clients

[Section titled “Add keyed Microsoft.Extensions.AI clients”](#add-keyed-microsoftextensionsai-clients)

There might be situations where you want to register multiple AI client instances with different connection names. To register keyed AI clients, use the keyed versions of the registration methods:

```csharp
builder.AddOllamaClientApi("chat")
       .AddKeyedChatClient("chat");
builder.AddOllamaClientApi("embeddings")
       .AddKeyedEmbeddingGenerator("embeddings");
```

Then you can retrieve the AI client instances using dependency injection. For example, to retrieve the clients from an example service:

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] IChatClient chatClient,
    [FromKeyedServices("embeddings")] IEmbeddingGenerator<string, Embedding<float>> embeddingGenerator)
{
    // Use AI clients...
}
```

## See also

[Section titled “See also”](#see-also)

* [Ollama](https://ollama.com)
* [Open WebUI](https://openwebui.com)
* [Aspire Community Toolkit GitHub repo](https://github.com/CommunityToolkit/Aspire)
* [OllamaSharp](https://github.com/awaescher/OllamaSharp)
* [Microsoft.Extensions.AI](https://devblogs.microsoft.com/dotnet/introducing-microsoft-extensions-ai-preview/)

# OpenAI integration

> Learn how to use the OpenAI integration, which includes both hosting and client integrations.

![OpenAI logo](/_astro/openai-icon.gefPjpNr.png)

[OpenAI](https://openai.com/) provides access to chat/completions, embeddings, image, and audio models via a REST API. The OpenAI integration lets you:

* Model an OpenAI account (endpoint + API key) once in the AppHost.
* Add one or more model resources that compose their connection strings from the parent.
* Reference those model resources from projects to get strongly-named connection strings.
* Consume those connection strings with the `Aspire.OpenAI` component to obtain an `OpenAIClient` and (optionally) an `IChatClient`.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The hosting integration models OpenAI with two resource types:

* `OpenAIResource`: Parent that holds the shared API key and base endpoint (defaults to `https://api.openai.com/v1`).
* `OpenAIModelResource`: Child representing a specific model; composes a connection string from the parent (`Endpoint` + `Key` + `Model`).

To access these types and APIs, install the [📦 Aspire.Hosting.OpenAI](https://www.nuget.org/packages/Aspire.Hosting.OpenAI) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.OpenAI package

  ```bash
  aspire add openai
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > openai (Aspire.Hosting.OpenAI)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.OpenAI@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.OpenAI package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.OpenAI" Version="*" />
  ```

### Add an OpenAI parent resource

[Section titled “Add an OpenAI parent resource”](#add-an-openai-parent-resource)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddOpenAI("openai");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(openai);


// After adding all resources, run the app...
```

### Add OpenAI model resources

[Section titled “Add OpenAI model resources”](#add-openai-model-resources)

Add one or more model children beneath the parent and reference them from projects:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddOpenAI("openai");


var chat = openai.AddModel("chat", "gpt-4o-mini");
var embeddings = openai.AddModel("embeddings", "text-embedding-3-small");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(chat);


// After adding all resources, run the app...
```

Referencing `chat` passes a connection string named `chat` to the project. Multiple models can share the single API key and endpoint via the parent resource.

### Use default API key parameter

[Section titled “Use default API key parameter”](#use-default-api-key-parameter)

Calling `AddOpenAI("openai")` creates a secret parameter named `openai-openai-apikey`. Aspire resolves its value in this order:

1. The `Parameters:openai-openai-apikey` configuration key (user secrets, `appsettings.*`, or environment variables).
2. The `OPENAI_API_KEY` environment variable.

If neither source provides a value, startup throws an exception. Provide the key via user-secrets:

```bash
dotnet user-secrets set Parameters:openai-openai-apikey sk-your-api-key
```

### Use custom API key parameter

[Section titled “Use custom API key parameter”](#use-custom-api-key-parameter)

Replace the default parameter by creating your own secret parameter and calling `WithApiKey` on the parent:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiKey = builder.AddParameter("my-api-key", secret: true);


var openai = builder.AddOpenAI("openai")
                    .WithApiKey(apiKey);


var chat = openai.AddModel("chat", "gpt-4o-mini");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(chat);
```

Note

Custom parameters must be marked `secret: true`.

### Add a custom endpoint

[Section titled “Add a custom endpoint”](#add-a-custom-endpoint)

Override the default endpoint (for example to use a proxy or compatible gateway):

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddOpenAI("openai")
                    .WithEndpoint("https://my-gateway.example.com/v1");


var chat = openai.AddModel("chat", "gpt-4o-mini");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(chat);
```

### Health checks

[Section titled “Health checks”](#health-checks)

Add an optional single-run health check per model when diagnosing issues:

```csharp
var chat = builder.AddOpenAI("openai")
                  .AddModel("chat", "gpt-4o-mini")
                  .WithHealthCheck();
```

The model health check validates endpoint reachability, API key validity (401), and model existence (404). It executes only once per application instance to limit rate-limit implications. A status-page check against `https://status.openai.com/api/v2/status.json` is automatically registered for each parent resource.

### Available models

[Section titled “Available models”](#available-models)

Common identifiers:

* `gpt-5`
* `gpt-4o-mini`
* `gpt-4o`
* `gpt-4-turbo`
* `gpt-realtime`
* `text-embedding-3-small`
* `text-embedding-3-large`
* `dall-e-3`
* `whisper-1`

Note

The model name is case-insensitive, but we usually write it in lowercase.

For more information, see the [OpenAI models documentation](https://platform.openai.com/docs/models).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference an OpenAI resource using `WithReference`, the following connection properties are made available to the consuming project:

#### OpenAI

[Section titled “OpenAI”](#openai)

The OpenAI resource exposes the following connection properties:

| Property Name | Description                                                                           |
| ------------- | ------------------------------------------------------------------------------------- |
| `Endpoint`    | The base endpoint URI for the OpenAI API, with the format `https://api.openai.com/v1` |
| `Uri`         | The endpoint URI (same as Endpoint), with the format `https://api.openai.com/v1`      |
| `Key`         | The API key for authentication                                                        |

**Example properties:**

```plaintext
Uri: https://api.openai.com/v1
Key: sk-proj-abc123...
```

#### OpenAI model

[Section titled “OpenAI model”](#openai-model)

The OpenAI model resource combines the parent properties above and adds the following connection property:

| Property Name | Description                                                             |
| ------------- | ----------------------------------------------------------------------- |
| `ModelName`   | The model identifier for inference requests, for instance `gpt-4o-mini` |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `chat` becomes `CHAT_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire OpenAI client integration, install the [📦 Aspire.OpenAI](https://www.nuget.org/packages/Aspire.OpenAI) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.OpenAI package

  ```bash
  dotnet add package Aspire.OpenAI
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.OpenAI@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.OpenAI package reference

  ```xml
  <PackageReference Include="Aspire.OpenAI" Version="*" />
  ```

### Add an OpenAI client

[Section titled “Add an OpenAI client”](#add-an-openai-client)

In the `Program.cs` file of your client-consuming project, use `AddOpenAIClient` to register an `OpenAIClient` for dependency injection. The method requires a connection name parameter:

```csharp
builder.AddOpenAIClient(connectionName: "chat");
```

Tip

The `connectionName` parameter must match the name used when adding the OpenAI resource in the AppHost project.

After adding the `OpenAIClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(OpenAIClient client)
{
    // Use client...
}
```

#### Add OpenAI client with registered IChatClient

[Section titled “Add OpenAI client with registered IChatClient”](#add-openai-client-with-registered-ichatclient)

```csharp
builder.AddOpenAIClient("chat")
       .AddChatClient(); // Model inferred from connection string (Model=...)
```

If only a parent resource was defined (no child model), provide the model name explicitly:

```csharp
builder.AddOpenAIClient("openai")
       .AddChatClient("gpt-4o-mini");
```

`AddChatClient` optionally accepts a model/deployment name; if omitted it comes from the connection string’s `Model` entry. Inject `OpenAIClient` or `IChatClient` as needed.

### Configuration

[Section titled “Configuration”](#configuration)

The OpenAI library provides multiple options to configure the OpenAI connection. Either a `Endpoint` or a `ConnectionString` is required.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

Resolved connection string shapes:

Parent (no model):

```plaintext
Endpoint={endpoint};Key={api_key}
```

Model child:

```plaintext
Endpoint={endpoint};Key={api_key};Model={model_name}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

Configure via `Aspire:OpenAI` keys (global) and `Aspire:OpenAI:{connectionName}` (per named client). Example `appsettings.json`:

```json
{
  "ConnectionStrings": {
    "chat": "Endpoint=https://api.openai.com/v1;Key=${OPENAI_API_KEY};Model=gpt-4o-mini"
  },
  "Aspire": {
    "OpenAI": {
      "DisableTracing": false,
      "DisableMetrics": false,
      "ClientOptions": {
        "UserAgentApplicationId": "myapp",
        "NetworkTimeout": "00:00:30"
      }
    }
  }
}
```

Inline configuration:

```csharp
builder.AddOpenAIClient("chat", settings => settings.DisableTracing = true);
builder.AddOpenAIClient("chat", configureOptions: o => o.NetworkTimeout = TimeSpan.FromSeconds(30));
```

Note

Telemetry (traces + metrics) is experimental in the OpenAI .NET SDK. Enable globally via the `OpenAI.Experimental.EnableOpenTelemetry` AppContext switch or `OPENAI_EXPERIMENTAL_ENABLE_OPEN_TELEMETRY=true`. Use `DisableTracing` / `DisableMetrics` to opt out when enabled.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

* `OpenAI.*`

#### Tracing

[Section titled “Tracing”](#tracing)

* `OpenAI.*` (when telemetry enabled and not disabled)

#### Metrics

[Section titled “Metrics”](#metrics)

* `OpenAI.*` meter (when telemetry enabled and not disabled)

# Garnet integration

> Learn how to use the Garnet integration, a Redis-compatible high-performance cache from Microsoft Research.

![Garnet logo](/_astro/garnet-icon.C0u592g4_1aVQXX.webp)

[Garnet](https://microsoft.github.io/garnet/) is a high-performance cache-store from Microsoft Research that complies with the Redis serialization protocol (RESP). The Garnet integration enables you to connect to existing Garnet instances, or create new instances from Aspire with the `ghcr.io/microsoft/garnet` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Garnet hosting integration models a Garnet resource as the `GarnetResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Garnet](https://www.nuget.org/packages/Aspire.Hosting.Garnet) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Garnet package

  ```bash
  aspire add garnet
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > garnet (Aspire.Hosting.Garnet)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Garnet@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Garnet package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Garnet" Version="*" />
  ```

### Add Garnet resource

[Section titled “Add Garnet resource”](#add-garnet-resource)

In your AppHost project, call `AddGarnet` on the builder instance to add a Garnet resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddGarnet("cache");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

When Aspire adds a container image to the AppHost, it creates a new Garnet instance on your local machine.

Tip

If you’d rather connect to an existing Garnet instance, call `AddConnectionString` instead. For more information on how to use `WithReference`, see [Resource dependencies](/get-started/resources/).

### Add Garnet resource with data volume

[Section titled “Add Garnet resource with data volume”](#add-garnet-resource-with-data-volume)

To add a data volume to the Garnet resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddGarnet("cache")
                   .WithDataVolume(isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The data volume is used to persist the Garnet data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Garnet container.

### Add Garnet resource with data bind mount

[Section titled “Add Garnet resource with data bind mount”](#add-garnet-resource-with-data-bind-mount)

To add a data bind mount to the Garnet resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddGarnet("cache")
                   .WithDataBindMount(
                       source: @"C:\Garnet\Data",
                       isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

### Add Garnet resource with persistence

[Section titled “Add Garnet resource with persistence”](#add-garnet-resource-with-persistence)

To add persistence to the Garnet resource, call the `WithPersistence` method with either the data volume or data bind mount:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddGarnet("cache")
                   .WithDataVolume()
                   .WithPersistence(
                       interval: TimeSpan.FromMinutes(5),
                       keysChangedThreshold: 100);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The preceding code adds persistence to the Garnet resource by taking snapshots of the data at a specified interval and threshold.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a Garnet resource using `WithReference`, the following connection properties are made available to the consuming project:

#### Garnet

[Section titled “Garnet”](#garnet)

The Garnet resource exposes the following connection properties:

| Property Name | Description                                                                         |
| ------------- | ----------------------------------------------------------------------------------- |
| `Host`        | The hostname or IP address of the Garnet server                                     |
| `Port`        | The port number the Garnet server is listening on                                   |
| `Password`    | The password for authentication (available when a password parameter is configured) |
| `Uri`         | The connection URI, with the format `redis://:{Password}@{Host}:{Port}`             |

**Example connection string:**

```plaintext
Uri: redis://:p%40ssw0rd1@localhost:6379
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `cache` becomes `CACHE_URI`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Garnet hosting integration automatically adds a health check for the Garnet resource. The health check verifies that the Garnet instance is running and that a connection can be established to it.

## Client integration

[Section titled “Client integration”](#client-integration)

Garnet is Redis-compatible, so you use the same Redis client packages. To get started, install the [📦 Aspire.StackExchange.Redis](https://www.nuget.org/packages/Aspire.StackExchange.Redis) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.StackExchange.Redis package

  ```bash
  dotnet add package Aspire.StackExchange.Redis
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.StackExchange.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.StackExchange.Redis package reference

  ```xml
  <PackageReference Include="Aspire.StackExchange.Redis" Version="*" />
  ```

### Add Garnet client

[Section titled “Add Garnet client”](#add-garnet-client)

In the `Program.cs` file of your client-consuming project, call the `AddRedisClient` extension method to register an `IConnectionMultiplexer`:

```csharp
builder.AddRedisClient(connectionName: "cache");
```

Tip

The `connectionName` parameter must match the name used when adding the Garnet resource in the AppHost project.

You can then retrieve the `IConnectionMultiplexer` instance using dependency injection:

```csharp
public class ExampleService(IConnectionMultiplexer connectionMux)
{
    // Use connection multiplexer...
}
```

### Configuration and other client features

[Section titled “Configuration and other client features”](#configuration-and-other-client-features)

Since Garnet is Redis-compatible, all Redis client configuration, keyed services, health checks, and observability features work the same way. See the [Redis integration](/integrations/caching/redis/) page for complete client integration documentation.

### Distributed caching and output caching

[Section titled “Distributed caching and output caching”](#distributed-caching-and-output-caching)

Garnet also supports Redis distributed caching and output caching. Install the respective packages:

* For distributed caching: [📦 Aspire.StackExchange.Redis.DistributedCaching](https://www.nuget.org/packages/Aspire.StackExchange.Redis.DistributedCaching)
* For output caching: [📦 Aspire.StackExchange.Redis.OutputCaching](https://www.nuget.org/packages/Aspire.StackExchange.Redis.OutputCaching)

See [Redis Distributed Caching](/integrations/caching/redis-distributed/) and [Redis Output Caching](/integrations/caching/redis-output/) for usage details.

# Redis integration

> Learn how to use the Redis integration, which includes both hosting and client integrations.

![Redis logo](/_astro/redis-icon.CxKuuAy2_Z1scdLi.webp)

[Redis®](#registered-trademark) is the world’s fastest data platform for caching, vector search, and NoSQL databases. The Aspire Redis integration enables you to connect to existing Redis instances, or create new instances from .NET with the [`docker.io/library/redis` container image](https://hub.docker.com/_/redis/).

Note

This page covers the Redis integration. For Garnet and Valkey (Redis-compatible alternatives), see their respective pages.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Redis hosting integration models a Redis resource as the `RedisResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Redis](https://www.nuget.org/packages/Aspire.Hosting.Redis) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Redis package

  ```bash
  aspire add redis
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > redis (Aspire.Hosting.Redis)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Redis package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Redis" Version="*" />
  ```

### Add Redis resource

[Section titled “Add Redis resource”](#add-redis-resource)

In your AppHost project, call `AddRedis` on the builder instance to add a Redis resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

When Aspire adds a container image to the AppHost, it creates a new Redis instance on your local machine.

Tip

If you’d rather connect to an existing Redis instance, call `AsExisting` instead.

### Add Redis resource with Redis Insights

[Section titled “Add Redis resource with Redis Insights”](#add-redis-resource-with-redis-insights)

To add [Redis Insights](https://redis.io/insight/) to the Redis resource, call the `WithRedisInsight` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithRedisInsight();


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

Redis Insights is a free graphical interface for analyzing Redis data across all operating systems and Redis deployments.

### Add Redis resource with Redis Commander

[Section titled “Add Redis resource with Redis Commander”](#add-redis-resource-with-redis-commander)

To add [Redis Commander](https://joeferner.github.io/redis-commander/) to the Redis resource, call the `WithRedisCommander` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithRedisCommander();


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

Redis Commander is a Node.js web application used to view, edit, and manage a Redis Database.

### Add Redis resource with data volume

[Section titled “Add Redis resource with data volume”](#add-redis-resource-with-data-volume)

To add a data volume to the Redis resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataVolume(isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The data volume is used to persist the Redis data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Redis container.

### Add Redis resource with data bind mount

[Section titled “Add Redis resource with data bind mount”](#add-redis-resource-with-data-bind-mount)

To add a data bind mount to the Redis resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataBindMount(
                       source: @"C:\Redis\Data",
                       isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

### Add Redis resource with persistence

[Section titled “Add Redis resource with persistence”](#add-redis-resource-with-persistence)

To add persistence to the Redis resource, call the `WithPersistence` method with either the data volume or data bind mount:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataVolume()
                   .WithPersistence(
                       interval: TimeSpan.FromMinutes(5),
                       keysChangedThreshold: 100);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The preceding code adds persistence to the Redis resource by taking snapshots of the Redis data at a specified interval and threshold.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a Redis resource using `WithReference`, the following connection properties are made available to the consuming project:

#### Redis

[Section titled “Redis”](#redis)

The Redis resource exposes the following connection properties:

| Property Name | Description                                                             |
| ------------- | ----------------------------------------------------------------------- |
| `Host`        | The hostname or IP address of the Redis server                          |
| `Port`        | The port number the Redis server is listening on                        |
| `Password`    | The password for authentication                                         |
| `Uri`         | The connection URI, with the format `redis://:{Password}@{Host}:{Port}` |

**Example connection string:**

```plaintext
Uri: redis://:p%40ssw0rd1@localhost:6379
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `cache` becomes `CACHE_URI`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Redis hosting integration automatically adds a health check for the Redis resource. The health check verifies that the Redis instance is running and that a connection can be established to it.

### Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

The Redis hosting integration can be used with any application technology. When you use `WithReference` to reference a Redis resource, connection information is automatically injected as environment variables:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis("cache")
    .WithLifetime(ContainerLifetime.Persistent);


// Configure a non-.NET application with Redis access
var app = builder.AddExecutable("my-app", "python", "app.py", ".")
    .WithReference(redis) // Provides ConnectionStrings__cache
    .WithEnvironment(context =>
    {
        context.EnvironmentVariables["REDIS_HOST"] = redis.Resource.PrimaryEndpoint.Property(EndpointProperty.Host);
        context.EnvironmentVariables["REDIS_PORT"] = redis.Resource.PrimaryEndpoint.Property(EndpointProperty.Port);
    });
```

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Redis client integration, install the [📦 Aspire.StackExchange.Redis](https://www.nuget.org/packages/Aspire.StackExchange.Redis) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.StackExchange.Redis package

  ```bash
  dotnet add package Aspire.StackExchange.Redis
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.StackExchange.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.StackExchange.Redis package reference

  ```xml
  <PackageReference Include="Aspire.StackExchange.Redis" Version="*" />
  ```

### Add Redis client

[Section titled “Add Redis client”](#add-redis-client)

In the `Program.cs` file of your client-consuming project, call the `AddRedisClient` extension method to register an `IConnectionMultiplexer` for use via the dependency injection container:

```csharp
builder.AddRedisClient(connectionName: "cache");
```

Tip

The `connectionName` parameter must match the name used when adding the Redis resource in the AppHost project.

You can then retrieve the `IConnectionMultiplexer` instance using dependency injection:

```csharp
public class ExampleService(IConnectionMultiplexer connectionMux)
{
    // Use connection multiplexer...
}
```

### Add keyed Redis client

[Section titled “Add keyed Redis client”](#add-keyed-redis-client)

There might be situations where you want to register multiple `IConnectionMultiplexer` instances with different connection names. To register keyed Redis clients, call the `AddKeyedRedisClient` method:

```csharp
builder.AddKeyedRedisClient(name: "chat");
builder.AddKeyedRedisClient(name: "queue");
```

Then retrieve the instances:

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] IConnectionMultiplexer chatConnectionMux,
    [FromKeyedServices("queue")] IConnectionMultiplexer queueConnectionMux)
{
    // Use connections...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddRedis`:

```csharp
builder.AddRedis("cache");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "cache": "localhost:6379"
  }
}
```

For more information on how to format this connection string, see the [Stack Exchange Redis configuration docs](https://stackexchange.github.io/StackExchange.Redis/Configuration.html#basic-configuration-strings).

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Redis client integration supports `Microsoft.Extensions.Configuration`. It loads the `StackExchangeRedisSettings` from configuration using the `Aspire:StackExchange:Redis` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "StackExchange": {
      "Redis": {
        "ConnectionString": "localhost:6379",
        "DisableHealthChecks": false,
        "DisableTracing": false
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the delegate to set up options inline:

```csharp
builder.AddRedisClient(
    "cache",
    static settings => settings.DisableTracing = true);
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Redis integration adds a health check that verifies the Redis instance is reachable and can execute commands.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Redis integration uses the following log categories:

* `Aspire.StackExchange.Redis`

#### Tracing

[Section titled “Tracing”](#tracing)

The Redis integration will emit the following tracing activities using OpenTelemetry:

* `OpenTelemetry.Instrumentation.StackExchangeRedis`

#### Metrics

[Section titled “Metrics”](#metrics)

The Redis integration emits metrics using OpenTelemetry.

Registered trademark

Redis is a registered trademark of Redis Ltd. Any rights therein are reserved to Redis Ltd. Any use by Microsoft is for referential purposes only and does not indicate any sponsorship, endorsement or affiliation between Redis and Microsoft. :::

# Redis Distributed Caching

> Learn how to use the Redis distributed caching integration to register an IDistributedCache provider backed by Redis.

![Redis logo](/_astro/redis-icon.CxKuuAy2_Z1scdLi.webp)

The [Redis®](#registered-trademark) distributed caching integration is used to register an [IDistributedCache](https://learn.microsoft.com/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache) provider backed by a [Redis](https://redis.io/) server with the [`docker.io/library/redis` container image](https://hub.docker.com/_/redis/).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Redis hosting integration models a Redis resource as the `RedisResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Redis](https://www.nuget.org/packages/Aspire.Hosting.Redis) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Redis package

  ```bash
  aspire add redis
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > redis (Aspire.Hosting.Redis)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Redis package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Redis" Version="*" />
  ```

### Add Redis resource

[Section titled “Add Redis resource”](#add-redis-resource)

In your AppHost project, call `AddRedis` on the builder instance to add a Redis resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

When Aspire adds a container image to the AppHost, it creates a new Redis instance on your local machine.

Tip

If you’d rather connect to an existing Redis instance, call `AsExisting` instead.

### Add Redis resource with data volume

[Section titled “Add Redis resource with data volume”](#add-redis-resource-with-data-volume)

To add a data volume to the Redis resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataVolume(isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The data volume is used to persist the Redis data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Redis container.

### Add Redis resource with persistence

[Section titled “Add Redis resource with persistence”](#add-redis-resource-with-persistence)

To add persistence to the Redis resource, call the `WithPersistence` method with either the data volume or data bind mount:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataVolume()
                   .WithPersistence(
                       interval: TimeSpan.FromMinutes(5),
                       keysChangedThreshold: 100);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The preceding code adds persistence to the Redis resource by taking snapshots of the Redis data at a specified interval and threshold.

For more Redis hosting integration options, see the main [Redis integration](/integrations/caching/redis/) page.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Redis distributed caching integration, install the [📦 Aspire.StackExchange.Redis.DistributedCaching](https://www.nuget.org/packages/Aspire.StackExchange.Redis.DistributedCaching) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.StackExchange.Redis.DistributedCaching package

  ```bash
  dotnet add package Aspire.StackExchange.Redis.DistributedCaching
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.StackExchange.Redis.DistributedCaching@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.StackExchange.Redis.DistributedCaching package reference

  ```xml
  <PackageReference Include="Aspire.StackExchange.Redis.DistributedCaching" Version="*" />
  ```

### Add Redis distributed cache

[Section titled “Add Redis distributed cache”](#add-redis-distributed-cache)

In the `Program.cs` file of your client-consuming project, call the `AddRedisDistributedCache` extension to register the required services for distributed caching:

```csharp
builder.AddRedisDistributedCache(connectionName: "cache");
```

Tip

The `connectionName` parameter must match the name used when adding the Redis resource in the AppHost project.

You can then retrieve the `IDistributedCache` instance using dependency injection:

```csharp
public class ExampleService(IDistributedCache cache)
{
    // Use cache...
}
```

### Add keyed Redis distributed cache

[Section titled “Add keyed Redis distributed cache”](#add-keyed-redis-distributed-cache)

Due to its limitations, you cannot register multiple `IDistributedCache` instances simultaneously. However, there may be scenarios where you need to register multiple Redis clients. To register a keyed Redis client for `IDistributedCache`, call the `AddKeyedRedisDistributedCache` method:

```csharp
builder.AddKeyedRedisClient(name: "chat");
builder.AddKeyedRedisDistributedCache(name: "product");
```

Then retrieve the instances:

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] IConnectionMultiplexer chatConnectionMux,
    IDistributedCache productCache)
{
    // Use product cache...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section:

```csharp
builder.AddRedisDistributedCache("cache");
```

Then the connection string will be retrieved:

```json
{
  "ConnectionStrings": {
    "cache": "localhost:6379"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Redis distributed caching integration supports `Microsoft.Extensions.Configuration`. Example `appsettings.json`:

```json
{
  "Aspire": {
    "StackExchange": {
      "Redis": {
        "DistributedCaching": {
          "ConnectionString": "localhost:6379",
          "DisableHealthChecks": false,
          "DisableTracing": false
        }
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the delegate to set up options inline:

```csharp
builder.AddRedisDistributedCache(
    "cache",
    settings => settings.DisableTracing = true);
```

You can also configure the [ConfigurationOptions](https://stackexchange.github.io/StackExchange.Redis/Configuration.html#configuration-options):

```csharp
builder.AddRedisDistributedCache(
    "cache",
    null,
    static options => options.ConnectTimeout = 3_000);
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks. The Redis distributed caching integration adds a health check that verifies the Redis instance is reachable.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Redis distributed caching integration uses standard .NET logging.

#### Tracing

[Section titled “Tracing”](#tracing)

The integration emits tracing activities using OpenTelemetry.

#### Metrics

[Section titled “Metrics”](#metrics)

The integration emits metrics using OpenTelemetry.

Registered trademark

Redis is a registered trademark of Redis Ltd. Any rights therein are reserved to Redis Ltd. Any use by Microsoft is for referential purposes only and does not indicate any sponsorship, endorsement or affiliation between Redis and Microsoft. :::

# Redis hosting extensions

⭐ Community Toolkit ![Redis logo](/_astro/redis-icon.CxKuuAy2_Z1scdLi.webp)

The Aspire Community Toolkit Redis hosting extensions package provides extra functionality to the [Aspire.Hosting.Redis](https://www.nuget.org/packages/Aspire.Hosting.Redis) hosting package.

This package provides the following features:

* [DbGate](https://dbgate.org/) management UI

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Community Toolkit Redis hosting extensions, install the [CommunityToolkit.Aspire.Hosting.Redis.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Redis.Extensions) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Redis.Extensions package

  ```bash
  aspire add communitytoolkit-redis-extensions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-redis-extensions (CommunityToolkit.Aspire.Hosting.Redis.Extensions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Redis.Extensions@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Redis.Extensions package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Redis.Extensions" Version="*" />
  ```

## Add management UI

[Section titled “Add management UI”](#add-management-ui)

### DbGate management UI

[Section titled “DbGate management UI”](#dbgate-management-ui)

To add the DbGate management UI to your Redis resource, call the `WithDbGate` method on the `RedisResource` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis("redis")
                   .WithDbGate();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(redis);


// After adding all resources, run the app...
```

This adds a new DbGate resource to the app host which is available from the Aspire dashboard. DbGate is a comprehensive database management tool that provides a web-based interface for managing your Redis databases.

## See also

[Section titled “See also”](#see-also)

* [DbGate documentation](https://dbgate.org/)
* [Redis integration](/integrations/caching/redis/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Redis Output Caching

> Learn how to use the Redis output caching integration to register an ASP.NET Core Output Caching provider backed by Redis.

![Redis logo](/_astro/redis-icon.CxKuuAy2_Z1scdLi.webp)

The [Redis®](#registered-trademark) output caching integration is used to register an [ASP.NET Core Output Caching](https://learn.microsoft.com/aspnet/core/performance/caching/output) provider backed by a [Redis](https://redis.io/) server with the [`docker.io/library/redis` container image](https://hub.docker.com/_/redis/).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Redis hosting integration models a Redis resource as the `RedisResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Redis](https://www.nuget.org/packages/Aspire.Hosting.Redis) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Redis package

  ```bash
  aspire add redis
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > redis (Aspire.Hosting.Redis)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Redis package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Redis" Version="*" />
  ```

### Add Redis resource

[Section titled “Add Redis resource”](#add-redis-resource)

In your AppHost project, call `AddRedis` on the builder instance to add a Redis resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

When Aspire adds a container image to the AppHost, it creates a new Redis instance on your local machine.

Tip

If you’d rather connect to an existing Redis instance, call `AsExisting` instead.

### Add Redis resource with data volume

[Section titled “Add Redis resource with data volume”](#add-redis-resource-with-data-volume)

To add a data volume to the Redis resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataVolume(isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The data volume is used to persist the Redis data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Redis container.

### Add Redis resource with persistence

[Section titled “Add Redis resource with persistence”](#add-redis-resource-with-persistence)

To add persistence to the Redis resource, call the `WithPersistence` method with either the data volume or data bind mount:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithDataVolume()
                   .WithPersistence(
                       interval: TimeSpan.FromMinutes(5),
                       keysChangedThreshold: 100);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The preceding code adds persistence to the Redis resource by taking snapshots of the Redis data at a specified interval and threshold.

For more Redis hosting integration options, see the main [Redis integration](/integrations/caching/redis/) page.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Redis output caching integration, install the [📦 Aspire.StackExchange.Redis.OutputCaching](https://www.nuget.org/packages/Aspire.StackExchange.Redis.OutputCaching) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.StackExchange.Redis.OutputCaching package

  ```bash
  dotnet add package Aspire.StackExchange.Redis.OutputCaching
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.StackExchange.Redis.OutputCaching@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.StackExchange.Redis.OutputCaching package reference

  ```xml
  <PackageReference Include="Aspire.StackExchange.Redis.OutputCaching" Version="*" />
  ```

### Add output caching

[Section titled “Add output caching”](#add-output-caching)

In the `Program.cs` file of your client-consuming project, call the `AddRedisOutputCache` extension method to register the required services for output caching:

```csharp
builder.AddRedisOutputCache(connectionName: "cache");
```

Tip

The `connectionName` parameter must match the name used when adding the Redis resource in the AppHost project.

Add the middleware to the request processing pipeline by calling `UseOutputCache`:

```csharp
var app = builder.Build();


app.UseOutputCache();
```

For minimal API apps, configure an endpoint to do caching by calling `CacheOutput`, or by applying the `OutputCacheAttribute`:

```csharp
app.MapGet("/cached", () => "Hello world!")
   .CacheOutput();


app.MapGet(
    "/attribute",
    [OutputCache] () => "Hello world!");
```

For apps with controllers, apply the `[OutputCache]` attribute to the action method. For Razor Pages apps, apply the attribute to the Razor page class.

### Configuration

[Section titled “Configuration”](#configuration)

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section:

```csharp
builder.AddRedisOutputCache(connectionName: "cache");
```

Then the connection string will be retrieved:

```json
{
  "ConnectionStrings": {
    "cache": "localhost:6379"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Redis output caching integration supports `Microsoft.Extensions.Configuration`. Example `appsettings.json`:

```json
{
  "Aspire": {
    "StackExchange": {
      "Redis": {
        "OutputCaching": {
          "ConnectionString": "localhost:6379",
          "DisableHealthChecks": false,
          "DisableTracing": false
        }
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the delegate to set up options inline:

```csharp
builder.AddRedisOutputCache(
    "cache",
    static settings => settings.DisableHealthChecks = true);
```

You can also configure the [ConfigurationOptions](https://stackexchange.github.io/StackExchange.Redis/Configuration.html#configuration-options):

```csharp
builder.AddRedisOutputCache(
    "cache",
    static settings => settings.ConnectTimeout = 3_000);
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks. The Redis output caching integration adds a health check that verifies the Redis instance is reachable.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Redis output caching integration uses standard .NET logging.

#### Tracing

[Section titled “Tracing”](#tracing)

The integration emits tracing activities using OpenTelemetry.

#### Metrics

[Section titled “Metrics”](#metrics)

The integration emits metrics using OpenTelemetry.

Registered trademark

Redis is a registered trademark of Redis Ltd. Any rights therein are reserved to Redis Ltd. Any use by Microsoft is for referential purposes only and does not indicate any sponsorship, endorsement or affiliation between Redis and Microsoft. :::

# Valkey integration

> Learn how to use the Valkey integration, a Redis fork that is a high-performance key/value datastore.

![Valkey logo](/_astro/valkey-icon.BdkvDMZ6_ZefUx.webp)

[Valkey](https://valkey.io/) is a Redis fork and complies with the Redis serialization protocol (RESP). It’s a high-performance key/value datastore that supports a variety of workloads such as caching, message queues, and can act as a primary database. The Valkey integration enables you to connect to existing Valkey instances, or create new instances from Aspire with the `docker.io/valkey/valkey` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Valkey hosting integration models a Valkey resource as the `ValkeyResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Valkey](https://www.nuget.org/packages/Aspire.Hosting.Valkey) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Valkey package

  ```bash
  aspire add valkey
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > valkey (Aspire.Hosting.Valkey)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Valkey@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Valkey package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Valkey" Version="*" />
  ```

### Add Valkey resource

[Section titled “Add Valkey resource”](#add-valkey-resource)

In your AppHost project, call `AddValkey` on the builder instance to add a Valkey resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddValkey("cache");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

When Aspire adds a container image to the AppHost, it creates a new Valkey instance on your local machine.

Tip

If you’d rather connect to an existing Valkey instance, call `AsExisting` instead.

### Add Valkey resource with data volume

[Section titled “Add Valkey resource with data volume”](#add-valkey-resource-with-data-volume)

To add a data volume to the Valkey resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddValkey("cache")
                   .WithDataVolume(isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The data volume is used to persist the Valkey data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Valkey container.

### Add Valkey resource with data bind mount

[Section titled “Add Valkey resource with data bind mount”](#add-valkey-resource-with-data-bind-mount)

To add a data bind mount to the Valkey resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddValkey("cache")
                   .WithDataBindMount(
                       source: @"C:\Valkey\Data",
                       isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

### Add Valkey resource with persistence

[Section titled “Add Valkey resource with persistence”](#add-valkey-resource-with-persistence)

To add persistence to the Valkey resource, call the `WithPersistence` method with either the data volume or data bind mount:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddValkey("cache")
                   .WithDataVolume()
                   .WithPersistence(
                       interval: TimeSpan.FromMinutes(5),
                       keysChangedThreshold: 100);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(cache);
```

The preceding code adds persistence to the Valkey resource by taking snapshots of the data at a specified interval and threshold.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a Valkey resource using `WithReference`, the following connection properties are made available to the consuming project:

#### Valkey

[Section titled “Valkey”](#valkey)

The Valkey resource exposes the following connection properties:

| Property Name | Description                                                              |
| ------------- | ------------------------------------------------------------------------ |
| `Host`        | The hostname or IP address of the Valkey server                          |
| `Port`        | The port number the Valkey server is listening on                        |
| `Password`    | The password for authentication                                          |
| `Uri`         | The connection URI, with the format `valkey://:{Password}@{Host}:{Port}` |

**Example connection string:**

```plaintext
Uri: valkey://:p%40ssw0rd1@localhost:6379
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `cache` becomes `CACHE_URI`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Valkey hosting integration automatically adds a health check for the Valkey resource. The health check verifies that the Valkey instance is running and that a connection can be established to it.

## Client integration

[Section titled “Client integration”](#client-integration)

Valkey is Redis-compatible, so you use the same Redis client packages. To get started, install the [📦 Aspire.StackExchange.Redis](https://www.nuget.org/packages/Aspire.StackExchange.Redis) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.StackExchange.Redis package

  ```bash
  dotnet add package Aspire.StackExchange.Redis
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.StackExchange.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.StackExchange.Redis package reference

  ```xml
  <PackageReference Include="Aspire.StackExchange.Redis" Version="*" />
  ```

### Add Valkey client

[Section titled “Add Valkey client”](#add-valkey-client)

In the `Program.cs` file of your client-consuming project, call the `AddRedisClient` extension method to register an `IConnectionMultiplexer`:

```csharp
builder.AddRedisClient(connectionName: "cache");
```

Tip

The `connectionName` parameter must match the name used when adding the Valkey resource in the AppHost project.

You can then retrieve the `IConnectionMultiplexer` instance using dependency injection:

```csharp
public class ExampleService(IConnectionMultiplexer connectionMux)
{
    // Use connection multiplexer...
}
```

### Configuration and other client features

[Section titled “Configuration and other client features”](#configuration-and-other-client-features)

Since Valkey is Redis-compatible, all Redis client configuration, keyed services, health checks, and observability features work the same way. See the [Redis integration](/integrations/caching/redis/) page for complete client integration documentation.

### Distributed caching and output caching

[Section titled “Distributed caching and output caching”](#distributed-caching-and-output-caching)

Valkey also supports Redis distributed caching and output caching. Install the respective packages:

* For distributed caching: [📦 Aspire.StackExchange.Redis.DistributedCaching](https://www.nuget.org/packages/Aspire.StackExchange.Redis.DistributedCaching)
* For output caching: [📦 Aspire.StackExchange.Redis.OutputCaching](https://www.nuget.org/packages/Aspire.StackExchange.Redis.OutputCaching)

See [Redis Distributed Caching](/integrations/caching/redis-distributed/) and [Redis Output Caching](/integrations/caching/redis-output/) for usage details.

# AI integrations compatibility matrix

> View the compatibility matrix for Aspire AI integrations including Azure OpenAI, Azure AI Inference, and IChatClient support.

Aspire provides several AI hosting and client integrations that enable you to work with different AI services and platforms. This article provides a compatibility matrix showing which client integrations work with which hosting integrations, along with guidance on the recommended pairings.

## Compatibility matrix

[Section titled “Compatibility matrix”](#compatibility-matrix)

The following table shows the compatibility between Aspire AI hosting and client integrations:

| **Hosting Integration**                  | **Aspire.OpenAI** | **Aspire.Azure.AI.OpenAI** | **Aspire.Azure.AI.Inference** |
| ---------------------------------------- | ----------------- | -------------------------- | ----------------------------- |
| `Aspire.Hosting.Azure.AIFoundry`         | ❌ No              | ⚠️ Partial                 | ✅ Yes (preferred)             |
| `Aspire.Hosting.Azure.CognitiveServices` | ❌ No              | ✅ Yes (preferred)          | ❌ No                          |
| `Aspire.Hosting.OpenAI`                  | ✅ Yes (preferred) | ✅ Yes                      | ❌ No                          |
| `Aspire.Hosting.GitHub.Models`           | ⚠️ Partial        | ❌ No                       | ✅ Yes (preferred)             |

Legend

* ✅ **Yes**: The client integration is compatible with the hosting integration.
* ⚠️ **Partial**: The client integration might not support all models or APIs.
* ❌ **No**: The client integration does not support the hosting environment.
* **(preferred)**: The recommended client integration for this hosting integration.

## Recommended pairings

[Section titled “Recommended pairings”](#recommended-pairings)

In general, use **Aspire.Azure.AI.Inference** to connect to Azure hosted models, or **Aspire.OpenAI** to connect directly to OpenAI.

### Azure AI Foundry

[Section titled “Azure AI Foundry”](#azure-ai-foundry)

For Azure AI Foundry resources, use the **Aspire.Azure.AI.Inference** client integration. This provides the best compatibility with the diverse range of models available through Azure AI Foundry. For more information, see [Azure AI Foundry integration](/integrations/cloud/azure/azure-ai-foundry/).

#### Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The [Aspire.Hosting.Azure.AIFoundry](https://www.nuget.org/packages/Aspire.Hosting.Azure.AIFoundry) package provides the hosting integration. In your app host project:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var foundry = builder.AddAzureAIFoundry("foundry");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(foundry);
```

#### Client integration

[Section titled “Client integration”](#client-integration)

The [Aspire.Azure.AI.Inference](https://www.nuget.org/packages/Aspire.Azure.AI.Inference) package provides the client integration. In your service project:

C# — AppHost.cs

```csharp
builder.AddAzureChatCompletionsClient("foundry");
```

### Azure Cognitive Services (Azure OpenAI)

[Section titled “Azure Cognitive Services (Azure OpenAI)”](#azure-cognitive-services-azure-openai)

For Azure OpenAI resources, use the **Aspire.Azure.AI.OpenAI** client integration for full Azure-specific features and authentication support. For more information, see [Azure OpenAI integration](/integrations/cloud/azure/azure-openai/).

#### Hosting integration

[Section titled “Hosting integration”](#hosting-integration-1)

The [Aspire.Hosting.Azure.CognitiveServices](https://www.nuget.org/packages/Aspire.Hosting.Azure.CognitiveServices) package provides the hosting integration. In your app host project:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddAzureOpenAI("openai");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(openai);
```

#### Client integration

[Section titled “Client integration”](#client-integration-1)

The [Aspire.Azure.AI.OpenAI](https://www.nuget.org/packages/Aspire.Azure.AI.OpenAI) package provides the client integration. In your service project:

C# — AppHost.cs

```csharp
builder.AddAzureOpenAIClient("openai");
```

### Direct OpenAI

[Section titled “Direct OpenAI”](#direct-openai)

For direct OpenAI API access, use the **Aspire.OpenAI** client integration. For more information, see [Aspire OpenAI integration (Preview)](/integrations/ai/openai/).

#### Hosting integration

[Section titled “Hosting integration”](#hosting-integration-2)

The [Aspire.Hosting.OpenAI](https://www.nuget.org/packages/Aspire.Hosting.OpenAI) package provides the hosting integration. In your app host project:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddOpenAI("openai");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(openai);
```

#### Client integration

[Section titled “Client integration”](#client-integration-2)

The [Aspire.OpenAI](https://www.nuget.org/packages/Aspire.OpenAI) package provides the client integration. In your service project:

C# — AppHost.cs

```csharp
builder.AddOpenAIClient("openai");
```

### GitHub Models

[Section titled “GitHub Models”](#github-models)

For GitHub Models, use the **Aspire.Azure.AI.Inference** client integration for the best compatibility with the GitHub Models API. For more information, see [Aspire GitHub Models integration (Preview)](/integrations/ai/github-models/).

#### Hosting integration

[Section titled “Hosting integration”](#hosting-integration-3)

The [Aspire.Hosting.GitHub.Models](https://www.nuget.org/packages/Aspire.Hosting.GitHub.Models) package provides the hosting integration. In your app host project:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var chat = builder.AddGitHubModel("chat", "openai/gpt-4o-mini");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(chat);
```

#### Client integration

[Section titled “Client integration”](#client-integration-3)

The [Aspire.Azure.AI.Inference](https://www.nuget.org/packages/Aspire.Azure.AI.Inference) package provides the client integration. In your service project:

C# — AppHost.cs

```csharp
builder.AddAzureChatCompletionsClient("chat");
```

## Connection string formats

[Section titled “Connection string formats”](#connection-string-formats)

Understanding how hosting and client integrations communicate through connection strings can help you troubleshoot connectivity issues and understand the underlying mechanics.

Each hosting integration generates connection strings in different formats that are consumed by the client integrations.

### Hosting integration connection strings

[Section titled “Hosting integration connection strings”](#hosting-integration-connection-strings)

#### Aspire.Hosting.Azure.AIFoundry

[Section titled “Aspire.Hosting.Azure.AIFoundry”](#aspirehostingazureaifoundry)

**Azure:**

```plaintext
Endpoint={Endpoint};EndpointAIInference={AIFoundryApiEndpoint}models
```

**Foundry local:**

```plaintext
Endpoint={EmulatorServiceUri};Key={ApiKey}
```

**Deployment:**

```plaintext
{Parent};Deployment={DeploymentName}
```

#### Aspire.Hosting.Azure.CognitiveServices

[Section titled “Aspire.Hosting.Azure.CognitiveServices”](#aspirehostingazurecognitiveservices)

**Deployment:**

```plaintext
{ConnectionString};Deployment={DeploymentName}
```

#### Aspire.Hosting.OpenAI

[Section titled “Aspire.Hosting.OpenAI”](#aspirehostingopenai)

```plaintext
Endpoint={Endpoint};Key={Key};Model={Model}
```

#### Aspire.Hosting.GitHub.Models

[Section titled “Aspire.Hosting.GitHub.Models”](#aspirehostinggithubmodels)

```plaintext
Endpoint=https://models.github.ai/inference;Key={Key};Model={ModelName}
```

### Client integration connection string requirements

[Section titled “Client integration connection string requirements”](#client-integration-connection-string-requirements)

#### Aspire.OpenAI

[Section titled “Aspire.OpenAI”](#aspireopenai)

Expects connection strings in the format:

```plaintext
Endpoint={Endpoint};Key={Key};Deployment={Deployment};Model={Model}
```

Uses either `Deployment` or `Model` (in that order). `Deployment` is set by `Aspire.Hosting.Azure.CognitiveServices` while `Model` is set by `Aspire.Hosting.OpenAI`.

#### Aspire.Azure.AI.OpenAI

[Section titled “Aspire.Azure.AI.OpenAI”](#aspireazureaiopenai)

Expects connection strings in the format:

```plaintext
Endpoint={Endpoint};Key={Key};Deployment={Deployment};Model={Model}
```

Uses either `Deployment` or `Model` (in that order). `Deployment` is set by `Aspire.Hosting.Azure.CognitiveServices` while `Model` is set by `Aspire.Hosting.OpenAI`.

This integration is a superset of `Aspire.OpenAI` and supports `TokenCredential` and Azure-specific features.

#### Aspire.Azure.AI.Inference

[Section titled “Aspire.Azure.AI.Inference”](#aspireazureaiinference)

Expects connection strings in the format:

```plaintext
Endpoint={Endpoint};EndpointAIInference={EndpointAIInference};Key={Key};Deployment={DeploymentName};Model={ModelName}
```

Uses either `Deployment` or `Model` (in that order). `Deployment` is set by `Aspire.Hosting.Azure.CognitiveServices` while `Model` is set by `Aspire.Hosting.GitHub.Models`.

Uses `EndpointAIInference` if available, otherwise `Endpoint`.

## See also

[Section titled “See also”](#see-also)

* [Azure OpenAI integration](/integrations/cloud/azure/azure-openai/)
* [Azure AI Inference integration](/integrations/cloud/azure/azure-ai-inference/)
* [Azure AI Foundry integration](/integrations/cloud/azure/azure-ai-foundry/)
* [Azure AI Search integration](/integrations/cloud/azure/azure-ai-search/)
* [Microsoft.Extensions.AI documentation](https://learn.microsoft.com/dotnet/ai/ai-extensions)

# Azure AI Foundry integration

> This article describes the Aspire Azure AI Foundry integration features and capabilities.

![Azure AI Foundry logo](/_astro/azure-ai-foundry-icon.0G-oiuDs_ZWHnhf.webp) 🧪 Preview

[Azure AI Foundry](https://learn.microsoft.com/ai-studio) provides a unified platform for developing, testing, and deploying AI applications. The Aspire Azure AI Foundry integration enables you to connect to Azure AI Foundry services from your applications, providing access to various AI capabilities including model deployments, prompt flow, and more.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure AI Foundry hosting integration models the AI Foundry project as the `AzureAIFoundryResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.AIFoundry](https://www.nuget.org/packages/Aspire.Hosting.Azure.AIFoundry) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.AIFoundry package

  ```bash
  aspire add azure-aifoundry
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-aifoundry (Aspire.Hosting.Azure.AIFoundry)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.AIFoundry@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.AIFoundry package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.AIFoundry" Version="*" />
  ```

### Add an Azure AI Foundry resource

[Section titled “Add an Azure AI Foundry resource”](#add-an-azure-ai-foundry-resource)

To add an Azure AI Foundry resource to your AppHost project, call the `AddAzureAIFoundry` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var foundry = builder.AddAzureAIFoundry("foundry");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(foundry);


// After adding all resources, run the app...
```

The preceding code adds an Azure AI Foundry resource named `foundry` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleProject` project.

Caution

When you call `AddAzureAIFoundry`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Add an Azure AI Foundry deployment resource

[Section titled “Add an Azure AI Foundry deployment resource”](#add-an-azure-ai-foundry-deployment-resource)

To add an Azure AI Foundry deployment resource, call the `AddDeployment` method:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var foundry = builder.AddAzureAIFoundry("foundry");


var chat = foundry.AddDeployment("chat", "Phi-4", "1", "Microsoft");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(chat)
    .WaitFor(chat);


// After adding all resources, run the app...
```

The preceding code:

* Adds an Azure AI Foundry resource named `foundry`.
* Adds an Azure AI Foundry deployment resource named `chat` with a model name of `Phi-4`. The model name must correspond to an [available model](https://learn.microsoft.com/azure/ai-foundry/foundry-models/concepts/models) in the Azure AI Foundry service.

Note

The `format` parameter of the `AddDeployment(...)` method specifies the model publisher or provider. Common values include:

* `"OpenAI"` for GPT models (e.g., GPT-4o, GPT-4, GPT-3.5 Turbo)
* `"Microsoft"` for Phi models (e.g., Phi-4, Phi-3.5)

For more information, see the [AIFoundryModel API reference](https://learn.microsoft.com/dotnet/api/aspire.hosting.azure.aifoundrymodel).

### Configure deployment properties

[Section titled “Configure deployment properties”](#configure-deployment-properties)

You can customize deployment properties using the `WithProperties` method:

```csharp
var chat = foundry.AddDeployment("chat", "Phi-4", "1", "Microsoft")
    .WithProperties(deployment =>
    {
        deployment.SkuName = "Standard";
        deployment.SkuCapacity = 10;
    });
```

The preceding code sets the SKU name to `Standard` and capacity to `10` for the deployment.

### Connect to an existing Azure AI Foundry service

[Section titled “Connect to an existing Azure AI Foundry service”](#connect-to-an-existing-azure-ai-foundry-service)

You might have an existing Azure AI Foundry service that you want to connect to. You can chain a call to annotate that your `AzureAIFoundryResource` is an existing resource:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingFoundryName = builder.AddParameter("existingFoundryName");
var existingFoundryResourceGroup = builder.AddParameter("existingFoundryResourceGroup");


var foundry = builder.AddAzureAIFoundry("foundry")
    .AsExisting(existingFoundryName, existingFoundryResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(foundry);


// After adding all resources, run the app...
```

Caution

When you call `RunAsExisting`, `PublishAsExisting`, or `AsExisting` methods to work with resources that are already present in your Azure subscription, you must add certain configuration values to your AppHost to ensure that Aspire can locate them. The necessary configuration values include **SubscriptionId**, **AllowResourceGroupCreation**, **ResourceGroup**, and **Location**. If you don’t set them, “Missing configuration” errors appear in the Aspire dashboard. For more information about how to set them, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

### Use Foundry Local for development

[Section titled “Use Foundry Local for development”](#use-foundry-local-for-development)

Aspire supports the usage of Foundry Local for local development. Add the following to your AppHost project:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var foundry = builder.AddAzureAIFoundry("foundry")
    .RunAsFoundryLocal();


var chat = foundry.AddDeployment("chat", "phi-3.5-mini", "1", "Microsoft");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(chat)
    .WaitFor(chat);


// After adding all resources, run the app...
```

When the AppHost starts up, the local foundry service is also started. This requires the local machine to have [Foundry Local](https://learn.microsoft.com/azure/ai-foundry/foundry-local/get-started) installed and running.

The `RunAsFoundryLocal` method configures the resource to run as an emulator. It downloads and loads the specified models locally. The method provides health checks for the local service and automatically manages the Foundry Local lifecycle.

### Assign roles to resources

[Section titled “Assign roles to resources”](#assign-roles-to-resources)

You can assign specific roles to resources that need to access the Azure AI Foundry service. Use the `WithRoleAssignments` method:

C# — AppHost.cs

```csharp
var foundry = builder.AddAzureAIFoundry("chat");


builder.AddProject<Projects.Api>("api")
  .WithRoleAssignments(foundry, CognitiveServicesBuiltInRole.CognitiveServicesUser)
  .WithReference(foundry);
```

The preceding code assigns the `CognitiveServicesUser` role to the `api` project, granting it the necessary permissions to access the Azure AI Foundry resource.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep provisions an Azure AI Foundry resource with standard defaults.

Generated Bicep — ai-foundry.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource ai_foundry 'Microsoft.CognitiveServices/accounts@2024-10-01' = {
  name: take('aifoundry-${uniqueString(resourceGroup().id)}', 64)
  location: location
  identity: {
    type: 'SystemAssigned'
  }
  kind: 'AIServices'
  properties: {
    customSubDomainName: toLower(take(concat('ai-foundry', uniqueString(resourceGroup().id)), 24))
    publicNetworkAccess: 'Enabled'
    disableLocalAuth: true
  }
  sku: {
    name: 'S0'
  }
  tags: {
    'aspire-resource-name': 'ai-foundry'
  }
}


resource chat 'Microsoft.CognitiveServices/accounts/deployments@2024-10-01' = {
  name: 'Phi-4'
  properties: {
    model: {
      format: 'Microsoft'
      name: 'Phi-4'
      version: '1'
    }
  }
  sku: {
    name: 'GlobalStandard'
    capacity: 1
  }
  parent: ai_foundry
}


output aiFoundryApiEndpoint string = ai_foundry.properties.endpoints['AI Foundry API']


output endpoint string = ai_foundry.properties.endpoint


output name string = ai_foundry.name
```

The preceding Bicep is a module that provisions an Azure Cognitive Services resource configured for AI Services. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — ai-foundry-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param ai_foundry_outputs_name string


param principalType string


param principalId string


resource ai_foundry 'Microsoft.CognitiveServices/accounts@2024-10-01' existing = {
  name: ai_foundry_outputs_name
}


resource ai_foundry_CognitiveServicesUser 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(ai_foundry.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'a97b65f3-24c7-4388-baec-2e87135dc908'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'a97b65f3-24c7-4388-baec-2e87135dc908')
    principalType: principalType
  }
  scope: ai_foundry
}


resource ai_foundry_CognitiveServicesOpenAIUser 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(ai_foundry.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '5e0bd9bd-7b93-4f28-af87-19fc36ad61bd'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '5e0bd9bd-7b93-4f28-af87-19fc36ad61bd')
    principalType: principalType
  }
  scope: ai_foundry
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they’re reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This enables customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
builder.AddAzureAIFoundry("foundry")
  .ConfigureInfrastructure(infra =>
  {
      var resources = infra.GetProvisionableResources();
      var account = resources.OfType<CognitiveServicesAccount>().Single();


      account.Sku = new CognitiveServicesSku
      {
          Tier = CognitiveServicesSkuTier.Enterprise,
          Name = "E0"
      };
      account.Tags.Add("ExampleKey", "Example value");
  });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `CognitiveServicesAccount` resource is retrieved.
  * The `Sku` property is assigned to a new instance of `CognitiveServicesSku` with an `E0` name and `Enterprise` tier.
  * A tag is added to the Cognitive Services resource with a key of `ExampleKey` and a value of `Example value`.

## Client integration

[Section titled “Client integration”](#client-integration)

The client integration for Azure AI Foundry is the [Azure AI Inference](/integrations/cloud/azure/azure-ai-inference/) integration.

# Azure AI Inference integration

> This article describes the Aspire Azure AI Inference integration features and capabilities.

![Azure AI Inference logo](/_astro/azure-ai-foundry-icon.0G-oiuDs_ZWHnhf.webp) 🧪 Preview

[Azure AI Inference](https://learn.microsoft.com/azure/ai-foundry/how-to/deploy-models-serverless?view=foundry-classic) provides serverless API endpoints for deploying and using AI models. The Aspire Azure AI Inference integration enables you to connect to Azure AI Inference services from your applications, making it easy to call models for chat, completions, embeddings, and more.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

Although the Azure AI Inference library doesn’t currently offer direct hosting integration, you can still integrate it into your AppHost project. Simply add a connection string to establish a reference to an existing Azure AI Foundry resource.

### Connect to an existing Azure AI Foundry service

[Section titled “Connect to an existing Azure AI Foundry service”](#connect-to-an-existing-azure-ai-foundry-service)

If you already have an [Azure AI Foundry](https://ai.azure.com/) service, you can easily connect to it by adding a connection string to your AppHost. This approach uses a simple, string-based configuration. To establish the connection, use the `AddConnectionString` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var aiFoundry = builder.AddConnectionString("ai-foundry");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(aiFoundry);


// After adding all resources, run the app...
```

Note

Connection strings are used to represent a wide range of connection information, including database connections, message brokers, endpoint URIs, and other services. In nomenclature, the term “connection string” is used to represent any kind of connection information.

The connection string is configured in the AppHost’s configuration, typically under User Secrets, under the `ConnectionStrings` section:

```json
{
  "ConnectionStrings": {
    "ai-foundry": "Endpoint=https://{endpoint}/;DeploymentId={deploymentName}"
  }
}
```

For more information, see [Add existing Azure resources with connection strings](/integrations/cloud/azure/overview/#add-existing-azure-resources-with-connection-strings).

## Client integration

[Section titled “Client integration”](#client-integration)

Two kinds of clients are available in the Aspire Azure AI Inference integration:

* `ChatCompletionsClient`: A client for interacting with a chat completions model.
  * `IChatClient`: An abstraction for chat clients from `Microsoft.Extensions.AI`.
* `EmbeddingsClient`: A client for interacting with a text embeddings model.
  * `IEmbeddingGenerator`: An abstraction for embeddings clients from `Microsoft.Extensions.AI`.

The Aspire Azure AI Inference client integration is used to work with Azure AI models using the `IChatClient` or `IEmbeddingGenerator` abstraction from `Microsoft.Extensions.AI`. To get started, install the [📦 Aspire.Azure.AI.Inference](https://www.nuget.org/packages/Aspire.Azure.AI.Inference) NuGet package.

* .NET CLI

  .NET CLI — Add Aspire.Azure.AI.Inference package

  ```bash
  dotnet add package Aspire.Azure.AI.Inference
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.AI.Inference@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.AI.Inference package reference

  ```xml
  <PackageReference Include="Aspire.Azure.AI.Inference" Version="*" />
  ```

Caution

Check the model inference tasks for both clients. Some models may only support chat completions, while others may only support embeddings. Ensure that the model you choose aligns with the client you intend to use. This information is available in the [model catalog](https://ai.azure.com/resource/models/) and in the Quick facts section of each model’s details page.

### Add an Azure AI Inference Chat Completions client

[Section titled “Add an Azure AI Inference Chat Completions client”](#add-an-azure-ai-inference-chat-completions-client)

In the *Program.cs* file of your client-consuming project, use the `AddAzureChatCompletionsClient` method on any `IHostApplicationBuilder` to register a `ChatCompletionsClient` for dependency injection (DI).

```csharp
builder.AddAzureChatCompletionsClient(connectionName: "ai-foundry");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure AI Inference resource in the AppHost project. For more information, see [Connect to an existing Azure AI Foundry service](#connect-to-an-existing-azure-ai-foundry-service).

After adding the `ChatCompletionsClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(ChatCompletionsClient client)
{
    // Use client...
}
```

For more information, see:

* [What is Azure AI model inference?](https://learn.microsoft.com/azure/ai-foundry/foundry-models/supported-languages?view=foundry-classic) for details on Azure AI model inference.
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.
* [The Azure AI Foundry SDK: C#](https://learn.microsoft.com/azure/ai-foundry/how-to/develop/sdk-overview?tabs=sync\&pivots=programming-language-csharp).

### Add Azure AI Inference Chat Completions client with registered `IChatClient`

[Section titled “Add Azure AI Inference Chat Completions client with registered IChatClient”](#add-azure-ai-inference-chat-completions-client-with-registered-ichatclient)

If you’re interested in using the `IChatClient` interface with the Azure AI Inference client, simply chain either of the following APIs to the `AddAzureChatCompletionsClient` method:

* `AddChatClient`: Registers a singleton `IChatClient` in the services.
* `AddKeyedChatClient`: Registers a keyed singleton `IChatClient` in the services.

For example, consider the following C# code that adds an `IChatClient` to the DI container:

```csharp
builder.AddAzureChatCompletionsClient(connectionName: "ai-foundry")
    .AddChatClient("deploymentName");
```

Similarly, you can add a keyed `IChatClient` with the following C# code:

```csharp
builder.AddAzureChatCompletionsClient(connectionName: "ai-foundry")
    .AddKeyedChatClient("serviceKey", "deploymentName");
```

After adding the `IChatClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(IChatClient chatClient)
{
    public async Task<string> GetResponseAsync(string userMessage)
    {
        var response = await chatClient.CompleteAsync(userMessage);
        return response.Message.Text ?? string.Empty;
    }
}
```

For more information on the `IChatClient` and its corresponding library, see [Artificial intelligence in .NET](https://learn.microsoft.com/dotnet/ai/microsoft-extensions-ai).

### Add keyed Azure AI Inference Chat Completions clients

[Section titled “Add keyed Azure AI Inference Chat Completions clients”](#add-keyed-azure-ai-inference-chat-completions-clients)

There might be situations where you want to register multiple `ChatCompletionsClient` instances with different connection names. To register keyed Azure AI Inference clients, call the `AddKeyedAzureChatCompletionsClient` method:

```csharp
builder.AddKeyedAzureChatCompletionsClient(name: "chat");
builder.AddKeyedAzureChatCompletionsClient(name: "code");
```

Caution

When using keyed services, ensure that your Azure AI Inference resource configures two named connections, one for `chat` and one for `code`.

Then you can retrieve the client instances using dependency injection. For example, to retrieve the clients from a service:

```csharp
public class ExampleService(
    [KeyedService("chat")] ChatCompletionsClient chatClient,
    [KeyedService("code")] ChatCompletionsClient codeClient)
{
    // Use clients...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Add an Azure AI Inference Embeddings client

[Section titled “Add an Azure AI Inference Embeddings client”](#add-an-azure-ai-inference-embeddings-client)

In the *Program.cs* file of your client-consuming project, use the `AddAzureEmbeddingsClient` method on any `IHostApplicationBuilder` to register an `EmbeddingsClient` for dependency injection (DI).

```csharp
builder.AddAzureEmbeddingsClient(connectionName: "ai-foundry");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure AI Inference resource in the AppHost project. For more information, see [Connect to an existing Azure AI Foundry service](#connect-to-an-existing-azure-ai-foundry-service).

After adding the `EmbeddingsClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(EmbeddingsClient client)
{
    // Use client...
}
```

For more information, see:

* [What is Azure AI model inference?](https://learn.microsoft.com/azure/ai-foundry/foundry-models/supported-languages?view=foundry-classic) for details on Azure AI model inference.
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.
* [The Azure AI Foundry SDK: C#](https://learn.microsoft.com/azure/ai-foundry/how-to/develop/sdk-overview?tabs=sync\&pivots=programming-language-csharp).

### Add Azure AI Inference Embeddings client with registered `IEmbeddingGenerator`

[Section titled “Add Azure AI Inference Embeddings client with registered IEmbeddingGenerator”](#add-azure-ai-inference-embeddings-client-with-registered-iembeddinggenerator)

If you’re interested in using the `IEmbeddingGenerator` interface with the Azure AI Inference client, simply chain either of the following APIs to the `AddAzureEmbeddingsClient` method:

* `AddEmbeddingsClient`: Registers a singleton `IEmbeddingGenerator` in the services.
* `AddKeyedEmbeddingsClient`: Registers a keyed singleton `IEmbeddingGenerator` in the services.

For example, consider the following C# code that adds an `IEmbeddingGenerator` to the DI container:

```csharp
builder.AddAzureEmbeddingsClient(connectionName: "ai-foundry")
    .AddEmbeddingsClient("deploymentName");
```

Similarly, you can add a keyed `IEmbeddingGenerator` with the following C# code:

```csharp
builder.AddAzureEmbeddingsClient(connectionName: "ai-foundry")
    .AddKeyedEmbeddingsClient("serviceKey", "deploymentName");
```

After adding the `IEmbeddingGenerator`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(IEmbeddingGenerator<string, Embedding<float>> embeddingGenerator)
{
    public async Task<GeneratedEmbeddings<Embedding<float>>> GenerateEmbeddingsAsync(string input)
    {
        return await embeddingGenerator.GenerateAsync(input);
    }
}
```

For more information on the `IEmbeddingGenerator` and its corresponding library, see [Artificial intelligence in .NET](https://learn.microsoft.com/dotnet/core/extensions/artificial-intelligence).

### Add keyed Azure AI Inference Embeddings clients

[Section titled “Add keyed Azure AI Inference Embeddings clients”](#add-keyed-azure-ai-inference-embeddings-clients)

There might be situations where you want to register multiple `EmbeddingsClient` instances with different connection names. To register keyed Azure AI Inference clients, call the `AddKeyedAzureEmbeddingsClient` method:

```csharp
builder.AddKeyedAzureEmbeddingsClient(name: "legal");
builder.AddKeyedAzureEmbeddingsClient(name: "code");
```

Caution

When using keyed services, ensure that your Azure AI Inference resource configures two named connections, one for `legal` and one for `code`.

Then you can retrieve the client instances using dependency injection. For example, to retrieve the clients from a service:

```csharp
public class ExampleService(
    [KeyedService("legal")] EmbeddingsClient legalClient,
    [KeyedService("code")] EmbeddingsClient codeClient)
{
    // Use clients...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Azure AI Inference library provides multiple options to configure the Azure AI Foundry Service based on the requirements and conventions of your project.

Note

Either an `Endpoint` and `DeploymentId`, or a `ConnectionString` is required to be supplied.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

A connection can be constructed from the `Keys`, `Deployment ID` and `Endpoint` tab with the format:

```plaintext
Endpoint={endpoint};Key={key};DeploymentId={deploymentId}`
```

You can provide the name of the connection string when calling `builder.AddAzureChatCompletionsClient()`:

```csharp
builder.AddAzureChatCompletionsClient(
    connectionName: "connection-string-name");
```

The connection string is retrieved from the `ConnectionStrings` configuration section. Two connection formats are supported:

##### Azure AI Foundry endpoint

[Section titled “Azure AI Foundry endpoint”](#azure-ai-foundry-endpoint)

The recommended approach is to use an `Endpoint`, which works with the `ChatCompletionsClientSettings.Credential` property to establish a connection. If no credential is configured, `DefaultAzureCredential` is used.

```json
{
  "ConnectionStrings": {
    "connection-string-name": "Endpoint=https://{endpoint}/;DeploymentId={deploymentName}"
  }
}
```

##### Connection string

[Section titled “Connection string”](#connection-string)

Alternatively, a custom connection string can be used.

```json
{
  "ConnectionStrings": {
    "connection-string-name": "Endpoint=https://{endpoint}/;Key={account_key};DeploymentId={deploymentName}"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Azure AI Inference library supports `Microsoft.Extensions.Configuration`. It loads the `ChatCompletionsClientSettings` and `AzureAIInferenceClientOptions` from configuration by using the `Aspire:Azure:AI:Inference` key. For example, consider an *appsettings.json* that configures some of the options:

```json
{
  "Aspire": {
    "Azure": {
      "AI": {
        "Inference": {
          "DisableTracing": false,
          "EnableSensitiveTelemetryData": false,
          "ClientOptions": {
            "UserAgentApplicationId": "myapp"
          }
        }
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<ChatCompletionsClientSettings> configureSettings` delegate to set up some or all the options inline, for example, to disable tracing from code:

```csharp
builder.AddAzureChatCompletionsClient(
    connectionName: "connection-string-name",
    static settings => settings.DisableTracing = true);
```

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. For more information about integration observability and telemetry, see [Aspire integrations overview](/integrations/overview/). Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Azure AI Inference integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`

### Tracing

[Section titled “Tracing”](#tracing)

The Azure AI Inference integration will emit the following tracing activities using OpenTelemetry:

* `Experimental.Microsoft.Extensions.AI` - Used by Microsoft.Extensions.AI to record AI operations

Caution

Telemetry is only recorded by default when using the `IChatClient` interface from Microsoft.Extensions.AI. Raw `ChatCompletionsClient` calls do not automatically generate telemetry.

#### Configuring sensitive data in telemetry

[Section titled “Configuring sensitive data in telemetry”](#configuring-sensitive-data-in-telemetry)

By default, telemetry includes metadata such as token counts, but not raw inputs and outputs like message content. To include potentially sensitive information in telemetry, set the `EnableSensitiveTelemetryData` configuration option:

```csharp
builder.AddAzureChatCompletionsClient(
    connectionName: "ai-foundry",
    configureSettings: settings =>
    {
        settings.EnableSensitiveTelemetryData = true;
    })
    .AddChatClient("deploymentName");
```

Or through configuration:

```json
{
  "Aspire": {
    "Azure": {
      "AI": {
        "Inference": {
          "EnableSensitiveTelemetryData": true
        }
      }
    }
  }
}
```

Alternatively, you can enable sensitive data capture by setting the environment variable:

```bash
OTEL_INSTRUMENTATION_GENAI_CAPTURE_MESSAGE_CONTENT=true
```

#### Using underlying library telemetry

[Section titled “Using underlying library telemetry”](#using-underlying-library-telemetry)

If you need to access telemetry from the underlying Azure AI Inference library directly, you can manually add the appropriate activity sources and meters to your OpenTelemetry configuration:

```csharp
builder.Services.AddOpenTelemetry()
    .WithTracing(tracing => tracing.AddSource("Azure.AI.Inference.*"))
    .WithMetrics(metrics => metrics.AddMeter("Azure.AI.Inference.*"));
```

However, you’ll need to enable experimental telemetry support in the Azure AI Inference library by setting the `AZURE_EXPERIMENTAL_ENABLE_ACTIVITY_SOURCE` environment variable to `"true"` or calling `AppContext.SetSwitch("Azure.Experimental.EnableActivitySource", true)` during app startup.

# Azure AI Search integration

> This article describes the Aspire Azure AI Search integration features and capabilities.

![Azure AI Search logo](/_astro/azure-search-icon.DfNUAH0j_Z16Bevl.webp)

[Azure AI Search](https://learn.microsoft.com/azure/search) is an enterprise-ready information retrieval system for your heterogeneous content that you ingest into a search index, and surface to users through queries and apps. It comes with a comprehensive set of advanced search technologies, built for high-performance applications at any scale. The Aspire Azure AI Search integration enables you to connect to Azure AI Search services from your applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure AI Search hosting integration models the search service as the `AzureSearchResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.Search](https://www.nuget.org/packages/Aspire.Hosting.Azure.Search) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Search package

  ```bash
  aspire add azure-search
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-search (Aspire.Hosting.Azure.Search)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Search@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Search package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Search" Version="*" />
  ```

### Add an Azure AI Search resource

[Section titled “Add an Azure AI Search resource”](#add-an-azure-ai-search-resource)

To add an Azure AI Search resource to your AppHost project, call the `AddAzureSearch` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var search = builder.AddAzureSearch("search");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(search);


// After adding all resources, run the app...
```

The preceding code adds an Azure AI Search resource named `search` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleProject` project.

Caution

When you call `AddAzureSearch`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure AI Search instance

[Section titled “Connect to an existing Azure AI Search instance”](#connect-to-an-existing-azure-ai-search-instance)

You might have an existing Azure AI Search service that you want to connect to. You can chain a call to annotate that your `AzureSearchResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingSearchName = builder.AddParameter("existingSearchName");
var existingSearchResourceGroup = builder.AddParameter("existingSearchResourceGroup");


var search = builder.AddAzureSearch("search")
    .AsExisting(existingSearchName, existingSearchResourceGroup);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(search);


// After adding all resources, run the app...
```

For more information on treating Azure AI Search resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure AI Search resource, you can add a connection string to the AppHost. This approach is weakly-typed and doesn’t work with role assignments or infrastructure customizations.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With , you don’t need to write Bicep by hand; instead, the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure AI Search resource, Bicep is generated to provision the search service with appropriate defaults.

Generated Bicep — search.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource search 'Microsoft.Search/searchServices@2023-11-01' = {
  name: take('search-${uniqueString(resourceGroup().id)}', 60)
  location: location
  properties: {
    hostingMode: 'default'
    disableLocalAuth: true
    partitionCount: 1
    replicaCount: 1
  }
  sku: {
    name: 'basic'
  }
  tags: {
    'aspire-resource-name': 'search'
  }
}


output connectionString string = 'Endpoint=https://${search.name}.search.windows.net'


output name string = search.name
```

The preceding Bicep is a module that provisions an Azure AI Search service resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — search-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param search_outputs_name string


param principalType string


param principalId string


resource search 'Microsoft.Search/searchServices@2023-11-01' existing = {
  name: search_outputs_name
}


resource search_SearchIndexDataContributor 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(search.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '8ebe5a00-799e-43f5-93ac-243d3dce84a7'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '8ebe5a00-799e-43f5-93ac-243d3dce84a7')
    principalType: principalType
  }
  scope: search
}


resource search_SearchServiceContributor 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(search.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7ca78c08-252a-4471-8644-bb5ff32d4ba0'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7ca78c08-252a-4471-8644-bb5ff32d4ba0')
    principalType: principalType
  }
  scope: search
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureSearch("search")
    .ConfigureInfrastructure(infra =>
    {
        var searchService = infra.GetProvisionableResources()
                                  .OfType<SearchService>()
                                  .Single();


        searchService.PartitionCount = 6;
        searchService.ReplicaCount = 3;
        searchService.SearchSkuName = SearchServiceSkuName.Standard3;
        searchService.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.

  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.

  * The single `SearchService` resource is retrieved.

    * The `PartitionCount` is set to `6`.
    * The `ReplicaCount` is set to `3`.
    * The `SearchSkuName` is set to `Standard3`.
    * A tag is added to the Cognitive Services resource with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Search resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference an Azure AI Search service using `WithReference`, the following connection properties are made available to the consuming project:

| Property Name | Description                                                                                          |
| ------------- | ---------------------------------------------------------------------------------------------------- |
| `Uri`         | The HTTPS endpoint of the Azure AI Search service in the format `https://{name}.search.windows.net`. |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `search1` becomes `SEARCH1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

The Aspire Azure AI Search client integration is used to connect to an Azure AI Search service using the `SearchIndexClient`. To get started with the Aspire Azure AI Search client integration, install the [📦 Aspire.Azure.Search.Documents](https://www.nuget.org/packages/Aspire.Azure.Search.Documents) NuGet package.

* .NET CLI

  .NET CLI — Add Aspire.Azure.Search.Documents package

  ```bash
  dotnet add package Aspire.Azure.Search.Documents
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Search.Documents@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Search.Documents package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Search.Documents" Version="*" />
  ```

### Add an Azure AI Search index client

[Section titled “Add an Azure AI Search index client”](#add-an-azure-ai-search-index-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureSearchClient` extension method on any `IHostApplicationBuilder` to register a [SearchIndexClient class](https://learn.microsoft.com/dotnet/api/microsoft.azure.search.searchindexclient) for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddAzureSearchClient(connectionName: "search");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure AI Search resource in the AppHost project. For more information, see [Add an Azure AI Search resource](#add-an-azure-ai-search-resource).

After adding the `SearchIndexClient`, you can retrieve the client instance using dependency injection. For example, to retrieve the client instance from an example service:

```csharp
public class ExampleService(SearchIndexClient indexClient)
{
    // Use indexClient
}
```

You can also retrieve a `SearchClient` which can be used for querying, by calling the `GetSearchClient` method:

```csharp
public class ExampleService(SearchIndexClient indexClient)
{
    public async Task<long> GetDocumentCountAsync(
        string indexName,
        CancellationToken cancellationToken)
    {
        var searchClient = indexClient.GetSearchClient(indexName);


        var documentCountResponse = await searchClient.GetDocumentCountAsync(
            cancellationToken);


        return documentCountResponse.Value;
    }
}
```

For more information, see:

* Azure AI Search client library for .NET [samples using the `SearchIndexClient`](https://learn.microsoft.com/azure/search/samples-dotnet).
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.

### Add keyed Azure AI Search index client

[Section titled “Add keyed Azure AI Search index client”](#add-keyed-azure-ai-search-index-client)

There might be situations where you want to register multiple `SearchIndexClient` instances with different connection names. To register keyed Azure AI Search clients, call the `AddKeyedAzureSearchClient` method:

```csharp
builder.AddKeyedAzureSearchClient(name: "images");
builder.AddKeyedAzureSearchClient(name: "documents");
```

Caution

When using keyed services, it’s expected that your Azure AI Search resource configured two named connections, one for the `images` and one for the `documents`.

Then you can retrieve the client instances using dependency injection. For example, to retrieve the clients from a service:

```csharp
public class ExampleService(
    [KeyedService("images")] SearchIndexClient imagesClient,
    [KeyedService("documents")] SearchIndexClient documentsClient)
{
    // Use clients...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Azure AI Search Documents library provides multiple options to configure the Azure AI Search connection based on the requirements and conventions of your project. Either an `Endpoint` or a `ConnectionString` is required to be supplied.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

A connection can be constructed from the **Keys and Endpoint** tab with the format `Endpoint={endpoint};Key={key};`. You can provide the name of the connection string when calling `builder.AddAzureSearchClient()`:

```csharp
builder.AddAzureSearchClient("searchConnectionName");
```

The connection string is retrieved from the `ConnectionStrings` configuration section. Two connection formats are supported:

##### Account endpoint

[Section titled “Account endpoint”](#account-endpoint)

The recommended approach is to use an `Endpoint`, which works with the `AzureSearchSettings.Credential` property to establish a connection. If no credential is configured, the `DefaultAzureCredential` is used.

```json
{
  "ConnectionStrings": {
    "search": "https://{search_service}.search.windows.net/"
  }
}
```

##### Connection string

[Section titled “Connection string”](#connection-string)

Alternatively, a connection string with key can be used, however; it’s not the recommended approach:

```json
{
  "ConnectionStrings": {
    "search": "Endpoint=https://{search_service}.search.windows.net/;Key={account_key};"
  }
}
```

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Azure AI Search library supports `Microsoft.Extensions.Configuration`. It loads the `AzureSearchSettings` and `SearchClientOptions` from configuration by using the `Aspire:Azure:Search:Documents` key. Example `appsettings.json` that configures some of the options:

```json
{
  "Aspire": {
    "Azure": {
      "Search": {
        "Documents": {
          "DisableTracing": false
        }
      }
    }
  }
}
```

For the complete Azure AI Search Documents client integration JSON schema, see [Aspire.Azure.Search.Documents/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Azure.Search.Documents/ConfigurationSchema.json).

### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Azure AI Search library supports named configuration, which allows you to configure multiple instances of the same resource type with different settings. The named configuration uses the connection name as a key under the main configuration section.

```json
{
  "Aspire": {
    "Azure": {
      "Search": {
        "Documents": {
          "search1": {
            "Endpoint": "https://mysearch1.search.windows.net/",
            "DisableTracing": false
          },
          "search2": {
            "Endpoint": "https://mysearch2.search.windows.net/",
            "DisableTracing": true
          }
        }
      }
    }
  }
}
```

In this example, the `search1` and `search2` connection names can be used when calling `AddAzureSearchClient`:

```csharp
builder.AddAzureSearchClient("search1");
builder.AddAzureSearchClient("search2");
```

Named configuration takes precedence over the top-level configuration. If both are provided, the settings from the named configuration override the top-level settings.

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureSearchSettings> configureSettings` delegate to set up some or all the options inline, for example to disable tracing from code:

```csharp
builder.AddAzureSearchClient(
    "searchConnectionName",
    static settings => settings.DisableTracing = true);
```

You can also set up the `SearchClientOptions` using the optional `Action<IAzureClientBuilder<SearchIndexClient, SearchClientOptions>> configureClientBuilder` parameter of the `AddAzureSearchClient` method. For example, to set the client ID for this client:

```csharp
builder.AddAzureSearchClient(
    "searchConnectionName",
    configureClientBuilder: builder => builder.ConfigureOptions(
        static options => options.Diagnostics.ApplicationId = "CLIENT_ID"));
```

The Azure AI Search Documents integration implements a single health check that calls the `GetServiceStatisticsAsync` method on the `SearchIndexClient` to verify that the service is available.

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. For more information about integration observability and telemetry, see [Aspire integrations overview](/integrations/overview/). Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Azure AI Search Documents integration uses the following log categories:

* `Azure`
* `Azure.Core`
* `Azure.Identity`

### Tracing

[Section titled “Tracing”](#tracing)

The Azure AI Search Documents integration emits tracing activities using OpenTelemetry when interacting with the search service.

# Azure App Configuration integration

> This article describes the Aspire Azure App Configuration integration features and capabilities.

![Azure App Configuration logo](/_astro/azure-appconfig-icon.CzIz3ORB_WYM7q.webp)

[Azure App Configuration](https://learn.microsoft.com/azure-app-configuration) provides a service to centrally manage application settings and feature flags. Modern programs, especially programs running in a cloud, generally have many components that are distributed in nature. Spreading configuration settings across these components can lead to hard-to-troubleshoot errors during an application deployment. The Aspire Azure App Configuration integration enables you to connect to existing App Configuration instances or create new instances all from your AppHost.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure App Configuration hosting integration models the App Configuration resource as the `AzureAppConfigurationResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.AppConfiguration](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppConfiguration) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.AppConfiguration package

  ```bash
  aspire add azure-appconfiguration
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-appconfiguration (Aspire.Hosting.Azure.AppConfiguration)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.AppConfiguration@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.AppConfiguration package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.AppConfiguration" Version="*" />
  ```

### Add an Azure App Configuration resource

[Section titled “Add an Azure App Configuration resource”](#add-an-azure-app-configuration-resource)

To add an Azure App Configuration resource to your AppHost project, call the `AddAzureAppConfiguration` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config");


// After adding all resources, run the app...


builder.Build().Run();
```

When you add an `AzureAppConfigurationResource` to the AppHost, it exposes other useful APIs.

Caution

When you call `AddAzureAppConfiguration`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

#### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure App Configuration resource, the following Bicep is generated:

:::code language=“bicep” source=”../snippets/azure/AppHost/config/config.bicep”:::

Generated Bicep — config.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource config 'Microsoft.AppConfiguration/configurationStores@2024-06-01' = {
  name: take('config-${uniqueString(resourceGroup().id)}', 50)
  location: location
  properties: {
    disableLocalAuth: true
  }
  sku: {
    name: 'standard'
  }
  tags: {
    'aspire-resource-name': 'config'
  }
}


output appConfigEndpoint string = config.properties.endpoint


output name string = config.name
```

The preceding Bicep is a module that provisions an Azure App Configuration resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — config-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param config_outputs_name string


param principalType string


param principalId string


resource config 'Microsoft.AppConfiguration/configurationStores@2024-06-01' existing = {
  name: config_outputs_name
}


resource config_AppConfigurationDataOwner 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(config.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '5ae67dd6-50cb-40e7-96ff-dc2bfa4b606b'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '5ae67dd6-50cb-40e7-96ff-dc2bfa4b606b')
    principalType: principalType
  }
  scope: config
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they’re reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API. For example, you can configure the `sku`, purge protection, and more. The following example demonstrates how to customize the Azure App Configuration resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureAppConfiguration("config")
    .ConfigureInfrastructure(infra =>
    {
        var appConfigStore = infra.GetProvisionableResources()
                                  .OfType<AppConfigurationStore>()
                                  .Single();


        appConfigStore.SkuName = "Free";
        appConfigStore.EnablePurgeProtection = true;
        appConfigStore.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `AppConfigurationStore` is retrieved.
  * The `AppConfigurationStore.SkuName` is assigned to `Free`.
  * A tag is added to the App Configuration store with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Azure App Configuration resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Use existing Azure App Configuration resource

[Section titled “Use existing Azure App Configuration resource”](#use-existing-azure-app-configuration-resource)

You might have an existing Azure App Configuration store that you want to connect to. If you want to use an existing Azure App Configuration store, you can do so by calling the `AsExisting` method. This method accepts the config store and resource group names as parameters, and uses it to connect to the existing Azure App Configuration store resource.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var configName = builder.AddParameter("configName");
var configResourceGroupName = builder.AddParameter("configResourceGroupName");


var appConfig = builder.AddAzureAppConfiguration("config")
    .AsExisting(configName, configResourceGroupName);


// After adding all resources, run the app...


builder.Build().Run();
```

For more information, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

### Connect to existing Azure App Configuration store

[Section titled “Connect to existing Azure App Configuration store”](#connect-to-existing-azure-app-configuration-store)

An alternative approach to using the `*AsExisting` APIs enables the addition of a connection string instead, where the AppHost uses configuration to resolve the connection information. To add a connection to an existing Azure App Configuration store, call the `AddConnectionString` method:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var config = builder.AddConnectionString("config");


builder.AddProject<Projects.WebApplication>("web")
       .WithReference(config);


// After adding all resources, run the app...
```

Note

Connection strings are used to represent a wide range of connection information, including database connections, message brokers, endpoint URIs, and other services. In Aspire nomenclature, the term “connection string” is used to represent any kind of connection information.

The connection string is configured in the AppHost’s configuration, typically under [User Secrets](https://learn.microsoft.com/aspnet/core/security/app-secrets), under the `ConnectionStrings` section. The AppHost injects this connection string as an environment variable into all dependent resources, for example:

```json
{
  "ConnectionStrings": {
    "config": "https://{store_name}.azconfig.io"
  }
}
```

The dependent resource can access the injected connection string by calling the `GetConnectionString` method, and passing the connection name as the parameter, in this case `"config"`. The `GetConnectionString` API is shorthand for `IConfiguration.GetSection("ConnectionStrings")[name]`.

### Add Azure App Configuration emulator resource

[Section titled “Add Azure App Configuration emulator resource”](#add-azure-app-configuration-emulator-resource)

Microsoft provides the Azure App Configuration emulator for developers who want a local, lightweight implementation of the Azure App Configuration service to code and test against. In Aspire, you can use this emulator by calling the `RunAsEmulator` method when you add your resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config")
    .RunAsEmulator();


// After adding all resources, run the app...


builder.Build().Run();
```

The Azure App Configuration emulator isn’t installed on your local computer. Instead, it’s accessible to Aspire as a container. The `RunAsEmulator` method creates and starts the container when the AppHost starts using the `azure-app-configuration/app-configuration-emulator` image.

#### Configure Azure App Configuration emulator container

[Section titled “Configure Azure App Configuration emulator container”](#configure-azure-app-configuration-emulator-container)

There are various configurations available to container resources. For example, you can configure the container’s port, environment variables, its lifetime, and more.

##### Configure Azure App Configuration emulator host port

[Section titled “Configure Azure App Configuration emulator host port”](#configure-azure-app-configuration-emulator-host-port)

By default, Aspire assigns a random host port for the emulator container. If you want to use a specific port, chain calls on the container resource builder provided by the `RunAsEmulator` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config")
    .RunAsEmulator(emulator =>
    {
        emulator.WithHostPort(28000);
    });


// After adding all resources, run the app...
```

The preceding code configures the emulator container’s endpoint to listen on port `28000`.

##### Configure Azure App Configuration emulator with persistent lifetime

[Section titled “Configure Azure App Configuration emulator with persistent lifetime”](#configure-azure-app-configuration-emulator-with-persistent-lifetime)

To configure the emulator container with a persistent lifetime, call the `WithLifetime` method on the emulator container resource and pass `ContainerLifetime.Persistent`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config")
    .RunAsEmulator(emulator =>
    {
        emulator.WithLifetime(ContainerLifetime.Persistent);
    });


// After adding all resources, run the app...
```

##### Configure Azure App Configuration emulator with data volume

[Section titled “Configure Azure App Configuration emulator with data volume”](#configure-azure-app-configuration-emulator-with-data-volume)

By default, the Azure App Configuration emulator doesn’t persist data between container restarts. To enable persistent storage using a Docker volume, call the `WithDataVolume` method on the emulator resource:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config")
    .RunAsEmulator(emulator =>
    {
        emulator.WithDataVolume();
    });


// After adding all resources, run the app...
```

The data volume is used to persist the emulator data outside the lifecycle of its container, ensuring configuration values survive container restarts. The data volume is mounted at the `/data` path in the emulator container and when a `name` parameter isn’t provided, the name is autogenerated from the application and resource names (for example, if your application is named `myapp` and the resource is `config`, the autogenerated name will be `myapp-config`). For more information on data volumes and details on why they’re preferred over [bind mounts](#configure-azure-app-configuration-emulator-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

##### Configure Azure App Configuration emulator with data bind mount

[Section titled “Configure Azure App Configuration emulator with data bind mount”](#configure-azure-app-configuration-emulator-with-data-bind-mount)

To persist emulator data to a specific directory on your host machine, call the `WithDataBindMount` method. This is useful when you want direct access to the data files on your host system:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config")
    .RunAsEmulator(emulator =>
    {
        emulator.WithDataBindMount("../Emulator/Data");
    });


// After adding all resources, run the app...
```

Caution

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the emulator data across container restarts. The data bind mount is mounted at the `../Emulator/Data` path on the host machine relative to the AppHost directory (`IDistributedApplicationBuilder.AppHostDirectory`) in the emulator container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure App Configuration client integration, install the [📦 Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration](https://www.nuget.org/packages/Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration) NuGet package in the client-consuming project, that is, the project for the application that uses the App Configuration client. The App Configuration client integration registers an Azure configuration provider to populate the `IConfiguration` instance.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration package

  ```bash
  dotnet add package Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddAzureAppConfiguration` extension method on any `IHostApplicationBuilder` to register the required services to flow Azure App Configuration values into the `IConfiguration` instance for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddAzureAppConfiguration(connectionName: "config");
```

Tip

The `connectionName` parameter must match the name used when adding the App Configuration resource in the AppHost project. In other words, when you call `AddAzureAppConfiguration` in the AppHost and provide a name of `config` that same name should be used when calling `AddAzureAppConfiguration` in the client-consuming project. For more information, see [Add an Azure App Configuration resource](#add-an-azure-app-configuration-resource).

You can then retrieve the `IConfiguration` instance using dependency injection. For example, to retrieve the client from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(IConfiguration configuration)
{
    private readonly string _someValue = configuration["SomeKey"];
}
```

### Configure the Azure App Configuration provider

[Section titled “Configure the Azure App Configuration provider”](#configure-the-azure-app-configuration-provider)

The `AddAzureAppConfiguration` method accepts an optional `Action<AzureAppConfigurationOptions> configureOptions` delegate that you use to configure the Azure App Configuration provider. This follows the same pattern as the non-Aspire `Microsoft.Extensions.Configuration.AzureAppConfiguration` package, but Aspire automatically handles the connection—you don’t need to call `options.Connect`.

C# — Program.cs

```csharp
builder.AddAzureAppConfiguration(
    "config",
    configureOptions: options =>
    {
        // Select specific keys or labels
        options.Select("MyApp:*");
        options.Select("MyApp:*", "Production");


        // Configure refresh options
        options.ConfigureRefresh(refresh =>
        {
            refresh.Register("MyApp:Sentinel", refreshAll: true)
                   .SetRefreshInterval(TimeSpan.FromSeconds(30));
        });
    });
```

For more information on available configuration options, see the [Azure App Configuration provider reference](https://learn.microsoft.com/azure/azure-app-configuration/reference-dotnet-provider).

### Use feature flags

[Section titled “Use feature flags”](#use-feature-flags)

To use feature flags, install the [📦 Microsoft.FeatureManagement](https://www.nuget.org/packages/Microsoft.FeatureManagement) NuGet package:

* .NET CLI

  .NET CLI — Add Microsoft.FeatureManagement package

  ```bash
  dotnet add package Microsoft.FeatureManagement
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Microsoft.FeatureManagement@*
  ```

* PackageReference (\*.csproj)

  XML — Add Microsoft.FeatureManagement package reference

  ```xml
  <PackageReference Include="Microsoft.FeatureManagement" Version="*" />
  ```

App Configuration doesn’t load feature flags by default. To load feature flags, use the `configureOptions` delegate (as shown in [Configure the Azure App Configuration provider](#configure-the-azure-app-configuration-provider)) to call `UseFeatureFlags()` when calling `builder.AddAzureAppConfiguration`.

C# — Program.cs

```csharp
builder.AddAzureAppConfiguration(
    "config",
    configureOptions: options => options.UseFeatureFlags());


// Register feature management services
builder.Services.AddFeatureManagement();
```

The `configureOptions` pattern is used to configure the Azure App Configuration provider. For more information, see [Azure App Configuration: .NET configuration provider](https://learn.microsoft.com/azure/azure-app-configuration/reference-dotnet-provider). You can then use `IFeatureManager` to evaluate feature flags in your app. Consider the following example ASP.NET Core Minimal API app:

C# — Program.cs

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.FeatureManagement;


var builder = WebApplication.CreateBuilder(args);


builder.AddAzureAppConfiguration(
    "config",
    configureOptions: options => options.UseFeatureFlags());


// Register feature management services
builder.Services.AddFeatureManagement();


var app = builder.Build();


app.MapGet("/", async (IFeatureManager featureManager) =>
{
    if (await featureManager.IsEnabledAsync("NewFeature"))
    {
        return Results.Ok("New feature is enabled!");
    }


    return Results.Ok("Using standard implementation.");
});


app.Run();
```

For more information, see [.NET Feature Management](https://learn.microsoft.com/azure/azure-app-configuration/feature-management-dotnet-reference).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure App Configuration library provides multiple options to configure the Azure App Configuration connection based on the requirements and conventions of your project. The App Config endpoint is required to be supplied, either in `AzureAppConfigurationSettings.Endpoint` or using a connection string.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `builder.AddAzureAppConfiguration()`:

C# — Program.cs

```csharp
builder.AddAzureAppConfiguration("config");
```

Then the App Configuration endpoint is retrieved from the `ConnectionStrings` configuration section. The App Configuration store URI works with the `AzureAppConfigurationSettings.Credential` property to establish a connection. If no credential is configured, the `DefaultAzureCredential` is used.

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "config": "https://{store_name}.azconfig.io"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Azure App Configuration library supports `Microsoft.Extensions.Configuration`. It loads the `AzureAppConfigurationSettings` from configuration by using the `Aspire:Microsoft:Extensions:Configuration:AzureAppConfiguration` key. Example *appsettings.json* that configures some of the options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "Extensions": {
        "Configuration": {
          "AzureAppConfiguration": {
            "Endpoint": "YOUR_APPCONFIGURATION_ENDPOINT_URI"
          }
        }
      }
    }
  }
}
```

For the complete App Configuration client integration JSON schema, see [ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration/ConfigurationSchema.json).

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureAppConfigurationSettings> configureSettings` delegate to set up some or all the options inline, for example to set App Configuration endpoint from code:

C# — Program.cs

```csharp
builder.AddAzureAppConfiguration(
    "config",
    configureSettings: settings => settings.Endpoint = "https://YOUR_URI");
```

#### Logging

[Section titled “Logging”](#logging)

The Aspire Azure App Configuration integration uses the following log categories:

* `Microsoft.Extensions.Configuration.AzureAppConfiguration.Refresh`

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure App Configuration integration doesn’t make use of any activity sources thus no tracing is available.

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure App Configuration integration currently doesn’t support metrics.

# Azure App Service integration

> This article describes the Aspire Azure App Service integration features and capabilities.

![Azure App Service logo](/_astro/azure-app-services.B0FFn4fq_Z1k8iGn.svg) 🧪 Preview

[Azure App Service](https://learn.microsoft.com/azure/app-service) is a fully managed platform for building, deploying, and scaling web apps. Aspire apps often run locally during development but require scalable, production-ready hosting environments for staging and production. The Aspire integration allows you to provision or reference an existing Azure App Service environment (App Service Plan) and seamlessly publish your container, executable, and project resources as Azure App Service websites. When you add an App Service environment, the integration automatically provisions an Azure Container Registry for container-based deployments and grants fine-grained role assignments to enable secure access between Azure resources.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure App Service hosting integration models App Service resources as the `AzureAppServiceResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.AppService](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppService) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.AppService package

  ```bash
  aspire add azure-appservice
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-appservice (Aspire.Hosting.Azure.AppService)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.AppService@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.AppService package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.AppService" Version="*" />
  ```

## Add Azure App Service environment

[Section titled “Add Azure App Service environment”](#add-azure-app-service-environment)

To use Azure App Service with Aspire, you first add an App Service environment to your AppHost project. The environment represents the hosting infrastructure (App Service Plan) where your apps will run.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appServiceEnv = builder.AddAzureAppServiceEnvironment("app-service-env");


// Add other resources to the app model


builder.Build().Run();
```

The preceding code creates a new Azure App Service environment named `app-service-env`. When you run your app locally, this environment is provisioned in your Azure subscription with the following resources:

* An App Service Plan with a Premium P0V3 tier on Linux.
* An Azure Container Registry (Basic SKU) for container image storage.
* A user-assigned managed identity for secure access to the container registry.

Caution

When you call `AddAzureAppServiceEnvironment`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

## Connect to an existing Azure App Service plan

[Section titled “Connect to an existing Azure App Service plan”](#connect-to-an-existing-azure-app-service-plan)

You might have an existing Azure App Service plan that you want to use. Chain a call to annotate that your `AzureAppServiceEnvironmentResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingAppServicePlanName = builder.AddParameter("existingAppServicePlanName");
var existingResourceGroup = builder.AddParameter("existingResourceGroup");


var appServiceEnv = builder.AddAzureAppServiceEnvironment("app-service-env")
    .AsExisting(existingAppServicePlanName, existingResourceGroup);


builder.AddProject<Projects.WebApi>("api")
    .PublishAsAzureAppServiceWebsite((infra, website) =>
    {
        // Optional: customize the Azure App Service website here
    });


// After adding all resources, run the app...
```

For more information on treating Azure App Service resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

## Publish resources as Azure App Service websites

[Section titled “Publish resources as Azure App Service websites”](#publish-resources-as-azure-app-service-websites)

After adding an App Service environment, you can publish compute resources (`IComputeResource`) as Azure App Service websites using the `PublishAsAzureAppServiceWebsite` method.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appServiceEnv = builder.AddAzureAppServiceEnvironment("app-service-env");


builder.AddProject<Projects.WebApi>("api")
    .PublishAsAzureAppServiceWebsite((infra, website) =>
    {
        // Optional: customize the Azure App Service website here
    });


builder.Build().Run();
```

The preceding code:

* Creates an Azure App Service environment named `app-service-env`.
* Adds a project named `api` to the AppHost.
* Configures the project to be published as an Azure App Service website.
* Provides an optional callback to customize the website configuration.

During local development (when running with F5 `F5` F5 `F5` F5 `F5` ), the project runs locally. When you publish your app, the project is deployed as an Azure App Service website within the provisioned environment.

## Customize the App Service website

[Section titled “Customize the App Service website”](#customize-the-app-service-website)

The `PublishAsAzureAppServiceWebsite` method accepts a callback that allows you to customize the Azure App Service website configuration using the [Azure.Provisioning](https://learn.microsoft.com/dotnet/api/azure.provisioning) APIs:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.WebApi>("api")
    .PublishAsAzureAppServiceWebsite((infra, website) =>
    {
        website.AppSettings.Add("ASPNETCORE_ENVIRONMENT", new AppServiceConfigurationSetting
        {
            Name = "ASPNETCORE_ENVIRONMENT",
            Value = "Production"
        });


        website.Tags.Add("Environment", "Production");
        website.Tags.Add("Team", "Engineering");
    });
```

The preceding code:

* Chains a call to `PublishAsAzureAppServiceWebsite` with a customization callback.
* Adds an application setting for `ASPNETCORE_ENVIRONMENT`.
* Adds multiple tags for metadata and organization.

## Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file.

When you add an Azure App Service environment, the following key resources are provisioned:

* **App Service Plan**: A Premium P0V3 Linux-based hosting plan.
* **Azure Container Registry**: A Basic SKU registry for storing container images.
* **User-assigned Managed Identity**: For secure access between App Service and Container Registry.
* **Role Assignments**: ACR Pull role assigned to the managed identity.

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly are overwritten, so make changes through the C# provisioning APIs to ensure they’re reflected in the generated files.

### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API. For example, you can configure the App Service Plan SKU, location, and more. The following example demonstrates how to customize the Azure App Service environment:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appServiceEnv = builder.AddAzureAppServiceEnvironment("app-service-env")
    .ConfigureInfrastructure(infra =>
    {
        var resources = infra.GetProvisionableResources();
        var plan = resources.OfType<AppServicePlan>().Single();


        plan.Sku = new AppServiceSkuDescription
        {
            Name = "P1V3",
            Tier = "Premium"
        };


        plan.Tags.Add("Environment", "Production");
        plan.Tags.Add("CostCenter", "Engineering");
    });


builder.Build().Run();
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `AppServicePlan` is retrieved.
  * The `Sku` property is changed to a P1V3 tier.
  * Tags are added to the App Service Plan for metadata and organization.

There are many more configuration options available to customize the App Service environment. For more information, see `Azure.Provisioning.AppService` and [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

# Azure Cache for Redis integration

> This article describes the Aspire Azure Cache for Redis integration features and capabilities.

![Azure Cache for Redis logo](/_astro/azure-cacheredis-icon.BPM2--yb_olerP.webp)

[Azure Cache for Redis](https://learn.microsoft.com/azure/azure-cache-for-redis/cache-overview) provides an in-memory data store based on the [Redis](https://redis.io/) software. Redis improves the performance and scalability of an application that uses backend data stores heavily. It’s able to process large volumes of application requests by keeping frequently accessed data in the server memory, which can be written to and read from quickly. Redis brings a critical low-latency and high-throughput data storage solution to modern applications.

Azure Cache for Redis offers both the Redis open-source (OSS Redis) and a commercial product from Redis Inc. (Redis Enterprise) as a managed service. It provides secure and dedicated Redis server instances and full Redis API compatibility. Microsoft operates the service, hosted on Azure, and usable by any application within or outside of Azure.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure Cache for Redis hosting integration models the Redis cache as the `AzureRedisResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.Redis](https://www.nuget.org/packages/Aspire.Hosting.Azure.Redis) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Redis package

  ```bash
  aspire add azure-redis
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-redis (Aspire.Hosting.Azure.Redis)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Redis package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Redis" Version="*" />
  ```

### Add an Azure Cache for Redis resource

[Section titled “Add an Azure Cache for Redis resource”](#add-an-azure-cache-for-redis-resource)

To add an Azure Cache for Redis resource to your AppHost project, call the `AddAzureRedis` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddAzureRedis("redis");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(redis);


// After adding all resources, run the app...
```

The preceding code adds an Azure Redis resource named `redis` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleProject` project.

Caution

When you call `AddAzureRedis`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Cache for Redis instance

[Section titled “Connect to an existing Azure Cache for Redis instance”](#connect-to-an-existing-azure-cache-for-redis-instance)

You might have an existing Azure Cache for Redis service that you want to connect to. You can chain a call to annotate that your `AzureRedisCacheResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingRedisName = builder.AddParameter("existingRedisName");
var existingRedisResourceGroup = builder.AddParameter("existingRedisResourceGroup");


var redis = builder.AddAzureRedis("redis")
    .AsExisting(existingRedisName, existingRedisResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(redis);


// After adding all resources, run the app...
```

For more information on treating Azure Redis resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

### Run Azure Cache for Redis resource as a container

[Section titled “Run Azure Cache for Redis resource as a container”](#run-azure-cache-for-redis-resource-as-a-container)

The Azure Cache for Redis hosting integration supports running the Redis server as a local container. This is beneficial for situations where you want to run the Redis server locally for development and testing purposes, avoiding the need to provision an Azure resource or connect to an existing Azure Cache for Redis server.

To make use of the [`docker.io/library/redis`](https://hub.docker.com/_/redis/) container image, and run the Azure Cache for Redis instance as a container locally, chain a call to `RunAsContainer`, as shown in the following example:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddAzureRedis("azcache")
    .RunAsContainer();


builder.AddProject<Projects.ExampleProject>()
    .WithReference(cache);


// After adding all resources, run the app...
```

The preceding code configures the Redis resource to run locally in a container.

Tip

The `RunAsContainer` method is useful for local development and testing. The API exposes an optional delegate that enables you to customize the underlying `RedisResource` configuration, such adding [Redis Insights](https://redis.io/insight/), [Redis Commander](https://joeferner.github.io/redis-commander/), adding a data volume or data bind mount. For more information, see the [Aspire Redis hosting integration](/integrations/caching/redis/#add-redis-resource-with-redis-insights).

### Configure the Azure Cache for Redis resource to use access key authentication

[Section titled “Configure the Azure Cache for Redis resource to use access key authentication”](#configure-the-azure-cache-for-redis-resource-to-use-access-key-authentication)

By default, the Azure Cache for Redis resource is configured to use [Microsoft Entra ID](https://learn.microsoft.com/azure/postgresql/flexible-server/concepts-azure-ad-authentication) authentication. If you want to use password authentication (not recommended), you can configure the server to use password authentication by calling the `WithAccessKeyAuthentication` method:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddAzureRedis("azcache")
    .WithAccessKeyAuthentication();


builder.AddProject<Projects.ExampleProject>()
    .WithReference(cache);


// After adding all resources, run the app...
```

The preceding code configures the Azure Cache for Redis resource to use access key authentication. This alters the generated Bicep to use access key authentication instead of Microsoft Entra ID authentication. In other words, the connection string will contain a password, and will be added to an Azure Key Vault secret.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Cache for Redis resource, the following Bicep is generated:

Bicep — redis.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource redis 'Microsoft.Cache/redis@2024-11-01' = {
  name: take('redis-${uniqueString(resourceGroup().id)}', 63)
  location: location
  properties: {
    sku: {
      name: 'Basic'
      family: 'C'
      capacity: 1
    }
    enableNonSslPort: false
    disableAccessKeyAuthentication: true
    minimumTlsVersion: '1.2'
    redisConfiguration: {
      'aad-enabled': 'true'
    }
  }
  tags: {
    'aspire-resource-name': 'redis'
  }
}


output connectionString string = '${redis.properties.hostName},ssl=true'


output name string = redis.name
```

The preceding Bicep is a module that provisions an Azure Cache for Redis resource. Additionally, role assignments are created for the Azure resource in a separate module:

Bicep — redis-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param redis_outputs_name string


param principalId string


param principalName string


resource redis 'Microsoft.Cache/redis@2024-11-01' existing = {
  name: redis_outputs_name
}


resource redis_contributor 'Microsoft.Cache/redis/accessPolicyAssignments@2024-11-01' = {
  name: guid(redis.id, principalId, 'Data Contributor')
  properties: {
    accessPolicyName: 'Data Contributor'
    objectId: principalId
    objectIdAlias: principalName
  }
  parent: redis
}
```

In addition to the Azure Cache for Redis, it also provisions an access policy assignment to the application access to the cache. The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureManagedRedis("redis")
    .WithAccessKeyAuthentication()
    .ConfigureInfrastructure(infra =>
    {
        var cluster = infra.GetProvisionableResources()
                           .OfType<RedisEnterpriseCluster>()
                           .Single();


        cluster.Sku = new RedisEnterpriseSku
        {
            Name = RedisEnterpriseSkuName.BalancedB0,
        };
        cluster.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `RedisEnterpriseCluster` is retrieved.
  * The `Sku` is set with a name of `BalancedB0`.
  * A tag is added to the Redis resource with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Redis resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Redis resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Azure Redis Enterprise

[Section titled “Azure Redis Enterprise”](#azure-redis-enterprise)

| Property Name | Description                                                                                                                                                    |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`        | The hostname of the Azure Redis Enterprise database endpoint.                                                                                                  |
| `Port`        | The port of the Azure Redis Enterprise database endpoint (10000 for Azure).                                                                                    |
| `Uri`         | The Redis connection URI. In Azure mode this is `redis://{Host}`; when running via `RunAsContainer` it matches `redis://[:{Password}@]{Host}:{Port}`.          |
| `Password`    | The access key for the Redis server. Empty when using Entra ID authentication; populated when using `WithAccessKeyAuthentication()` or running as a container. |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `cache` becomes `CACHE_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

The Aspire Azure Cache for Redis client integration is used to connect to an Azure Redis cache using StackExchange.Redis. To get started with the Aspire Azure Cache for Redis client integration, install the [📦 Aspire.StackExchange.Redis](https://www.nuget.org/packages/Aspire.StackExchange.Redis) NuGet package.

* .NET CLI

  .NET CLI — Add Aspire.StackExchange.Redis package

  ```bash
  dotnet add package Aspire.StackExchange.Redis
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.StackExchange.Redis@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.StackExchange.Redis package reference

  ```xml
  <PackageReference Include="Aspire.StackExchange.Redis" Version="*" />
  ```

### Add Redis client

[Section titled “Add Redis client”](#add-redis-client)

In the `Program.cs` file of your client-consuming project, call the `AddRedisClient` extension method to register an `IConnectionMultiplexer` for use via the dependency injection container. The method takes a connection name parameter:

```csharp
builder.AddRedisClient(connectionName: "redis");
```

Tip

The `connectionName` parameter must match the name used when adding the Redis resource in the AppHost project.

After adding the `IConnectionMultiplexer`, you can retrieve the connection instance using dependency injection:

```csharp
public class ExampleService(IConnectionMultiplexer redis)
{
    // Use redis...
}
```

For more information, see:

* [StackExchange.Redis documentation](https://stackexchange.github.io/StackExchange.Redis/) for examples on using the `IConnectionMultiplexer`.
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.

### Add Redis distributed cache

[Section titled “Add Redis distributed cache”](#add-redis-distributed-cache)

For caching scenarios, you can add a Redis-based distributed cache using the `AddRedisDistributedCache` method:

```csharp
builder.AddRedisDistributedCache(connectionName: "redis");
```

This registers an `IDistributedCache` implementation backed by Redis:

```csharp
public class ExampleService(IDistributedCache cache)
{
    // Use cache...
}
```

### Add Redis output cache

[Section titled “Add Redis output cache”](#add-redis-output-cache)

For output caching scenarios in ASP.NET Core, you can add a Redis-based output cache using the `AddRedisOutputCache` method:

```csharp
builder.AddRedisOutputCache(connectionName: "redis");
```

This configures Redis as the output cache store for your web application.

### Add keyed Redis client

[Section titled “Add keyed Redis client”](#add-keyed-redis-client)

There might be situations where you want to register multiple `IConnectionMultiplexer` instances with different connection names. To register keyed Redis clients, call the `AddKeyedRedisClient` method:

```csharp
builder.AddKeyedRedisClient(name: "primary-cache");
builder.AddKeyedRedisClient(name: "secondary-cache");
```

Then you can retrieve the connection instances using dependency injection:

```csharp
public class ExampleService(
    [KeyedService("primary-cache")] IConnectionMultiplexer primaryRedis,
    [KeyedService("secondary-cache")] IConnectionMultiplexer secondaryRedis)
{
    // Use redis connections...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure Cache for Redis library provides multiple options to configure the Redis connection based on the requirements and conventions of your project. A `ConnectionString` is required.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddRedisClient`:

```csharp
builder.AddRedisClient(connectionName: "redis");
```

The connection information is retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "redis": "myredis.redis.cache.windows.net:6380,password=your_password,ssl=True"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The library supports `Microsoft.Extensions.Configuration`. It loads settings from configuration using the `Aspire:StackExchange:Redis` key:

```json
{
  "Aspire": {
    "StackExchange": {
      "Redis": {
        "DisableHealthChecks": true,
        "DisableTracing": false
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can configure settings inline:

```csharp
builder.AddRedisClient(
    "redis",
    settings => settings.DisableHealthChecks = true);
```

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

#### Logging

[Section titled “Logging”](#logging)

The Aspire Azure Cache for Redis integration uses standard .NET logging for connection events and errors.

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure Cache for Redis integration will emit the following tracing activities using OpenTelemetry:

* `StackExchange.Redis.*`

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure Cache for Redis integration currently doesn’t expose custom metrics by default, but uses standard Redis monitoring capabilities.

# Azure Container Registry integration

> This article describes the Aspire Azure Container Registry integration features and capabilities.

![Azure Container Registry logo](/_astro/azure-container-registry-icon.CdJMtCXt_Z1k8iGn.svg)

[Azure Container Registry](https://learn.microsoft.com/azure/container-registry) is a managed Docker container registry service that simplifies the storage, management, and deployment of container images. The Aspire integration allows you to provision or reference an existing Azure Container Registry and seamlessly integrate it with your app’s compute environments.

## Overview

[Section titled “Overview”](#overview)

Aspire apps often build and run container images locally but require secure registries for staging and production environments. The Azure Container Registry integration provides the following capabilities:

* Provision or reference an existing Azure Container Registry.
* Attach the registry to any compute-environment resource (for example, Azure Container Apps, Docker, Kubernetes) to ensure proper credential flow.
* Grant fine-grained ACR role assignments to other Azure resources.

## Supported scenarios

[Section titled “Supported scenarios”](#supported-scenarios)

The Azure Container Registry integration supports the following scenarios:

* **Provisioning a new registry**: Automatically create a new Azure Container Registry for your app.
* **Referencing an existing registry**: Use an existing Azure Container Registry by providing its name and resource group.
* **Credential management**: Automatically flow credentials to compute environments for secure image pulls.
* **Role assignments**: Assign specific roles (for example, `AcrPush`) to enable services to push images to the registry.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure Container Registry hosting integration models the container registry as the `AzureContainerRegistryResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.ContainerRegistry](https://www.nuget.org/packages/Aspire.Hosting.Azure.ContainerRegistry) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.ContainerRegistry package

  ```bash
  aspire add azure-containerregistry
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-containerregistry (Aspire.Hosting.Azure.ContainerRegistry)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.ContainerRegistry@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.ContainerRegistry package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.ContainerRegistry" Version="*" />
  ```

### Provision a new container registry

[Section titled “Provision a new container registry”](#provision-a-new-container-registry)

The following example demonstrates how to provision a new Azure Container Registry and attach it to a container app environment:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add (or reference) the registry
var acr = builder.AddAzureContainerRegistry("my-acr");


// Wire an environment to that registry
builder.AddAzureContainerAppEnvironment("env")
       .WithAzureContainerRegistry(acr);


builder.Build().Run();
```

The preceding code:

* Creates a new Azure Container Registry named `my-acr`.
* Attaches the registry to an Azure Container Apps environment named `env`.
* Optionally grants the `AcrPush` role to a project resource named `api`, allowing it to push images to the registry.

For more information, see [Configure Azure Container Apps environments](/integrations/cloud/azure/configure-container-apps/).

Caution

When you call `AddAzureContainerRegistry`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Reference an existing container registry

[Section titled “Reference an existing container registry”](#reference-an-existing-container-registry)

To reference an existing Azure Container Registry, use the `PublishAsExisting` method with the registry name and resource group:

:::code source=“snippets/acr/AspireAcr.AppHost/AspireAcr.AppHost/Program.Existing.cs” id=“existing”:::

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var registryName = builder.AddParameter("registryName");
var rgName = builder.AddParameter("rgName");


// Add (or reference) the registry
var acr = builder.AddAzureContainerRegistry("my-acr")
    .PublishAsExisting(registryName, rgName);


// Wire an environment to that registry
builder.AddAzureContainerAppEnvironment("env")
    .WithAzureContainerRegistry(acr);


builder.Build().Run();
```

The preceding code:

* References an existing Azure Container Registry named `my-acr` in the specified resource group.
* Attaches the registry to an Azure Container Apps environment named `env`.
* Uses parameters to allow for dynamic configuration of the registry name and resource group.
* Optionally grants the `AcrPush` role to a project resource named `api`, allowing it to push images to the registry.

### Key features

[Section titled “Key features”](#key-features)

**Automatic credential flow**

When you attach an Azure Container Registry to a compute environment, Aspire automatically ensures that the correct credentials are available for secure image pulls.

**Fine-grained role assignments**

You can assign specific roles to Azure resources to control access to the container registry. For example, the `AcrPush` role allows a service to push images to the registry.

```csharp
builder.AddProject("api", "../Api/Api.csproj")
       .WithRoleAssignments(acr, ContainerRegistryBuiltInRole.AcrPush);
```

#### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With , you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Container Registry resource, the following Bicep is generated:

my-acr.module.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource my_acr 'Microsoft.ContainerRegistry/registries@2023-07-01' = {
  name: take('myacr${uniqueString(resourceGroup().id)}', 50)
  location: location
  sku: {
    name: 'Basic'
  }
  tags: {
    'aspire-resource-name': 'my-acr'
  }
}


output name string = my_acr.name


output loginServer string = my_acr.properties.loginServer
```

The preceding Bicep provisions an Azure Container Registry resource. Additionally, the added Azure Container App environment resource is also generated:

env.module.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param userPrincipalId string


param tags object = { }


param my_acr_outputs_name string


resource env_mi 'Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31' = {
  name: take('env_mi-${uniqueString(resourceGroup().id)}', 128)
  location: location
  tags: tags
}


resource my_acr 'Microsoft.ContainerRegistry/registries@2023-07-01' existing = {
  name: my_acr_outputs_name
}


resource my_acr_env_mi_AcrPull 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(my_acr.id, env_mi.id, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7f951dda-4ed3-4680-a7ca-43fe172d538d'))
  properties: {
    principalId: env_mi.properties.principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7f951dda-4ed3-4680-a7ca-43fe172d538d')
    principalType: 'ServicePrincipal'
  }
  scope: my_acr
}


resource env_law 'Microsoft.OperationalInsights/workspaces@2023-09-01' = {
  name: take('envlaw-${uniqueString(resourceGroup().id)}', 63)
  location: location
  properties: {
    sku: {
      name: 'PerGB2018'
    }
  }
  tags: tags
}


resource env 'Microsoft.App/managedEnvironments@2024-03-01' = {
  name: take('env${uniqueString(resourceGroup().id)}', 24)
  location: location
  properties: {
    appLogsConfiguration: {
      destination: 'log-analytics'
      logAnalyticsConfiguration: {
        customerId: env_law.properties.customerId
        sharedKey: env_law.listKeys().primarySharedKey
      }
    }
    workloadProfiles: [
      {
        name: 'consumption'
        workloadProfileType: 'Consumption'
      }
    ]
  }
  tags: tags
}


resource aspireDashboard 'Microsoft.App/managedEnvironments/dotNetComponents@2024-10-02-preview' = {
  name: 'aspire-dashboard'
  properties: {
    componentType: 'AspireDashboard'
  }
  parent: env
}


resource env_Contributor 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(env.id, userPrincipalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b24988ac-6180-42a0-ab88-20f7382dd24c'))
  properties: {
    principalId: userPrincipalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b24988ac-6180-42a0-ab88-20f7382dd24c')
  }
  scope: env
}


output MANAGED_IDENTITY_NAME string = env_mi.name


output MANAGED_IDENTITY_PRINCIPAL_ID string = env_mi.properties.principalId


output AZURE_LOG_ANALYTICS_WORKSPACE_NAME string = env_law.name


output AZURE_LOG_ANALYTICS_WORKSPACE_ID string = env_law.id


output AZURE_CONTAINER_REGISTRY_NAME string = my_acr_outputs_name


output AZURE_CONTAINER_REGISTRY_ENDPOINT string = my_acr.properties.loginServer


output AZURE_CONTAINER_REGISTRY_MANAGED_IDENTITY_ID string = env_mi.id


output AZURE_CONTAINER_APPS_ENVIRONMENT_NAME string = env.name


output AZURE_CONTAINER_APPS_ENVIRONMENT_ID string = env.id


output AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN string = env.properties.defaultDomain
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly are overwritten, so make changes through the C# provisioning APIs to ensure they’re reflected in the generated files.

# Azure Cosmos DB integration

> Learn how to install and configure the Aspire Azure Cosmos DB integration to connect to existing Cosmos DB instances or create new instances from Aspire with the Azure Cosmos DB emulator.

![Azure Cosmos DB logo](/_astro/azure-cosmosdb-icon.4tqzZo4Z_Z1sl4nn.webp)

[Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a fully managed NoSQL database service for modern app development. The Aspire Azure Cosmos DB integration enables you to connect to existing Cosmos DB instances or create new instances with the Azure Cosmos DB emulator.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure Cosmos DB hosting integration models Cosmos DB resources as the following types:

* `AzureCosmosDBResource`: Represents an Azure Cosmos DB resource.
* `AzureCosmosDBContainerResource`: Represents an Azure Cosmos DB container resource.
* `AzureCosmosDBDatabaseResource`: Represents an Azure Cosmos DB database resource.
* `AzureCosmosDBEmulatorResource`: Represents an Azure Cosmos DB emulator resource.

To access these types and APIs, add the [📦 Aspire.Hosting.Azure.CosmosDB](https://www.nuget.org/packages/Aspire.Hosting.Azure.CosmosDB) NuGet package to your AppHost project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.CosmosDB package

  ```bash
  aspire add azure-cosmosdb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-cosmosdb (Aspire.Hosting.Azure.CosmosDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.CosmosDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.CosmosDB package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.CosmosDB" Version="*" />
  ```

### Add Azure Cosmos DB resource

[Section titled “Add Azure Cosmos DB resource”](#add-azure-cosmos-db-resource)

In your AppHost project, call `AddAzureCosmosDB` to add and return an Azure Cosmos DB resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");


// After adding all resources, run the app...
```

When you add an `AzureCosmosDBResource` to the AppHost, it exposes other useful APIs to add databases and containers. In other words, you must add an `AzureCosmosDBResource` before adding any of the other Cosmos DB resources.

Caution

When you call `AddAzureCosmosDB`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Cosmos DB account

[Section titled “Connect to an existing Azure Cosmos DB account”](#connect-to-an-existing-azure-cosmos-db-account)

You might have an existing Azure Cosmos DB account that you want to connect to. Chain a call to annotate that your resource is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingCosmosName = builder.AddParameter("existingCosmosName");
var existingCosmosResourceGroup = builder.AddParameter("existingCosmosResourceGroup");


var cosmosdb = builder.AddAzureCosmosDB("cosmos-db")
    .AsExisting(existingCosmosName, existingCosmosResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(cosmosdb);


// After adding all resources, run the app...
```

For more information on treating Azure Cosmos DB resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure Cosmos DB account resource, you can add a connection string to the AppHost. This approach is weakly-typed and doesn’t work with role assignments or infrastructure customizations.

### Add Azure Cosmos DB database and container resources

[Section titled “Add Azure Cosmos DB database and container resources”](#add-azure-cosmos-db-database-and-container-resources)

Aspire models parent child relationships between Azure Cosmos DB resources. For example, an Azure Cosmos DB account (`AzureCosmosDBResource`) can have multiple databases (`AzureCosmosDBDatabaseResource`), and each database can have multiple containers (`AzureCosmosDBContainerResource`). When you add a database or container resource, you do so on a parent resource.

To add an Azure Cosmos DB database resource, call the `AddCosmosDatabase` method on an `IResourceBuilder<AzureCosmosDBResource>` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");
var db = cosmos.AddCosmosDatabase("db");


// After adding all resources, run the app...
```

When you call `AddCosmosDatabase`, it adds a database named `db` to your Cosmos DB resources and returns the newly created database resource. The database is created in the Cosmos DB account that’s represented by the `AzureCosmosDBResource` that you added earlier. The database is a logical container for collections and users.

An Azure Cosmos DB container is where data is stored. When you create a container, you need to supply a partition key.

To add an Azure Cosmos DB container resource, call the `AddContainer` method on an `IResourceBuilder<AzureCosmosDBDatabaseResource>` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");
var db = cosmos.AddCosmosDatabase("db");
var container = db.AddContainer("entries", "/id");


// After adding all resources, run the app...
```

The container is created in the database that’s represented by the `AzureCosmosDBDatabaseResource` that you added earlier. For more information, see [Databases, containers, and items in Azure Cosmos DB](https://learn.microsoft.com/azure/cosmos-db/resource-model).

#### Parent child resource relationship example

[Section titled “Parent child resource relationship example”](#parent-child-resource-relationship-example)

To better understand the parent-child relationship between Azure Cosmos DB resources, consider the following example, which demonstrates adding an Azure Cosmos DB resource along with a database and container:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos");


var customers = cosmos.AddCosmosDatabase("customers");
var profiles = customers.AddContainer("profiles", "/id");


var orders = cosmos.AddCosmosDatabase("orders");
var details = orders.AddContainer("details", "/id");
var history = orders.AddContainer("history", "/id");


builder.AddProject<Projects.Api>("api")
    .WithReference(profiles)
    .WithReference(details)
    .WithReference(history);


builder.Build().Run();
```

The preceding code adds an Azure Cosmos DB resource named `cosmos` with two databases: `customers` and `orders`. The `customers` database has a single container named `profiles`, while the `orders` database has two containers: `details` and `history`. The partition key for each container is `/id`.

The following diagram illustrates the parent child relationship between the Azure Cosmos DB resources:

![](/_astro/cosmos-resource-relationships.BuZpjyMd.svg)

When your AppHost code expresses parent-child relationships, the client can deep-link to these resources by name. For example, the `customers` database can be referenced by name in the client project, registering a `Microsoft.Azure.Cosmos.Database` instance that connects to the `customers` database. The same applies to named containers, for example, the `details` container can be referenced by name in the client project, registering a `Microsoft.Azure.Cosmos.Container` instance that connects to the `details` container.

### Add Azure Cosmos DB emulator resource

[Section titled “Add Azure Cosmos DB emulator resource”](#add-azure-cosmos-db-emulator-resource)

To add an Azure Cosmos DB emulator resource, chain a call on an `IResourceBuilder<AzureCosmosDBResource>` to the `RunAsEmulator` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
  .RunAsEmulator();


// After adding all resources, run the app...
```

When you call `RunAsEmulator`, it configures your Cosmos DB resources to run locally using an emulator. The emulator in this case is the [Azure Cosmos DB Emulator](https://learn.microsoft.com/azure/cosmos-db/local-emulator). The Azure Cosmos DB Emulator provides a free local environment for testing your Azure Cosmos DB apps and it’s a perfect companion to the Aspire Azure hosting integration. The emulator isn’t installed, instead, it’s accessible to Aspire as a container. When you add a container to the AppHost, as shown in the preceding example with the `mcr.microsoft.com/cosmosdb/emulator` image, it creates and starts the container when the AppHost starts.

#### Configure Cosmos DB emulator container

[Section titled “Configure Cosmos DB emulator container”](#configure-cosmos-db-emulator-container)

There are various configurations available to container resources, for example, you can configure the container’s ports, environment variables, it’s lifetime, and more.

##### Configure Cosmos DB emulator container gateway port

[Section titled “Configure Cosmos DB emulator container gateway port”](#configure-cosmos-db-emulator-container-gateway-port)

By default, the Cosmos DB emulator container when configured by Aspire, exposes the following endpoints:

| Endpoint | Container port | Host port |
| -------- | -------------- | --------- |
| `https`  | 8081           | dynamic   |

The port that it’s listening on is dynamic by default. When the container starts, the port is mapped to a random port on the host machine. To configure the endpoint port, chain calls on the container resource builder provided by the `RunAsEmulator` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithGatewayPort(7777);
    });


// After adding all resources, run the app...
```

The preceding code configures the Cosmos DB emulator container’s existing `https` endpoint to listen on port `8081`. The Cosmos DB emulator container’s port is mapped to the host port as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------: | ------------------------------- |
|       `https` | `8081:7777`                     |

##### Configure Cosmos DB emulator container with persistent lifetime

[Section titled “Configure Cosmos DB emulator container with persistent lifetime”](#configure-cosmos-db-emulator-container-with-persistent-lifetime)

To configure the Cosmos DB emulator container with a persistent lifetime, call the `WithLifetime` method on the Cosmos DB emulator container resource and pass `ContainerLifetime.Persistent`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithLifetime(ContainerLifetime.Persistent);
    });


// After adding all resources, run the app...
```

##### Configure Cosmos DB emulator container with data volume

[Section titled “Configure Cosmos DB emulator container with data volume”](#configure-cosmos-db-emulator-container-with-data-volume)

To add a data volume to the Azure Cosmos DB emulator resource, call the `WithDataVolume` method on the Azure Cosmos DB emulator resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithDataVolume();
    });


// After adding all resources, run the app...
```

The data volume is used to persist the Cosmos DB emulator data outside the lifecycle of its container. The data volume is mounted at the `/tmp/cosmos/appdata` path in the Cosmos DB emulator container and when a `name` parameter isn’t provided, the name is generated. The emulator has its `AZURE_COSMOS_EMULATOR_ENABLE_DATA_PERSISTENCE` environment variable set to `true`. For more information on data volumes and details on why they’re preferred over bind mounts, see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

#### Configure Cosmos DB emulator container partition count

[Section titled “Configure Cosmos DB emulator container partition count”](#configure-cosmos-db-emulator-container-partition-count)

To configure the partition count of the Cosmos DB emulator container, call the `WithPartitionCount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithPartitionCount(100); // Defaults to 25
    });


// After adding all resources, run the app...
```

The preceding code configures the Cosmos DB emulator container to have a partition count of `100`. This is a shorthand for setting the `AZURE_COSMOS_EMULATOR_PARTITION_COUNT` environment variable.

#### Use Linux-based emulator (preview)

[Section titled “Use Linux-based emulator (preview)”](#use-linux-based-emulator-preview)

The [next generation of the Azure Cosmos DB emulator](https://learn.microsoft.com/azure/cosmos-db/emulator-linux) is entirely Linux-based and is available as a Docker container. It supports running on a wide variety of processors and operating systems.

To use the preview version of the Cosmos DB emulator, call the `RunAsPreviewEmulator` method. Since this feature is in preview, you need to explicitly opt into the preview feature by suppressing the `ASPIRECOSMOSDB001` experimental diagnostic.

The preview emulator also supports exposing a “Data Explorer” endpoint which allows you to view the data stored in the Cosmos DB emulator via a web UI. To enable the Data Explorer, call the `WithDataExplorer` method.

```csharp
#pragma warning disable ASPIRECOSMOSDB001


var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsPreviewEmulator(emulator =>
    {
        emulator.WithDataExplorer();
    });


// After adding all resources, run the app...
```

The preceding code configures the Linux-based preview Cosmos DB emulator container, with the Data Explorer endpoint, to use at run time.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Cosmos DB resource, the following Bicep is generated:

"Generated

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource cosmos 'Microsoft.DocumentDB/databaseAccounts@2024-08-15' = {
  name: take('cosmos-${uniqueString(resourceGroup().id)}', 44)
  location: location
  properties: {
    locations: [
      {
        locationName: location
        failoverPriority: 0
      }
    ]
    capabilities: [
      {
        name: 'EnableServerless'
      }
    ]
    consistencyPolicy: {
      defaultConsistencyLevel: 'Session'
    }
    databaseAccountOfferType: 'Standard'
    disableLocalAuth: true
  }
  kind: 'GlobalDocumentDB'
  tags: {
    'aspire-resource-name': 'cosmos'
  }
}


output connectionString string = cosmos.properties.documentEndpoint


output name string = cosmos.name
```

The preceding Bicep is a module that provisions an Azure Cosmos DB account resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — cosmos-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param cosmos_outputs_name string


param principalId string


resource cosmos 'Microsoft.DocumentDB/databaseAccounts@2024-08-15' existing = {
  name: cosmos_outputs_name
}


resource cosmos_roleDefinition 'Microsoft.DocumentDB/databaseAccounts/sqlRoleDefinitions@2024-08-15' existing = {
  name: '00000000-0000-0000-0000-000000000002'
  parent: cosmos
}


resource cosmos_roleAssignment 'Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments@2024-08-15' = {
  name: guid(principalId, cosmos_roleDefinition.id, cosmos.id)
  properties: {
    principalId: principalId
    roleDefinitionId: cosmos_roleDefinition.id
    scope: cosmos.id
  }
  parent: cosmos
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API. For example, you can configure the `kind`, `consistencyPolicy`, `locations`, and more. The following example demonstrates how to customize the Azure Cosmos DB resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureCosmosDB("cosmos-db")
    .ConfigureInfrastructure(infra =>
    {
        var cosmosDbAccount = infra.GetProvisionableResources()
                                    .OfType<CosmosDBAccount>()
                                    .Single();


        cosmosDbAccount.Kind = CosmosDBAccountKind.MongoDB;
        cosmosDbAccount.ConsistencyPolicy = new()
        {
            DefaultConsistencyLevel = DefaultConsistencyLevel.Strong,
        };
        cosmosDbAccount.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `CosmosDBAccount` is retrieved.
  * The `CosmosDBAccount.ConsistencyPolicy` is assigned to a `DefaultConsistencyLevel.Strong`.
  * A tag is added to the Cosmos DB account with a key of `ExampleKey` and a value of `Example value`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.CosmosDb](https://www.nuget.org/packages/AspNetCore.HealthChecks.CosmosDb) NuGet package.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Cosmos DB resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Cosmos DB account

[Section titled “Cosmos DB account”](#cosmos-db-account)

The Cosmos DB account resource exposes the following connection properties:

| Property Name      | Description                                                                                                                                                      |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`              | The account endpoint URI for the Cosmos DB account, with the format `https://mycosmosaccount.documents.azure.com:443/`                                           |
| `AccountKey`       | The account key for the Cosmos DB account (only available for emulator and access key authentication)                                                            |
| `ConnectionString` | **Emulator or access key authentication only.** A full connection string (includes account key for emulator; access key secret when access key auth is enabled). |

#### Cosmos DB database

[Section titled “Cosmos DB database”](#cosmos-db-database)

The Cosmos DB database resource inherits all properties from its parent Cosmos DB account and adds:

| Property Name  | Description              |
| -------------- | ------------------------ |
| `DatabaseName` | The name of the database |

#### Cosmos DB container

[Section titled “Cosmos DB container”](#cosmos-db-container)

The Cosmos DB container resource inherits all properties from its parent Cosmos DB database and adds:

| Property Name   | Description               |
| --------------- | ------------------------- |
| `ContainerName` | The name of the container |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Microsoft Entity Framework Core Cosmos DB integration, install the [📦 Aspire.Microsoft.EntityFrameworkCore.Cosmos](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.Cosmos) NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.Cosmos package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.Cosmos@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.Cosmos package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.Cosmos" Version="*" />
  ```

### Add Cosmos DB context

[Section titled “Add Cosmos DB context”](#add-cosmos-db-context)

In the `Program.cs` file of your client-consuming project, call the `AddCosmosDbContext` extension method to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter and a database name parameter.

```csharp
builder.AddCosmosDbContext<MyDbContext>("cosmosdb", "databaseName");
```

Alternatively, the database name can be inferred from the connection when there’s a single database in the connection string. In this case, you can omit the database name parameter:

```csharp
builder.AddCosmosDbContext<MyDbContext>("cosmosdb");
```

Tip

The `connectionName` parameter must match the name used when adding the Cosmos DB resource in the AppHost project. In other words, when you call `AddAzureCosmosDB` and provide a name of `cosmosdb` that same name should be used when calling `AddCosmosDbContext`. For more information, see [Add Azure Cosmos DB resource](#add-azure-cosmos-db-resource).

You can then retrieve the `DbContext` instance using dependency injection. For example, to retrieve the client from a service:

```csharp
public class ExampleService(MyDbContext context)
{
    // Use context...
}
```

For more information on using Entity Framework Core with Azure Cosmos DB, see the [Examples for Azure Cosmos DB for NoSQL SDK for .NET](https://learn.microsoft.com/ef/core/providers/cosmos/?tabs=dotnet-core-cli).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `builder.AddCosmosDbContext`:

C# — Program.cs

```csharp
builder.AddCosmosDbContext<MyDbContext>("CosmosConnection");
```

And then the connection string will be retrieved from the `ConnectionStrings` configuration section:

appsettings.json

```json
{
  "ConnectionStrings": {
    "CosmosConnection": "AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"
  }
}
```

For more information, see the [ConnectionString documentation](https://learn.microsoft.com/azure/cosmos-db/nosql/how-to-dotnet-get-started#connect-with-a-connection-string).

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Microsoft Entity Framework Core Cosmos DB integration supports `Microsoft.Extensions.Configuration`. It loads the `EntityFrameworkCoreCosmosSettings` from configuration files such as `appsettings.json`. Example `appsettings.json` that configures some of the options:

appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "EntityFrameworkCore": {
        "Cosmos": {
          "DisableTracing": true
        }
      }
    }
  }
}
```

For the complete Cosmos DB client integration JSON schema, see [Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json).

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<EntityFrameworkCoreCosmosSettings> configureSettings` delegate to set up some or all the `EntityFrameworkCoreCosmosSettings` options inline, for example to disable tracing from code:

```csharp
builder.AddCosmosDbContext<MyDbContext>(
    "cosmosdb",
    settings => settings.DisableTracing = true);
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

The Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn’t implement health checks, though this may change in future releases.

#### Logging

[Section titled “Logging”](#logging)

The Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories:

* `Azure-Cosmos-Operation-Request-Diagnostics`
* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Query`

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry:

* `Azure.Cosmos.Operation`
* `OpenTelemetry.Instrumentation.EntityFrameworkCore`

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics:

* `Microsoft.EntityFrameworkCore`

  * `ec_Microsoft_EntityFrameworkCore_active_db_contexts`
  * `ec_Microsoft_EntityFrameworkCore_total_queries`
  * `ec_Microsoft_EntityFrameworkCore_queries_per_second`
  * `ec_Microsoft_EntityFrameworkCore_total_save_changes`
  * `ec_Microsoft_EntityFrameworkCore_save_changes_per_second`
  * `ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate`
  * `ec_Microsoft_Entity_total_execution_strategy_operation_failures`
  * `ec_Microsoft_E_execution_strategy_operation_failures_per_second`
  * `ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures`
  * `ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second`

# Azure Event Hubs integration

> This article describes the Aspire Azure Event Hubs integration features and capabilities.

![Azure Event Hubs logo](/_astro/azure-eventhubs-icon.8SLmUE2W_1FQERq.webp)

[Azure Event Hubs](https://learn.microsoft.com/event-hubs/event-hubs-about) is a native data-streaming service in the cloud that can stream millions of events per second, with low latency, from any source to any destination. The Aspire Azure Event Hubs integration enables you to connect to Azure Event Hubs instances from your applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure Event Hubs hosting integration models the various Event Hub resources as the following types:

* `AzureEventHubsResource`: Represents a top-level Azure Event Hubs resource, used for representing collections of hubs and the connection information to the underlying Azure resource.
* `AzureEventHubResource`: Represents a single Event Hub resource.
* `AzureEventHubsEmulatorResource`: Represents an Azure Event Hubs emulator as a container resource.
* `AzureEventHubConsumerGroupResource`: Represents a consumer group within an Event Hub resource.

To access these types and APIs for expressing them within your [AppHost](/get-started/app-host/) project, install the [📦 Aspire.Hosting.Azure.EventHubs](https://www.nuget.org/packages/Aspire.Hosting.Azure.EventHubs) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.EventHubs package

  ```bash
  aspire add azure-eventhubs
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-eventhubs (Aspire.Hosting.Azure.EventHubs)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.EventHubs@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.EventHubs package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.EventHubs" Version="*" />
  ```

### Add an Azure Event Hubs resource

[Section titled “Add an Azure Event Hubs resource”](#add-an-azure-event-hubs-resource)

To add an `AzureEventHubsResource` to your AppHost project, call the `AddAzureEventHubs` method providing a name, and then call `AddHub`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs");
eventHubs.AddHub("messages");


builder.AddProject<Projects.ExampleService>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

When you add an Azure Event Hubs resource to the AppHost, it exposes other useful APIs to add Event Hub resources, consumer groups, express explicit provisioning configuration, and enables the use of the Azure Event Hubs emulator. The preceding code adds an Azure Event Hubs resource named `event-hubs` and an Event Hub named `messages` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleService` project.

Caution

When you call `AddAzureEventHubs`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Event Hubs namespace

[Section titled “Connect to an existing Azure Event Hubs namespace”](#connect-to-an-existing-azure-event-hubs-namespace)

You might have an existing Azure Event Hubs service that you want to connect to. You can chain a call to annotate that your `AzureEventHubsResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingEventHubsName = builder.AddParameter("existingEventHubsName");
var existingEventHubsResourceGroup = builder.AddParameter("existingEventHubsResourceGroup");


var eventHubs = builder.AddAzureEventHubs("event-hubs")
    .AsExisting(existingEventHubsName, existingEventHubsResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

For more information on treating Azure Event Hubs resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure Event Hubs resource, you can add a connection string to the AppHost. This approach is weakly-typed, and doesn’t work with role assignments or infrastructure customizations. For more information, see [Add existing Azure resources with connection strings](/integrations/cloud/azure/overview/#add-existing-azure-resources-with-connection-strings).

### Add Event Hub consumer group

[Section titled “Add Event Hub consumer group”](#add-event-hub-consumer-group)

To add a consumer group, chain a call on an `IResourceBuilder<AzureEventHubsResource>` to the `AddConsumerGroup` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs");
var messages = eventHubs.AddHub("messages");
messages.AddConsumerGroup("messagesConsumer");


builder.AddProject<Projects.ExampleService>()
       .WithReference(eventHubs);


// After adding all resources, run the app...
```

When you call `AddConsumerGroup`, it configures your `messages` Event Hub resource to have a consumer group named `messagesConsumer`. The consumer group is created in the Azure Event Hubs namespace that’s represented by the `AzureEventHubsResource` that you added earlier. For more information, see [Azure Event Hubs: Consumer groups](https://learn.microsoft.com/event-hubs/event-hubs-features#consumer-groups).

### Add Azure Event Hubs emulator resource

[Section titled “Add Azure Event Hubs emulator resource”](#add-azure-event-hubs-emulator-resource)

The Aspire Azure Event Hubs hosting integration supports running the Event Hubs resource as an emulator locally, based on the `mcr.microsoft.com/azure-messaging/eventhubs-emulator/latest` container image. This is beneficial for situations where you want to run the Event Hubs resource locally for development and testing purposes, avoiding the need to provision an Azure resource or connect to an existing Azure Event Hubs server.

To run the Event Hubs resource as an emulator, call the `RunAsEmulator` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs")
    .RunAsEmulator();


eventHubs.AddHub("messages");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

The preceding code configures an Azure Event Hubs resource to run locally in a container. For more information, see [Azure Event Hubs Emulator](https://learn.microsoft.com/azure/event-hubs/overview-emulator).

#### Configure Event Hubs emulator container

[Section titled “Configure Event Hubs emulator container”](#configure-event-hubs-emulator-container)

There are various configurations available for container resources, for example, you can configure the container’s ports, data bind mounts, data volumes, or providing a wholistic JSON configuration which overrides everything.

##### Configure Event Hubs emulator container host port

[Section titled “Configure Event Hubs emulator container host port”](#configure-event-hubs-emulator-container-host-port)

By default, the Event Hubs emulator container when configured by Aspire exposes the following endpoints:

| Endpoint   | Image                                                         | Container port | Host port |
| ---------- | ------------------------------------------------------------- | -------------- | --------- |
| `emulator` | `mcr.microsoft.com/azure-messaging/eventhubs-emulator/latest` | 5672           | dynamic   |

The port that it’s listening on is dynamic by default. When the container starts, the port is mapped to a random port on the host machine. To configure the endpoint port, chain calls on the container resource builder provided by the `RunAsEmulator` method and then the `WithHostPort` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs")
    .RunAsEmulator(emulator =>
    {
        emulator.WithHostPort(7777);
    });


eventHubs.AddHub("messages");


builder.AddProject<Projects.ExampleService>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

The preceding code configures the Azure Event emulator container’s existing `emulator` endpoint to listen on port `7777`. The Azure Event emulator container’s port is mapped to the host port as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------- | ------------------------------- |
| `emulator`    | `5672:7777`                     |

##### Add Event Hubs emulator with data volume

[Section titled “Add Event Hubs emulator with data volume”](#add-event-hubs-emulator-with-data-volume)

To add a data volume to the Event Hubs emulator resource, call the `WithDataVolume` method on the Event Hubs emulator resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs")
    .RunAsEmulator(emulator =>
    {
        emulator.WithDataVolume();
    });


eventHubs.AddHub("messages");


builder.AddProject<Projects.ExampleService>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

The data volume is used to persist the Event Hubs emulator data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the container. A name is generated at random unless you provide a set the `name` parameter. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-event-hubs-emulator-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

##### Add Event Hubs emulator with data bind mount

[Section titled “Add Event Hubs emulator with data bind mount”](#add-event-hubs-emulator-with-data-bind-mount)

The add a bind mount to the Event Hubs emulator container, chain a call to the `WithDataBindMount` API, as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs")
    .RunAsEmulator(emulator =>
    {
        emulator.WithDataBindMount("/path/to/data");
    });


eventHubs.AddHub("messages");


builder.AddProject<Projects.ExampleService>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

Data bind mounts rely on the host machine’s filesystem to persist the Azure Event Hubs emulator resource data across container restarts. The data bind mount is mounted at the `/path/to/data` path on the host machine in the container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

##### Configure Event Hubs emulator container JSON configuration

[Section titled “Configure Event Hubs emulator container JSON configuration”](#configure-event-hubs-emulator-container-json-configuration)

The Event Hubs emulator container runs with a default [*config.json*](https://github.com/Azure/azure-event-hubs-emulator-installer/blob/main/EventHub-Emulator/Config/Config.json) file. You can override this file entirely, or update the JSON configuration with a `JsonNode` representation of the configuration.

To provide a custom JSON configuration file, call the `WithConfigurationFile` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs")
  .RunAsEmulator(emulator =>
  {
      emulator.WithConfigurationFile("./messaging/custom-config.json");
  });


eventHubs.AddHub("messages");


builder.AddProject<Projects.ExampleService>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

The preceding code configures the Event Hubs emulator container to use a custom JSON configuration file located at `./messaging/custom-config.json`. This will be mounted at the `/Eventhubs_Emulator/ConfigFiles/Config.json` path on the container, as a read-only file. To instead override specific properties in the default configuration, call the `WithConfiguration` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var eventHubs = builder.AddAzureEventHubs("event-hubs")
    .RunAsEmulator(emulator =>
    {
        emulator.WithConfiguration(
            (JsonNode configuration) =>
            {
                var userConfig = configuration["UserConfig"];
                var ns = userConfig["NamespaceConfig"][0];
                var firstEntity = ns["Entities"][0];


                firstEntity["PartitionCount"] = 5;
            });
    });


eventHubs.AddHub("messages");


builder.AddProject<Projects.ExampleService>()
    .WithReference(eventHubs);


// After adding all resources, run the app...
```

The preceding code retrieves the `UserConfig` node from the default configuration. It then updates the first entity’s `PartitionCount` to `5`.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand; instead, the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Event Hubs resource, the following Bicep is generated:

Generated Bicep — event-hubs.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param sku string = 'Standard'


resource event_hubs 'Microsoft.EventHub/namespaces@2024-01-01' = {
  name: take('event_hubs-${uniqueString(resourceGroup().id)}', 256)
  location: location
  properties: {
    disableLocalAuth: true
  }
  sku: {
    name: sku
  }
  tags: {
    'aspire-resource-name': 'event-hubs'
  }
}


resource messages 'Microsoft.EventHub/namespaces/eventhubs@2024-01-01' = {
  name: 'messages'
  parent: event_hubs
}


output eventHubsEndpoint string = event_hubs.properties.serviceBusEndpoint


output name string = event_hubs.name
```

The preceding Bicep is a module that provisions an Azure Event Hubs resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — event-hubs-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param event_hubs_outputs_name string


param principalType string


param principalId string


resource event_hubs 'Microsoft.EventHub/namespaces@2024-01-01' existing = {
  name: event_hubs_outputs_name
}


resource event_hubs_AzureEventHubsDataOwner 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(event_hubs.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'f526a384-b230-433a-b45c-95f59c4a2dec'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'f526a384-b230-433a-b45c-95f59c4a2dec')
    principalType: principalType
  }
  scope: event_hubs
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API. For example, you can configure the `kind`, `consistencyPolicy`, `locations`, and more. The following example demonstrates how to customize the Azure Event Hubs resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureEventHubs("event-hubs")
    .ConfigureInfrastructure(infra =>
    {
        var eventHubs = infra.GetProvisionableResources()
                              .OfType<EventHubsNamespace>()
                              .Single();


        eventHubs.Sku = new EventHubsSku()
        {
            Name = EventHubsSkuName.Premium,
            Tier = EventHubsSkuTier.Premium,
            Capacity = 7,
        };
        eventHubs.PublicNetworkAccess = EventHubsPublicNetworkAccess.SecuredByPerimeter;
        eventHubs.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `EventHubsNamespace` resource is retrieved.
  * The `Sku` property is assigned to a new instance of `EventHubsSku` with a `Premium` name and tier, and a `Capacity` of `7`.
  * The `PublicNetworkAccess` property is assigned to `SecuredByPerimeter`.
  * A tag is added to the Event Hubs resource with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Event Hubs resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Azure Event Hubs hosting integration automatically adds a health check for the Event Hubs resource. The health check verifies that the Event Hubs is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.Azure.Messaging.EventHubs](https://www.nuget.org/packages/AspNetCore.HealthChecks.Azure.Messaging.EventHubs) NuGet package.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Event Hubs resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Event Hubs namespace

[Section titled “Event Hubs namespace”](#event-hubs-namespace)

The Event Hubs namespace resource exposes the following connection properties:

| Property Name      | Description                                                                                                                                                     |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`             | The hostname of the Event Hubs namespace                                                                                                                        |
| `Port`             | The port of the Event Hubs namespace when the emulator is used                                                                                                  |
| `Uri`              | The connection URI for the Event Hubs namespace, with the format `sb://myeventhubs.servicebus.windows.net` on azure and `sb://localhost:62824` for the emulator |
| `ConnectionString` | **Emulator only.** Includes SAS key material for the local emulator connection.                                                                                 |

#### Event Hub

[Section titled “Event Hub”](#event-hub)

The Event Hub resource inherits all properties from its parent Event Hubs namespace and adds:

| Property Name  | Description               |
| -------------- | ------------------------- |
| `EventHubName` | The name of the event hub |

#### Event Hub consumer group

[Section titled “Event Hub consumer group”](#event-hub-consumer-group)

The Event Hub consumer group resource inherits all properties from its parent Event Hub and adds:

| Property Name       | Description                    |
| ------------------- | ------------------------------ |
| `ConsumerGroupName` | The name of the consumer group |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `eh1` becomes `EH1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure Event Hubs client integration, install the [📦 Aspire.Azure.Messaging.EventHubs](https://www.nuget.org/packages/Aspire.Azure.Messaging.EventHubs) NuGet package in the client-consuming project, that is, the project for the application that uses the Event Hubs client.

* .NET CLI

  .NET CLI — Add Aspire.Azure.Messaging.EventHubs package

  ```bash
  dotnet add package Aspire.Azure.Messaging.EventHubs
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Messaging.EventHubs@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Messaging.EventHubs package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Messaging.EventHubs" Version="*" />
  ```

### Supported Event Hubs client types

[Section titled “Supported Event Hubs client types”](#supported-event-hubs-client-types)

The following Event Hub clients are supported by the library, along with their corresponding options and settings classes:

| Azure client type                | Azure options class                     | Aspire settings class                              |
| -------------------------------- | --------------------------------------- | -------------------------------------------------- |
| `EventHubProducerClient`         | `EventHubProducerClientOptions`         | `AzureMessagingEventHubsProducerSettings`          |
| `EventHubBufferedProducerClient` | `EventHubBufferedProducerClientOptions` | `AzureMessagingEventHubsBufferedProducerSettings`  |
| `EventHubConsumerClient`         | `EventHubConsumerClientOptions`         | `AzureMessagingEventHubsConsumerSettings`          |
| `EventProcessorClient`           | `EventProcessorClientOptions`           | `AzureMessagingEventHubsProcessorSettings`         |
| PartitionReceiver Class          | `PartitionReceiverOptions`              | `AzureMessagingEventHubsPartitionReceiverSettings` |

The client types are from the Azure SDK for .NET, as are the corresponding options classes. The settings classes are provided by Aspire. The settings classes are used to configure the client instances.

### Add an Event Hubs producer client

[Section titled “Add an Event Hubs producer client”](#add-an-event-hubs-producer-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureEventHubProducerClient` extension method on any `IHostApplicationBuilder` to register an `EventHubProducerClient` for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddAzureEventHubProducerClient(connectionName: "event-hubs");
```

Tip

The `connectionName` parameter must match the name used when adding the Event Hubs resource in the AppHost project. For more information, see [Add an Azure Event Hubs resource](#add-an-azure-event-hubs-resource).

After adding the `EventHubProducerClient`, you can retrieve the client instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

```csharp
public class ExampleService(EventHubProducerClient client)
{
    // Use client...
}
```

For more information, see:

* [Azure.Messaging.EventHubs documentation](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/eventhub/Azure.Messaging.EventHubs/README.md) for examples on using the `EventHubProducerClient`.
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.

#### Additional APIs to consider

[Section titled “Additional APIs to consider”](#additional-apis-to-consider)

The client integration provides additional APIs to configure client instances. When you need to register an Event Hubs client, consider the following APIs:

| Azure client type                | Registration API                         |
| -------------------------------- | ---------------------------------------- |
| `EventHubProducerClient`         | `AddAzureEventHubProducerClient`         |
| `EventHubBufferedProducerClient` | `AddAzureEventHubBufferedProducerClient` |
| `EventHubConsumerClient`         | `AddAzureEventHubConsumerClient`         |
| `EventProcessorClient`           | `AddAzureEventProcessorClient`           |
| `PartitionReceiver`              | `AddAzurePartitionReceiverClient`        |

All of the aforementioned APIs include optional parameters to configure the client instances.

### Add keyed Event Hubs producer client

[Section titled “Add keyed Event Hubs producer client”](#add-keyed-event-hubs-producer-client)

There might be situations where you want to register multiple `EventHubProducerClient` instances with different connection names. To register keyed Event Hubs clients, call the `AddKeyedAzureEventHubProducerClient` method:

```csharp
builder.AddKeyedAzureEventHubProducerClient(name: "messages");
builder.AddKeyedAzureEventHubProducerClient(name: "commands");
```

Caution

When using keyed services, it’s expected that your Event Hubs resource configured two named hubs, one for the `messages` and one for the `commands`.

Then you can retrieve the client instances using dependency injection. For example, to retrieve the clients from a service:

```csharp
public class ExampleService(
    [KeyedService("messages")] EventHubProducerClient messagesClient,
    [KeyedService("commands")] EventHubProducerClient commandsClient)
{
    // Use clients...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

#### Additional keyed APIs to consider

[Section titled “Additional keyed APIs to consider”](#additional-keyed-apis-to-consider)

The client integration provides additional APIs to configure keyed client instances. When you need to register a keyed Event Hubs client, consider the following APIs:

| Azure client type                | Registration API                              |
| -------------------------------- | --------------------------------------------- |
| `EventHubProducerClient`         | `AddKeyedAzureEventHubProducerClient`         |
| `EventHubBufferedProducerClient` | `AddKeyedAzureEventHubBufferedProducerClient` |
| `EventHubConsumerClient`         | `AddKeyedAzureEventHubConsumerClient`         |
| `EventProcessorClient`           | `AddKeyedAzureEventProcessorClient`           |
| PartitionReceiver class          | `AddKeyedAzurePartitionReceiverClient`        |

All of the aforementioned APIs include optional parameters to configure the client instances.

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure Event Hubs library provides multiple options to configure the Azure Event Hubs connection based on the requirements and conventions of your project. Either a `FullyQualifiedNamespace` or a `ConnectionString` is required to be supplied.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name of the connection string when calling `builder.AddAzureEventHubProducerClient()` and other supported Event Hubs clients. In this example, the connection string does not include the `EntityPath` property, so the `EventHubName` property must be set in the settings callback:

```csharp
builder.AddAzureEventHubProducerClient(
    "event-hubs",
    static settings =>
    {
        settings.EventHubName = "MyHub";
    });
```

And then the connection information will be retrieved from the `ConnectionStrings` configuration section. Two connection formats are supported:

##### Fully Qualified Namespace (FQN)

[Section titled “Fully Qualified Namespace (FQN)”](#fully-qualified-namespace-fqn)

The recommended approach is to use a fully qualified namespace, which works with the `Credential` property to establish a connection. If no credential is configured, the `DefaultAzureCredential` is used.

```json
{
  "ConnectionStrings": {
    "event-hubs": "{your_namespace}.servicebus.windows.net"
  }
}
```

#### Connection string

[Section titled “Connection string”](#connection-string)

Alternatively, use a connection string:

```json
{
  "ConnectionStrings": {
    "event-hubs": "Endpoint=sb://mynamespace.servicebus.windows.net/;SharedAccessKeyName=accesskeyname;SharedAccessKey=accesskey;EntityPath=MyHub"
  }
}
```

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Azure Event Hubs library supports `Microsoft.Extensions.Configuration`. It loads the `AzureMessagingEventHubsSettings` and the associated Options, e.g. `EventProcessorClientOptions`, from configuration by using the `Aspire:Azure:Messaging:EventHubs:` key prefix, followed by the name of the specific client in use. For example, consider the `appsettings.json` that configures some of the options for an `EventProcessorClient`:

```json
{
  "Aspire": {
    "Azure": {
      "Messaging": {
        "EventHubs": {
          "EventProcessorClient": {
            "EventHubName": "MyHub",
            "ClientOptions": {
              "Identifier": "PROCESSOR_ID"
            }
          }
        }
      }
    }
  }
}
```

For the complete Azure Event Hubs client integration JSON schema, see [Aspire.Azure.Messaging.EventHubs/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Azure.Messaging.EventHubs/ConfigurationSchema.json).

### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Aspire Azure Event Hubs library supports named configuration, which allows you to configure multiple instances of the same client type with different settings. The named configuration uses the connection name as a key under the specific client configuration section.

```json
{
  "Aspire": {
    "Azure": {
      "Messaging": {
        "EventHubs": {
          "EventProcessorClient": {
            "processor1": {
              "EventHubName": "MyHub1",
              "ClientOptions": {
                "Identifier": "PROCESSOR_1"
              }
            },
            "processor2": {
              "EventHubName": "MyHub2",
              "ClientOptions": {
                "Identifier": "PROCESSOR_2"
              }
            }
          }
        }
      }
    }
  }
}
```

In this example, the `processor1` and `processor2` connection names can be used when calling `AddAzureEventProcessorClient`:

```csharp
builder.AddAzureEventProcessorClient("processor1");
builder.AddAzureEventProcessorClient("processor2");
```

Named configuration takes precedence over the top-level configuration. If both are provided, the settings from the named configuration override the top-level settings.

You can also setup the Options type using the optional `Action<IAzureClientBuilder<EventProcessorClient, EventProcessorClientOptions>> configureClientBuilder` parameter of the `AddAzureEventProcessorClient` method. For example, to set the processor’s client ID for this client:

```csharp
builder.AddAzureEventProcessorClient(
    "event-hubs",
    configureClientBuilder: clientBuilder => clientBuilder.ConfigureOptions(
        options => options.Identifier = "PROCESSOR_ID"));
```

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire Azure Event Hubs integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure Event Hubs integration will emit the following tracing activities using OpenTelemetry:

* `Azure.Messaging.EventHubs.*`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure Event Hubs integration currently doesn’t support metrics by default due to limitations with the Azure SDK for .NET. If that changes in the future, this section will be updated to reflect those changes.

# Azure Functions integration

> This article describes the Aspire Azure Functions integration features and capabilities.

Choose a development environment

Visual Studio Code  Visual Studio  .NET CLI

![Azure Functions logo](/_astro/azure-functionapps-icon.C0faWE2U_MNx4J.webp)

[Azure Functions](https://learn.microsoft.com/azure-functions) is a serverless compute service that lets you run event-triggered code without having to explicitly provision or manage infrastructure. The Aspire Azure Functions integration enables you to model Azure Functions projects as part of your distributed application.

It’s expected that you’ve installed the required Azure tooling:

* [Configure Visual Studio for Azure development with .NET](https://learn.microsoft.com/dotnet/azure/configure-visual-studio)

- [Configure Visual Studio Code for Azure development with .NET](https://learn.microsoft.com/dotnet/azure/configure-vs-code)

* [Install the Azure Functions Core Tools](https://learn.microsoft.com/azure/azure-functions/functions-run-local?tabs=isolated-process\&pivots=programming-language-csharp#install-the-azure-functions-core-tools)

## Supported scenarios

[Section titled “Supported scenarios”](#supported-scenarios)

The Aspire Azure Functions integration has several key supported scenarios. This section outlines the scenarios and provides details related to the implementation of each approach.

### Supported triggers

[Section titled “Supported triggers”](#supported-triggers)

The following table lists the supported triggers for Azure Functions in the Aspire integration:

| Trigger                      | Attribute           | Details                                                                                              |
| ---------------------------- | ------------------- | ---------------------------------------------------------------------------------------------------- |
| Azure Event Hubs trigger     | `EventHubTrigger`   | [📦 Aspire.Hosting.Azure.EventHubs](https://www.nuget.org/packages/Aspire.Hosting.Azure.EventHubs)   |
| Azure Service Bus trigger    | `ServiceBusTrigger` | [📦 Aspire.Hosting.Azure.ServiceBus](https://www.nuget.org/packages/Aspire.Hosting.Azure.ServiceBus) |
| Azure Storage Blobs trigger  | `BlobTrigger`       | [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage)       |
| Azure Storage Queues trigger | `QueueTrigger`      | [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage)       |
| Azure CosmosDB trigger       | `CosmosDbTrigger`   | [📦 Aspire.Hosting.Azure.CosmosDB](https://www.nuget.org/packages/Aspire.Hosting.Azure.CosmosDB)     |
| HTTP trigger                 | `HttpTrigger`       | Supported without any additional resource dependencies.                                              |
| Timer trigger                | `TimerTrigger`      | Supported without any additional resource dependencies—relies on implicit host storage.              |

Caution

Other Azure Functions triggers and bindings aren’t currently supported in the Aspire Azure Functions integration.

### Deployment

[Section titled “Deployment”](#deployment)

Deployment to Azure Container Apps (ACA) is supported using the SDK container publish function in `Microsoft.Azure.Functions.Worker.Sdk`. When deploying to Azure Container Apps, KEDA-based auto-scaling rules will automatically be configured for your functions.

For more information about the Azure Functions integration with Aspire, see [Azure Functions and Aspire integration](https://learn.microsoft.com/azure/azure-functions/dotnet-aspire-integration).

#### Configure external HTTP endpoints

[Section titled “Configure external HTTP endpoints”](#configure-external-http-endpoints)

To make HTTP triggers publicly accessible, call the `WithExternalHttpEndpoints` API on the `AzureFunctionsProjectResource`. For more information, see [Add Azure Functions resource](#add-azure-functions-resource).

## Azure Function project constraints

[Section titled “Azure Function project constraints”](#azure-function-project-constraints)

The Aspire Azure Functions integration has the following project constraints:

* You must target .NET 8.0 or later.

* You must use a .NET 9 SDK or later.

* It currently only supports .NET workers with the [isolated worker model](https://learn.microsoft.com/azure/azure-functions/dotnet-isolated-process-guide).

* Requires the following NuGet packages:

  * [📦 Microsoft.Azure.Functions.Worker](https://www.nuget.org/packages/Microsoft.Azure.Functions.Worker): Use the `FunctionsApplicationBuilder`.
  * [📦 Microsoft.Azure.Functions.Worker.Sdk](https://www.nuget.org/packages/Microsoft.Azure.Functions.Worker.Sdk): Adds support for `aspire run` and `aspire deploy`.
  * [📦 Microsoft.Azure.Functions.Http.AspNetCore](https://www.nuget.org/packages/Microsoft.Azure.Functions.Worker.Extensions.Http.AspNetCore): Adds HTTP trigger-supporting APIs.

If you encounter issues with the Azure Functions project, such as:

> There is no Functions runtime available that matches the version specified in the project

In Visual Studio, try checking for an update on the Azure Functions tooling. Open the **Options** dialog, navigate to **Projects and Solutions**, and then select **Azure Functions**. Select the **Check for updates** button to ensure you have the latest version of the Azure Functions tooling:

![Visual Studio: Options / Projects and Solutions / Azure Functions.](/_astro/visual-studio-azure-functions-options.BbabHvWK_Z1raakf.webp)

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure Functions hosting integration models Azure Functions projects as the `AzureFunctionsProjectResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.Functions](https://www.nuget.org/packages/Aspire.Hosting.Azure.Functions) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Functions package

  ```bash
  aspire add azure-functions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-functions (Aspire.Hosting.Azure.Functions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Functions@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Functions package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Functions" Version="*" />
  ```

### Add Azure Functions resource

[Section titled “Add Azure Functions resource”](#add-azure-functions-resource)

In your AppHost project, call `AddAzureFunctionsProject` on the `builder` instance to add an Azure Functions resource. There are two ways to add an Azure Functions project, depending on whether the Functions project is referenced in your AppHost project.

#### Add a referenced Functions project

[Section titled “Add a referenced Functions project”](#add-a-referenced-functions-project)

If the Azure Functions project is referenced in your AppHost project, use the generic overload of `AddAzureFunctionsProject`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var functions = builder.AddAzureFunctionsProject<Projects.ExampleFunctions>("functions")
    .WithExternalHttpEndpoints();


builder.AddProject<Projects.ExampleProject>()
    .WithReference(functions)
    .WaitFor(functions);


// After adding all resources, run the app...
```

#### Add a Functions project by file path

[Section titled “Add a Functions project by file path”](#add-a-functions-project-by-file-path)

If the Azure Functions project is not referenced in your AppHost project, you can add it by specifying the path to the project file:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var functions = builder.AddAzureFunctionsProject("functions", "../MyFunctions/MyFunctions.csproj")
    .WithExternalHttpEndpoints();


builder.AddProject<Projects.ExampleProject>()
    .WithReference(functions)
    .WaitFor(functions);


// After adding all resources, run the app...
```

In the preceding example, the path to the Functions project file is relative to the AppHost project directory. If the path is not absolute, it will be resolved relative to the AppHost directory.

***

When Aspire adds an Azure Functions project resource to the AppHost, as shown in the preceding examples, the `functions` resource can be referenced by other project resources. The `WithReference` method configures a connection in the `ExampleProject` named `"functions"`. If the Azure Resource was deployed and it exposed an HTTP trigger, its endpoint would be external due to the call to `WithExternalHttpEndpoints`.

### Add Azure Functions resource with host storage

[Section titled “Add Azure Functions resource with host storage”](#add-azure-functions-resource-with-host-storage)

If you want to modify the default host storage account that the Azure Functions host uses, call the `WithHostStorage` method on the Azure Functions project resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator();


var functions = builder.AddAzureFunctionsProject<Projects.ExampleFunctions>("functions")
    .WithHostStorage(storage);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(functions)
    .WaitFor(functions);


// After adding all resources, run the app...
```

The preceding code relies on the [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage) NuGet package to add an Azure Storage resource that runs as an emulator. The `storage` resource is then passed to the `WithHostStorage` API, explicitly setting the host storage to the emulated resource.

Note

If you’re not using the implicit host storage, you must manually assign the `StorageAccountContributor` role to your resource for deployed instances. The implicit host storage is automatically configured with the following roles to support maximum interoperability with all scenarios:

* `StorageBlobDataContributor`
* `StorageTableDataContributor`
* `StorageQueueDataContributor`
* `StorageAccountContributor`

For production scenarios, it is recommended to register the storage account explicitly with the `WithHostStorage` and `WithRoleAssignment` APIs and register a more tailored set of roles.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage");


builder.AddAzureFunctionsProject<Projects.ExampleFunctions>("functions")
       .WithHostStorage(storage)
       .WithRoleAssignments(storage, StorageBuiltInRole.StorageBlobDataReader,
                                    StorageBuiltInRole.StorageQueueDataReader);
```

### Reference resources in Azure Functions

[Section titled “Reference resources in Azure Functions”](#reference-resources-in-azure-functions)

To reference other Azure resources in an Azure Functions project, chain a call to `WithReference` on the Azure Functions project resource and provide the resource to reference:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage").RunAsEmulator();
var blobs = storage.AddBlobs("blobs");


builder.AddAzureFunctionsProject<Projects.ExampleFunctions>("functions")
    .WithHostStorage(storage)
    .WithReference(blobs);


builder.Build().Run();
```

The preceding code adds an Azure Storage resource to the AppHost and references it in the Azure Functions project. The `blobs` resource is added to the `storage` resource and then referenced by the `functions` resource. The connection information required to connect to the `blobs` resource is automatically injected into the Azure Functions project and enables the project to define a `BlobTrigger` that relies on `blobs` resource.

# Azure Key Vault

> Learn how to use the Azure Key Vault integration to securely store and access secrets, keys, and certificates.

![Azure Key Vault logo](/_astro/azure-keyvault-icon.1ZBAx6bH_2nWpTI.webp)

[Azure Key Vault](https://learn.microsoft.com/azure/key-vault/general/overview) helps safeguard cryptographic keys and secrets used by cloud applications and services. The Aspire Azure Key Vault integration enables you to connect to existing Azure Key Vault instances.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Azure Key Vault hosting integration models an Azure Key Vault resource as the `AzureKeyVaultResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Azure.KeyVault](https://www.nuget.org/packages/Aspire.Hosting.Azure.KeyVault) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.KeyVault package

  ```bash
  aspire add azure-keyvault
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-keyvault (Aspire.Hosting.Azure.KeyVault)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.KeyVault@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.KeyVault package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.KeyVault" Version="*" />
  ```

### Add Azure Key Vault resource

[Section titled “Add Azure Key Vault resource”](#add-azure-key-vault-resource)

In your AppHost project, call `AddAzureKeyVault` on the builder instance to add an Azure Key Vault resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keyVault = builder.AddAzureKeyVault("key-vault");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(keyVault);


// After adding all resources, run the app...
```

The `WithReference` method configures a connection in the `ExampleProject` named `"key-vault"`.

Caution

By default, `AddAzureKeyVault` configures a [Key Vault Administrator built-in role](https://learn.microsoft.com/azure/role-based-access-control/built-in-roles/security#key-vault-administrator).

Tip

When you call `AddAzureKeyVault`, it implicitly calls `AddAzureProvisioning`, which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Key Vault instance

[Section titled “Connect to an existing Azure Key Vault instance”](#connect-to-an-existing-azure-key-vault-instance)

You might have an existing Azure Key Vault instance that you want to connect to. You can chain a call to annotate that your resource is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingKeyVaultName = builder.AddParameter("existingKeyVaultName");
var existingKeyVaultResourceGroup = builder.AddParameter("existingKeyVaultResourceGroup");


var keyvault = builder.AddAzureKeyVault("key-vault")
    .AsExisting(existingKeyVaultName, existingKeyVaultResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(keyvault);
```

Note

Alternatively, instead of representing an Azure Key Vault resource, you can add a connection string to the AppHost. This approach is weakly-typed and doesn’t work with role assignments or infrastructure customizations.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you add an Azure Key Vault resource, the following Bicep is generated:

:::code language=“bicep” source=”../snippets/azure/AppHost/key-vault/key-vault.bicep”:::

Generated Bicep — key-vault.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource key_vault 'Microsoft.KeyVault/vaults@2024-11-01' = {
  name: take('keyvault-${uniqueString(resourceGroup().id)}', 24)
  location: location
  properties: {
    tenantId: tenant().tenantId
    sku: {
      family: 'A'
      name: 'standard'
    }
    enableRbacAuthorization: true
  }
  tags: {
    'aspire-resource-name': 'key-vault'
  }
}


output vaultUri string = key_vault.properties.vaultUri


output name string = key_vault.name
```

The preceding Bicep is a module that provisions an Azure Key Vault resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — key-vault-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param key_vault_outputs_name string


param principalType string


param principalId string


resource key_vault 'Microsoft.KeyVault/vaults@2024-11-01' existing = {
  name: key_vault_outputs_name
}


resource key_vault_KeyVaultSecretsUser 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(key_vault.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '4633458b-17de-408a-b874-0445c86b69e6'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '4633458b-17de-408a-b874-0445c86b69e6')
    principalType: principalType
  }
  scope: key_vault
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API. For example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureKeyVault("key-vault")
    .ConfigureInfrastructure(infra =>
    {
        var keyVault = infra.GetProvisionableResources()
                            .OfType<KeyVaultService>()
                            .Single();


        keyVault.Properties.Sku = new()
        {
            Family = KeyVaultSkuFamily.A,
            Name = KeyVaultSkuName.Premium,
        };
        keyVault.Properties.EnableRbacAuthorization = true;
        keyVault.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `KeyVaultService` resource is retrieved.
  * The `Sku` property is set to a new `KeyVault.KeyVaultSku` instance.
  * The `KeyVaultProperties.EnableRbacAuthorization` property is set to `true`.
  * A tag is added to the resource with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Key Vault resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Key Vault resources using `WithReference`, the following connection properties are made available to the consuming project:

| Property Name | Description                                                                   |
| ------------- | ----------------------------------------------------------------------------- |
| `Uri`         | The Key Vault endpoint URI, typically `https://<vault-name>.vault.azure.net/` |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `kv1` becomes `KV1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure Key Vault client integration, install the [📦 Aspire.Azure.Security.KeyVault](https://www.nuget.org/packages/Aspire.Azure.Security.KeyVault) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.Azure.Security.KeyVault package

  ```bash
  dotnet add package Aspire.Azure.Security.KeyVault
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Security.KeyVault@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Security.KeyVault package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Security.KeyVault" Version="*" />
  ```

The client integration provides two ways to access secrets from Azure Key Vault:

* Add secrets to app configuration, using either the `IConfiguration` or the `IOptions<T>` pattern.
* Use a `SecretClient` to retrieve secrets on demand.

### Add secrets to configuration

[Section titled “Add secrets to configuration”](#add-secrets-to-configuration)

In the `Program.cs` file of your client-consuming project, call the `AddAzureKeyVaultSecrets` extension method on the `IConfiguration` to add the secrets as part of your app’s configuration. The method takes a connection name parameter:

```csharp
builder.Configuration.AddAzureKeyVaultSecrets(connectionName: "key-vault");
```

Note

The `AddAzureKeyVaultSecrets` API name has caused a bit of confusion. The method is used to configure the `SecretClient` based on the given connection name, and *it’s not used* to add secrets to the configuration.

Tip

The `connectionName` parameter must match the name used when adding the Azure Key Vault resource in the AppHost project. For more information, see [Add Azure Key Vault resource](#add-azure-key-vault-resource)

You can then retrieve a secret-based configuration value through the normal `IConfiguration` APIs, or by binding to strongly-typed classes with the options pattern.

#### Retrieve `IConfiguration` instance

[Section titled “Retrieve IConfiguration instance”](#retrieve-iconfiguration-instance)

```csharp
public class ExampleService(IConfiguration configuration)
{
    // Use configuration...
    private string _secretValue = configuration["SecretKey"];
}
```

#### Retrieve `IOptions<T>` instance

[Section titled “Retrieve IOptions\<T> instance”](#retrieve-ioptionst-instance)

```csharp
public class ExampleService(IOptions<SecretOptions> options)
{
    // Use options...
    private string _secretValue = options.Value.SecretKey;
}
```

Additional `AddAzureKeyVaultSecrets` API parameters are available optionally for the following scenarios:

* `Action<AzureSecurityKeyVaultSettings>? configureSettings`: To set up some or all the options inline.
* `Action<SecretClientOptions>? configureClientOptions`: To set up the `SecretClientOptions` inline.
* `AzureKeyVaultConfigurationOptions? options`: To configure the `AzureKeyVaultConfigurationOptions` inline.

### Add an Azure Secret client

[Section titled “Add an Azure Secret client”](#add-an-azure-secret-client)

Alternatively, you can use the `SecretClient` directly to retrieve the secrets on demand. This requires a slightly different registration API.

In the `Program.cs` file of your client-consuming project, call the `AddAzureKeyVaultClient` extension on the `IHostApplicationBuilder` instance to register a `SecretClient` for use via the dependency injection container:

```csharp
builder.AddAzureKeyVaultClient(connectionName: "key-vault");
```

After adding the `SecretClient` to the builder, you can get the `SecretClient` instance using dependency injection:

```csharp
public class ExampleService(SecretClient client)
{
    // Use client...
}
```

### Add keyed Azure Key Vault client

[Section titled “Add keyed Azure Key Vault client”](#add-keyed-azure-key-vault-client)

There might be situations where you want to register multiple `SecretClient` instances with different connection names. To register keyed Azure Key Vault clients, call the `AddKeyedAzureKeyVaultClient` method:

```csharp
builder.AddKeyedAzureKeyVaultClient(name: "feature-toggles");
builder.AddKeyedAzureKeyVaultClient(name: "admin-portal");
```

Then you can retrieve the `SecretClient` instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("feature-toggles")] SecretClient featureTogglesClient,
    [FromKeyedServices("admin-portal")] SecretClient adminPortalClient)
{
    // Use clients...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Azure Key Vault integration provides multiple options to configure the `SecretClient`.

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Azure Key Vault integration supports `Microsoft.Extensions.Configuration`. It loads the `AzureSecurityKeyVaultSettings` from `appsettings.json` or other configuration files using `Aspire:Azure:Security:KeyVault` key:

```json
{
  "Aspire": {
    "Azure": {
      "Security": {
        "KeyVault": {
          "DisableHealthChecks": true,
          "DisableTracing": false,
          "ClientOptions": {
            "Diagnostics": {
              "ApplicationId": "myapp"
            }
          }
        }
      }
    }
  }
}
```

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Azure Key Vault integration supports named configuration for multiple instances:

```json
{
  "Aspire": {
    "Azure": {
      "Security": {
        "KeyVault": {
          "vault1": {
            "VaultUri": "https://myvault1.vault.azure.net/",
            "DisableHealthChecks": true,
            "ClientOptions": {
              "Diagnostics": {
                "ApplicationId": "myapp1"
              }
            }
          },
          "vault2": {
            "VaultUri": "https://myvault2.vault.azure.net/",
            "DisableTracing": true,
            "ClientOptions": {
              "Diagnostics": {
                "ApplicationId": "myapp2"
              }
            }
          }
        }
      }
    }
  }
}
```

Use the connection names when calling `AddAzureKeyVaultSecrets`:

```csharp
builder.AddAzureKeyVaultSecrets("vault1");
builder.AddAzureKeyVaultSecrets("vault2");
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureSecurityKeyVaultSettings>` delegate to set up options inline:

```csharp
builder.AddAzureKeyVaultSecrets(
    connectionName: "key-vault",
    configureSettings: settings => settings.VaultUri = new Uri("KEY_VAULT_URI"));
```

You can also configure the `SecretClientOptions`:

```csharp
builder.AddAzureKeyVaultSecrets(
    connectionName: "key-vault",
    configureClientOptions: options => options.DisableChallengeResourceVerification = true);
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

The following configurable options are exposed through the `AzureSecurityKeyVaultSettings` class:

| Name                  | Description                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------- |
| `Credential`          | The credential used to authenticate to the Azure Key Vault.                                 |
| `DisableHealthChecks` | A boolean value that indicates whether the Key Vault health check is disabled or not.       |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not.        |
| `VaultUri`            | A URI to the vault on which the client operates. Appears as “DNS Name” in the Azure portal. |

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Azure Key Vault integration includes the following health checks:

* Adds the `AzureKeyVaultSecretsHealthCheck` health check, which attempts to connect to and query the Key Vault
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Azure Key Vault integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`

#### Tracing

[Section titled “Tracing”](#tracing)

The Azure Key Vault integration emits the following tracing activities using OpenTelemetry:

* `Azure.Security.KeyVault.Secrets.SecretClient`

#### Metrics

[Section titled “Metrics”](#metrics)

The Azure Key Vault integration currently doesn’t support metrics by default due to limitations with the Azure SDK.

# Azure OpenAI integration

> This article describes the Aspire Azure OpenAI integration features and capabilities.

![Azure OpenAI logo](/_astro/azure-openai-icon.DONb5yBE_252Wri.webp)

[Azure OpenAI Service](https://azure.microsoft.com/products/ai-services/openai-service) provides access to OpenAI’s powerful language and embedding models with the security and enterprise promise of Azure. The Aspire Azure OpenAI integration enables you to connect to Azure OpenAI services from your applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure OpenAI hosting integration models the Azure OpenAI service as the `AzureOpenAIResource` type. To access this type and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.CognitiveServices](https://www.nuget.org/packages/Aspire.Hosting.Azure.CognitiveServices) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.CognitiveServices package

  ```bash
  aspire add azure-cognitiveservices
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-cognitiveservices (Aspire.Hosting.Azure.CognitiveServices)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.CognitiveServices@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.CognitiveServices package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.CognitiveServices" Version="*" />
  ```

### Add an Azure OpenAI resource

[Section titled “Add an Azure OpenAI resource”](#add-an-azure-openai-resource)

To add an Azure OpenAI resource to your AppHost project, call the `AddAzureOpenAI` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddAzureOpenAI("openai");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(openai);


// After adding all resources, run the app...
```

The preceding code adds an Azure OpenAI resource named `openai` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleProject` project.

Caution

When you call `AddAzureOpenAI`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Add an Azure OpenAI deployment resource

[Section titled “Add an Azure OpenAI deployment resource”](#add-an-azure-openai-deployment-resource)

To add an Azure OpenAI deployment resource, call the `AddDeployment` method:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddAzureOpenAI("openai");


openai.AddDeployment(
    name: "preview",
    modelName: "gpt-4.5-preview",
    modelVersion: "2025-02-27");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(openai)
       .WaitFor(openai);


// After adding all resources, run the app...
```

The preceding code:

* Adds an Azure OpenAI resource named `openai`.
* Adds an Azure OpenAI deployment resource named `preview` with a model name of `gpt-4.5-preview`. The model name must correspond to an [available model](https://learn.microsoft.com/azure/ai-services/openai/concepts/models) in the Azure OpenAI service.

### Connect to an existing Azure OpenAI service

[Section titled “Connect to an existing Azure OpenAI service”](#connect-to-an-existing-azure-openai-service)

You might have an existing Azure OpenAI service that you want to connect to. You can chain a call to annotate that your `AzureOpenAIResource` is an existing resource:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingOpenAIName = builder.AddParameter("existingOpenAIName");
var existingOpenAIResourceGroup = builder.AddParameter("existingOpenAIResourceGroup");


var openai = builder.AddAzureOpenAI("openai")
    .AsExisting(existingOpenAIName, existingOpenAIResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(openai);


// After adding all resources, run the app...
```

For more information on treating Azure OpenAI resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure OpenAI resource, you can add a connection string to the AppHost. This approach is weakly-typed, and doesn’t work with role assignments or infrastructure customizations. For more information, see [Add existing Azure resources with connection strings](/integrations/cloud/azure/overview/#add-existing-azure-resources-with-connection-strings).

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep provisions an Azure OpenAI resource with standard defaults.

Bicep — openai.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource openai 'Microsoft.CognitiveServices/accounts@2024-10-01' = {
  name: take('openai-${uniqueString(resourceGroup().id)}', 64)
  location: location
  kind: 'OpenAI'
  properties: {
    customSubDomainName: toLower(take(concat('openai', uniqueString(resourceGroup().id)), 24))
    publicNetworkAccess: 'Enabled'
    disableLocalAuth: true
  }
  sku: {
    name: 'S0'
  }
  tags: {
    'aspire-resource-name': 'openai'
  }
}


resource preview 'Microsoft.CognitiveServices/accounts/deployments@2024-10-01' = {
  name: 'preview'
  properties: {
    model: {
      format: 'OpenAI'
      name: 'gpt-4.5-preview'
      version: '2025-02-27'
    }
  }
  sku: {
    name: 'Standard'
    capacity: 8
  }
  parent: openai
}


output connectionString string = 'Endpoint=${openai.properties.endpoint}'


output name string = openai.name
```

The preceding Bicep is a module that provisions an Azure Cognitive Services resource. Additionally, role assignments are created for the Azure resource in a separate module:

Bicep — openai-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param openai_outputs_name string


param principalType string


param principalId string


resource openai 'Microsoft.CognitiveServices/accounts@2024-10-01' existing = {
  name: openai_outputs_name
}


resource openai_CognitiveServicesOpenAIUser 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(openai.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '5e0bd9bd-7b93-4f28-af87-19fc36ad61bd'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '5e0bd9bd-7b93-4f28-af87-19fc36ad61bd')
    principalType: principalType
  }
  scope: openai
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This enables customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureOpenAI("openai")
    .ConfigureInfrastructure(infra =>
    {
        var resources = infra.GetProvisionableResources();
        var account = resources.OfType<CognitiveServicesAccount>().Single();


        account.Sku = new CognitiveServicesSku
        {
            Tier = CognitiveServicesSkuTier.Enterprise,
            Name = "E0"
        };
        account.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the \`AzureResourceInfrastructure type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `CognitiveServicesAccount` resource is retrieved.
  * The `CognitiveServicesAccount` property is assigned to a new instance of `CognitiveServices.CognitiveServicesSku` with an `E0` name and CognitiveServicesSkuTier.Enterprise\` tier.
  * A tag is added to the Cognitive Services resource with a key of `ExampleKey` and a value of `Example value`.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure OpenAI resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Azure OpenAI resource

[Section titled “Azure OpenAI resource”](#azure-openai-resource)

The Azure OpenAI resource exposes the following connection properties:

| Property Name | Description                                                                                           |
| ------------- | ----------------------------------------------------------------------------------------------------- |
| `Uri`         | The endpoint URI for the Azure OpenAI resource, typically `https://<resource-name>.openai.azure.com/` |

#### Azure OpenAI deployment

[Section titled “Azure OpenAI deployment”](#azure-openai-deployment)

The Azure OpenAI deployment resource inherits all properties from its parent Azure OpenAI resource and adds:

| Property Name | Description                                           |
| ------------- | ----------------------------------------------------- |
| `ModelName`   | The name of the Azure OpenAI deployment, e.g., `chat` |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `chat` becomes `CHAT_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

The Aspire Azure OpenAI client integration is used to connect to an Azure OpenAI service. To get started with the Aspire Azure OpenAI client integration, install the [📦 Aspire.Azure.AI.OpenAI](https://www.nuget.org/packages/Aspire.Azure.AI.OpenAI) NuGet package.

* .NET CLI

  .NET CLI — Add Aspire.Azure.AI.OpenAI package

  ```bash
  dotnet add package Aspire.Azure.AI.OpenAI
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.AI.OpenAI@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.AI.OpenAI package reference

  ```xml
  <PackageReference Include="Aspire.Azure.AI.OpenAI" Version="*" />
  ```

### Add Azure OpenAI client

[Section titled “Add Azure OpenAI client”](#add-azure-openai-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureOpenAIClient` extension method to register an `AzureOpenAIClient` for use via the dependency injection container. The method takes a connection name parameter:

```csharp
builder.AddAzureOpenAIClient(connectionName: "openai");
```

Tip

The `connectionName` parameter must match the name used when adding the OpenAI resource in the AppHost project.

After adding the `AzureOpenAIClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(AzureOpenAIClient client)
{
    // Use client...
}
```

### Add Azure OpenAI client with registered `IChatClient`

[Section titled “Add Azure OpenAI client with registered IChatClient”](#add-azure-openai-client-with-registered-ichatclient)

If you’re interested in using the `IChatClient` interface, with the OpenAI client, simply chain either of the following APIs to the `AddAzureOpenAIClient` method:

* `AddChatClient`: Registers a singleton `IChatClient` in the services provided by the `AspireOpenAIClientBuilder`.
* `AddKeyedChatClient`: Registers a keyed singleton `IChatClient` in the services provided by the `AspireOpenAIClientBuilder`.

For example, consider the following C# code that adds an `IChatClient` to the DI container:

```csharp
builder.AddAzureOpenAIClient(connectionName: "openai")
       .AddChatClient("deploymentName");
```

Similarly, you can add a keyed `IChatClient` with the following C# code:

```csharp
builder.AddAzureOpenAIClient(connectionName: "openai")
       .AddKeyedChatClient("serviceKey", "deploymentName");
```

After adding the `IChatClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(IChatClient chatClient)
{
    public async Task<string> GetResponseAsync(string userMessage)
    {
        var response = await chatClient.CompleteAsync(userMessage);
        return response.Message.Text ?? string.Empty;
    }
}
```

For more information on `IChatClient` and `Microsoft.Extensions.AI`, see [Unified AI Building Blocks for .NET](https://learn.microsoft.com/dotnet/core/extensions/artificial-intelligence).

### Configure Azure OpenAI client settings

[Section titled “Configure Azure OpenAI client settings”](#configure-azure-openai-client-settings)

The Aspire Azure OpenAI library provides a set of settings to configure the Azure OpenAI client. The `AddAzureOpenAIClient` method exposes an optional `configureSettings` parameter of type `Action<AzureOpenAISettings>?`. To configure settings inline, consider the following example:

```csharp
builder.AddAzureOpenAIClient(
    connectionName: "openai",
    configureSettings: settings =>
    {
        settings.DisableTracing = true;


        var uriString = builder.Configuration["AZURE_OPENAI_ENDPOINT"]
            ?? throw new InvalidOperationException("AZURE_OPENAI_ENDPOINT is not set.");


        settings.Endpoint = new Uri(uriString);
    });
```

The preceding code sets the `AzureOpenAISettings.DisableTracing` property to `true`, and sets the `AzureOpenAISettings.Endpoint` property to the Azure OpenAI endpoint.

### Configure Azure OpenAI client builder options

[Section titled “Configure Azure OpenAI client builder options”](#configure-azure-openai-client-builder-options)

To configure the `AzureOpenAIClientOptions` for the client, you can use the `AddAzureOpenAIClient` method. This method takes an optional `configureClientBuilder` parameter of type `Action<IAzureClientBuilder<OpenAIClient, AzureOpenAIClientOptions>>?`. Consider the following example:

```csharp
builder.AddAzureOpenAIClient(
    connectionName: "openai",
    configureClientBuilder: clientBuilder =>
    {
        clientBuilder.ConfigureOptions(options =>
        {
            options.UserAgentApplicationId = "CLIENT_ID";
        });
    });
```

The client builder is an instance of the `IAzureClientBuilder` type, which provides a fluent API to configure the client options. The preceding code sets the `AzureOpenAIClientOptions.UserAgentApplicationId` property to `CLIENT_ID`.

### Add Azure OpenAI client from configuration

[Section titled “Add Azure OpenAI client from configuration”](#add-azure-openai-client-from-configuration)

Additionally, the package provides the `AddOpenAIClientFromConfiguration` extension method to register an `OpenAIClient` or `AzureOpenAIClient` instance based on the provided connection string. This method follows these rules:

* If the `Endpoint` attribute is empty or missing, an `OpenAIClient` instance is registered using the provided key, for example, `Key={key};`.
* If the `IsAzure` attribute is `true`, an `AzureOpenAIClient` is registered; otherwise, an `OpenAIClient` is registered, for example, `Endpoint={azure_endpoint};Key={key};IsAzure=true` registers an `AzureOpenAIClient`, while `Endpoint=https://localhost:18889;Key={key}` registers an `OpenAIClient`.
* If the `Endpoint` attribute contains `".azure."`, an `AzureOpenAIClient` is registered; otherwise, an `OpenAIClient` is registered, for example, `Endpoint=https://{account}.azure.com;Key={key};`.

Consider the following example:

```csharp
builder.AddOpenAIClientFromConfiguration("openai");
```

Tip

A valid connection string must contain at least an `Endpoint` or a `Key`.

Consider the following example connection strings and whether they register an `OpenAIClient` or `AzureOpenAIClient`:

| Example connection string                                                           | Registered client type |
| ----------------------------------------------------------------------------------- | ---------------------- |
| `Endpoint=https://{account_name}.openai.azure.com/;Key={account_key}`               | `AzureOpenAIClient`    |
| `Endpoint=https://{account_name}.openai.azure.com/;Key={account_key};IsAzure=false` | `OpenAIClient`         |
| `Endpoint=https://{account_name}.openai.azure.com/;Key={account_key};IsAzure=true`  | `AzureOpenAIClient`    |
| `Endpoint=https://localhost:18889;Key={account_key}`                                | `OpenAIClient`         |

### Add keyed Azure OpenAI clients

[Section titled “Add keyed Azure OpenAI clients”](#add-keyed-azure-openai-clients)

There might be situations where you want to register multiple `OpenAIClient` instances with different connection names. To register keyed Azure OpenAI clients, call the `AddKeyedAzureOpenAIClient` method:

```csharp
builder.AddKeyedAzureOpenAIClient(name: "chat");
builder.AddKeyedAzureOpenAIClient(name: "code");
```

Caution

When using keyed services, ensure that your Azure OpenAI resource configures two named connections, one for `chat` and one for `code`.

Then you can retrieve the client instances using dependency injection. For example, to retrieve the clients from a service:

```csharp
public class ExampleService(
    [KeyedService("chat")] OpenAIClient chatClient,
    [KeyedService("code")] OpenAIClient codeClient)
{
    // Use clients...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Add keyed Azure OpenAI clients from configuration

[Section titled “Add keyed Azure OpenAI clients from configuration”](#add-keyed-azure-openai-clients-from-configuration)

The same functionality and rules exist for keyed Azure OpenAI clients as for the nonkeyed clients. You can use the `AddKeyedOpenAIClientFromConfiguration` extension method to register an `OpenAIClient` or `AzureOpenAIClient` instance based on the provided connection string.

Consider the following example:

```csharp
builder.AddKeyedOpenAIClientFromConfiguration("openai");
```

This method follows the same rules as detailed in the [Add Azure OpenAI client from configuration](#add-azure-openai-client-from-configuration).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure OpenAI library provides multiple options to configure the Azure OpenAI connection based on the requirements and conventions of your project. Either an `Endpoint` or a `ConnectionString` must be supplied.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddAzureOpenAIClient`:

```csharp
builder.AddAzureOpenAIClient(connectionName: "openai");
```

The connection information is retrieved from the `ConnectionStrings` configuration section. Two connection formats are supported:

* **Service endpoint (recommended)**: Uses the service endpoint with `DefaultAzureCredential`.

  ```json
  {
    "ConnectionStrings": {
      "openai": "https://{account_name}.openai.azure.com/"
    }
  }
  ```

* **Connection string**: Includes an API key.

  ```json
  {
    "ConnectionStrings": {
      "openai": "Endpoint=https://{account_name}.openai.azure.com/;Key={api_key}"
    }
  }
  ```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The library supports `Microsoft.Extensions.Configuration`. It loads settings from configuration using the `Aspire:Azure:AI:OpenAI` key:

```json
{
  "Aspire": {
    "Azure": {
      "AI": {
        "OpenAI": {
          "DisableTracing": false
        }
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can configure settings inline:

```csharp
builder.AddAzureOpenAIClient(
    "openai",
    settings => settings.DisableTracing = true);
```

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

#### Logging

[Section titled “Logging”](#logging)

The Aspire Azure OpenAI integration uses the following log categories:

* `Azure`
* `Azure.Core`
* `Azure.Identity`
* `Azure.AI.OpenAI`

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure OpenAI integration will emit the following tracing activities using OpenTelemetry:

* `Azure.AI.OpenAI.*`
* `gen_ai.system` - Generic AI system tracing
* `gen_ai.operation.name` - Operation names for AI calls

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure OpenAI integration currently doesn’t support metrics by default due to limitations with the Azure SDK for .NET.

# Azure PostgreSQL client integration

> Learn how to use the Aspire Azure PostgreSQL client integration to connect to Azure PostgreSQL databases.

![Azure Database for PostgreSQL logo](/_astro/azure-postgresql-icon.BMlm1jYK_ZWuyLk.webp)

To get started with the Aspire Azure PostgreSQL client integration, install the [📦 Aspire.Azure.Npgsql](https://www.nuget.org/packages/Aspire.Azure.Npgsql) NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an [NpgsqlDataSource](https://www.npgsql.org/doc/api/Npgsql.NpgsqlDataSource.html) instance that you can use to interact with PostgreSQL.

* .NET CLI

  .NET CLI — Add Aspire.Azure.Npgsql package

  ```bash
  dotnet add package Aspire.Azure.Npgsql
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Npgsql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Npgsql package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Npgsql" Version="*" />
  ```

For an introduction to working with the Azure PostgreSQL client integration, see [Get started with the Azure PostgreSQL integrations](/integrations/cloud/azure/azure-postgresql/azure-postgresql-get-started/).

## Add PostgreSQL client

[Section titled “Add PostgreSQL client”](#add-postgresql-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureNpgsqlDataSource` extension method to register a `NpgsqlDataSource` for use via the dependency injection container. The method takes a connection name parameter:

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDataSource(connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the PostgreSQL database resource in the AppHost project. For more information, see [Add an Azure Database for PostgreSQL resource](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/#add-an-azure-database-for-postgresql-resource).

The preceding code snippet demonstrates how to use the `AddAzureNpgsqlDataSource` method to register an `NpgsqlDataSource` instance that uses Azure authentication ([Microsoft Entra ID](https://learn.microsoft.com/azure/postgresql/flexible-server/concepts-azure-ad-authentication)). This `"postgresdb"` connection name corresponds to a connection string configuration value.

After adding `NpgsqlDataSource` to the builder, you can get the `NpgsqlDataSource` instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(NpgsqlDataSource dataSource)
{
    // Use dataSource...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Properties of the Azure PostgreSQL resources

[Section titled “Properties of the Azure PostgreSQL resources”](#properties-of-the-azure-postgresql-resources)

When you use the `WithReference` method to pass an Azure PostgreSQL server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

### Azure PostgreSQL flexible server

[Section titled “Azure PostgreSQL flexible server”](#azure-postgresql-flexible-server)

The Azure PostgreSQL server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                                                              |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Host`                 | The hostname for the PostgreSQL server                                                                                                                                                                                   |
| `Port`                 | The PostgreSQL port (fixed at `5432` in Azure Flexible Server)                                                                                                                                                           |
| `Uri`                  | The connection URI for the server, with the format `postgresql://{Username}:{Password}@{Host}` (credentials omitted when not applicable)                                                                                 |
| `JdbcConnectionString` | JDBC-format connection string for the server, with the format `jdbc:postgresql://{Host}?sslmode=require&authenticationPluginClassName=com.azure.identity.extensions.jdbc.postgresql.AzurePostgresqlAuthenticationPlugin` |
| `Username`             | Present when password authentication is enabled; the configured administrator username                                                                                                                                   |
| `Password`             | Present when password authentication is enabled; the configured administrator password                                                                                                                                   |

### Azure PostgreSQL database

[Section titled “Azure PostgreSQL database”](#azure-postgresql-database)

The Azure PostgreSQL database resource inherits all properties from its parent server and adds:

| Property Name          | Description                                                                                                                                                                                                                               |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `DatabaseName`         | The name of the database                                                                                                                                                                                                                  |
| `Uri`                  | The database-specific connection URI, with the format `postgresql://{Username}:{Password}@{Host}/{DatabaseName}` (credentials omitted when not applicable)                                                                                |
| `JdbcConnectionString` | JDBC-format connection string for the database, with the format `jdbc:postgresql://{Host}/{DatabaseName}?sslmode=require&authenticationPluginClassName=com.azure.identity.extensions.jdbc.postgresql.AzurePostgresqlAuthenticationPlugin` |

For example, if you reference a database resource named `postgresdb` in your AppHost project, the following environment variables will be available in the consuming project:

* `POSTGRESDB_HOST`
* `POSTGRESDB_PORT`
* `POSTGRESDB_URI`
* `POSTGRESDB_JDBCCONNECTIONSTRING`
* `POSTGRESDB_DATABASENAME`

When password authentication is enabled, additional environment variables are available:

* `POSTGRESDB_USERNAME`
* `POSTGRESDB_PASSWORD`

## Add keyed Azure Npgsql client

[Section titled “Add keyed Azure Npgsql client”](#add-keyed-azure-npgsql-client)

There might be situations where you want to register multiple `NpgsqlDataSource` instances with different connection names. To register keyed Npgsql clients, call the `AddKeyedAzureNpgsqlDataSource` method:

C# — Program.cs

```csharp
builder.AddKeyedAzureNpgsqlDataSource(name: "sales_db");
builder.AddKeyedAzureNpgsqlDataSource(name: "inventory_db");
```

Then you can retrieve the `NpgsqlDataSource` instances using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("sales_db")] NpgsqlDataSource salesDataSource,
    [FromKeyedServices("inventory_db")] NpgsqlDataSource inventoryDataSource)
{
    // Use data sources...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure Database for PostgreSQL library provides multiple options to configure the PostgreSQL connection based on the requirements and conventions of your project. A `ConnectionString` is required.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddAzureNpgsqlDataSource`:

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDataSource(connectionName: "database");
```

The connection information is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "database": "Host=myserver;Database=mydb;Username=myuser;Password=mypassword"
  }
}
```

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The library supports `Microsoft.Extensions.Configuration`. It loads settings from configuration using the `Aspire:Npgsql` key:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "DisableHealthChecks": true,
      "DisableTracing": false
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can configure settings inline:

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDataSource(
    "database",
    settings => settings.DisableHealthChecks = true);
```

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

### Logging

[Section titled “Logging”](#logging)

The Aspire Azure Database for PostgreSQL integration uses the following log categories:

* `Npgsql.Connection`
* `Npgsql.Command`
* `Npgsql.Transaction`
* `Npgsql.Copy`
* `Npgsql.Replication`
* `Npgsql.Exception`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure Database for PostgreSQL integration will emit the following tracing activities using OpenTelemetry:

* `Npgsql`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure Database for PostgreSQL integration will emit the following metrics using OpenTelemetry:

* `Npgsql`

  * `db.client.connections.create_time`
  * `db.client.connections.use_time`
  * `db.client.connections.wait_time`
  * `db.client.connections.idle.max`
  * `db.client.connections.idle.min`
  * `db.client.connections.max`
  * `db.client.connections.pending_requests`
  * `db.client.connections.timeouts`
  * `db.client.connections.usage`

# Get started with the Azure PostgreSQL integrations

> Learn how to set up the Aspire Azure PostgreSQL Hosting and Client integrations simply.

![Azure Database for PostgreSQL logo](/_astro/azure-postgresql-icon.BMlm1jYK_ZWuyLk.webp)

[Azure Database for PostgreSQL](https://learn.microsoft.com/azure/postgresql/)—Flexible Server is a relational database service based on the open-source Postgres database engine. It’s a fully managed database-as-a-service that can handle mission-critical workloads with predictable performance, security, high availability, and dynamic scalability. The Aspire Azure PostgreSQL integration provides a way to connect to existing Azure PostgreSQL databases, or create new instances from .NET with the [`docker.io/library/postgres` container image](https://hub.docker.com/_/postgres).

In this introduction, you’ll see how to install and use the Aspire Azure PostgreSQL integrations in a simple configuration. If you already have this knowledge, see [Azure PostgreSQL Hosting integration](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Azure PostgreSQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Azure PostgreSQL database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.PostgreSQL package

  ```bash
  aspire add azure-postgresql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-postgresql (Aspire.Hosting.Azure.PostgreSQL)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.PostgreSQL" Version="*" />
  ```

Next, in the AppHost project, create instances of Azure PostgreSQL server and database resources, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(postgresdb)
                            .WithReference(postgresdb);


builder.Build().Run();
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(postgresdb)
                            .WithReference(postgresdb);


builder.Build().Run();
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(postgresdb)
                 .WithReference(postgresdb);


builder.Build().Run();
```

Caution

When you call `AddAzurePostgresFlexibleServer`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

Tip

This is the simplest implementation of Azure PostgreSQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Azure PostgreSQL Hosting integration](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Azure PostgreSQL client integration:

* .NET CLI

  .NET CLI — Add Aspire.Azure.Npgsql package

  ```bash
  dotnet add package Aspire.Azure.Npgsql
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Npgsql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Npgsql package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Npgsql" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddAzureNpgsqlDataSource` extension method on any `IHostApplicationBuilder` to register an `NpgsqlDataSource` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDataSource(connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure PostgreSQL database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with Azure PostgreSQL databases in your Python consuming projects, you need to include a PostgreSQL adapter library. Two popular options are `psycopg` (synchronous) and `asyncpg` (asynchronous). You can install either of these libraries using pip. In this article, example code uses `psycopg`:

```bash
pip install psycopg[binary]
```

Ensure that you `import psycopg` in code files that interact with the database. You should also import the `os` module to access environment variables:

Python — Import psycopg

```python
import psycopg
import os
```

To interact with Azure PostgreSQL databases in your JavaScript consuming projects, you need to include a PostgreSQL client library. A popular option is `pg`. You can install this library using npm:

```bash
npm install pg
```

Ensure that you `import pg` in code files that interact with the database:

JavaScript — Import pg

```javascript
import pg from 'pg';
```

### Use injected Azure PostgreSQL properties

[Section titled “Use injected Azure PostgreSQL properties”](#use-injected-azure-postgresql-properties)

In the AppHost, when you used the `WithReference` method to pass an Azure PostgreSQL server or database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `postgresdb` becomes `POSTGRESDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# — Obtain configuration properties

```csharp
string hostname = builder.Configuration.GetValue<string>("POSTGRESDB_HOST");
string databaseport = builder.Configuration.GetValue<string>("POSTGRESDB_PORT");
string jdbcconnectionstring = builder.Configuration.GetValue<string>("POSTGRESDB_JDBCCONNECTIONSTRING");
string databasename = builder.Configuration.GetValue<string>("POSTGRESDB_DATABASENAME");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python — Obtain configuration properties

```python
postgres_uri = os.getenv("POSTGRESDB_URI")
postgres_name = os.getenv("POSTGRESDB_DATABASENAME", "db")
```

Use the `process.env` object to obtain these environment variables in consuming projects:

JavaScript — Obtain configuration properties

```javascript
const pghost = process.env.POSTGRESDB_HOST;
const pgport = process.env.POSTGRESDB_PORT;
const pgdatabase = process.env.POSTGRESDB_DATABASENAME;
// Note: When using Microsoft Entra ID (default), username and password are not used
```

Tip

The full set of properties that Aspire injects depends on whether you passed an Azure PostgreSQL server or database resource. For more information, see [Properties of the Azure PostgreSQL resources](/integrations/cloud/azure/azure-postgresql/azure-postgresql-client/#properties-of-the-azure-postgresql-resources).

### Use Azure PostgreSQL resources in client code

[Section titled “Use Azure PostgreSQL resources in client code”](#use-azure-postgresql-resources-in-client-code)

Now that you’ve added `NpgsqlDataSource` to the builder in the consuming project, you can use the Azure PostgreSQL resource to get and store data. Get the `NpgsqlDataSource` instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(NpgsqlDataSource dataSource)
{
    // Use dataSource to query the database...
}
```

Having obtained the data source, you can work with the Azure PostgreSQL database as you would in any other C# application.

Use the information you have obtained about the Azure PostgreSQL resource to connect to the database. Here is an example of how to connect using `psycopg`:

Python — Connect to Azure PostgreSQL

```python
async with await psycopg.AsyncConnection.connect(postgres_uri, autocommit=True) as conn:
    # Use connection to query the database...
```

Having obtained the connection, you can work with the Azure PostgreSQL database as you would in any other Python application.

Use the information you have obtained about the Azure PostgreSQL resource to connect to the database. Here is an example of how to connect using `pg`:

JavaScript — Connect to Azure PostgreSQL

```javascript
const client = new pg.Client({
  host: pghost,
  database: pgdatabase,
  port: pgport,
  // Note: When using Microsoft Entra ID (default), configure Azure authentication
});


client.connect();
```

Having obtained the connection, you can work with the Azure PostgreSQL database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now, that you have an Aspire app with Azure PostgreSQL integrations up and running, you can use the following reference documents to learn how to configure and interact with the Azure PostgreSQL resources:

[Understand the Azure PostgreSQL hosting integration ](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/)Discover how to configure password authentication, run as container, and more.

[Understand the Azure PostgreSQL client integration ](/integrations/cloud/azure/azure-postgresql/azure-postgresql-client/)Discover how to configure keyed clients, observability, and more.

# Azure PostgreSQL hosting integration

> Learn how to use the Aspire Azure PostgreSQL hosting integration to create Azure PostgreSQL resources.

![Azure Database for PostgreSQL logo](/_astro/azure-postgresql-icon.BMlm1jYK_ZWuyLk.webp)

The Aspire Azure PostgreSQL hosting integration models a PostgreSQL flexible server and database as the `AzurePostgresFlexibleServerResource` and `AzurePostgresFlexibleServerDatabaseResource` types. Other types that are inherently available in the hosting integration are represented in the following resources:

* `PostgresServerResource`
* `PostgresDatabaseResource`
* `PgAdminContainerResource`
* `PgWebContainerResource`

To access these types and APIs for expressing them as resources in your [AppHost](/get-started/app-host/) project, install the [📦 Aspire.Hosting.Azure.PostgreSQL](https://www.nuget.org/packages/Aspire.Hosting.Azure.PostgreSQL) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.PostgreSQL package

  ```bash
  aspire add azure-postgresql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-postgresql (Aspire.Hosting.Azure.PostgreSQL)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.PostgreSQL" Version="*" />
  ```

For an introduction to working with the Azure PostgreSQL hosting integration, see [Get started with the Azure PostgreSQL integrations](/integrations/cloud/azure/azure-postgresql/azure-postgresql-get-started/).

## Add an Azure Database for PostgreSQL resource

[Section titled “Add an Azure Database for PostgreSQL resource”](#add-an-azure-database-for-postgresql-resource)

To add an Azure Database for PostgreSQL resource to your AppHost project, call the `AddAzurePostgresFlexibleServer` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
    .WithReference(postgresdb);


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding code adds an Azure PostgreSQL resource named `postgres` with a database named `postgresdb` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleProject` project.

Caution

When you call `AddAzurePostgresFlexibleServer`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

## Connect to an existing Azure PostgreSQL flexible server

[Section titled “Connect to an existing Azure PostgreSQL flexible server”](#connect-to-an-existing-azure-postgresql-flexible-server)

You might have an existing Azure Database for PostgreSQL service that you want to connect to. You can chain a call to annotate that your `AzurePostgresResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingPostgresName = builder.AddParameter("existingPostgresName");
var existingPostgresResourceGroup = builder.AddParameter("existingPostgresResourceGroup");


var postgres = builder.AddAzurePostgresFlexibleServer("postgres")
    .AsExisting(existingPostgresName, existingPostgresResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(postgres);


// After adding all resources, run the app...


builder.Build().Run();
```

For more information on treating Azure PostgreSQL resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

## Run Azure PostgreSQL resource as a container

[Section titled “Run Azure PostgreSQL resource as a container”](#run-azure-postgresql-resource-as-a-container)

The Azure PostgreSQL hosting integration supports running the PostgreSQL server as a local container. This is beneficial for situations where you want to run the PostgreSQL server locally for development and testing purposes, avoiding the need to provision an Azure resource or connect to an existing Azure PostgreSQL server.

To run the PostgreSQL server as a container, call the `RunAsContainer` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres")
    .RunAsContainer();


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
    .WithReference(postgresdb);


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding code configures an Azure PostgreSQL Flexible Server resource to run locally in a container.

Tip

The `RunAsContainer` method is useful for local development and testing. The API exposes an optional delegate that enables you to customize the underlying `PostgresServerResource` configuration. For example, you can add **pgAdmin** and **pgWeb**, add a data volume or data bind mount, and add an init bind mount. For more information, see [PostgreSQL Hosting integration](/integrations/databases/postgres/postgres-host/#add-postgresql-server-resource).

## Configure the Azure PostgreSQL server to use password authentication

[Section titled “Configure the Azure PostgreSQL server to use password authentication”](#configure-the-azure-postgresql-server-to-use-password-authentication)

By default, the Azure PostgreSQL server is configured to use [Microsoft Entra ID](https://learn.microsoft.com/azure/postgresql/flexible-server/concepts-azure-ad-authentication) authentication. If you want to use password authentication, you can configure the server to use password authentication by calling the `WithPasswordAuthentication` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("username", secret: true);
var password = builder.AddParameter("password", secret: true);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres")
    .WithPasswordAuthentication(username, password);


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
    .WithReference(postgresdb);


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding code configures the Azure PostgreSQL server to use password authentication. The `username` and `password` parameters are added to the AppHost as parameters, and the `WithPasswordAuthentication` method is called to configure the Azure PostgreSQL server to use password authentication.

## Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by hand, because the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure PostgreSQL resource, the following Bicep is generated:

Generated Bicep — postgres.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource postgres_flexible 'Microsoft.DBforPostgreSQL/flexibleServers@2024-08-01' = {
  name: take('postgresflexible-${uniqueString(resourceGroup().id)}', 63)
  location: location
  properties: {
    authConfig: {
      activeDirectoryAuth: 'Enabled'
      passwordAuth: 'Disabled'
    }
    availabilityZone: '1'
    backup: {
      backupRetentionDays: 7
      geoRedundantBackup: 'Disabled'
    }
    highAvailability: {
      mode: 'Disabled'
    }
    storage: {
      storageSizeGB: 32
    }
    version: '16'
  }
  sku: {
    name: 'Standard_B1ms'
    tier: 'Burstable'
  }
  tags: {
    'aspire-resource-name': 'postgres-flexible'
  }
}


resource postgreSqlFirewallRule_AllowAllAzureIps 'Microsoft.DBforPostgreSQL/flexibleServers/firewallRules@2024-08-01' = {
  name: 'AllowAllAzureIps'
  properties: {
    endIpAddress: '0.0.0.0'
    startIpAddress: '0.0.0.0'
  }
  parent: postgres_flexible
}


output connectionString string = 'Host=${postgres_flexible.properties.fullyQualifiedDomainName}'


output name string = postgres_flexible.name
```

The preceding Bicep is a module that provisions an Azure PostgreSQL flexible server resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — postgres-flexible-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param postgres_flexible_outputs_name string


param principalType string


param principalId string


param principalName string


resource postgres_flexible 'Microsoft.DBforPostgreSQL/flexibleServers@2024-08-01' existing = {
  name: postgres_flexible_outputs_name
}


resource postgres_flexible_admin 'Microsoft.DBforPostgreSQL/flexibleServers/administrators@2024-08-01' = {
  name: principalId
  properties: {
    principalName: principalName
    principalType: principalType
  }
  parent: postgres_flexible
}
```

In addition to the PostgreSQL flexible server, it also provisions an Azure Firewall rule to allow all Azure IP addresses. Finally, an administrator is created for the PostgreSQL server, and the connection string is outputted as an output variable. The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

## Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzurePostgresFlexibleServer("postgres")
  .ConfigureInfrastructure(infra =>
  {
      var flexibleServer = infra.GetProvisionableResources()
                                .OfType<PostgreSqlFlexibleServer>()
                                .Single();


      flexibleServer.Sku = new PostgreSqlFlexibleServerSku
      {
          Tier = PostgreSqlFlexibleServerSkuTier.Burstable,
      };
      flexibleServer.HighAvailability = new PostgreSqlFlexibleServerHighAvailability
      {
          Mode = PostgreSqlFlexibleServerHighAvailabilityMode.ZoneRedundant,
          StandbyAvailabilityZone = "2",
      };
      flexibleServer.Tags.Add("ExampleKey", "Example value");
  });


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `PostgreSqlFlexibleServer` is retrieved.
  * The `sku` is set with `PostgreSqlFlexibleServerSkuTier.Burstable`.
  * The high availability properties are set with `PostgreSqlFlexibleServerHighAvailabilityMode.ZoneRedundant` in standby availability zone `"2"`.
  * A tag is added to the flexible server with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the PostgreSQL resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

# Azure Service Bus integration

> Learn how to install and configure the Aspire Azure Service Bus integration to connect to Azure Service Bus instances from any application.

![Azure Service Bus logo](/_astro/azure-servicebus-icon.DHL-Rg8b_ZVfXHv.webp)

[Azure Service Bus](https://learn.microsoft.com/azure/service-bus-messaging) is a fully managed enterprise message broker with message queues and publish-subscribe topics. The Aspire Azure Service Bus integration enables you to connect to Azure Service Bus instances from your applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

[Azure Service Bus](https://azure.microsoft.com/services/service-bus/) is a fully managed enterprise message broker with message queues and publish-subscribe topics. The Aspire Azure Service Bus integration enables you to connect to Azure Service Bus instances from applications.

* `AzureServiceBusResource`: Represents an Azure Service Bus resource.
* `AzureServiceBusQueueResource`: Represents an Azure Service Bus queue resource.
* `AzureServiceBusSubscriptionResource`: Represents an Azure Service Bus subscription resource.
* `AzureServiceBusEmulatorResource`: Represents an Azure Service Bus emulator resource.
* `AzureServiceBusTopicResource`: Represents an Azure Service Bus topic resource.

To access these types and APIs for expressing them, add the [📦 Aspire.Hosting.Azure.ServiceBus](https://www.nuget.org/packages/Aspire.Hosting.Azure.ServiceBus) NuGet package in the AppHost project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.ServiceBus package

  ```bash
  aspire add azure-servicebus
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-servicebus (Aspire.Hosting.Azure.ServiceBus)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.ServiceBus@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.ServiceBus package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.ServiceBus" Version="*" />
  ```

### Add Azure Service Bus resource

[Section titled “Add Azure Service Bus resource”](#add-azure-service-bus-resource)

In your AppHost project, call `AddAzureServiceBus` to add and return an Azure Service Bus resource builder.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging");


// After adding all resources, run the app...
```

When you add an `AzureServiceBusResource` to the AppHost, it exposes other useful APIs to add queues and topics. In other words, you must add an `AzureServiceBusResource` before adding any of the other Service Bus resources.

Caution

When you call `AddAzureServiceBus`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Service Bus namespace

[Section titled “Connect to an existing Azure Service Bus namespace”](#connect-to-an-existing-azure-service-bus-namespace)

You might have an existing Azure Service Bus namespace that you want to connect to. Chain a call to annotate that your `AzureServiceBusResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingServiceBusName = builder.AddParameter("existingServiceBusName");
var existingServiceBusResourceGroup = builder.AddParameter("existingServiceBusResourceGroup");


var serviceBus = builder.AddAzureServiceBus("messaging")
    .AsExisting(existingServiceBusName, existingServiceBusResourceGroup);


builder.AddProject<Projects.WebApplication>("web")
    .WithReference(serviceBus);


// After adding all resources, run the app...
```

For more information on treating Azure Service Bus resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure Service Bus resource, you can add a connection string to the AppHost. This approach is weakly-typed, and doesn’t work with role assignments or infrastructure customizations. For more information, see [Add existing Azure resources with connection strings](/integrations/cloud/azure/overview/#add-existing-azure-resources-with-connection-strings).

### Add Azure Service Bus queue

[Section titled “Add Azure Service Bus queue”](#add-azure-service-bus-queue)

To add an Azure Service Bus queue, call the `AddServiceBusQueue` method on the `IResourceBuilder<AzureServiceBusResource>`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging");
var queue = serviceBus.AddServiceBusQueue("queue");


// After adding all resources, run the app...
```

When you call `AddServiceBusQueue`, it configures your Service Bus resources to have a queue named `queue`. This expresses an explicit parent-child relationship between the `messaging` Service Bus resource and its child `queue`. The queue is created in the Service Bus namespace that’s represented by the `AzureServiceBusResource` that you added earlier. For more information, see [Queues, topics, and subscriptions in Azure Service Bus](https://learn.microsoft.com/azure/service-bus-messaging/service-bus-queues-topics-subscriptions).

### Add Azure Service Bus topic and subscription

[Section titled “Add Azure Service Bus topic and subscription”](#add-azure-service-bus-topic-and-subscription)

To add an Azure Service Bus topic, call the `AddServiceBusTopic` method on the `IResourceBuilder<AzureServiceBusResource>`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging");
var topic = serviceBus.AddServiceBusTopic("topic");


// After adding all resources, run the app...
```

When you call `AddServiceBusTopic`, it configures your Service Bus resources to have a topic named `topic`. The topic is created in the Service Bus namespace that’s represented by the `AzureServiceBusResource` that you added earlier.

To add a subscription for the topic, call the `AddServiceBusSubscription` method on the `IResourceBuilder<AzureServiceBusTopicResource>` and configure it using the `WithProperties` method:

C# — AppHost.cs

```csharp
using Aspire.Hosting.Azure;


var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging");
var topic = serviceBus.AddServiceBusTopic("topic");
topic.AddServiceBusSubscription("sub1")
     .WithProperties(subscription =>
     {
         subscription.MaxDeliveryCount = 10;
         subscription.Rules.Add(
             new AzureServiceBusRule("app-prop-filter-1")
             {
                 CorrelationFilter = new()
                 {
                     ContentType = "application/text",
                     CorrelationId = "id1",
                     Subject = "subject1",
                     MessageId = "msgid1",
                     ReplyTo = "someQueue",
                     ReplyToSessionId = "sessionId",
                     SessionId = "session1",
                     SendTo = "xyz"
                 }
             });
     });


// After adding all resources, run the app...
```

The preceding code not only adds a topic but also creates and configures a subscription named `sub1` for the topic. The subscription has a maximum delivery count of `10` and a rule named `app-prop-filter-1`. The rule is a correlation filter that filters messages based on the `ContentType`, `CorrelationId`, `Subject`, `MessageId`, `ReplyTo`, `ReplyToSessionId`, `SessionId`, and `SendTo` properties.

For more information, see [Queues, topics, and subscriptions in Azure Service Bus](https://learn.microsoft.com/azure/service-bus-messaging/service-bus-queues-topics-subscriptions).

### Add Azure Service Bus emulator resource

[Section titled “Add Azure Service Bus emulator resource”](#add-azure-service-bus-emulator-resource)

To add an Azure Service Bus emulator resource, chain a call on an `IResourceBuilder<AzureServiceBusResource>` to the `RunAsEmulator` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging")
    .RunAsEmulator();


// After adding all resources, run the app...
```

When you call `RunAsEmulator`, it configures your Service Bus resources to run locally using an emulator. The emulator in this case is the [Azure Service Bus Emulator](https://learn.microsoft.com/azure/service-bus-messaging/overview-emulator). The Azure Service Bus Emulator provides a free local environment for testing your Azure Service Bus apps and it’s a perfect companion to the Aspire Azure hosting integration. The emulator isn’t installed; instead, it’s accessible to Aspire as a container. When you add a container to the AppHost, as shown in the preceding example with the `mcr.microsoft.com/azure-messaging/servicebus-emulator` image (and the companion `mcr.microsoft.com/azure-sql-edge` image), it creates and starts the container when the AppHost starts. For more information, see [Container resource lifecycle](/architecture/resource-model/#built-in-resources-and-lifecycle).

#### Configure Service Bus emulator container

[Section titled “Configure Service Bus emulator container”](#configure-service-bus-emulator-container)

There are various configurations available for container resources, for example, you can configure the container’s ports or providing a wholistic JSON configuration which overrides everything.

##### Configure Service Bus emulator container host port

[Section titled “Configure Service Bus emulator container host port”](#configure-service-bus-emulator-container-host-port)

By default, the Service Bus emulator container when configured by Aspire exposes the following endpoints:

| Endpoint   | Image                                                   | Container port | Host port |
| ---------- | ------------------------------------------------------- | -------------- | --------- |
| `emulator` | `mcr.microsoft.com/azure-messaging/servicebus-emulator` | 5672           | dynamic   |
| `tcp`      | `mcr.microsoft.com/mssql/server`                        | 1433           | dynamic   |

The port that it’s listening on is dynamic by default. When the container starts, the port is mapped to a random port on the host machine. To configure the endpoint port, chain calls on the container resource builder provided by the `RunAsEmulator` method and then the `WithHostPort` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging")
  .RunAsEmulator(emulator =>
  {
      emulator.WithHostPort(7777);
  });


// After adding all resources, run the app...
```

The preceding code configures the Service Bus emulator container’s existing `emulator` endpoint to listen on port `7777`. The Service Bus emulator container’s port is mapped to the host port as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------- | ------------------------------- |
| `emulator`    | `5672:7777`                     |

##### Configure Service Bus emulator container JSON configuration

[Section titled “Configure Service Bus emulator container JSON configuration”](#configure-service-bus-emulator-container-json-configuration)

The Service Bus emulator automatically generates a configuration similar to this [*config.json*](https://github.com/Azure/azure-service-bus-emulator-installer/blob/main/ServiceBus-Emulator/Config/Config.json) file from the configured resources. You can override this generated file entirely, or update the JSON configuration with a `JsonNode` representation of the configuration.

To provide a custom JSON configuration file, call the `WithConfigurationFile` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging")
    .RunAsEmulator(emulator =>
    {
        emulator.WithConfigurationFile(
            path: "./messaging/custom-config.json");
    });
```

The preceding code configures the Service Bus emulator container to use a custom JSON configuration file located at `./messaging/custom-config.json`. To instead override specific properties in the default configuration, call the `WithConfiguration` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serviceBus = builder.AddAzureServiceBus("messaging")
  .RunAsEmulator(emulator =>
  {
      emulator.WithConfiguration(
          (JsonNode configuration) =>
          {
              var userConfig = configuration["UserConfig"];
              var ns = userConfig["Namespaces"][0];
              var firstQueue = ns["Queues"][0];
              var properties = firstQueue["Properties"];


              properties["MaxDeliveryCount"] = 5;
              properties["RequiresDuplicateDetection"] = true;
              properties["DefaultMessageTimeToLive"] = "PT2H";
          });
  });


// After adding all resources, run the app...
```

The preceding code retrieves the `UserConfig` node from the default configuration. It then updates the first queue’s properties to set the `MaxDeliveryCount` to `5`, `RequiresDuplicateDetection` to `true`, and `DefaultMessageTimeToLive` to `2 hours`.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Service Bus resource, the following Bicep is generated:

Generated Bicep — service-bus.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param sku string = 'Standard'


resource service_bus 'Microsoft.ServiceBus/namespaces@2024-01-01' = {
  name: take('servicebus-${uniqueString(resourceGroup().id)}', 50)
  location: location
  properties: {
    disableLocalAuth: true
  }
  sku: {
    name: sku
  }
  tags: {
    'aspire-resource-name': 'service-bus'
  }
}


output serviceBusEndpoint string = service_bus.properties.serviceBusEndpoint


output name string = service_bus.name
```

The preceding Bicep is a module that provisions an Azure Service Bus namespace resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — service-bus-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param service_bus_outputs_name string


param principalType string


param principalId string


resource service_bus 'Microsoft.ServiceBus/namespaces@2024-01-01' existing = {
  name: service_bus_outputs_name
}


resource service_bus_AzureServiceBusDataOwner 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(service_bus.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '090c5cfd-751d-490a-894a-3ce6f1109419'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '090c5cfd-751d-490a-894a-3ce6f1109419')
    principalType: principalType
  }
  scope: service_bus
}
```

In addition to the Service Bus namespace, it also provisions an Azure role-based access control (Azure RBAC) built-in role of Azure Service Bus Data Owner. The role is assigned to the Service Bus namespace’s resource group. For more information, see [Azure Service Bus Data Owner](https://learn.microsoft.com/azure/role-based-access-control/built-in-roles/integration#azure-service-bus-data-owner).

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API. For example, you can configure the sku, location, and more. The following example demonstrates how to customize the Azure Service Bus resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureServiceBus("service-bus")
    .ConfigureInfrastructure(infra =>
    {
        var serviceBusNamespace = infra.GetProvisionableResources()
                                        .OfType<ServiceBusNamespace>()
                                        .Single();


        serviceBusNamespace.Sku = new ServiceBusSku
        {
            Name = ServiceBusSkuName.Premium
        };
        serviceBusNamespace.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `ServiceBusNamespace` is retrieved.
  * The `Sku` is created with a `ServiceBusSkuTier.Premium`.
  * A tag is added to the Service Bus namespace with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Azure Service Bus resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Azure Service Bus hosting integration automatically adds a health check for the Service Bus resource. The health check verifies that the Service Bus is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.AzureServiceBus](https://www.nuget.org/packages/AspNetCore.HealthChecks.AzureServiceBus) NuGet package.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Service Bus resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Service Bus namespace

[Section titled “Service Bus namespace”](#service-bus-namespace)

The Service Bus namespace resource exposes the following connection properties:

| Property Name      | Description                                                                     |
| ------------------ | ------------------------------------------------------------------------------- |
| `Host`             | The hostname of the Service Bus namespace                                       |
| `Port`             | The port of the Service Bus namespace when the emulator is used                 |
| `Uri`              | The connection URI, with the format `sb://myservicebus.servicebus.windows.net`  |
| `ConnectionString` | **Emulator only.** Includes SAS key material for the local emulator connection. |

#### Service Bus queue

[Section titled “Service Bus queue”](#service-bus-queue)

The Service Bus queue resource inherits all properties from its parent Service Bus namespace and adds:

| Property Name | Description           |
| ------------- | --------------------- |
| `QueueName`   | The name of the queue |

#### Service Bus topic

[Section titled “Service Bus topic”](#service-bus-topic)

The Service Bus topic resource inherits all properties from its parent Service Bus namespace and adds:

| Property Name | Description           |
| ------------- | --------------------- |
| `TopicName`   | The name of the topic |

#### Service Bus subscription

[Section titled “Service Bus subscription”](#service-bus-subscription)

The Service Bus subscription resource inherits all properties from its parent Service Bus topic and adds:

| Property Name      | Description                                |
| ------------------ | ------------------------------------------ |
| `SubscriptionName` | The name of the subscription               |
| `ConnectionString` | The connection string for the subscription |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `sb1` becomes `SB1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure Service Bus client integration, install the [📦 Aspire.Azure.Messaging.ServiceBus](https://www.nuget.org/packages/Aspire.Azure.Messaging.ServiceBus) NuGet package in the client-consuming project, that is, the project for the application that uses the Service Bus client. The Service Bus client integration registers a `ServiceBusClient` instance that you can use to interact with Service Bus.

* .NET CLI

  .NET CLI — Add Aspire.Azure.Messaging.ServiceBus package

  ```bash
  dotnet add package Aspire.Azure.Messaging.ServiceBus
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Messaging.ServiceBus@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Messaging.ServiceBus package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Messaging.ServiceBus" Version="*" />
  ```

### Add Service Bus client

[Section titled “Add Service Bus client”](#add-service-bus-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureServiceBusClient` extension method on any `IHostApplicationBuilder` to register a `ServiceBusClient` for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddAzureServiceBusClient(connectionName: "messaging");
```

You can then retrieve the `ServiceBusClient` instance using dependency injection. For example, to retrieve the connection from an example service:

```csharp
public class ExampleService(ServiceBusClient client)
{
    // Use client...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

### Choose the correct connection name

[Section titled “Choose the correct connection name”](#choose-the-correct-connection-name)

When you call `AddAzureServiceBusClient()`, the correct value depends on the object you passed to the client in the AppHost.

For example, if you use this code in the AppHost:

```csharp
var serviceBus = builder.AddAzureServiceBus("messaging");


var apiService = builder.AddProject<Projects.Example_ApiService>("apiservice")
    .WithReference(serviceBus);
```

Then the correct code to add the Service Bus in your client-consuming program is:

```csharp
builder.AddAzureServiceBusClient(connectionName: "messaging");
```

However, if you created and passed a Service Bus topic in the AppHost:

```csharp
var serviceBus = builder.AddAzureServiceBus("messaging");
var topic = serviceBus.AddServiceBusTopic("myTopic");


var apiService = builder.AddProject<Projects.Example_ApiService>("apiservice")
    .WithReference(topic);
```

Then the correct code to add the Service Bus topic in your client-consuming program is:

```csharp
builder.AddAzureServiceBusClient(connectionName: "myTopic");
```

For more information, see [Add Azure Service Bus resource](#add-azure-service-bus-resource) and [Add Azure Service Bus topic and subscription](#add-azure-service-bus-topic-and-subscription).

### Add keyed Service Bus client

[Section titled “Add keyed Service Bus client”](#add-keyed-service-bus-client)

There might be situations where you want to register multiple `ServiceBusClient` instances with different connection names. To register keyed Service Bus clients, call the `AddKeyedAzureServiceBusClient` method:

```csharp
builder.AddKeyedAzureServiceBusClient(name: "mainBus");
builder.AddKeyedAzureServiceBusClient(name: "loggingBus");
```

Caution

When using keyed services, it’s expected that your Service Bus resource configured two named buses, one for the `mainBus` and one for the `loggingBus`.

Then you can retrieve the `ServiceBusClient` instances using dependency injection. For example, to retrieve the connection from an example service:

```csharp
public class ExampleService(
    [FromKeyedServices("mainBus")] ServiceBusClient mainBusClient,
    [FromKeyedServices("loggingBus")] ServiceBusClient loggingBusClient)
{
    // Use clients...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure Service Bus integration provides multiple options to configure the connection based on the requirements and conventions of your project.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling the `AddAzureServiceBusClient` method:

```csharp
builder.AddAzureServiceBusClient("messaging");
```

Then the connection string is retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "messaging": "Endpoint=sb://{namespace}.servicebus.windows.net/;SharedAccessKeyName={keyName};SharedAccessKey={key};"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Azure Service Bus integration supports `Microsoft.Extensions.Configuration`. It loads the `AzureMessagingServiceBusSettings` from configuration by using the `Aspire:Azure:Messaging:ServiceBus` key. The following snippet is an example of an `appsettings.json` file that configures some of the options:

```json
{
  "Aspire": {
    "Azure": {
      "Messaging": {
        "ServiceBus": {
          "ConnectionString": "Endpoint=sb://{namespace}.servicebus.windows.net/;SharedAccessKeyName={keyName};SharedAccessKey={key};",
          "DisableTracing": false
        }
      }
    }
  }
}
```

For the complete Service Bus client integration JSON schema, see [Aspire.Azure.Messaging.ServiceBus/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/v9.1.0/src/Components/Aspire.Azure.Messaging.ServiceBus/ConfigurationSchema.json).

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Aspire Azure Service Bus integration supports named configuration, which allows you to configure multiple instances of the same resource type with different settings. The named configuration uses the connection name as a key under the main configuration section.

```json
{
  "Aspire": {
    "Azure": {
      "Messaging": {
        "ServiceBus": {
          "bus1": {
            "ConnectionString": "Endpoint=sb://namespace1.servicebus.windows.net/;SharedAccessKeyName=keyName;SharedAccessKey=key;",
            "DisableTracing": false
          },
          "bus2": {
            "ConnectionString": "Endpoint=sb://namespace2.servicebus.windows.net/;SharedAccessKeyName=keyName;SharedAccessKey=key;",
            "DisableTracing": true
          }
        }
      }
    }
  }
}
```

In this example, the `bus1` and `bus2` connection names can be used when calling `AddAzureServiceBusClient`:

```csharp
builder.AddAzureServiceBusClient("bus1");
builder.AddAzureServiceBusClient("bus2");
```

Named configuration takes precedence over the top-level configuration. If both are provided, the settings from the named configuration override the top-level settings.

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureMessagingServiceBusSettings> configureSettings` delegate to set up some or all the options inline, for example to disable tracing from code:

```csharp
builder.AddAzureServiceBusClient(
    "messaging",
    static settings => settings.DisableTracing = true);
```

You can also set up the `ServiceBusClientOptions` using the optional `Action<ServiceBusClientOptions> configureClientOptions` parameter of the `AddAzureServiceBusClient` method. For example, to set the `Identifier` user-agent header suffix for all requests issued by this client:

```csharp
builder.AddAzureServiceBusClient(
    "messaging",
    configureClientOptions:
        clientOptions => clientOptions.Identifier = "myapp");
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

The Aspire Azure Service Bus integration:

* Adds the health check when `DisableTracing` is `false`, which attempts to connect to the Service Bus.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

#### Logging

[Section titled “Logging”](#logging)

The Aspire Azure Service Bus integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`
* `Azure-Messaging-ServiceBus`

In addition to getting Azure Service Bus request diagnostics for failed requests, you can configure latency thresholds to determine which successful Azure Service Bus request diagnostics will be logged. The default values are 100 ms for point operations and 500 ms for non point operations.

```csharp
builder.AddAzureServiceBusClient(
    "messaging",
    configureClientOptions:
        clientOptions => {
            clientOptions.ServiceBusClientTelemetryOptions = new()
            {
                ServiceBusThresholdOptions = new()
                {
                    PointOperationLatencyThreshold = TimeSpan.FromMilliseconds(50),
                    NonPointOperationLatencyThreshold = TimeSpan.FromMilliseconds(300)
                }
            };
        });
```

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure Service Bus integration will emit the following tracing activities using OpenTelemetry:

* `Message`
* `ServiceBusSender.Send`
* `ServiceBusSender.Schedule`
* `ServiceBusSender.Cancel`
* `ServiceBusReceiver.Receive`
* `ServiceBusReceiver.ReceiveDeferred`
* `ServiceBusReceiver.Peek`
* `ServiceBusReceiver.Abandon`
* `ServiceBusReceiver.Complete`
* `ServiceBusReceiver.DeadLetter`
* `ServiceBusReceiver.Defer`
* `ServiceBusReceiver.RenewMessageLock`
* `ServiceBusSessionReceiver.RenewSessionLock`
* `ServiceBusSessionReceiver.GetSessionState`
* `ServiceBusSessionReceiver.SetSessionState`
* `ServiceBusProcessor.ProcessMessage`
* `ServiceBusSessionProcessor.ProcessSessionMessage`
* `ServiceBusRuleManager.CreateRule`
* `ServiceBusRuleManager.DeleteRule`
* `ServiceBusRuleManager.GetRules`

Azure Service Bus tracing is currently in preview, so you must set the experimental switch to ensure traces are emitted.

```csharp
AppContext.SetSwitch("Azure.Experimental.EnableActivitySource", true);
```

For more information, see [Azure Service Bus: Distributed tracing and correlation through Service Bus messaging](https://learn.microsoft.com/azure/service-bus-messaging/service-bus-end-to-end-tracing).

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure Service Bus integration currently doesn’t support metrics by default due to limitations with the Azure SDK.

# Azure SignalR Service integration

> This article describes the Aspire Azure SignalR Service integration features and capabilities.

![Azure SignalR Service icon](/_astro/azure-signalr-icon.D9MOb89K_762iY.webp)

[Azure SignalR Service](https://learn.microsoft.com/azure-signalr) is a fully managed real-time messaging service that simplifies adding real-time web functionality to applications. The Aspire Azure SignalR Service integration enables you to connect to Azure SignalR instances from your applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure SignalR Service hosting integration models Azure SignalR resources as the following types:

* `AzureSignalRResource`: Represents an Azure SignalR Service resource, including connection information to the underlying Azure resource.
* `AzureSignalREmulatorResource`: Represents an emulator for Azure SignalR Service, allowing local development and testing without requiring an Azure subscription.

To access the hosting types and APIs for expressing these resources in the distributed application builder, install the [📦 Aspire.Hosting.Azure.SignalR](https://www.nuget.org/packages/Aspire.Hosting.Azure.SignalR) NuGet package in your [AppHost](/get-started/app-host/) project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.SignalR package

  ```bash
  aspire add azure-signalr
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-signalr (Aspire.Hosting.Azure.SignalR)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.SignalR@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.SignalR package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.SignalR" Version="*" />
  ```

### Add an Azure SignalR Service resource

[Section titled “Add an Azure SignalR Service resource”](#add-an-azure-signalr-service-resource)

To add an Azure SignalR Service resource to your AppHost project, call the `AddAzureSignalR` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var signalR = builder.AddAzureSignalR("signalr");


var api = builder.AddProject<Projects.ApiService>("api")
    .WithReference(signalR)
    .WaitFor(signalR);


builder.AddProject<Projects.WebApp>("webapp")
    .WithReference(api)
    .WaitFor(api);


// Continue configuring and run the app...
```

In the preceding example:

* An Azure SignalR Service resource named `signalr` is added.
* The `signalr` resource is referenced by the `api` project.
* The `api` project is referenced by the `webapp` project.

This architecture allows the `webapp` project to communicate with the `api` project, which in turn communicates with the Azure SignalR Service resource.

Caution

When you call `AddAzureSignalR`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure SignalR instance

[Section titled “Connect to an existing Azure SignalR instance”](#connect-to-an-existing-azure-signalr-instance)

You might have an existing Azure SignalR Service that you want to connect to. You can chain a call to annotate that your `AzureSignalRResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingSignalRName = builder.AddParameter("existingSignalRName");
var existingSignalRResourceGroup = builder.AddParameter("existingSignalRResourceGroup");


var signalr = builder.AddAzureSignalR("signalr")
    .AsExisting(existingSignalRName, existingSignalRResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(signalr);


// After adding all resources, run the app...
```

For more information on treating Azure SignalR resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure SignalR resource, you can add a connection string to the AppHost. This approach is weakly-typed and doesn’t work with role assignments or infrastructure customizations.

### Add an Azure SignalR Service emulator resource

[Section titled “Add an Azure SignalR Service emulator resource”](#add-an-azure-signalr-service-emulator-resource)

The Azure SignalR Service emulator is a local development and testing tool that emulates the behavior of Azure SignalR Service. This emulator only supports [*Serverless* mode](https://learn.microsoft.com/azure/azure-signalr/concept-service-mode#serverless-mode), which requires a specific configuration when using the emulator.

To use the emulator, chain a call to the `RunAsEmulator` method:

```csharp
using Aspire.Hosting.Azure;


var builder = DistributedApplication.CreateBuilder(args);


var signalR = builder.AddAzureSignalR("signalr", AzureSignalRServiceMode.Serverless)
    .RunAsEmulator();


builder.AddProject<Projects.ApiService>("apiService")
    .WithReference(signalR)
    .WaitFor(signalR);


// After adding all resources, run the app...
```

In the preceding example, the `RunAsEmulator` method configures the Azure SignalR Service resource to run as an emulator. The emulator is based on the `mcr.microsoft.com/signalr/signalr-emulator:latest` container image. The emulator is started when the AppHost is run, and is stopped when the AppHost is stopped.

#### Azure SignalR Service modes

[Section titled “Azure SignalR Service modes”](#azure-signalr-service-modes)

While the Azure SignalR Service emulator only supports the *Serverless* mode, the Azure SignalR Service resource can be configured to use either of the following modes:

* `AzureSignalRServiceMode.Default`
* `AzureSignalRServiceMode.Serverless`

The *Default* mode is the “default” configuration for Azure SignalR Service. Each mode has its own set of features and limitations. For more information, see [Azure SignalR Service modes](https://learn.microsoft.com/azure/azure-signalr/concept-service-mode).

Caution

The Azure SignalR Service emulator only works in *Serverless* mode and the `AddNamedAzureSignalR` method doesn’t support *Serverless* mode.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

When you add an Azure SignalR Service resource, Aspire generates provisioning infrastructure using [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview). The generated Bicep includes defaults for location, SKU, and role assignments:

signalr.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource signalr 'Microsoft.SignalRService/signalR@2024-03-01' = {
  name: take('signalr-${uniqueString(resourceGroup().id)}', 63)
  location: location
  properties: {
    cors: {
      allowedOrigins: [
        '*'
      ]
    }
    disableLocalAuth: true
    features: [
      {
        flag: 'ServiceMode'
        value: 'Default'
      }
    ]
  }
  kind: 'SignalR'
  sku: {
    name: 'Free_F1'
    capacity: 1
  }
  tags: {
    'aspire-resource-name': 'signalr'
  }
}


output hostName string = signalr.properties.hostName


output name string = signalr.name
```

The preceding Bicep is a module that provisions an Azure SignalR Service resource. Additionally, role assignments are created for the Azure resource in a separate module:

signalr-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param signalr_outputs_name string


param principalType string


param principalId string


resource signalr 'Microsoft.SignalRService/signalR@2024-03-01' existing = {
  name: signalr_outputs_name
}


resource signalr_SignalRAppServer 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(signalr.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '420fcaa2-552c-430f-98ca-3264be4806c7'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '420fcaa2-552c-430f-98ca-3264be4806c7')
    principalType: principalType
  }
  scope: signalr
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureSignalR("signalr")
    .ConfigureInfrastructure(infra =>
    {
        var signalRService = infra.GetProvisionableResources()
                                  .OfType<SignalRService>()
                                  .Single();


        signalRService.Sku.Name = "Premium_P1";
        signalRService.Sku.Capacity = 10;
        signalRService.PublicNetworkAccess = "Enabled";
        signalRService.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `SignalRService` resource is retrieved.
  * The `Sku` object has its name and capacity properties set.
  * A tag is added to the SignalR resource with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the SignalR resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference an Azure SignalR resource using `WithReference`, the following connection properties are made available to the consuming project:

| Property Name | Description                                                                                                                                                                                            |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Uri`         | The connection URI for the SignalR service, with the format `https://{host}` in Azure (typically `https://<resource-name>.service.signalr.net`) or the emulator-provided endpoint when running locally |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `sr` becomes `SR_URI`.

## Hub host integration

[Section titled “Hub host integration”](#hub-host-integration)

There isn’t an official Aspire Azure SignalR *client integration*. However, there is limited support for similar experiences. In these scenarios, the Azure SignalR Service acts as a proxy between the server (where the `Hub` or `Hub<T>` are hosted) and the client (where the SignalR client is hosted). The Azure SignalR Service routes traffic between the server and client, allowing for real-time communication.

Caution

It’s important to disambiguate between Aspire client integrations and the .NET SignalR client. SignalR exposes hubs—which act as a server-side concept—and SignalR clients connect to those hubs. The .NET projects that host SignalR hubs are where you integrate with Aspire. The SignalR client is a separate library that connects to those hubs, in a different project.

There are two packages available for, each with addressing specific scenarios such as managing the client connection to Azure SignalR Service, and hooking up to the Azure SignalR Service resource. To get started, install the [📦 Microsoft.Azure.SignalR](https://www.nuget.org/packages/Microsoft.Azure.SignalR) NuGet package in the project hosting your SignalR hub.

* .NET CLI

  .NET CLI — Add Microsoft.Azure.SignalR package

  ```bash
  dotnet add package Microsoft.Azure.SignalR
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Microsoft.Azure.SignalR@*
  ```

* PackageReference (\*.csproj)

  XML — Add Microsoft.Azure.SignalR package reference

  ```xml
  <PackageReference Include="Microsoft.Azure.SignalR" Version="*" />
  ```

### Configure named Azure SignalR Service in Default mode

[Section titled “Configure named Azure SignalR Service in Default mode”](#configure-named-azure-signalr-service-in-default-mode)

In *Default* mode, your consuming project needs to rely on a named Azure SignalR Service resource. Consider the following diagram that illustrates the architecture of Azure SignalR Service in *Default* mode:

![Azure SignalR Service: Default mode diagram.](/_astro/default-mode.DMoLcnJU.svg)

For more information on *Default* mode, see [Azure SignalR Service: Default mode](https://learn.microsoft.com/azure/azure-signalr/concept-service-mode#default-mode).

In your SignalR hub host project, configure Azure SignalR Service by chaining calls to `.AddSignalR().AddNamedAzureSignalR("name")`:

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.Services.AddSignalR()
                .AddNamedAzureSignalR("signalr");


var app = builder.Build();


app.MapHub<ChatHub>("/chat");


app.Run();
```

The `AddNamedAzureSignalR` method configures the project to use the Azure SignalR Service resource named `signalr`. The connection string is read from the configuration key `ConnectionStrings:signalr`, and additional settings are loaded from the `Azure:SignalR:signalr` configuration section.

Note

If you’re using the Azure SignalR emulator, you cannot use the `AddNamedAzureSignalR` method.

### Configure Azure SignalR Service in Serverless mode

[Section titled “Configure Azure SignalR Service in Serverless mode”](#configure-azure-signalr-service-in-serverless-mode)

If you’re AppHost is using the Azure SignalR emulator, you’ll also need to install the [📦 Microsoft.Azure.SignalR.Management](https://www.nuget.org/packages/Microsoft.Azure.SignalR.Management) NuGet package.

* .NET CLI

  .NET CLI — Add Microsoft.Azure.SignalR.Management package

  ```bash
  dotnet add package Microsoft.Azure.SignalR.Management
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Microsoft.Azure.SignalR.Management@*
  ```

* PackageReference (\*.csproj)

  XML — Add Microsoft.Azure.SignalR.Management package reference

  ```xml
  <PackageReference Include="Microsoft.Azure.SignalR.Management" Version="*" />
  ```

Azure SignalR *Serverless* mode doesn’t require a hub server to be running. The Azure SignalR Service is responsible for maintaining client connections. Additionally, in this mode, you cannot use traditional SignalR Hubs, such as `Microsoft.AspNetCore.SignalR.Hub`, `Microsoft.AspNetCore.SignalR.Hub<T>`, or `Microsoft.AspNetCore.SignalR.IHubContext<THub>`. Instead, [configure an upstream endpoint which is usually an Azure Function SignalR trigger](https://learn.microsoft.com/azure/azure-signalr/concept-upstream). Consider the following diagram that illustrates the architecture of Azure SignalR Service in *Serverless* mode:

![Azure SignalR Service: Serverless mode diagram.](/_astro/serverless-mode.D3ZTFQwZ.svg)

For more information on *Serverless* mode, see [Azure SignalR Service: Serverless mode](https://learn.microsoft.com/azure/azure-signalr/concept-service-mode#serverless-mode).

In a project that’s intended to communicate with the Azure SignalR Service, register the appropriate services by calling `AddSignalR` and then registering the `ServiceManager` using the `signalr` connection string and add a `/negotiate` endpoint:

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.Services.AddSingleton(sp =>
{
   return new ServiceManagerBuilder()
       .WithOptions(options =>
       {
           options.ConnectionString = builder.Configuration.GetConnectionString("signalr");
       })
       .BuildServiceManager();
});


var app = builder.Build();


app.MapPost("/negotiate", async (string? userId, ServiceManager sm, CancellationToken token) =>
{
    // The creation of the ServiceHubContext is expensive, so it's recommended to
    // only create it once per named context / per app run if possible.
    var context = await sm.CreateHubContextAsync("messages", token);


    var negotiateResponse = await context.NegotiateAsync(new NegotiationOptions
    {
        UserId = userId
    }, token);


    // The JSON serializer options need to be set to ignore null values, otherwise the
    // response will contain null values for the properties that are not set.
    // The .NET SignalR client will not be able to parse the response if the null values are present.
    // For more information, see https://github.com/dotnet/aspnetcore/issues/60935.
    return Results.Json(negotiateResponse, new JsonSerializerOptions(JsonSerializerDefaults.Web)
    {
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    });
});


app.Run();
```

The preceding code configures the Azure SignalR Service using the `ServiceManagerBuilder` class, but doesn’t call `AddSignalR` or `MapHub`. These two extensions aren’t required with *Serverless* mode. The connection string is read from the configuration key `ConnectionStrings:signalr`. When using the emulator, only the HTTP endpoint is available. Within the app, you can use the `ServiceManager` instance to create a `ServiceHubContext`. The `ServiceHubContext` is used to broadcast messages and manage connections to clients.

The `/negotiate` endpoint is required to establish a connection between the connecting client and the Azure SignalR Service. The `ServiceHubContext` is created using the `ServiceManager.CreateHubContextAsync` method, which takes the hub name as a parameter. The `NegotiateAsync` method is called to negotiate the connection with the Azure SignalR Service, which returns an access token and the URL for the client to connect to.

For more information, see [Use Azure SignalR Management SDK](https://learn.microsoft.com/azure/azure-signalr/signalr-howto-use-management-sdk).

# Azure SQL Database integration

> This article describes the Aspire Azure SQL Database integration features and capabilities.

![Azure SQL Database logo](/_astro/azure-sqlserver-icon.Cqcoy_ug_bKS6O.webp)

[Azure SQL](https://azure.microsoft.com/products/azure-sql) is a family of relational database management systems that run in the Azure cloud. The database systems are Platform-as-a-Service (PaaS) products that enable database administrators to implement highly scalable and available databases without maintaining complex infrastructures themselves. The Aspire Azure SQL Server Hosting integration provides methods to create a new Azure Database server and databases from code in your Aspire AppHost project. In a consuming project, you can use the Aspire SQL Server client integration as you would for any other SQL Server instance.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure SQL Database hosting integration models the SQL Server as the `AzureSqlServerResource` type and SQL databases as the `AzureSqlDatabaseResource` type. To access these types and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.Sql](https://www.nuget.org/packages/Aspire.Hosting.Azure.Sql) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Sql package

  ```bash
  aspire add azure-sql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-sql (Aspire.Hosting.Azure.Sql)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Sql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Sql package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Sql" Version="*" />
  ```

### Add Azure SQL server resource and database resource

[Section titled “Add Azure SQL server resource and database resource”](#add-azure-sql-server-resource-and-database-resource)

In your AppHost project, call `AddAzureSqlServer` to add and return an Azure SQL server resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add an Azure SQL database resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var azureSql = builder.AddAzureSqlServer("azuresql")
    .AddDatabase("database");


var myService = builder.AddProject<Projects.MyService>()
    .WithReference(azureSql);
```

The preceding call to `AddAzureSqlServer` configures the Azure SQL server resource to be deployed as an [Azure SQL Database server](https://learn.microsoft.com/azure/azure-sql/database/sql-database-paas-overview).

Caution

When you call `AddAzureSqlServer`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure SQL server

[Section titled “Connect to an existing Azure SQL server”](#connect-to-an-existing-azure-sql-server)

You might have an existing Azure SQL Database service that you want to connect to. You can chain a call to annotate that your `AzureSqlServerResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingSqlServerName = builder.AddParameter("existingSqlServerName");
var existingSqlServerResourceGroup = builder.AddParameter("existingSqlServerResourceGroup");


var sqlserver = builder.AddAzureSqlServer("sqlserver")
    .AsExisting(existingSqlServerName, existingSqlServerResourceGroup)
    .AddDatabase("database");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(sqlserver);


// After adding all resources, run the app...
```

For more information on treating Azure SQL resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

### Run Azure SQL server resource as a container

[Section titled “Run Azure SQL server resource as a container”](#run-azure-sql-server-resource-as-a-container)

The Azure SQL Server hosting integration supports running the Azure SQL server as a local container. This is beneficial for situations where you want to run the Azure SQL server locally for development and testing purposes, avoiding the need to provision an Azure resource or connect to an existing Azure SQL server.

To run the Azure SQL server as a container, call the `RunAsContainer` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var azureSql = builder.AddAzureSqlServer("azuresql")
    .RunAsContainer();


var azureSqlData = azureSql.AddDatabase("database");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
    .WithReference(azureSqlData);
```

The preceding code configures an Azure SQL Database resource to run locally in a container.

Tip

The `RunAsContainer` method is useful for local development and testing. The API exposes an optional delegate that enables you to customize the underlying `SqlServerServerResource` configuration. For example, you can add a data volume or data bind mount. For more information, see the [Aspire SQL Server hosting integration](/integrations/databases/sql-server/sql-server-host/#add-sql-server-resource-with-data-volume) section.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure SQL Server resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Azure SQL Server resource

[Section titled “Azure SQL Server resource”](#azure-sql-server-resource)

The Azure SQL Server resource exposes the following connection properties:

| Property Name          | Description                                                                                                       |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `Host`                 | The fully qualified domain name of the Azure SQL Server                                                           |
| `Port`                 | The SQL Server port (`1433` for Azure)                                                                            |
| `Uri`                  | The connection URI, with the format `mssql://{Host}:{Port}`                                                       |
| `JdbcConnectionString` | JDBC connection string with the format `jdbc:sqlserver://{Host}:{Port};encrypt=true;trustServerCertificate=false` |

#### Azure SQL database resource

[Section titled “Azure SQL database resource”](#azure-sql-database-resource)

The Azure SQL database resource inherits all properties from its parent Azure SQL Server resource and adds:

| Property Name          | Description                                                                                                                               |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `DatabaseName`         | The name of the database                                                                                                                  |
| `Uri`                  | The connection URI, with the format `mssql://{Host}:{Port}/{DatabaseName}`                                                                |
| `JdbcConnectionString` | JDBC connection string with the format `jdbc:sqlserver://{Host}:{Port};database={DatabaseName};encrypt=true;trustServerCertificate=false` |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`. The client should add a valid authentication property for the JDBC connection string like `authentication=ActiveDirectoryDefault` or `authentication=ActiveDirectoryManagedIdentity`.

## Client integration

[Section titled “Client integration”](#client-integration)

The Aspire Azure SQL Database client integration is used to connect to an Azure SQL database using Microsoft.Data.SqlClient. To get started with the Aspire Azure SQL Database client integration, install the [📦 Aspire.Microsoft.Data.SqlClient](https://www.nuget.org/packages/Aspire.Microsoft.Data.SqlClient) NuGet package.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.Data.SqlClient package

  ```bash
  dotnet add package Aspire.Microsoft.Data.SqlClient
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.Data.SqlClient@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.Data.SqlClient package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.Data.SqlClient" Version="*" />
  ```

### Add SQL Server client

[Section titled “Add SQL Server client”](#add-sql-server-client)

In the `Program.cs` file of your client-consuming project, call the `AddSqlServerClient` extension method to register a `SqlConnection` for use via the dependency injection container. The method takes a connection name parameter:

```csharp
builder.AddSqlServerClient(connectionName: "database");
```

Tip

The `connectionName` parameter must match the name used when adding the SQL database resource in the AppHost project.

After adding the `SqlConnection`, you can retrieve the connection instance using dependency injection:

```csharp
public class ExampleService(SqlConnection connection)
{
    // Use connection...
}
```

For more information, see:

* [Microsoft.Data.SqlClient documentation](https://learn.microsoft.com/sql/connect/ado-net/introduction-microsoft-data-sqlclient-namespace) for examples on using the `SqlConnection`.
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.

### Add keyed SQL client

[Section titled “Add keyed SQL client”](#add-keyed-sql-client)

There might be situations where you want to register multiple `SqlConnection` instances with different connection names. To register keyed SQL clients, call the `AddKeyedSqlServerClient` method:

```csharp
builder.AddKeyedSqlServerClient(name: "primary-db");
builder.AddKeyedSqlServerClient(name: "secondary-db");
```

Then you can retrieve the connection instances using dependency injection:

```csharp
public class ExampleService(
    [KeyedService("primary-db")] SqlConnection primaryConnection,
    [KeyedService("secondary-db")] SqlConnection secondaryConnection)
{
    // Use connections...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure SQL Database library provides multiple options to configure the SQL connection based on the requirements and conventions of your project. A `ConnectionString` is required.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddSqlServerClient`:

```csharp
builder.AddSqlServerClient(connectionName: "database");
```

The connection information is retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "database": "Server=myserver;Database=mydb;User Id=myuser;Password=mypassword;Encrypt=True"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The library supports `Microsoft.Extensions.Configuration`. It loads settings from configuration using the `Aspire:Microsoft:Data:SqlClient` key:

```json
{
  "Aspire": {
    "Microsoft": {
      "Data": {
        "SqlClient": {
          "DisableHealthChecks": true,
          "DisableTracing": false,
          "DisableMetrics": false
        }
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can configure settings inline:

```csharp
builder.AddSqlServerClient(
    "database",
    settings => settings.DisableHealthChecks = true);
```

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

#### Logging

[Section titled “Logging”](#logging)

The Aspire Azure SQL Database integration uses the following log categories:

* `Microsoft.Data.SqlClient`

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure SQL Database integration will emit the following tracing activities using OpenTelemetry:

* `Microsoft.Data.SqlClient`

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure SQL Database integration will emit the following metrics using OpenTelemetry:

* `Microsoft.Data.SqlClient`

  * `db.client.connections.create_time`
  * `db.client.connections.use_time`
  * `db.client.connections.wait_time`
  * `db.client.connections.idle.max`
  * `db.client.connections.idle.min`
  * `db.client.connections.max`
  * `db.client.connections.pending_requests`
  * `db.client.connections.timeouts`
  * `db.client.connections.usage`

# Azure Blob Storage

> Learn how to use the Azure Blob Storage integration, which includes both hosting and client integrations.

![Azure Blob Storage logo](/_astro/azure-storagecontainer-icon.BHpAHDcw_rTffx.webp)

[Azure Blob Storage](https://azure.microsoft.com/services/storage/blobs/) is a service for storing large amounts of unstructured data. The Aspire Azure Blob Storage integration enables you to connect to existing Azure Storage instances or create new instances from applications with the [`mcr.microsoft.com/azure-storage/azurite` container image](https://mcr.microsoft.com/product/azure-storage/azurite/about).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire [Azure Storage](https://learn.microsoft.com/azure/storage/) hosting integration models the various storage resources as the following types:

* `AzureStorageResource`: Represents an Azure Storage resource.
* `AzureStorageEmulatorResource`: Represents an Azure Storage emulator resource (Azurite).
* `AzureBlobStorageResource`: Represents an Azure Blob storage resource.

To access these types and APIs for expressing them, add the [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage) NuGet package in the [AppHost](/get-started/app-host/) project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Storage package

  ```bash
  aspire add azure-storage
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-storage (Aspire.Hosting.Azure.Storage)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Storage@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Storage package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Storage" Version="*" />
  ```

### Add Azure Blob Storage resource

[Section titled “Add Azure Blob Storage resource”](#add-azure-blob-storage-resource)

In your AppHost project, register the Azure Blob Storage integration by chaining a call to `AddBlobs` on the `IResourceBuilder<IAzureStorageResource>` instance returned by `AddAzureStorage`. The following example demonstrates how to add an Azure Blob Storage resource named `storage` and a blob container named `blobs`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var blobs = builder.AddAzureStorage("storage")
    .AddBlobs("blobs");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(blobs)
    .WaitFor(blobs);


// After adding all resources, run the app...
```

The preceding code:

* Adds an Azure Storage resource named `storage`.
* Chains a call to `RunAsEmulator` to configure the storage resource to run locally using an emulator. The emulator in this case is [Azurite](https://learn.microsoft.com/azure/storage/common/storage-use-azurite).
* Adds a blob container named `blobs` to the storage resource.
* Adds the `blobs` resource to the `ExampleProject` and waits for it to be ready before starting the project.

Caution

When you call `AddAzureStorage`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Storage account

[Section titled “Connect to an existing Azure Storage account”](#connect-to-an-existing-azure-storage-account)

You might have an existing Azure Storage account that you want to connect to. You can chain a call to annotate that your `AzureStorageResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingStorageName = builder.AddParameter("existingStorageName");
var existingStorageResourceGroup = builder.AddParameter("existingStorageResourceGroup");


var storageaccount = builder.AddAzureStorage("storage")
    .AsExisting(existingStorageName, existingStorageResourceGroup)
    .AddBlobs("blobs");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(storageaccount);


// After adding all resources, run the app...
```

Caution

When you call `RunAsExisting`, `PublishAsExisting`, or `AsExisting` methods to work with resources that are already present in your Azure subscription, you must add certain configuration values to your AppHost to ensure that Aspire can locate them. The necessary configuration values include **SubscriptionId**, **AllowResourceGroupCreation**, **ResourceGroup**, and **Location**. If you don’t set them, “Missing configuration” errors appear in the Aspire dashboard. For more information about how to set them, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

#### Configure Azurite container

[Section titled “Configure Azurite container”](#configure-azurite-container)

There are various configurations available to container resources, for example, you can configure the container’s ports, environment variables, it’s lifetime, and more.

##### Configure Azurite container ports

[Section titled “Configure Azurite container ports”](#configure-azurite-container-ports)

By default, the Azurite container when configured by Aspire, exposes the following endpoints:

| Endpoint | Container port | Host port |
| -------- | -------------- | --------- |
| `blob`   | 10000          | dynamic   |
| `queue`  | 10001          | dynamic   |
| `table`  | 10002          | dynamic   |

The port that they’re listening on is dynamic by default. When the container starts, the ports are mapped to a random port on the host machine. To configure the endpoint ports, chain calls on the container resource builder provided by the `RunAsEmulator` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
  .RunAsEmulator(azurite =>
  {
      azurite.WithBlobPort(27000)
             .WithQueuePort(27001)
             .WithTablePort(27002);
  });


// After adding all resources, run the app...
```

The preceding code configures the Azurite container’s existing `blob`, `queue`, and `table` endpoints to listen on ports `27000`, `27001`, and `27002`, respectively. The Azurite container’s ports are mapped to the host ports as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------: | ------------------------------- |
|        `blob` | `10000:27000`                   |
|       `queue` | `10001:27001`                   |
|       `table` | `10002:27002`                   |

##### Configure Azurite container with persistent lifetime

[Section titled “Configure Azurite container with persistent lifetime”](#configure-azurite-container-with-persistent-lifetime)

To configure the Azurite container with a persistent lifetime, call the `WithLifetime` method on the Azurite container resource and pass `ContainerLifetime.Persistent`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithLifetime(ContainerLifetime.Persistent);
    });


// After adding all resources, run the app...
```

##### Configure Azurite container with data volume

[Section titled “Configure Azurite container with data volume”](#configure-azurite-container-with-data-volume)

To add a data volume to the Azure Storage emulator resource, call the `WithDataVolume` method on the Azure Storage emulator resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithDataVolume();
    });


// After adding all resources, run the app...
```

The data volume is used to persist the Azurite data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Azurite container and when a `name` parameter isn’t provided, the name is formatted as `.azurite/{resource name}`. For more information on data volumes and details on why they’re preferred over [bind mounts](#configure-azurite-container-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

##### Configure Azurite container with data bind mount

[Section titled “Configure Azurite container with data bind mount”](#configure-azurite-container-with-data-bind-mount)

To add a data bind mount to the Azure Storage emulator resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithDataBindMount("../azurite/data");
    });


// After adding all resources, run the app...
```

Caution

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the Azurite data across container restarts. The data bind mount is mounted at the `../azurite/data` path on the host machine relative to the AppHost directory (`IDistributedApplicationBuilder.AppHostDirectory`) in the Azurite container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

### Connect to storage resources

[Section titled “Connect to storage resources”](#connect-to-storage-resources)

When the Aspire AppHost runs, the storage resources can be accessed by external tools, such as the [Azure Storage Explorer](https://azure.microsoft.com/features/storage-explorer/). If your storage resource is running locally using Azurite, it will automatically be picked up by the Azure Storage Explorer.

Note

The Azure Storage Explorer discovers Azurite storage resources assuming the default ports are used. If you’ve [configured the Azurite container to use different ports](#configure-azurite-container-ports), you’ll need to configure the Azure Storage Explorer to connect to the correct ports.

To connect to the storage resource from Azure Storage Explorer, follow these steps:

1. Run the Aspire AppHost.

2. Open the Azure Storage Explorer.

3. View the **Explorer** pane.

4. Select the **Refresh all** link to refresh the list of storage accounts.

5. Expand the **Emulator & Attached** node.

6. Expand the **Storage Accounts** node.

7. You should see a storage account with your resource’s name as a prefix:

   ![Azure Storage Explorer: Azurite storage resource discovered.](/_astro/azure-storage-explorer.BVwS67k7_xnqII.webp)

You’re free to explore the storage account and its contents using the Azure Storage Explorer. For more information on using the Azure Storage Explorer, see [Get started with Storage Explorer](https://learn.microsoft.com/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Storage resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Azure Storage

[Section titled “Azure Storage”](#azure-storage)

The Azure Storage account resource doesn’t expose any connection property, reference sub-resources:

#### Blob Storage

[Section titled “Blob Storage”](#blob-storage)

The Blob Storage resource exposes the following connection properties:

| Property Name      | Description                                                                                            |
| ------------------ | ------------------------------------------------------------------------------------------------------ |
| `Uri`              | The URI of the blob storage service, with the format `https://mystorageaccount.blob.core.windows.net/` |
| `ConnectionString` | **Emulator only.** The connection string for the blob storage service                                  |

#### Blob Container

[Section titled “Blob Container”](#blob-container)

The Blob Container resource inherits all properties from its parent `AzureBlobStorageResource` and adds:

| Property Name       | Description                    |
| ------------------- | ------------------------------ |
| `BlobContainerName` | The name of the blob container |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `blobs1` becomes `BLOBS1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure Blob Storage client integration, install the [📦 Aspire.Azure.Storage.Blobs](https://www.nuget.org/packages/Aspire.Azure.Storage.Blobs) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.Azure.Storage.Blobs package

  ```bash
  dotnet add package Aspire.Azure.Storage.Blobs
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Storage.Blobs@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Storage.Blobs package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Storage.Blobs" Version="*" />
  ```

### Add Azure Blob Storage client

[Section titled “Add Azure Blob Storage client”](#add-azure-blob-storage-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureBlobServiceClient` extension method to register a `BlobServiceClient` for dependency injection. The method takes a connection name parameter:

```csharp
builder.AddAzureBlobServiceClient("blobs");
```

You can then retrieve the `BlobServiceClient` instance using dependency injection:

```csharp
public class ExampleService(BlobServiceClient client)
{
    // Use client...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Azure Blob Storage integration provides multiple options to configure the `BlobServiceClient`.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name when calling `AddAzureBlobServiceClient`:

```csharp
builder.AddAzureBlobServiceClient("blobs");
```

Two connection formats are supported:

##### Service URI

[Section titled “Service URI”](#service-uri)

The recommended approach is to use a `ServiceUri`, which works with the `Credential` property. If no credential is configured, the `DefaultAzureCredential` is used:

```json
{
  "ConnectionStrings": {
    "blobs": "https://{account_name}.blob.core.windows.net/"
  }
}
```

##### Connection string

[Section titled “Connection string”](#connection-string)

Alternatively, an [Azure Storage connection string](https://learn.microsoft.com/azure/storage/common/storage-configure-connection-string) can be used:

```json
{
  "ConnectionStrings": {
    "blobs": "AccountName=myaccount;AccountKey=myaccountkey"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Azure Blob Storage integration supports `Microsoft.Extensions.Configuration`. It loads the `AzureStorageBlobsSettings` and `BlobClientOptions` from configuration using the `Aspire:Azure:Storage:Blobs` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "Azure": {
      "Storage": {
        "Blobs": {
          "DisableHealthChecks": true,
          "DisableTracing": false,
          "ClientOptions": {
            "Diagnostics": {
              "ApplicationId": "myapp"
            }
          }
        }
      }
    }
  }
}
```

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Azure Blob Storage integration supports named configuration for multiple instances:

```json
{
  "Aspire": {
    "Azure": {
      "Storage": {
        "Blobs": {
          "blob1": {
            "DisableHealthChecks": true,
            "ClientOptions": {
              "Diagnostics": {
                "ApplicationId": "myapp1"
              }
            }
          },
          "blob2": {
            "DisableTracing": true,
            "ClientOptions": {
              "Diagnostics": {
                "ApplicationId": "myapp2"
              }
            }
          }
        }
      }
    }
  }
}
```

Use the connection names when calling `AddAzureBlobServiceClient`:

```csharp
builder.AddAzureBlobServiceClient("blob1");
builder.AddAzureBlobServiceClient("blob2");
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureStorageBlobsSettings>` delegate to set up options inline:

```csharp
builder.AddAzureBlobServiceClient(
    "blobs",
    settings => settings.DisableHealthChecks = true);
```

You can also configure the `BlobClientOptions`:

```csharp
builder.AddAzureBlobServiceClient(
    "blobs",
    configureClientBuilder: clientBuilder =>
        clientBuilder.ConfigureOptions(
            options => options.Diagnostics.ApplicationId = "myapp"));
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Azure Blob Storage integration:

* Adds the health check when `DisableHealthChecks` is `false`, which attempts to connect to the Azure Blob Storage.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Azure Blob Storage integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`

#### Tracing

[Section titled “Tracing”](#tracing)

The Azure Blob Storage integration emits the following tracing activities using OpenTelemetry:

* `Azure.Storage.Blobs.BlobContainerClient`

#### Metrics

[Section titled “Metrics”](#metrics)

The Azure Blob Storage integration currently doesn’t support metrics by default due to limitations with the Azure SDK.

# Azure Queue Storage

> Learn how to use the Azure Queue Storage integration, which includes both hosting and client integrations.

![Azure Queue Storage logo](/_astro/azure-storagequeue-icon.CaHewY1O_Z14dxKi.webp)

[Azure Queue Storage](https://azure.microsoft.com/services/storage/queues/) is a service for storing large amounts of unstructured data. The Aspire Azure Blob Storage integration enables you to connect to existing Azure Storage instances or create new instances from applications with the [`mcr.microsoft.com/azure-storage/azurite` container image](https://mcr.microsoft.com/product/azure-storage/azurite/about).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire [Azure Storage](https://learn.microsoft.com/azure/storage/) hosting integration models the various storage resources as the following types:

* `AzureStorageResource`: Represents an Azure Storage resource.
* `AzureStorageEmulatorResource`: Represents an Azure Storage emulator resource (Azurite).
* `AzureQueueStorageQueueResource`: Represents an Azure Queue storage resource.

To access these types and APIs for expressing them, add the [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage) NuGet package in the [AppHost](/get-started/app-host/) project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Storage package

  ```bash
  aspire add azure-storage
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-storage (Aspire.Hosting.Azure.Storage)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Storage@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Storage package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Storage" Version="*" />
  ```

### Add Azure Queue Storage resource

[Section titled “Add Azure Queue Storage resource”](#add-azure-queue-storage-resource)

In your AppHost project, register the Azure Queue Storage integration by chaining a call to `AddQueues` on the `IResourceBuilder<IAzureStorageResource>` instance returned by `AddAzureStorage`. The following example demonstrates how to add an Azure Queue Storage resource named `storage` and a queue named `queues`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var queues = builder.AddAzureStorage("storage")
    .AddQueues("queues");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(queues)
    .WaitFor(queues);


// After adding all resources, run the app...
```

The preceding code:

* Adds an Azure Storage resource named `storage`.
* Chains a call to `RunAsEmulator` to configure the storage resource to run locally using an emulator. The emulator in this case is [Azurite](https://learn.microsoft.com/azure/storage/common/storage-use-azurite).
* Adds a blob container named `queues` to the storage resource.
* Adds the `queues` resource to the `ExampleProject` and waits for it to be ready before starting the project.

Caution

When you call `AddAzureStorage`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Storage account

[Section titled “Connect to an existing Azure Storage account”](#connect-to-an-existing-azure-storage-account)

You might have an existing Azure Storage account that you want to connect to. You can chain a call to annotate that your `AzureStorageResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingStorageName = builder.AddParameter("existingStorageName");
var existingStorageResourceGroup = builder.AddParameter("existingStorageResourceGroup");


var storageaccount = builder.AddAzureStorage("storage")
    .AsExisting(existingStorageName, existingStorageResourceGroup)
    .AddQueues("queues");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(storageaccount);


// After adding all resources, run the app...
```

Caution

When you call `RunAsExisting`, `PublishAsExisting`, or `AsExisting` methods to work with resources that are already present in your Azure subscription, you must add certain configuration values to your AppHost to ensure that Aspire can locate them. The necessary configuration values include **SubscriptionId**, **AllowResourceGroupCreation**, **ResourceGroup**, and **Location**. If you don’t set them, “Missing configuration” errors appear in the Aspire dashboard. For more information about how to set them, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

#### Configure Azurite container

[Section titled “Configure Azurite container”](#configure-azurite-container)

There are various configurations available to container resources, for example, you can configure the container’s ports, environment variables, it’s lifetime, and more.

##### Configure Azurite container ports

[Section titled “Configure Azurite container ports”](#configure-azurite-container-ports)

By default, the Azurite container when configured by Aspire, exposes the following endpoints:

| Endpoint | Container port | Host port |
| -------- | -------------- | --------- |
| `blob`   | 10000          | dynamic   |
| `queue`  | 10001          | dynamic   |
| `table`  | 10002          | dynamic   |

The port that they’re listening on is dynamic by default. When the container starts, the ports are mapped to a random port on the host machine. To configure the endpoint ports, chain calls on the container resource builder provided by the `RunAsEmulator` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
  .RunAsEmulator(azurite =>
  {
      azurite.WithBlobPort(27000)
            .WithQueuePort(27001)
            .WithTablePort(27002);
  });


// After adding all resources, run the app...
```

The preceding code configures the Azurite container’s existing `blob`, `queue`, and `table` endpoints to listen on ports `27000`, `27001`, and `27002`, respectively. The Azurite container’s ports are mapped to the host ports as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------: | ------------------------------- |
|        `blob` | `10000:27000`                   |
|       `queue` | `10001:27001`                   |
|       `table` | `10002:27002`                   |

##### Configure Azurite container with persistent lifetime

[Section titled “Configure Azurite container with persistent lifetime”](#configure-azurite-container-with-persistent-lifetime)

To configure the Azurite container with a persistent lifetime, call the `WithLifetime` method on the Azurite container resource and pass `ContainerLifetime.Persistent`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithLifetime(ContainerLifetime.Persistent);
    });


// After adding all resources, run the app...
```

##### Configure Azurite container with data volume

[Section titled “Configure Azurite container with data volume”](#configure-azurite-container-with-data-volume)

To add a data volume to the Azure Storage emulator resource, call the `WithDataVolume` method on the Azure Storage emulator resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithDataVolume();
    });


// After adding all resources, run the app...
```

The data volume is used to persist the Azurite data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Azurite container and when a `name` parameter isn’t provided, the name is formatted as `.azurite/{resource name}`. For more information on data volumes and details on why they’re preferred over [bind mounts](#configure-azurite-container-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

##### Configure Azurite container with data bind mount

[Section titled “Configure Azurite container with data bind mount”](#configure-azurite-container-with-data-bind-mount)

To add a data bind mount to the Azure Storage emulator resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithDataBindMount("../azurite/data");
    });


// After adding all resources, run the app...
```

Caution

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the Azurite data across container restarts. The data bind mount is mounted at the `../azurite/data` path on the host machine relative to the AppHost directory (`IDistributedApplicationBuilder.AppHostDirectory`) in the Azurite container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

### Connect to storage resources

[Section titled “Connect to storage resources”](#connect-to-storage-resources)

When the Aspire AppHost runs, the storage resources can be accessed by external tools, such as the [Azure Storage Explorer](https://azure.microsoft.com/features/storage-explorer/). If your storage resource is running locally using Azurite, it will automatically be picked up by the Azure Storage Explorer.

Note

The Azure Storage Explorer discovers Azurite storage resources assuming the default ports are used. If you’ve [configured the Azurite container to use different ports](#configure-azurite-container-ports), you’ll need to configure the Azure Storage Explorer to connect to the correct ports.

To connect to the storage resource from Azure Storage Explorer, follow these steps:

1. Run the Aspire AppHost.

2. Open the Azure Storage Explorer.

3. View the **Explorer** pane.

4. Select the **Refresh all** link to refresh the list of storage accounts.

5. Expand the **Emulator & Attached** node.

6. Expand the **Storage Accounts** node.

7. You should see a storage account with your resource’s name as a prefix:

   ![Azure Storage Explorer: Azurite storage resource discovered.](/_astro/azure-storage-explorer.BVwS67k7_xnqII.webp)

You’re free to explore the storage account and its contents using the Azure Storage Explorer. For more information on using the Azure Storage Explorer, see [Get started with Storage Explorer](https://learn.microsoft.com/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Storage resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Queue Storage

[Section titled “Queue Storage”](#queue-storage)

The Queue Storage resource exposes the following connection properties:

| Property Name      | Description                                                                                              |
| ------------------ | -------------------------------------------------------------------------------------------------------- |
| `Uri`              | The URI of the queue storage service, with the format `https://mystorageaccount.queue.core.windows.net/` |
| `ConnectionString` | **Emulator only.** The connection string for the queue storage service                                   |

#### Queue

[Section titled “Queue”](#queue)

The Queue resource inherits all properties from its parent `AzureQueueStorageResource` and adds:

| Property Name      | Description                                                            |
| ------------------ | ---------------------------------------------------------------------- |
| `QueueName`        | The name of the queue                                                  |
| `ConnectionString` | **Emulator only.** The connection string for the table storage service |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `queue1` becomes `QUEUE1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure Queue Storage client integration, install the [📦 Aspire.Azure.Storage.Queues](https://www.nuget.org/packages/Aspire.Azure.Storage.Queues) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.Azure.Storage.Queues package

  ```bash
  dotnet add package Aspire.Azure.Storage.Queues
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Storage.Queues@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Storage.Queues package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Storage.Queues" Version="*" />
  ```

### Add Azure Queue Storage client

[Section titled “Add Azure Queue Storage client”](#add-azure-queue-storage-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureQueueClient` extension method to register a `QueueServiceClient` for dependency injection. The method takes a connection name parameter:

```csharp
builder.AddAzureQueueClient("queues");
```

You can then retrieve the `QueueServiceClient` instance using dependency injection:

```csharp
public class ExampleService(QueueServiceClient client)
{
    // Use client...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Azure Queue Storage integration provides multiple options to configure the `QueueServiceClient`.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name when calling `AddAzureQueueClient`:

```csharp
builder.AddAzureQueueClient("queues");
```

Two connection formats are supported:

##### Service URI

[Section titled “Service URI”](#service-uri)

The recommended approach is to use a `ServiceUri`, which works with the `Credential` property. If no credential is configured, the `DefaultAzureCredential` is used:

```json
{
  "ConnectionStrings": {
    "queues": "https://{account_name}.queue.core.windows.net/"
  }
}
```

##### Connection string

[Section titled “Connection string”](#connection-string)

Alternatively, an [Azure Storage connection string](https://learn.microsoft.com/azure/storage/common/storage-configure-connection-string) can be used:

```json
{
  "ConnectionStrings": {
    "queues": "AccountName=myaccount;AccountKey=myaccountkey"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Azure Queue Storage integration supports `Microsoft.Extensions.Configuration`. It loads the `AzureStorageQueuesSettings` and `QueueClientOptions` from configuration using the `Aspire:Azure:Storage:Queues` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "Azure": {
      "Storage": {
        "Queues": {
          "DisableHealthChecks": true,
          "DisableTracing": false,
          "ClientOptions": {
            "Diagnostics": {
              "ApplicationId": "myapp"
            }
          }
        }
      }
    }
  }
}
```

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Azure Queue Storage integration supports named configuration for multiple instances:

```json
{
  "Aspire": {
    "Azure": {
      "Storage": {
        "Queues": {
          "queue1": {
            "DisableHealthChecks": true,
            "ClientOptions": {
              "Diagnostics": {
                "ApplicationId": "myapp1"
              }
            }
          },
          "queue2": {
            "DisableTracing": true,
            "ClientOptions": {
              "Diagnostics": {
                "ApplicationId": "myapp2"
              }
            }
          }
        }
      }
    }
  }
}
```

Use the connection names when calling `AddAzureQueueClient`:

```csharp
builder.AddAzureQueueClient("queue1");
builder.AddAzureQueueClient("queue2");
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureStorageQueuesSettings>` delegate to set up options inline:

```csharp
builder.AddAzureQueueClient(
    "queues",
    settings => settings.DisableHealthChecks = true);
```

You can also configure the `QueueClientOptions`:

```csharp
builder.AddAzureQueueClient(
    "queues",
    configureClientBuilder: clientBuilder =>
        clientBuilder.ConfigureOptions(
            options => options.Diagnostics.ApplicationId = "myapp"));
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Azure Queue Storage integration:

* Adds the health check when `DisableHealthChecks` is `false`, which attempts to connect to the Azure Queue Storage.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Azure Queue Storage integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`

#### Tracing

[Section titled “Tracing”](#tracing)

The Azure Queue Storage integration emits the following tracing activities using OpenTelemetry:

* `Azure.Storage.Queues.QueueClient`

#### Metrics

[Section titled “Metrics”](#metrics)

The Azure Queue Storage integration currently doesn’t support metrics by default due to limitations with the Azure SDK.

# Azure Table Storage

> Learn how to use the Azure Table Storage integration to store structured NoSQL data in Azure Storage tables.

![Azure Table Storage logo](/_astro/azure-table-icon.pXm7NAMI_Z16Q6s.webp)

[Azure Table Storage](https://learn.microsoft.com/azure/storage/tables/table-storage-overview) is a service for storing large amounts of unstructured data. The Aspire Azure Blob Storage integration enables you to connect to existing Azure Storage instances or create new instances from applications with the [`mcr.microsoft.com/azure-storage/azurite` container image](https://mcr.microsoft.com/product/azure-storage/azurite/about).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire [Azure Storage](https://learn.microsoft.com/azure/storage/) hosting integration models the various storage resources as the following types:

* `AzureStorageResource`: Represents an Azure Storage resource.
* `AzureStorageEmulatorResource`: Represents an Azure Storage emulator resource (Azurite).
* `AzureTableStorageResource`: Represents an Azure Table storage resource.

To access these types and APIs for expressing them, add the [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage) NuGet package in the [AppHost](/get-started/app-host/) project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Storage package

  ```bash
  aspire add azure-storage
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-storage (Aspire.Hosting.Azure.Storage)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Storage@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Storage package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Storage" Version="*" />
  ```

### Add Azure Table Storage resource

[Section titled “Add Azure Table Storage resource”](#add-azure-table-storage-resource)

In your AppHost project, register the Azure Table Storage integration by chaining a call to `AddTables` on the `IResourceBuilder<IAzureStorageResource>` instance returned by `AddAzureStorage`. The following example demonstrates how to add an Azure Table Storage resource named `storage` and a table named `tables`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var tables = builder.AddAzureStorage("storage")
    .AddTables("tables");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(tables)
    .WaitFor(tables);


// After adding all resources, run the app...
```

The preceding code:

* Adds an Azure Storage resource named `storage`.
* Chains a call to `RunAsEmulator` to configure the storage resource to run locally using an emulator. The emulator in this case is [Azurite](https://learn.microsoft.com/azure/storage/common/storage-use-azurite).
* Adds a blob container named `tables` to the storage resource.
* Adds the `tables` resource to the `ExampleProject` and waits for it to be ready before starting the project.

Caution

When you call `AddAzureStorage`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Connect to an existing Azure Storage account

[Section titled “Connect to an existing Azure Storage account”](#connect-to-an-existing-azure-storage-account)

You might have an existing Azure Storage account that you want to connect to. You can chain a call to annotate that your `AzureStorageResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingStorageName = builder.AddParameter("existingStorageName");
var existingStorageResourceGroup = builder.AddParameter("existingStorageResourceGroup");


var storageaccount = builder.AddAzureStorage("storage")
    .AsExisting(existingStorageName, existingStorageResourceGroup)
    .AddTables("tables");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(storageaccount);


// After adding all resources, run the app...
```

Caution

When you call `RunAsExisting`, `PublishAsExisting`, or `AsExisting` methods to work with resources that are already present in your Azure subscription, you must add certain configuration values to your AppHost to ensure that Aspire can locate them. The necessary configuration values include **SubscriptionId**, **AllowResourceGroupCreation**, **ResourceGroup**, and **Location**. If you don’t set them, “Missing configuration” errors appear in the Aspire dashboard. For more information about how to set them, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

#### Configure Azurite container

[Section titled “Configure Azurite container”](#configure-azurite-container)

There are various configurations available to container resources, for example, you can configure the container’s ports, environment variables, it’s lifetime, and more.

##### Configure Azurite container ports

[Section titled “Configure Azurite container ports”](#configure-azurite-container-ports)

By default, the Azurite container when configured by Aspire, exposes the following endpoints:

| Endpoint | Container port | Host port |
| -------- | -------------- | --------- |
| `blob`   | 10000          | dynamic   |
| `queue`  | 10001          | dynamic   |
| `table`  | 10002          | dynamic   |

The port that they’re listening on is dynamic by default. When the container starts, the ports are mapped to a random port on the host machine. To configure the endpoint ports, chain calls on the container resource builder provided by the `RunAsEmulator` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
  .RunAsEmulator(azurite =>
  {
      azurite.WithBlobPort(27000)
             .WithQueuePort(27001)
             .WithTablePort(27002);
  });


// After adding all resources, run the app...
```

The preceding code configures the Azurite container’s existing `blob`, `queue`, and `table` endpoints to listen on ports `27000`, `27001`, and `27002`, respectively. The Azurite container’s ports are mapped to the host ports as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------: | ------------------------------- |
|        `blob` | `10000:27000`                   |
|       `queue` | `10001:27001`                   |
|       `table` | `10002:27002`                   |

##### Configure Azurite container with persistent lifetime

[Section titled “Configure Azurite container with persistent lifetime”](#configure-azurite-container-with-persistent-lifetime)

To configure the Azurite container with a persistent lifetime, call the `WithLifetime` method on the Azurite container resource and pass `ContainerLifetime.Persistent`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithLifetime(ContainerLifetime.Persistent);
    });


// After adding all resources, run the app...
```

##### Configure Azurite container with data volume

[Section titled “Configure Azurite container with data volume”](#configure-azurite-container-with-data-volume)

To add a data volume to the Azure Storage emulator resource, call the `WithDataVolume` method on the Azure Storage emulator resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithDataVolume();
    });


// After adding all resources, run the app...
```

The data volume is used to persist the Azurite data outside the lifecycle of its container. The data volume is mounted at the `/data` path in the Azurite container and when a `name` parameter isn’t provided, the name is formatted as `.azurite/{resource name}`. For more information on data volumes and details on why they’re preferred over [bind mounts](#configure-azurite-container-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

##### Configure Azurite container with data bind mount

[Section titled “Configure Azurite container with data bind mount”](#configure-azurite-container-with-data-bind-mount)

To add a data bind mount to the Azure Storage emulator resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
    .RunAsEmulator(azurite =>
    {
        azurite.WithDataBindMount("../azurite/data");
    });


// After adding all resources, run the app...
```

Caution

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the Azurite data across container restarts. The data bind mount is mounted at the `../azurite/data` path on the host machine relative to the AppHost directory (`IDistributedApplicationBuilder.AppHostDirectory`) in the Azurite container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

### Connect to storage resources

[Section titled “Connect to storage resources”](#connect-to-storage-resources)

When the Aspire AppHost runs, the storage resources can be accessed by external tools, such as the [Azure Storage Explorer](https://azure.microsoft.com/features/storage-explorer/). If your storage resource is running locally using Azurite, it will automatically be picked up by the Azure Storage Explorer.

Note

The Azure Storage Explorer discovers Azurite storage resources assuming the default ports are used. If you’ve [configured the Azurite container to use different ports](#configure-azurite-container-ports), you’ll need to configure the Azure Storage Explorer to connect to the correct ports.

To connect to the storage resource from Azure Storage Explorer, follow these steps:

1. Run the Aspire AppHost.

2. Open the Azure Storage Explorer.

3. View the **Explorer** pane.

4. Select the **Refresh all** link to refresh the list of storage accounts.

5. Expand the **Emulator & Attached** node.

6. Expand the **Storage Accounts** node.

7. You should see a storage account with your resource’s name as a prefix:

   ![Azure Storage Explorer: Azurite storage resource discovered.](/_astro/azure-storage-explorer.BVwS67k7_xnqII.webp)

You’re free to explore the storage account and its contents using the Azure Storage Explorer. For more information on using the Azure Storage Explorer, see [Get started with Storage Explorer](https://learn.microsoft.com/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference Azure Storage resources using `WithReference`, the following connection properties are made available to the consuming project:

#### Table Storage

[Section titled “Table Storage”](#table-storage)

The Table Storage resource exposes the following connection properties:

| Property Name      | Description                                                                                              |
| ------------------ | -------------------------------------------------------------------------------------------------------- |
| `Uri`              | The URI of the table storage service, with the format `https://mystorageaccount.table.core.windows.net/` |
| `ConnectionString` | The connection string for the table storage service                                                      |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `table1` becomes `TABLE1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Azure Table Storage client integration, install the [📦 Aspire.Azure.Data.Tables](https://www.nuget.org/packages/Aspire.Azure.Data.Tables) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.Azure.Data.Tables package

  ```bash
  dotnet add package Aspire.Azure.Data.Tables
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Data.Tables@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Data.Tables package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Data.Tables" Version="*" />
  ```

### Add Azure Table Storage client

[Section titled “Add Azure Table Storage client”](#add-azure-table-storage-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureTableClient` extension method to register a `TableServiceClient` for dependency injection. The method takes a connection name parameter:

```csharp
builder.AddAzureTableClient("tables");
```

You can then retrieve the `TableServiceClient` instance using dependency injection:

```csharp
public class ExampleService(TableServiceClient client)
{
    // Use client...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Azure Table Storage integration provides multiple options to configure the `TableServiceClient`.

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Azure Table Storage integration supports `Microsoft.Extensions.Configuration`. It loads the `AzureDataTablesSettings` and `TableClientOptions` from configuration using the `Aspire:Azure:Data:Tables` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "Azure": {
      "Data": {
        "Tables": {
          "ServiceUri": "YOUR_URI",
          "DisableHealthChecks": true,
          "DisableTracing": false,
          "ClientOptions": {
            "EnableTenantDiscovery": true
          }
        }
      }
    }
  }
}
```

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Azure Table Storage integration supports named configuration for multiple instances:

```json
{
  "Aspire": {
    "Azure": {
      "Data": {
        "Tables": {
          "tables1": {
            "ServiceUri": "https://myaccount1.table.core.windows.net/",
            "DisableHealthChecks": true,
            "ClientOptions": {
              "EnableTenantDiscovery": true
            }
          },
          "tables2": {
            "ServiceUri": "https://myaccount2.table.core.windows.net/",
            "DisableTracing": true,
            "ClientOptions": {
              "EnableTenantDiscovery": false
            }
          }
        }
      }
    }
  }
}
```

Use the connection names when calling `AddAzureTableClient`:

```csharp
builder.AddAzureTableClient("tables1");
builder.AddAzureTableClient("tables2");
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<AzureDataTablesSettings>` delegate to set up options inline:

```csharp
builder.AddAzureTableClient(
    "tables",
    settings => settings.DisableHealthChecks = true);
```

You can also configure the `TableClientOptions`:

```csharp
builder.AddAzureTableClient(
    "tables",
    configureClientBuilder: clientBuilder =>
        clientBuilder.ConfigureOptions(
            options => options.EnableTenantDiscovery = true));
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Azure Table Storage integration:

* Adds the health check when `DisableHealthChecks` is `false`, which attempts to connect to the Azure Table Storage.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Azure Table Storage integration uses the following log categories:

* `Azure.Core`
* `Azure.Identity`

#### Tracing

[Section titled “Tracing”](#tracing)

The Azure Table Storage integration emits the following tracing activities using OpenTelemetry:

* `Azure.Data.Tables.TableServiceClient`

#### Metrics

[Section titled “Metrics”](#metrics)

The Azure Table Storage integration currently doesn’t support metrics by default due to limitations with the Azure SDK.

# Azure Web PubSub integration

> This article describes the Aspire Azure Web PubSub integration features and capabilities.

![Azure Web PubSub logo](/_astro/azure-webpubsub-icon.BXTJxxmO_DymhR.webp)

[Azure Web PubSub](https://learn.microsoft.com/azure/azure-web-pubsub/) is a fully managed real-time messaging service that enables you to build real-time web applications using WebSockets and publish-subscribe patterns. The Aspire Azure Web PubSub integration enables you to connect to Azure Web PubSub instances from your applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Aspire Azure Web PubSub hosting integration models the Web PubSub resources as the following types:

* `AzureWebPubSubResource`: Represents an Azure Web PubSub resource, including connection information to the underlying Azure resource.
* `AzureWebPubSubHubResource`: Represents a Web PubSub hub settings resource, which contains the settings for a hub. For example, you can specify if the hub allows anonymous connections or add event handlers to the hub.

To access these types and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.WebPubSub](https://www.nuget.org/packages/Aspire.Hosting.Azure.WebPubSub) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.WebPubSub package

  ```bash
  aspire add azure-webpubsub
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-webpubsub (Aspire.Hosting.Azure.WebPubSub)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.WebPubSub@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.WebPubSub package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.WebPubSub" Version="*" />
  ```

### Add an Azure Web PubSub resource

[Section titled “Add an Azure Web PubSub resource”](#add-an-azure-web-pubsub-resource)

To add an Azure Web PubSub resource to your AppHost project, call the `AddAzureWebPubSub` method providing a name:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var webPubSub = builder.AddAzureWebPubSub("web-pubsub");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(webPubSub);


// After adding all resources, run the app...
```

The preceding code adds an Azure Web PubSub resource named `web-pubsub` to the AppHost project. The `WithReference` method passes the connection information to the `ExampleProject` project.

Caution

When you call `AddAzureWebPubSub`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

### Add an Azure Web PubSub hub resource

[Section titled “Add an Azure Web PubSub hub resource”](#add-an-azure-web-pubsub-hub-resource)

When you add an Azure Web PubSub resource, you can also add a child hub resource. The hub resource is a logical grouping of connections and event handlers. To add an Azure Web PubSub hub resource to your AppHost project, chain a call to the `AddHub` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var worker = builder.AddProject<Projects.WorkerService>("worker")
    .WithExternalHttpEndpoints();


var webPubSub = builder.AddAzureWebPubSub("web-pubsub");
var messagesHub = webPubSub.AddHub(name: "messages", hubName: "messageHub");


// After adding all resources, run the app...
```

The preceding code adds an Azure Web PubSub hub resource named `messages` and a hub name of `messageHub`, which enables the addition of event handlers. To add an event handler, call the `AddEventHandler`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var worker = builder.AddProject<Projects.WorkerService>("worker")
    .WithExternalHttpEndpoints();


var webPubSub = builder.AddAzureWebPubSub("web-pubsub");
var messagesHub = webPubSub.AddHub(name: "messages", hubName: "messageHub");


messagesHub.AddEventHandler(
    $"{worker.GetEndpoint("https")}/eventhandler/",
    systemEvents: ["connected"]);


// After adding all resources, run the app...
```

The preceding code adds a worker service project named `worker` with an external HTTP endpoint. The hub named `messages` resource is added to the `web-pubsub` resource, and an event handler is added to the `messagesHub` resource. The event handler URL is set to the worker service’s external HTTP endpoint. For more information, see [Azure Web PubSub event handlers](https://learn.microsoft.com/azure-web-pubsub/howto-develop-eventhandler).

### Connect to an existing Azure Web PubSub instance

[Section titled “Connect to an existing Azure Web PubSub instance”](#connect-to-an-existing-azure-web-pubsub-instance)

You might have an existing Azure Web PubSub service that you want to connect to. You can chain a call to annotate that your `AzureWebPubSubResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingPubSubName = builder.AddParameter("existingPubSubName");
var existingPubSubResourceGroup = builder.AddParameter("existingPubSubResourceGroup");


var webPubSub = builder.AddAzureWebPubSub("web-pubsub")
    .AsExisting(existingPubSubName, existingPubSubResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(webPubSub);


// After adding all resources, run the app...
```

For more information on treating Azure Web PubSub resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure Web PubSub resource, you can add a connection string to the AppHost. This approach is weakly-typed and doesn’t work with role assignments or infrastructure customizations.

### Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

When you publish your app, Aspire provisioning APIs generate Bicep alongside the manifest file. Bicep is a domain-specific language for defining Azure resources. For more information, see [Bicep Overview](https://learn.microsoft.com/azure-resource-manager/bicep/overview).

When you add an Azure Web PubSub resource, the following Bicep is generated:

web-pubsub.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param sku string = 'Free_F1'


param capacity int = 1


param messages_url_0 string


resource web_pubsub 'Microsoft.SignalRService/webPubSub@2024-03-01' = {
  name: take('webpubsub-${uniqueString(resourceGroup().id)}', 63)
  location: location
  properties: {
    disableLocalAuth: true
  }
  sku: {
    name: sku
    capacity: capacity
  }
  tags: {
    'aspire-resource-name': 'web-pubsub'
  }
}


resource messages 'Microsoft.SignalRService/webPubSub/hubs@2024-03-01' = {
  name: 'messages'
  properties: {
    eventHandlers: [
      {
        urlTemplate: messages_url_0
        userEventPattern: '*'
        systemEvents: [
          'connected'
        ]
      }
    ]
  }
  parent: web_pubsub
}


output endpoint string = 'https://${web_pubsub.properties.hostName}'


output name string = web_pubsub.name
```

The preceding Bicep is a module that provisions an Azure Web PubSub resource. Additionally, role assignments are created for the Azure resource in a separate module:

web-pubsub-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param web_pubsub_outputs_name string


param principalType string


param principalId string


resource web_pubsub 'Microsoft.SignalRService/webPubSub@2024-03-01' existing = {
  name: web_pubsub_outputs_name
}


resource web_pubsub_WebPubSubServiceOwner 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(web_pubsub.id, principalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '12cf5a90-567b-43ae-8102-96cf46c7d9b4'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '12cf5a90-567b-43ae-8102-96cf46c7d9b4')
    principalType: principalType
  }
  scope: web_pubsub
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

#### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources using the `ConfigureInfrastructure` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureWebPubSub("web-pubsub")
    .ConfigureInfrastructure(infra =>
    {
        var webPubSubService = infra.GetProvisionableResources()
                                    .OfType<WebPubSubService>()
                                    .Single();


        webPubSubService.Sku.Name = "Standard_S1";
        webPubSubService.Sku.Capacity = 5;
        webPubSubService.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `WebPubSubService` resource is retrieved.
  * The `Sku` object has its name and capacity properties set to `Standard_S1` and `5`, respectively.
  * A tag is added to the Web PubSub resource with a key of `ExampleKey` and a value of `Example value`.

There are many more configuration options available to customize the Web PubSub resource. For more information, see [Azure.Provisioning customization](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization).

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference an Azure Web PubSub resource using `WithReference`, the following connection properties are made available to the consuming project:

| Property Name | Description                                                                                             |
| ------------- | ------------------------------------------------------------------------------------------------------- |
| `Uri`         | The HTTPS endpoint for the Web PubSub service, typically `https://<resource-name>.webpubsub.azure.com/` |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `wps1` becomes `WPS1_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

The Aspire Azure Web PubSub client integration is used to connect to an Azure Web PubSub service using the `WebPubSubServiceClient`. To get started with the Aspire Azure Web PubSub service client integration, install the [📦 Aspire.Azure.Messaging.WebPubSub](https://www.nuget.org/packages/Aspire.Azure.Messaging.WebPubSub) NuGet package.

* .NET CLI

  .NET CLI — Add Aspire.Azure.Messaging.WebPubSub package

  ```bash
  dotnet add package Aspire.Azure.Messaging.WebPubSub
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Messaging.WebPubSub@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Messaging.WebPubSub package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Messaging.WebPubSub" Version="*" />
  ```

### Supported Web PubSub client types

[Section titled “Supported Web PubSub client types”](#supported-web-pubsub-client-types)

The following Web PubSub client types are supported by the library:

| Azure client type        | Azure options class             | Aspire settings class             |
| ------------------------ | ------------------------------- | --------------------------------- |
| `WebPubSubServiceClient` | `WebPubSubServiceClientOptions` | `AzureMessagingWebPubSubSettings` |

### Add Web PubSub client

[Section titled “Add Web PubSub client”](#add-web-pubsub-client)

In the `Program.cs` file of your client-consuming project, call the `AddAzureWebPubSubServiceClient` extension method to register a `WebPubSubServiceClient` for use via the dependency injection container. The method takes a connection name parameter:

```csharp
builder.AddAzureWebPubSubServiceClient(connectionName: "web-pubsub");
```

Tip

The `connectionName` parameter must match the name used when adding the Web PubSub resource in the AppHost project. For more information, see [Add an Azure Web PubSub resource](#add-an-azure-web-pubsub-resource).

After adding the `WebPubSubServiceClient`, you can retrieve the client instance using dependency injection:

```csharp
public class ExampleService(WebPubSubServiceClient client)
{
    // Use client...
}
```

For more information, see:

* [Azure.Messaging.WebPubSub documentation](https://learn.microsoft.com/azure-web-pubsub/howto-create-serviceclient-with-net-and-azure-identity) for examples on using the `WebPubSubServiceClient`.
* [Dependency injection in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection) for details on dependency injection.

### Add keyed Web PubSub client

[Section titled “Add keyed Web PubSub client”](#add-keyed-web-pubsub-client)

There might be situations where you want to register multiple `WebPubSubServiceClient` instances with different connection names. To register keyed Web PubSub clients, call the `AddKeyedAzureWebPubSubServiceClient` method:

```csharp
builder.AddKeyedAzureWebPubSubServiceClient(name: "messages");
builder.AddKeyedAzureWebPubSubServiceClient(name: "commands");
```

Caution

When using keyed services, it’s expected that your Web PubSub resource configured two named hubs, one for the `messages` and one for the `commands`.

Then you can retrieve the client instances using dependency injection:

```csharp
public class ExampleService(
    [KeyedService("messages")] WebPubSubServiceClient messagesClient,
    [KeyedService("commands")] WebPubSubServiceClient commandsClient)
{
    // Use clients...
}
```

For more information, see [Keyed services in .NET](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure Web PubSub library provides multiple options to configure the Azure Web PubSub connection based on the requirements and conventions of your project. Either an `Endpoint` or a `ConnectionString` must be supplied.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddAzureWebPubSubServiceClient`:

```csharp
builder.AddAzureWebPubSubServiceClient(
    "web-pubsub",
    settings => settings.HubName = "your_hub_name");
```

The connection information is retrieved from the `ConnectionStrings` configuration section. Two connection formats are supported:

* **Service endpoint (recommended)**: Uses the service endpoint with `DefaultAzureCredential`.

  ```json
  {
    "ConnectionStrings": {
      "web-pubsub": "https://{account_name}.webpubsub.azure.com"
    }
  }
  ```

* **Connection string**: Includes an access key.

  ```json
  {
    "ConnectionStrings": {
      "web-pubsub": "Endpoint=https://{account_name}.webpubsub.azure.com;AccessKey={account_key}"
    }
  }
  ```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The library supports `Microsoft.Extensions.Configuration`. It loads settings from configuration using the `Aspire:Azure:Messaging:WebPubSub` key:

```json
{
  "Aspire": {
    "Azure": {
      "Messaging": {
        "WebPubSub": {
          "DisableHealthChecks": true,
          "HubName": "your_hub_name"
        }
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can configure settings inline:

```csharp
builder.AddAzureWebPubSubServiceClient(
    "web-pubsub",
    settings => settings.DisableHealthChecks = true);
```

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

#### Logging

[Section titled “Logging”](#logging)

The Aspire Azure Web PubSub integration uses the following log categories:

* `Azure`
* `Azure.Core`
* `Azure.Identity`
* `Azure.Messaging.WebPubSub`

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Azure Web PubSub integration will emit the following tracing activities using OpenTelemetry:

* `Azure.Messaging.WebPubSub.*`

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Azure Web PubSub integration currently doesn’t support metrics by default due to limitations with the Azure SDK for .NET.

# Configure Azure Container Apps environments

> Learn how to configure Azure Container Apps environment settings for Aspire deployments.

![Azure Container Apps environment logo](/_astro/azure-container-apps-environments.Cxfx93EZ_Z1k8iGn.svg)

The [Aspire AppHost](/get-started/app-host/) simplifies infrastructure provisioning by generating code to create Azure resources for your applications. This approach enables you to model and configure deployment-related aspects directly in C#, reducing the need to rely on tools like Bicep. These aspects include configuring ACA environments, which provide a serverless platform for running containerized applications.

It’s easy to [publish resources as Azure Container Apps (ACA)](/integrations/cloud/azure/overview/#publish-as-azure-container-app) using any of the supported APIs:

* [`AzureContainerAppProjectExtensions.PublishAsAzureContainerApp`](https://learn.microsoft.com/dotnet/api/aspire.hosting.azurecontainerappprojectextensions.publishasazurecontainerapp)
* [`AzureContainerAppContainerExtensions.PublishAsAzureContainerApp`](https://learn.microsoft.com/dotnet/api/aspire.hosting.azurecontainerappcontainerextensions.publishasazurecontainerapp)
* [`AzureContainerAppExecutableExtensions.PublishAsAzureContainerApp`](https://learn.microsoft.com/dotnet/api/aspire.hosting.azurecontainerappexecutableextensions.publishasazurecontainerapp)

These APIs automatically create a default ACA environment when you publish your app. While this default setup works well for most scenarios, you might need to customize the ACA environment to meet specific requirements. To achieve this, use the `AddAzureContainerAppEnvironment` method.

By using the `Azure.Provisioning` APIs (explained in [Customize Azure resources](/integrations/cloud/azure/customize-resources/)), you can configure and customize ACA environments along with related resources, such as container registries and file share volumes. Any available deployment setting can be configured. For more information on the available settings, see [Microsoft.App managedEnvironments](https://learn.microsoft.com/azure/templates/microsoft.app/managedenvironments).

This article guides you through the process of tailoring ACA environments for your solutions.

## Add an ACA environment

[Section titled “Add an ACA environment”](#add-an-aca-environment)

The `AzureContainerAppEnvironmentResource` type models an ACA environment resource. When you call the `AddAzureContainerAppEnvironment` method, it creates an instance of this type (wrapped in the `IResourceBuilder<AzureContainerAppEnvironmentResource>`).

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var acaEnv = builder.AddAzureContainerAppEnvironment("aca-env");


// Omitted for brevity...


builder.Build().Run();
```

By default, the calling this API to add an ACA environment generates the following provisioning Bicep module:

aca-env.module.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param userPrincipalId string


param tags object = { }


resource aca_env_mi 'Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31' = {
  name: take('aca_env_mi-${uniqueString(resourceGroup().id)}', 128)
  location: location
  tags: tags
}


resource aca_env_acr 'Microsoft.ContainerRegistry/registries@2023-07-01' = {
  name: take('acaenvacr${uniqueString(resourceGroup().id)}', 50)
  location: location
  sku: {
    name: 'Basic'
  }
  tags: tags
}


resource aca_env_acr_aca_env_mi_AcrPull 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(aca_env_acr.id, aca_env_mi.id, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7f951dda-4ed3-4680-a7ca-43fe172d538d'))
  properties: {
    principalId: aca_env_mi.properties.principalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7f951dda-4ed3-4680-a7ca-43fe172d538d')
    principalType: 'ServicePrincipal'
  }
  scope: aca_env_acr
}


resource aca_env_law 'Microsoft.OperationalInsights/workspaces@2023-09-01' = {
  name: take('acaenvlaw-${uniqueString(resourceGroup().id)}', 63)
  location: location
  properties: {
    sku: {
      name: 'PerGB2018'
    }
  }
  tags: tags
}


resource aca_env 'Microsoft.App/managedEnvironments@2024-03-01' = {
  name: take('acaenv${uniqueString(resourceGroup().id)}', 24)
  location: location
  properties: {
    appLogsConfiguration: {
      destination: 'log-analytics'
      logAnalyticsConfiguration: {
        customerId: aca_env_law.properties.customerId
        sharedKey: aca_env_law.listKeys().primarySharedKey
      }
    }
    workloadProfiles: [
      {
        name: 'consumption'
        workloadProfileType: 'Consumption'
      }
    ]
  }
  tags: tags
}


resource aspireDashboard 'Microsoft.App/managedEnvironments/dotNetComponents@2024-10-02-preview' = {
  name: 'aspire-dashboard'
  properties: {
    componentType: 'AspireDashboard'
  }
  parent: aca_env
}


resource aca_env_Contributor 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(aca_env.id, userPrincipalId, subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b24988ac-6180-42a0-ab88-20f7382dd24c'))
  properties: {
    principalId: userPrincipalId
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b24988ac-6180-42a0-ab88-20f7382dd24c')
  }
  scope: aca_env
}


output MANAGED_IDENTITY_NAME string = aca_env_mi.name


output MANAGED_IDENTITY_PRINCIPAL_ID string = aca_env_mi.properties.principalId


output AZURE_LOG_ANALYTICS_WORKSPACE_NAME string = aca_env_law.name


output AZURE_LOG_ANALYTICS_WORKSPACE_ID string = aca_env_law.id


output AZURE_CONTAINER_REGISTRY_NAME string = aca_env_acr.name


output AZURE_CONTAINER_REGISTRY_ENDPOINT string = aca_env_acr.properties.loginServer


output AZURE_CONTAINER_REGISTRY_MANAGED_IDENTITY_ID string = aca_env_mi.id


output AZURE_CONTAINER_APPS_ENVIRONMENT_NAME string = aca_env.name


output AZURE_CONTAINER_APPS_ENVIRONMENT_ID string = aca_env.id


output AZURE_CONTAINER_APPS_ENVIRONMENT_DEFAULT_DOMAIN string = aca_env.properties.defaultDomain
```

This module configures:

* A user-assigned managed identity for the ACA environment.
* An Azure Container Registry (ACR) for the ACA environment.
* A Log Analytics workspace for the ACA environment.
* An Azure Container Apps environment.
* The [Aspire dashboard](/dashboard/overview/) for the ACA environment.
* A role assignment for the user principal ID to the ACA environment.
* Various outputs for the ACA environment.

Using the `acaEnv` variable, you can chain a call to the `ConfigureInfrastructure` API to customize the ACA environment to your liking. For more information, see [Configure infrastructure](/integrations/cloud/azure/customize-resources/).

## Handle naming conventions

[Section titled “Handle naming conventions”](#handle-naming-conventions)

By default, `AddAzureContainerAppEnvironment` uses a different Azure resource naming scheme than the [Azure Developer CLI (`azd`)](https://learn.microsoft.com/azure/developer/azure-developer-cli/). If you’re upgrading an existing deployment that previously used `azd`, you might see duplicate Azure resources. To avoid this issue, call the `WithAzdResourceNaming` method to revert to the naming convention used by `azd`:

```csharp
var builder = DistributionApplicationBuilder.Create(args);


var acaEnv = builder.AddAzureContainerAppEnvironment("aca-env")
    .WithAzdResourceNaming();


// Omitted for brevity...


builder.Build().Run();
```

Calling this API ensures your existing Azure resources remain consistent and prevents duplication.

## Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Azure resources are subclasses of the `AzureProvisioningResource` type. This enables customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API:

```csharp
var builder = DistributionApplicationBuilder.Create(args);


var acaEnv = builder.AddAzureContainerAppEnvironment(Config.ContainEnvironmentName);


acaEnv.ConfigureInfrastructure(config =>
{
    var resources = config.GetProvisionableResources();
    var containerEnvironment = resources.OfType<ContainerAppManagedEnvironment>().FirstOrDefault();


    containerEnvironment.Tags.Add("ExampleKey", "Example value");
});
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `ContainerAppManagedEnvironment` resource is retrieved.
  * A tag is added to the Azure Container Apps environment resource with a key of `ExampleKey` and a value of `Example value`.

## See also

[Section titled “See also”](#see-also)

* [Azure integrations overview](/integrations/cloud/azure/overview/)
* [Deploy to Azure Container Apps](/get-started/deploy-first-app/)
* [Azure Container Apps documentation](https://learn.microsoft.com/azure/container-apps/)
* [Container Apps pricing](https://learn.microsoft.com/azure/container-apps/billing)

# Azure Container App Jobs

> Learn how to deploy Aspire worker services as Azure Container App Jobs for scheduled and event-driven workloads.

![Azure Container Apps environment logo](/_astro/azure-container-apps-environments.Cxfx93EZ_Z1k8iGn.svg)

[Azure Container Apps jobs](https://learn.microsoft.com/azure/container-apps/jobs) enable you to run containerized tasks that execute for a finite duration and exit. You can use jobs to perform tasks such as data processing, machine learning, or any scenario where on-demand processing is required. Unlike traditional Azure Container Apps that run continuously, Container App Jobs are designed for batch processing, scheduled tasks, and event-driven workloads.

Aspire provides support for Azure Container App Jobs through the `PublishAsAzureContainerAppJob` extension method, allowing you to deploy your .NET projects, containers, and executables as jobs in Azure Container Apps.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

* Azure subscription.
* Aspire project.
* Understanding of Azure Container Apps jobs.

## Supported resource types

[Section titled “Supported resource types”](#supported-resource-types)

Aspire allows you to publish the following resource types as Azure Container App Jobs:

* `ContainerResource`: Represents a specified container.
* `ExecutableResource`: Represents a specified executable process.
* `ProjectResource`: Represents a specified .NET project.

## Publishing as Azure Container App Jobs

[Section titled “Publishing as Azure Container App Jobs”](#publishing-as-azure-container-app-jobs)

To publish resources as Azure Container App Jobs, use the following APIs:

* `PublishAsAzureContainerAppJob<T>(IResourceBuilder<T>);`
* `PublishAsAzureContainerAppJob<T>(IResourceBuilder<T>, Action<AzureResourceInfrastructure, ContainerAppJob>);`
* `PublishAsScheduledAzureContainerAppJob<T>(IResourceBuilder<T>, string, Action<AzureResourceInfrastructure, ContainerAppJob>);`

## Basic usage

[Section titled “Basic usage”](#basic-usage)

The following example demonstrates how to configure a .NET project as an Azure Container App Job with a scheduled trigger:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder();


builder.AddProject<Projects.DataProcessor>("data-processor")
    .PublishAsScheduledAzureContainerAppJob("0 0 * * *"); // Every day at midnight
```

This code:

* Creates a new distributed application builder.
* Adds a project named `data-processor` to the builder.
* Calls `PublishAsScheduledAzureContainerAppJob` to configure the project as a Container App Job.
* Sets the trigger type to `Schedule` with a cron expression to run daily at midnight.

## Job trigger types

[Section titled “Job trigger types”](#job-trigger-types)

Azure Container App Jobs support different trigger types:

### Manual trigger

[Section titled “Manual trigger”](#manual-trigger)

Use manual triggers for on-demand job execution:

C# — AppHost.cs

```csharp
builder.AddProject<Projects.ManualTask>("manual-task")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Manual;
    });
```

### Schedule trigger

[Section titled “Schedule trigger”](#schedule-trigger)

Use schedule triggers for time-based job execution:

C# — AppHost.cs

```csharp
builder.AddProject<Projects.ScheduledTask>("scheduled-task")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Schedule;
        job.Configuration.ScheduleTriggerConfig.CronExpression = "0 */6 * * *"; // Every 6 hours
        job.Configuration.ScheduleTriggerConfig.Parallelism = 1;
        job.Configuration.ScheduleTriggerConfig.ReplicaCompletionCount = 1;
    });
```

### Event trigger

[Section titled “Event trigger”](#event-trigger)

Use event triggers for reactive job execution based on external events:

C# — AppHost.cs

```csharp
builder.AddProject<Projects.EventDrivenTask>("event-task")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Event;
        job.Configuration.EventTriggerConfig.Scale.MinExecutions = 1;
        job.Configuration.EventTriggerConfig.Scale.MaxExecutions = 10;
        job.Configuration.EventTriggerConfig.Parallelism = 1;
        job.Configuration.EventTriggerConfig.ReplicaCompletionCount = 1;
    });
```

## Advanced configuration

[Section titled “Advanced configuration”](#advanced-configuration)

### Setting resource requirements

[Section titled “Setting resource requirements”](#setting-resource-requirements)

Configure CPU and memory resources for your job:

C# — AppHost.cs

```csharp
builder.AddProject<Projects.ResourceIntensiveTask>("intensive-task")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Manual;
        job.Template.Containers[0].Value!.Resources.Cpu = 1.0;
        job.Template.Containers[0].Value!.Resources.Memory = "2Gi";
    });
```

### Environment variables

[Section titled “Environment variables”](#environment-variables)

Add environment variables to your job:

C# — AppHost.cs

```csharp
var connectionString = builder.AddParameter("connectionString");


builder.AddProject<Projects.DatabaseTask>("db-task")
    .PublishAsAzureContainerAppJob((infra, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Manual;
        job.Template.Containers[0].Value!.Env.Add(new ContainerAppEnvironmentVariable
        {
            Name = "ConnectionString",
            Value = connectionString.AsProvisioningParameter(infra)
        });
    });
```

### Timeout and retry policy

[Section titled “Timeout and retry policy”](#timeout-and-retry-policy)

Configure job execution timeout and retry behavior:

C# — AppHost.cs

```csharp
builder.AddProject<Projects.RetryableTask>("retryable-task")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Manual;
        job.Configuration.ReplicaTimeout = 1800; // 30 minutes
        job.Configuration.ReplicaRetryLimit = 3;
    });
```

## Container resources

[Section titled “Container resources”](#container-resources)

You can also publish container resources as Azure Container App Jobs:

C# — AppHost.cs

```csharp
builder.AddContainer("batch-processor", "myregistry.azurecr.io/batch-processor:latest")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Schedule;
        job.Configuration.ScheduleTriggerConfig.CronExpression = "0 2 * * 0"; // Weekly on Sunday at 2 AM
    });
```

## Executable resources

[Section titled “Executable resources”](#executable-resources)

Executable resources can also be published as jobs:

C# — AppHost.cs

```csharp
builder.AddExecutable("data-script", "python", ".", "process_data.py")
    .PublishAsAzureContainerAppJob((_, job) =>
    {
        job.Configuration.TriggerType = ContainerAppJobTriggerType.Manual;
    });
```

## Experimental feature notice

[Section titled “Experimental feature notice”](#experimental-feature-notice)

Caution

Azure Container App Jobs support in Aspire is an experimental feature. The APIs are subject to change in future releases. You might encounter the diagnostic `ASPIREAZURE002` when using these features. For more information, see [ASPIREAZURE002](/diagnostics/aspireazure002/).

# Customize Azure resources

> Learn how to customize Azure resource infrastructure in Aspire using ConfigureInfrastructure and custom Bicep.

When working with Azure integrations in Aspire, you often need to customize the generated infrastructure beyond the default settings. Aspire provides two main approaches for customizing Azure resources: using the `ConfigureInfrastructure` API and creating custom Bicep templates.

## Azure.Provisioning customization

[Section titled “Azure.Provisioning customization”](#azureprovisioning-customization)

The `ConfigureInfrastructure` API provides a strongly-typed, C#-based way to customize Azure resources. This is the recommended approach for most customizations.

### Basic infrastructure customization

[Section titled “Basic infrastructure customization”](#basic-infrastructure-customization)

All Azure resources in Aspire inherit from `AzureProvisioningResource`, which exposes the `ConfigureInfrastructure` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage");


storage.ConfigureInfrastructure(infra =>
{
    // Get the storage account resource
    var storageAccount = infra.GetProvisionableResources()
                               .OfType<StorageAccount>()
                               .Single();


    // Customize the SKU
    storageAccount.Sku = new StorageSku
    {
        Name = StorageSkuName.PremiumLRS
    };


    // Add tags
    storageAccount.Tags["Environment"] = "Development";
    storageAccount.Tags["CostCenter"] = "Engineering";
});
```

### Common customization scenarios

[Section titled “Common customization scenarios”](#common-customization-scenarios)

#### Configure SKUs and tiers

[Section titled “Configure SKUs and tiers”](#configure-skus-and-tiers)

* Storage

  ```csharp
  storage.ConfigureInfrastructure(infra =>
  {
      var account = infra.GetProvisionableResources()
                         .OfType<StorageAccount>()
                         .Single();


      account.Sku = new StorageSku
      {
          Name = StorageSkuName.StandardGRS
      };
      account.Kind = StorageKind.StorageV2;
  });
  ```

* Service Bus

  ```csharp
  serviceBus.ConfigureInfrastructure(infra =>
  {
      var ns = infra.GetProvisionableResources()
                    .OfType<ServiceBusNamespace>()
                    .Single();


      ns.Sku = new ServiceBusSku
      {
          Name = ServiceBusSkuName.Premium,
          Capacity = 2
      };
  });
  ```

* Redis

  ```csharp
  redis.ConfigureInfrastructure(infra =>
  {
      var cache = infra.GetProvisionableResources()
                       .OfType<RedisCache>()
                       .Single();


      cache.Sku = new RedisCacheSku
      {
          Name = RedisCacheSkuName.Premium,
          Family = RedisCacheSkuFamily.P,
          Capacity = 1
      };
  });
  ```

#### Configure networking

[Section titled “Configure networking”](#configure-networking)

```csharp
storage.ConfigureInfrastructure(infra =>
{
    var account = infra.GetProvisionableResources()
                       .OfType<StorageAccount>()
                       .Single();


    // Enable firewall
    account.NetworkRuleSet = new StorageAccountNetworkRuleSet
    {
        DefaultAction = StorageNetworkDefaultAction.Deny,
        Bypass = "AzureServices"
    };


    // Allow specific IP
    account.NetworkRuleSet.IpRules.Add(new StorageAccountIPRule
    {
        IPAddressOrRange = "203.0.113.0/24",
        Action = "Allow"
    });
});
```

#### Configure security and compliance

[Section titled “Configure security and compliance”](#configure-security-and-compliance)

```csharp
storage.ConfigureInfrastructure(infra =>
{
    var account = infra.GetProvisionableResources()
                       .OfType<StorageAccount>()
                       .Single();


    // Require HTTPS
    account.EnableHttpsTrafficOnly = true;


    // Configure TLS version
    account.MinimumTlsVersion = StorageMinimumTlsVersion.Tls1_2;


    // Enable blob encryption
    account.Encryption = new StorageAccountEncryption
    {
        KeySource = StorageAccountKeySource.MicrosoftStorage,
        Services = new StorageAccountEncryptionServices
        {
            Blob = new StorageEncryptionService { Enabled = true },
            File = new StorageEncryptionService { Enabled = true }
        }
    };
});
```

### Working with multiple resources

[Section titled “Working with multiple resources”](#working-with-multiple-resources)

When an integration creates multiple resources, you can customize each one:

```csharp
var servicebus = builder.AddAzureServiceBus("messaging");
var queue = servicebus.AddQueue("orders");


servicebus.ConfigureInfrastructure(infra =>
{
    // Customize the namespace
    var ns = infra.GetProvisionableResources()
                  .OfType<ServiceBusNamespace>()
                  .Single();
    ns.Sku = new ServiceBusSku { Name = ServiceBusSkuName.Standard };


    // Customize the queue
    var queueResource = infra.GetProvisionableResources()
                             .OfType<ServiceBusQueue>()
                             .FirstOrDefault(q => q.Name.Contains("orders"));


    if (queueResource != null)
    {
        queueResource.MaxDeliveryCount = 5;
        queueResource.DefaultMessageTimeToLive = TimeSpan.FromHours(24);
    }
});
```

### Adding Azure resources

[Section titled “Adding Azure resources”](#adding-azure-resources)

You can add additional Azure resources to the infrastructure:

```csharp
storage.ConfigureInfrastructure(infra =>
{
    // Add a private endpoint
    var privateEndpoint = new PrivateEndpoint("storagepe")
    {
        Location = "eastus",
        Subnet = new SubnetReference
        {
            Id = "/subscriptions/.../subnets/mysubnet"
        }
    };


    infra.Add(privateEndpoint);
});
```

## Custom Bicep templates

[Section titled “Custom Bicep templates”](#custom-bicep-templates)

For more complex scenarios or when you need full control, you can provide custom Bicep templates.

### Using custom Bicep files

[Section titled “Using custom Bicep files”](#using-custom-bicep-files)

Create a custom Bicep file in your AppHost project:

custom-storage.bicep

```bicep
@description('Storage account name')
param storageAccountName string


@description('Location')
param location string = resourceGroup().location


resource storageAccount 'Microsoft.Storage/storageAccounts@2023-01-01' = {
  name: storageAccountName
  location: location
  sku: {
    name: 'Premium_LRS'
  }
  kind: 'BlockBlobStorage'
  properties: {
    minimumTlsVersion: 'TLS1_2'
    allowBlobPublicAccess: false
    networkAcls: {
      defaultAction: 'Deny'
      bypass: 'AzureServices'
    }
  }
}


output connectionString string = 'DefaultEndpointsProtocol=https;AccountName=${storageAccount.name};...'
```

Reference it in your AppHost:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureBicepResource(
    name: "storage",
    bicepFilePath: "./custom-storage.bicep")
    .WithParameter("storageAccountName", "mystorageaccount");


builder.AddProject<Projects.WebApp>("webapp")
       .WithReference(storage);
```

### Combining approaches

[Section titled “Combining approaches”](#combining-approaches)

You can combine `ConfigureInfrastructure` with custom Bicep for maximum flexibility:

```csharp
// Start with Aspire's default
var storage = builder.AddAzureStorage("storage");


// Customize with ConfigureInfrastructure
storage.ConfigureInfrastructure(infra =>
{
    var account = infra.GetProvisionableResources()
                       .OfType<StorageAccount>()
                       .Single();
    account.Sku = new StorageSku { Name = StorageSkuName.PremiumLRS };
});


// Add custom resources via Bicep
var customResource = builder.AddAzureBicepResource(
    name: "custom",
    bicepFilePath: "./custom-resource.bicep");
```

## Best practices

[Section titled “Best practices”](#best-practices)

### Use ConfigureInfrastructure for standard customizations

[Section titled “Use ConfigureInfrastructure for standard customizations”](#use-configureinfrastructure-for-standard-customizations)

For common property changes like SKUs, tags, and basic configuration, prefer `ConfigureInfrastructure`:

```csharp
// ✅ Good - Simple and maintainable
storage.ConfigureInfrastructure(infra =>
{
    var account = infra.GetProvisionableResources()
                       .OfType<StorageAccount>()
                       .Single();
    account.Sku = new StorageSku { Name = StorageSkuName.PremiumLRS };
});
```

### Use custom Bicep for complex scenarios

[Section titled “Use custom Bicep for complex scenarios”](#use-custom-bicep-for-complex-scenarios)

Use custom Bicep when you need:

* Complex networking configurations
* Multiple interconnected resources
* Custom resource types not in Azure.Provisioning
* Advanced policy configurations

### Keep infrastructure code close to application code

[Section titled “Keep infrastructure code close to application code”](#keep-infrastructure-code-close-to-application-code)

Define infrastructure customizations in your AppHost alongside resource declarations:

```csharp
// All storage configuration in one place
var storage = builder.AddAzureStorage("storage")
                     .ConfigureInfrastructure(infra =>
                     {
                         // Customizations here
                     });
```

### Use configuration for environment-specific values

[Section titled “Use configuration for environment-specific values”](#use-configuration-for-environment-specific-values)

Don’t hard-code environment-specific values:

```csharp
var skuName = builder.Configuration["Azure:Storage:Sku"] ?? "Standard_LRS";


storage.ConfigureInfrastructure(infra =>
{
    var account = infra.GetProvisionableResources()
                       .OfType<StorageAccount>()
                       .Single();
    account.Sku = new StorageSku { Name = skuName };
});
```

## Generated Bicep inspection

[Section titled “Generated Bicep inspection”](#generated-bicep-inspection)

After customization, you can inspect the generated Bicep:

1. Run your AppHost locally
2. Check the `./infra` directory in your AppHost project
3. Review the generated `.bicep` files

The generated files reflect all customizations made via `ConfigureInfrastructure`.

## Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

### Finding resource types

[Section titled “Finding resource types”](#finding-resource-types)

If you’re unsure what resource type to use:

```csharp
storage.ConfigureInfrastructure(infra =>
{
    // List all resources
    var resources = infra.GetProvisionableResources();
    foreach (var resource in resources)
    {
        Console.WriteLine($"Type: {resource.GetType().Name}");
    }
});
```

### Property not available

[Section titled “Property not available”](#property-not-available)

If a property isn’t available in the Azure.Provisioning types, you may need to:

1. Update to the latest Aspire version
2. Use custom Bicep for that specific property
3. File an issue on the Aspire GitHub repository

### Validation errors

[Section titled “Validation errors”](#validation-errors)

Azure will validate your configuration during deployment. Common issues:

* Invalid SKU names or combinations
* Location mismatches
* Naming convention violations
* Missing required properties

Tip

Use the Azure Portal’s “Export template” feature to see the Bicep for manually configured resources, then adapt it for Aspire.

## See also

[Section titled “See also”](#see-also)

* [Azure integrations overview](/integrations/cloud/azure/overview/)
* [Local Azure provisioning](/integrations/cloud/azure/local-provisioning/)
* [Deploy to Azure Container Apps](/get-started/deploy-first-app/)

# Local Azure provisioning

> Learn how to automatically provision Azure resources during local development with Aspire.

Local Azure provisioning enables Aspire to automatically create and configure Azure resources during local development. When you add Azure resources to your AppHost and run your application, Aspire can provision those resources in your Azure subscription without manual intervention.

## How it works

[Section titled “How it works”](#how-it-works)

When you add an Azure resource using methods like `AddAzureStorage()` or `AddAzureServiceBus()`, Aspire:

1. Detects that the resource doesn’t exist locally
2. Generates Bicep infrastructure-as-code
3. Uses Azure CLI or Azure SDK to deploy resources
4. Configures connection information automatically
5. Injects configuration into your application

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

Before using local provisioning, ensure you have:

* **Azure subscription**: An active Azure subscription
* **Azure CLI**: Installed and authenticated (`az login`)
* **Appropriate permissions**: Contributor access to create resources
* **Aspire 9.0+**: Local provisioning requires Aspire 9.0 or later

## Configuration

[Section titled “Configuration”](#configuration)

Local provisioning requires configuring your Azure subscription and location. You can do this in multiple ways:

### User secrets

[Section titled “User secrets”](#user-secrets)

The recommended approach for development is using user secrets:

```bash
dotnet user-secrets init --project ./YourAppHost/YourAppHost.csproj
dotnet user-secrets set "Azure:SubscriptionId" "your-subscription-id" --project ./YourAppHost
dotnet user-secrets set "Azure:Location" "eastus" --project ./YourAppHost
```

### appsettings.json

[Section titled “appsettings.json”](#appsettingsjson)

Alternatively, configure in `appsettings.Development.json`:

```json
{
  "Azure": {
    "SubscriptionId": "your-subscription-id",
    "Location": "eastus",
    "CredentialSource": "AzureCli"
  }
}
```

Caution

Don’t commit subscription IDs to source control in appsettings.json. Use user secrets or environment variables instead.

### Environment variables

[Section titled “Environment variables”](#environment-variables)

You can also use environment variables:

* Bash

  ```bash
  Azure__Location="eastus"
  ```

* PowerShell

  ```powershell
  $env:Azure__Location = "eastus"
  ```

## Configuration options

[Section titled “Configuration options”](#configuration-options)

The following configuration options are available:

| Setting                            | Description                    | Default    |
| ---------------------------------- | ------------------------------ | ---------- |
| `Azure:SubscriptionId`             | Your Azure subscription ID     | (required) |
| `Azure:Location`                   | Azure region for resources     | (required) |
| `Azure:CredentialSource`           | Authentication method          | `AzureCli` |
| `Azure:AllowResourceGroupCreation` | Allow creating resource groups | `true`     |

## Resource group management

[Section titled “Resource group management”](#resource-group-management)

By default, Aspire creates a resource group for your provisioned resources. The resource group name follows the pattern: `rg-{apphost-name}`.

### Use an existing resource group

[Section titled “Use an existing resource group”](#use-an-existing-resource-group)

To use an existing resource group:

```json
{
  "Azure": {
    "SubscriptionId": "your-subscription-id",
    "Location": "eastus",
    "ResourceGroup": "my-existing-rg"
  }
}
```

### Disable resource group creation

[Section titled “Disable resource group creation”](#disable-resource-group-creation)

To prevent Aspire from creating resource groups:

```json
{
  "Azure": {
    "SubscriptionId": "your-subscription-id",
    "Location": "eastus",
    "AllowResourceGroupCreation": false,
    "ResourceGroup": "my-existing-rg"
  }
}
```

## Using local provisioning

[Section titled “Using local provisioning”](#using-local-provisioning)

1. **Add Azure resources to your AppHost**

   ```csharp
   var builder = DistributedApplication.CreateBuilder(args);


   var storage = builder.AddAzureStorage("storage");
   var blobs = storage.AddBlobs("blobs");


   builder.AddProject<Projects.WebApp>("webapp")
          .WithReference(blobs);
   ```

2. **Configure Azure subscription** (if not already done)

   ```bash
   dotnet user-secrets set "Azure:SubscriptionId" "your-sub-id" --project ./AppHost
   dotnet user-secrets set "Azure:Location" "eastus" --project ./AppHost
   ```

3. **Run your application**

   ```bash
   aspire run
   ```

4. **Automatic provisioning**

   Aspire detects the Azure resources and provisions them automatically. You’ll see output like:

   ```txt
   [Azure Provisioning] Creating resource group: rg-myapp
   [Azure Provisioning] Deploying storage account: stmyapp
   [Azure Provisioning] Deployment complete
   ```

## Authentication

[Section titled “Authentication”](#authentication)

Local provisioning supports multiple authentication methods:

### Azure CLI (Default)

[Section titled “Azure CLI (Default)”](#azure-cli-default)

Uses your Azure CLI credentials:

```bash
az login
```

Configuration:

```json
{
  "Azure": {
    "CredentialSource": "AzureCli"
  }
}
```

### Managed Identity

[Section titled “Managed Identity”](#managed-identity)

When running in Azure (e.g., Azure Container Instances):

```json
{
  "Azure": {
    "CredentialSource": "ManagedIdentity"
  }
}
```

### Visual Studio

[Section titled “Visual Studio”](#visual-studio)

Uses Visual Studio’s Azure account:

```json
{
  "Azure": {
    "CredentialSource": "VisualStudio"
  }
}
```

## Provisioned resource naming

[Section titled “Provisioned resource naming”](#provisioned-resource-naming)

Aspire generates unique resource names following Azure naming conventions:

* **Storage accounts**: `st{appname}{hash}` (lowercase, no hyphens)
* **Key Vaults**: `kv-{appname}-{hash}` (hyphens allowed)
* **Service Bus**: `sb-{appname}-{hash}`
* **Cosmos DB**: `cosmos-{appname}-{hash}`

The hash ensures uniqueness across subscriptions.

## Generated infrastructure

[Section titled “Generated infrastructure”](#generated-infrastructure)

When you use local provisioning, Aspire generates Bicep files in the `./infra` directory of your AppHost project. These files:

* Define all Azure resources
* Include configurations and connections
* Can be customized using `ConfigureInfrastructure()`
* Are used for both local provisioning and production deployment

Example generated structure:

* AppHost

  * infra Bicep files

    * main.bicep
    * storage.bicep
    * servicebus.bicep

  * Program.cs

## Limitations

[Section titled “Limitations”](#limitations)

Local provisioning has some limitations:

* **First-run delays**: Initial provisioning takes several minutes
* **Subscription limits**: Subject to Azure subscription quotas
* **Network requirements**: Requires internet connectivity
* **Cost considerations**: Provisioned resources incur Azure charges

Tip

Use emulators (like Azurite for Storage) during development to avoid provisioning costs. Switch to local provisioning when you need to test with real Azure services.

## Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

### Authentication failures

[Section titled “Authentication failures”](#authentication-failures)

If you see authentication errors:

```bash
az login
az account set --subscription "your-subscription-id"
```

### Insufficient permissions

[Section titled “Insufficient permissions”](#insufficient-permissions)

Ensure your account has Contributor role:

```bash
az role assignment list --assignee your-email@domain.com
```

### Resource naming conflicts

[Section titled “Resource naming conflicts”](#resource-naming-conflicts)

If resource names conflict, delete the existing resources or change your app name:

```bash
az group delete --name rg-myapp
```

### View provisioning logs

[Section titled “View provisioning logs”](#view-provisioning-logs)

Enable detailed logging:

```json
{
  "Logging": {
    "LogLevel": {
      "Aspire.Hosting.Azure": "Debug"
    }
  }
}
```

## Comparison with manual provisioning

[Section titled “Comparison with manual provisioning”](#comparison-with-manual-provisioning)

| Aspect                     | Local Provisioning                 | Manual Provisioning           |
| -------------------------- | ---------------------------------- | ----------------------------- |
| **Setup time**             | Automatic                          | Manual Azure Portal/CLI       |
| **Configuration**          | Automatic                          | Manual connection strings     |
| **Infrastructure as Code** | Auto-generated Bicep               | Manual Bicep/ARM              |
| **Development speed**      | Fast                               | Slower                        |
| **Learning curve**         | Lower                              | Higher                        |
| **Control**                | Good (via ConfigureInfrastructure) | Full                          |
| **Cost**                   | Pay for provisioned resources      | Pay for provisioned resources |

## See also

[Section titled “See also”](#see-also)

* [Azure integrations overview](/integrations/cloud/azure/overview/)
* [Customize Azure resources](/integrations/cloud/azure/customize-resources/)
* [Deploy to Azure Container Apps](/get-started/deploy-first-app/)

# Azure integrations overview

> Learn about Aspire integrations for Azure services and how to use them in your distributed applications.

![Azure logo](/_astro/azure-icon.Be9vXxEg_1kLtcC.webp)

Aspire provides a comprehensive set of integrations for Azure services that enable you to build cloud-native distributed applications. These integrations handle configuration, health checks, telemetry, and deployment for various Azure services.

## What are Azure integrations?

[Section titled “What are Azure integrations?”](#what-are-azure-integrations)

Azure integrations in Aspire provide two main capabilities:

1. **Hosting integrations**: Model Azure resources in your AppHost project, enabling local development and streamlined deployment.
2. **Client integrations**: Configure .NET clients to connect to Azure services with proper defaults for observability and resilience.

## Add Azure resources

[Section titled “Add Azure resources”](#add-azure-resources)

All Aspire Azure hosting integrations expose Azure resources and by convention are added using `AddAzure*` APIs. When you add these resources to your Aspire AppHost, they represent an Azure service. The `AddAzure*` API returns an `IResourceBuilder<T>` where `T` is the type of Azure resource. These `IResourceBuilder<T>` (builder) interfaces provide a fluent API that allows you to configure the underlying Azure resource within the [app model](/get-started/app-host/). There are APIs for adding new Azure resources, marking resources as existing, and configuring how the resources behave in various execution contexts.

### Typical developer experience

[Section titled “Typical developer experience”](#typical-developer-experience)

When your Aspire AppHost contains Azure resources, and you run it locally (typical developer F5 `F5` F5 `F5` F5 `F5` or `dotnet run` experience), the [Azure resources are provisioned](/integrations/cloud/azure/local-provisioning/) in your Azure subscription. This allows you as the developer to debug against them locally in the context of your AppHost.

Aspire aims to minimize costs by defaulting to *Basic* or *Standard* [Stock Keeping Unit (SKU)](https://learn.microsoft.com/partner-center/developer/product-resources#sku) for its Azure integrations. While these sensible defaults are provided, you can [customize the Azure resources](/integrations/cloud/azure/customize-resources/#azureprovisioning-customization) to suit your needs. Additionally, some integrations support [emulators](#local-emulators) or [containers](#local-containers), which are useful for local development, testing, and debugging. By default, when you run your app locally, the Azure resources use the actual Azure service. However, you can configure them to use local emulators or containers, avoiding costs associated with the actual Azure service during local development.

### Local emulators

[Section titled “Local emulators”](#local-emulators)

Some Azure services can be emulated to run locally. Currently, Aspire supports the following Azure emulators:

| Hosting integration                                                           | Description                                                                                                                                                                                                                                                              |
| ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [Azure App Configuration](/integrations/cloud/azure/azure-app-configuration/) | Call `RunAsEmulator` on the `IResourceBuilder<AzureAppConfigurationResource>` to configure the Azure App Configuration resource to be [emulated with the Azure App Configuration Emulator](https://learn.microsoft.com/azure/azure-app-configuration/emulator-overview). |
| [Azure Cosmos DB](/integrations/cloud/azure/azure-cosmos-db/)                 | Call `RunAsEmulator` on the `IResourceBuilder<AzureCosmosDBResource>` to configure the Cosmos DB resource to be [emulated with the NoSQL API](https://learn.microsoft.com/azure/cosmos-db/how-to-develop-emulator).                                                      |
| [Azure AI Foundry](/integrations/cloud/azure/azure-ai-foundry/)               | Call `RunAsFoundryLocal` on the `IResourceBuilder<AzureAIFoundryResource>` to configure the resource to be [emulated with Foundry Local](https://learn.microsoft.com/azure/ai-foundry/foundry-local/get-started).                                                        |
| [Azure Event Hubs](/integrations/cloud/azure/azure-event-hubs/)               | Call `RunAsEmulator` on the `IResourceBuilder<AzureEventHubsResource>` to configure the Event Hubs resource to be [emulated](https://learn.microsoft.com/azure/event-hubs/overview-emulator).                                                                            |
| [Azure Service Bus](/integrations/cloud/azure/azure-service-bus/)             | Call `RunAsEmulator` on the `IResourceBuilder<AzureServiceBusResource>` to configure the Service Bus resource to be [emulated with Service Bus emulator](https://learn.microsoft.com/azure/service-bus-messaging/overview-emulator).                                     |
| [Azure SignalR Service](/integrations/cloud/azure/azure-signalr/)             | Call `RunAsEmulator` on the `IResourceBuilder<AzureSignalRResource>` to configure the SignalR resource to be [emulated with Azure SignalR emulator](https://learn.microsoft.com/azure/azure-signalr/signalr-howto-emulator).                                             |
| [Azure Storage](/integrations/cloud/azure/azure-storage-blobs/)               | Call `RunAsEmulator` on the `IResourceBuilder<AzureStorageResource>` to configure the Storage resource to be [emulated with Azurite](https://learn.microsoft.com/azure/storage/common/storage-use-azurite).                                                              |

To have your Azure resources use the local emulators, chain a call the `RunAsEmulator` method on the Azure resource builder. This method configures the Azure resource to use the local emulator instead of the actual Azure service.

Caution

Calling any of the available `RunAsEmulator` APIs on an Azure resource builder doesn’t effect the [publishing manifest](/architecture/resource-publishing/). When you publish your app, [the generated Bicep file](/integrations/cloud/azure/customize-resources/) reflects the actual Azure service, not the local emulator.

### Local containers

[Section titled “Local containers”](#local-containers)

Some Azure resources can be substituted locally using open-source or on-premises containers. To substitute an Azure resource locally in a container, chain a call to the `RunAsContainer` method on the Azure resource builder. This method configures the Azure resource to use a containerized version of the service for local development and testing, rather than the actual Azure service.

Currently, Aspire supports the following Azure services as containers:

| Hosting integration                                                                                          | Details                                                                                                                                                                              |
| ------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [Azure Cache for Redis](/integrations/cloud/azure/azure-cache-redis/)                                        | Call `RunAsContainer` on the `IResourceBuilder<AzureRedisCacheResource>` to configure it to run locally in a container, based on the `docker.io/library/redis` image.                |
| [Azure PostgreSQL Flexible Server](/integrations/cloud/azure/azure-postgresql/azure-postgresql-get-started/) | Call `RunAsContainer` on the `IResourceBuilder<AzurePostgresFlexibleServerResource>` to configure it to run locally in a container, based on the `docker.io/library/postgres` image. |
| [Azure SQL Server](/integrations/cloud/azure/azure-sql-database/)                                            | Call `RunAsContainer` on the `IResourceBuilder<AzureSqlServerResource>` to configure it to run locally in a container, based on the `mcr.microsoft.com/mssql/server` image.          |

Note

Like emulators, calling `RunAsContainer` on an Azure resource builder doesn’t effect the [publishing manifest](/architecture/resource-publishing/). When you publish your app, the [generated Bicep file](/integrations/cloud/azure/customize-resources/) reflects the actual Azure service, not the local container.

### Understand Azure integration APIs

[Section titled “Understand Azure integration APIs”](#understand-azure-integration-apis)

Aspire’s strength lies in its ability to provide an amazing developer inner-loop. The Azure integrations are no different. They provide a set of common APIs and patterns that are shared across all Azure resources. These APIs and patterns are designed to make it easy to work with Azure resources in a consistent manner.

In the preceding containers section, you saw how to run Azure services locally in containers. If you’re familiar with Aspire, you might wonder how calling `AddAzureRedis("redis").RunAsContainer()` to get a local `docker.io/library/redis` container differs from `AddRedis("redis")`—as they both result in the same local container.

The answer is that there’s no difference when running locally. However, when they’re published you get different resources:

| API                                       | Run mode              | Publish mode                         |
| ----------------------------------------- | --------------------- | ------------------------------------ |
| `AddAzureRedis("redis").RunAsContainer()` | Local Redis container | Azure Cache for Redis                |
| `AddRedis("redis")`                       | Local Redis container | Azure Container App with Redis image |

The same is true for SQL and PostgreSQL services:

| API                                                           | Run mode                   | Publish mode                              |
| ------------------------------------------------------------- | -------------------------- | ----------------------------------------- |
| `AddAzurePostgresFlexibleServer("postgres").RunAsContainer()` | Local PostgreSQL container | Azure PostgreSQL Flexible Server          |
| `AddPostgres("postgres")`                                     | Local PostgreSQL container | Azure Container App with PostgreSQL image |
| `AddAzureSqlServer("sql").RunAsContainer()`                   | Local SQL Server container | Azure SQL Server                          |
| `AddSqlServer("sql")`                                         | Local SQL Server container | Azure Container App with SQL Server image |

For more information on the difference between run and publish modes, see [Aspire AppHost: Execution context](/get-started/app-host/).

### APIs for expressing Azure resources in different modes

[Section titled “APIs for expressing Azure resources in different modes”](#apis-for-expressing-azure-resources-in-different-modes)

The distributed application builder, part of the [AppHost](/get-started/app-host/), uses the builder pattern to `AddAzure*` resources to the [*app model*](/architecture/resource-model/). Developers can configure these resources and define their behavior in different execution contexts. Azure hosting integrations provide APIs to specify how these resources should be “published” and “run.”

When the AppHost executes, the [*execution context*](/get-started/app-host/) is used to determine whether the AppHost is in `Run` or `Publish` mode. The naming conventions for these APIs indicate the intended action for the resource.

The following table summarizes the naming conventions used to express Azure resources:

| Operation       | API                         | Description                                                                                                         |
| --------------- | --------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| Publish         | `PublishAsConnectionString` | Changes the resource to be published as a connection string reference in the manifest.                              |
| Publish         | `PublishAsExisting`         | Uses an existing Azure resource when the application is deployed instead of creating a new one.                     |
| Run             | `RunAsContainer`            | Configures an equivalent container to run locally. For more information, see [Local containers](#local-containers). |
| Run             | `RunAsEmulator`             | Configures the Azure resource to be emulated. For more information, see [Local emulators](#local-emulators).        |
| Run             | `RunAsExisting`             | Uses an existing resource when the application is running instead of creating a new one.                            |
| Publish and Run | `AsExisting`                | Uses an existing resource regardless of the operation.                                                              |

Note

Not all APIs are available on all Azure resources. For example, some Azure resources can be containerized or emulated, while others can’t.

For more information on execution modes, see [Execution context](/get-started/app-host/).

#### General run mode API use cases

[Section titled “General run mode API use cases”](#general-run-mode-api-use-cases)

Use `RunAsExisting` when you need to dynamically interact with an existing resource during runtime without needing to deploy or update it. Use `PublishAsExisting` when declaring existing resources as part of a deployment configuration, ensuring the correct scopes and permissions are applied. Finally, use `AsExisting` when declaring existing resources in both configurations, with a requirement to parameterize the references.

You can query whether a resource is marked as an existing resource, by calling the `IsExisting` extension method on the `IResource`. For more information, see [Use existing Azure resources](#use-existing-azure-resources).

## Use existing Azure resources

[Section titled “Use existing Azure resources”](#use-existing-azure-resources)

Aspire provides support for referencing existing Azure resources. You mark an existing resource through the `PublishAsExisting`, `RunAsExisting`, and `AsExisting` APIs. These APIs allow developers to reference already-deployed Azure resources, configure them, and generate appropriate deployment manifests using Bicep templates.

Caution

When you call `RunAsExisting`, `PublishAsExisting`, or `AsExisting` methods to work with resources that are already present in your Azure subscription, you must add certain configuration values to your AppHost to ensure that Aspire can locate them. The necessary configuration values include **SubscriptionId**, **AllowResourceGroupCreation**, **ResourceGroup**, and **Location**. If you don’t set them, “Missing configuration” errors appear in the Aspire dashboard. For more information about how to set them, see [Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

Existing resources referenced with these APIs can be enhanced with [role assignments](/integrations/cloud/azure/role-assignments/) and other customizations that are available with Aspire’s [infrastructure as code capabilities](/integrations/cloud/azure/customize-resources/). These APIs are limited to Azure resources that can be deployed with Bicep templates.

### Configure existing Azure resources for run mode

[Section titled “Configure existing Azure resources for run mode”](#configure-existing-azure-resources-for-run-mode)

The `RunAsExisting` method is used when a distributed application is executing in “run” mode. In this mode, it assumes that the referenced Azure resource already exists and integrates with it during execution without provisioning the resource. To mark an Azure resource as existing, call the `RunAsExisting` method on the resource builder. Consider the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder();


var existingServiceBusName = builder.AddParameter("existingServiceBusName");
var existingServiceBusResourceGroup = builder.AddParameter("existingServiceBusResourceGroup");


var serviceBus = builder.AddAzureServiceBus("messaging")
                        .RunAsExisting(existingServiceBusName, existingServiceBusResourceGroup);


serviceBus.AddServiceBusQueue("queue");
```

The preceding code:

* Creates a new `builder` instance.
* Adds a parameter named `existingServiceBusName` to the builder.
* Adds an Azure Service Bus resource named `messaging` to the builder.
* Calls the `RunAsExisting` method on the `serviceBus` resource builder, passing the `existingServiceBusName` parameter—alternatively, you can use the `string` parameter overload.
* Adds a queue named `queue` to the `serviceBus` resource.

By default, the Service Bus parameter reference is assumed to be in the same Azure resource group. However, if it’s in a different resource group, you can pass the resource group explicitly as a parameter to correctly specify the appropriate resource grouping.

### Configure existing Azure resources for publish mode

[Section titled “Configure existing Azure resources for publish mode”](#configure-existing-azure-resources-for-publish-mode)

The `PublishAsExisting` method is used in “publish” mode when the intent is to declare and reference an already-existing Azure resource during publish mode. This API facilitates the creation of manifests and templates that include resource definitions that map to existing resources in Bicep.

To mark an Azure resource as existing in for the “publish” mode, call the `PublishAsExisting` method on the resource builder. Consider the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder();


var existingServiceBusName = builder.AddParameter("existingServiceBusName");
var existingServiceBusResourceGroup = builder.AddParameter("existingServiceBusResourceGroup");


var serviceBus = builder.AddAzureServiceBus("messaging")
                        .PublishAsExisting(existingServiceBusName, existingServiceBusResourceGroup);


serviceBus.AddServiceBusQueue("queue");
```

The preceding code:

* Creates a new `builder` instance.
* Adds a parameter named `existingServiceBusName` to the builder.
* Adds an Azure Service Bus resource named `messaging` to the builder.
* Calls the `PublishAsExisting` method on the `serviceBus` resource builder, passing the `existingServiceBusName` parameter—alternatively, you can use the `string` parameter overload.
* Adds a queue named `queue` to the `serviceBus` resource.

After the AppHost is executed in publish mode, the generated manifest file will include the `existingResourceName` parameter, which can be used to reference the existing Azure resource. Consider the following generated partial snippet of the manifest file:

JSON — aspire manifest

```json
"messaging": {
  "type": "azure.bicep.v0",
  "connectionString": "{messaging.outputs.serviceBusEndpoint}",
  "path": "messaging.module.bicep",
  "params": {
    "existingServiceBusName": "{existingServiceBusName.value}",
    "principalType": "",
    "principalId": ""
  }
},
"queue": {
  "type": "value.v0",
  "connectionString": "{messaging.outputs.serviceBusEndpoint}"
}
```

For more information on the manifest file, see [Aspire manifest format for deployment tool builders](/architecture/resource-publishing/).

Additionally, the generated Bicep template includes the `existingResourceName` parameter, which can be used to reference the existing Azure resource. Consider the following generated Bicep template:

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param existingServiceBusName string


param principalType string


param principalId string


resource messaging 'Microsoft.ServiceBus/namespaces@2024-01-01' existing = {
  name: existingServiceBusName
}


resource messaging_AzureServiceBusDataOwner 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(messaging.id, principalId, subscriptionResourceId(
    'Microsoft.Authorization/roleDefinitions', '090c5cfd-751d-490a-894a-3ce6f1109419'))
  properties: {
    principalId: principalId
    roleDefinitionId: subscriptionResourceId(
        'Microsoft.Authorization/roleDefinitions', '090c5cfd-751d-490a-894a-3ce6f1109419')
    principalType: principalType
  }
  scope: messaging
}


resource queue 'Microsoft.ServiceBus/namespaces/queues@2024-01-01' = {
  name: 'queue'
  parent: messaging
}


output serviceBusEndpoint string = messaging.properties.serviceBusEndpoint
```

For more information on the generated Bicep templates, see [Customize Azure resources](/integrations/cloud/azure/customize-resources/) and [consider other publishing APIs](#publish-as-azure-container-app).

Caution

When interacting with existing resources that require authentication, ensure the authentication strategy that you’re configuring in the Aspire application model aligns with the authentication strategy allowed by the existing resource. For example, it’s not possible to use managed identity against an existing Azure PostgreSQL resource that isn’t configured to allow managed identity. Similarly, if an existing Azure Redis resource disabled access keys, it’s not possible to use access key authentication.

### Configure existing Azure resources in all modes

[Section titled “Configure existing Azure resources in all modes”](#configure-existing-azure-resources-in-all-modes)

The `AsExisting` method is used when the distributed application is running in “run” or “publish” mode. Because the `AsExisting` method operates in both scenarios, it only supports a parameterized reference to the resource name or resource group name. This approach helps prevent the use of the same resource in both testing and production environments.

To mark an Azure resource as existing, call the `AsExisting` method on the resource builder. Consider the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder();


var existingServiceBusName = builder.AddParameter("existingServiceBusName");
var existingServiceBusResourceGroup = builder.AddParameter("existingServiceBusResourceGroup");


var serviceBus = builder.AddAzureServiceBus("messaging")
    .AsExisting(existingServiceBusName, existingServiceBusResourceGroup);


serviceBus.AddServiceBusQueue("queue");
```

The preceding code:

* Creates a new `builder` instance.
* Adds a parameter named `existingServiceBusName` to the builder.
* Adds an Azure Service Bus resource named `messaging` to the builder.
* Calls the `AsExisting` method on the `serviceBus` resource builder, passing the `existingServiceBusName` parameter.
* Adds a queue named `queue` to the `serviceBus` resource.

## Add existing Azure resources with connection strings

[Section titled “Add existing Azure resources with connection strings”](#add-existing-azure-resources-with-connection-strings)

Aspire provides the ability to [connect to existing resources](/get-started/resources/), including Azure resources. Expressing connection strings is useful when you have existing Azure resources that you want to use in your Aspire app. The `AddConnectionString` API is used with the AppHost’s [execution context](/get-started/app-host/) to conditionally add a connection string to the app model.

Note

Connection strings are used to represent a wide range of connection information, including database connections, message brokers, endpoint URIs, and other services. In Aspire nomenclature, the term “connection string” is used to represent any kind of connection information.

Consider the following example, where in *publish* mode you add an Azure Storage resource while in *run* mode you add a connection string to an existing Azure Storage:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.ExecutionContext.IsPublishMode
    ? builder.AddAzureStorage("storage")
    : builder.AddConnectionString("storage");


builder.AddProject<Projects.Api>("api")
    .WithReference(storage);


// After adding all resources, run the app...
```

The preceding code:

* Creates a new `builder` instance.
* Adds an Azure Storage resource named `storage` in “publish” mode.
* Adds a connection string to an existing Azure Storage named `storage` in “run” mode.
* Adds a project named `api` to the builder.
* The `api` project references the `storage` resource regardless of the mode.

The consuming API project uses the connection string information with no knowledge of how the AppHost configured it. In “publish” mode, the code adds a new Azure Storage resource—which would be reflected in the [deployment manifest](/architecture/resource-publishing/) accordingly. When in “run” mode the connection string corresponds to a configuration value visible to the AppHost. It’s assumed that all role assignments for the target resource are configured. This means, you’d likely configure an environment variable or a user secret to store the connection string. The configuration is resolved from the `ConnectionStrings__storage` (or `ConnectionStrings:storage`) configuration key. These configuration values can be viewed when the app runs. For more information, see [Resource details](/dashboard/explore/#resource-details).

Unlike existing resources modeled with [the first-class `AsExisting` API](#use-existing-azure-resources), existing resource modeled as connection strings can’t be enhanced with additional role assignments or infrastructure customizations.

## Publish as Azure Container App

[Section titled “Publish as Azure Container App”](#publish-as-azure-container-app)

Aspire allows you to publish primitive resources as [Azure Container Apps](https://learn.microsoft.com/azure/container-apps/overview), a serverless platform that reduces infrastructure management. Supported resource types include:

* `ContainerResource`: Represents a specified container.
* `ExecutableResource`: Represents a specified executable process.
* `ProjectResource`: Represents a specified .NET project.

To publish these resources, use the following APIs:

* `PublishAsAzureContainerApp` for containers
* `PublishAsAzureContainerApp` for executables
* `PublishAsAzureContainerApp` for projects

These APIs configure the resource to be published as an Azure Container App and implicitly call `AddAzureContainerAppsInfrastructure` to add the necessary infrastructure and Bicep files to your AppHost. As an example, consider the following code:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder();


var env = builder.AddParameter("env");


var api = builder.AddProject<Projects.AspireApi>("api")
    .PublishAsAzureContainerApp<Projects.AspireApi>((infra, app) =>
    {
        app.Template.Containers[0].Value!.Env.Add(new ContainerAppEnvironmentVariable
        {
            Name = "Hello",
            Value = env.AsProvisioningParameter(infra)
        });
    });
```

The preceding code:

* Creates a new `builder` instance.

* Adds a parameter named `env` to the builder.

* Adds a project named `api` to the builder.

* Calls the `PublishAsAzureContainerApp` method on the `api` resource builder, passing a lambda expression that configures the Azure Container App infrastructure—where `infra` is the `AzureResourceInfrastructure` and `app` is the `ContainerApp`.

  * Adds an environment variable named `Hello` to the container app, using the `env` parameter.
  * The `AsProvisioningParameter` method is used to treat `env` as either a new `ProvisioningParameter` in infrastructure, or reuses an existing bicep parameter if one with the same name already exists.

To configure the Azure Container App environment, see [Configure Azure Container Apps environments](/integrations/cloud/azure/configure-container-apps/). For information about publishing resources as Azure Container App Jobs, see [Azure Container App Jobs](/integrations/cloud/azure/container-app-jobs/). For more information, see [Azure.Provisioning.AppContainers.ContainerApp](https://learn.microsoft.com/dotnet/api/azure.provisioning.appcontainers.containerapp) and the `AsProvisioningParameter` API documentation.

Tip

If you’re working with Azure Container Apps, you might also be interested in the [Aspire Azure Container Registry integration](/integrations/cloud/azure/azure-container-registry/).

## See also

[Section titled “See also”](#see-also)

* [Local Azure provisioning](/integrations/cloud/azure/local-provisioning/)
* [Customize Azure resources](/integrations/cloud/azure/customize-resources/)
* [Azure role assignments](/integrations/cloud/azure/role-assignments/)
* [Aspire integrations overview](/integrations/overview/)

# Manage Azure role assignments

> Learn how to configure Azure role-based access control (RBAC) for Aspire applications.

All Aspire Azure hosting integrations define Azure resources. These resources come with default role assignments. You can replace these default role assignments with built-in role [or custom role assignments](/integrations/cloud/azure/customize-resources/). In this article, you learn how to manage Azure role assignments on Aspire resources.

## Default built-in role assignments

[Section titled “Default built-in role assignments”](#default-built-in-role-assignments)

When you add an Azure resource to the [AppHost](/get-started/app-host/), it’s assigned default roles. If a resource depends on another resource, it inherits the same role assignments as the referenced resource unless explicitly overridden.

Consider a scenario where an API project resource references an [Azure Search](/integrations/cloud/azure/azure-ai-search/) resource. The API project is given the default role assignments, as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var search = builder.AddAzureSearch("search");


var api = builder.AddProject<Projects.Api>("api")
    .WithReference(search);
```

In the example code, the `api` project resource depends on the Azure `search` resource, meaning it references the `search` resource. By default, the `search` resource is assigned the following built-in roles:

* `Azure.Provisioning.Search.SearchBuiltInRole.SearchIndexDataContributor`
* `Azure.Provisioning.Search.SearchBuiltInRole.SearchServiceContributor`

These role assignments allow the API project to read and write data to the Azure Search resource, and manage it. However, this behavior might not always be desirable. For instance, you might want to restrict the API project to only read data from the Azure Search resource.

## Override default role assignments

[Section titled “Override default role assignments”](#override-default-role-assignments)

To override the default role assignment, use the [WithRoleAssignments APIs](https://learn.microsoft.com/dotnet/api/?preserve-view=true\&view=dotnet-aspire-13.0\&term=WithRoleAssignments) and assign built-in roles as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var search = builder.AddAzureSearch("search");


var api = builder.AddProject<Projects.Api>("api")
    .WithRoleAssignments(search, SearchBuiltInRole.SearchIndexDataReader)
    .WithReference(search);
```

When you use the `WithRoleAssignments` method, it replaces the default role assignments with the specified ones. This method requires two parameters: the resource to which the role assignment applies and the built-in role to assign. In the preceding example, the `search` resource is assigned the `Azure.Provisioning.Search.SearchBuiltInRole.SearchIndexDataReader` role.

When you replace the default role assignments with the `SearchIndexDataReader` role, the API project is restricted to only reading data from the Azure Search resource. This ensures the API project can’t write data to the Azure Search resource.

For more information, see [Azure built-in roles](https://learn.microsoft.com/azure/role-based-access-control/built-in-roles).

## Built-in role assignment reference

[Section titled “Built-in role assignment reference”](#built-in-role-assignment-reference)

All built-in roles are defined within the \`Azure.Provisioning> namespaces and are included in the corresponding [📦 Azure.Provisioning.\*](https://www.nuget.org/packages?q=Azure.Provisioning) NuGet packages. Each Aspire Azure hosting integration automatically depends on the appropriate provisioning package. For more information, see [Customized Azure resources](/integrations/cloud/azure/customize-resources/).

The following sections list the built-in roles for each Azure provisioning type that can be used as a parameter to the `WithRoleAssignments` API.

### Azure App Configuration

[Section titled “Azure App Configuration”](#azure-app-configuration)

The provisioning resource type is `Azure.Provisioning.AppConfiguration.AppConfigurationStore>, and the built-in roles are defined in the `Azure.Provisioning.AppConfiguration.AppConfigurationBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.AppConfiguration.AppConfigurationBuiltInRole.AppConfigurationDataOwner`
* `Azure.Provisioning.AppConfiguration.AppConfigurationBuiltInRole.AppConfigurationDataReader`

### Azure App Container

[Section titled “Azure App Container”](#azure-app-container)

The provisioning resource type is `Azure.Provisioning.AppContainers.ContainerApp>, and the built-in roles are defined in the `Azure.Provisioning.AppContainers.AppContainersBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.AppContainers.AppContainersBuiltInRole.Contributor`
* `Azure.Provisioning.AppContainers.AppContainersBuiltInRole.Owner`
* `Azure.Provisioning.AppContainers.AppContainersBuiltInRole.Reader`

For more information, see [Configure Azure Container Apps environments](/integrations/cloud/azure/configure-container-apps/).

### Azure Application Insights

[Section titled “Azure Application Insights”](#azure-application-insights)

The provisioning resource type is `Azure.Provisioning.ApplicationInsights.ApplicationInsightsComponent`, and the built-in roles are defined in the `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole` struct. The built-in roles are:

* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.ApplicationInsightsComponentContributor`
* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.ApplicationInsightsSnapshotDebugger`
* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.MonitoringContributor`
* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.MonitoringMetricsPublisher`
* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.MonitoringReader`
* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.WorkbookContributor`
* `Azure.Provisioning.ApplicationInsights.ApplicationInsightsBuiltInRole.WorkbookReader`

### Azure AI (formerly Cognitive Services)

[Section titled “Azure AI (formerly Cognitive Services)”](#azure-ai-formerly-cognitive-services)

The provisioning resource type is `Azure.Provisioning.CognitiveServices.CognitiveServicesAccount>, and the built-in roles are defined in the `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.AzureAIDeveloper`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.AzureAIEnterpriseNetworkConnectionApprover`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.AzureAIInferenceDeploymentOperator`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesContributor`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesCustomVisionContributor`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesCustomVisionDeployment`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesCustomVisionLabeler`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesCustomVisionReader`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesCustomVisionTrainer`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesDataReader`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesFaceRecognizer`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesMetricsAdvisorAdministrator`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesOpenAIContributor`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesOpenAIUser`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesOpenAIUser`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesQnAMakerEditor`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesQnAMakerReader`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesUsagesReader`
* `Azure.Provisioning.CognitiveServices.CognitiveServicesBuiltInRole.CognitiveServicesUser`

For more information, see [Aspire Azure OpenAI integration](/integrations/cloud/azure/azure-openai/).

### Azure Cosmos DB

[Section titled “Azure Cosmos DB”](#azure-cosmos-db)

The provisioning resource type is `Azure.Provisioning.CosmosDB.CosmosDBAccount>, and the built-in roles are defined in the `Azure.Provisioning.CosmosDB.CosmosDBBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.CosmosDB.CosmosDBBuiltInRole.CosmosDBOperator`
* `Azure.Provisioning.CosmosDB.CosmosDBBuiltInRole.CosmosBackupOperator`
* `Azure.Provisioning.CosmosDB.CosmosDBBuiltInRole.CosmosRestoreOperator`

For more information, see:

* [Aspire Azure Cosmos DB integration](/integrations/cloud/azure/azure-cosmos-db/).

### Azure Event Hubs

[Section titled “Azure Event Hubs”](#azure-event-hubs)

The provisioning resource type is `Azure.Provisioning.EventHubs.EventHubsNamespace>, and the built-in roles are defined in the `Azure.Provisioning.EventHubs.EventHubsBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.EventHubs.EventHubsBuiltInRole.AzureEventHubsDataOwner`
* `Azure.Provisioning.EventHubs.EventHubsBuiltInRole.AzureEventHubsDataReceiver`
* `Azure.Provisioning.EventHubs.EventHubsBuiltInRole.AzureEventHubsDataSender`
* `Azure.Provisioning.EventHubs.EventHubsBuiltInRole.SchemaRegistryContributor`
* `Azure.Provisioning.EventHubs.EventHubsBuiltInRole.SchemaRegistryReader`

For more information, see [Aspire Azure Event Hubs integration](/integrations/cloud/azure/azure-event-hubs/).

### Azure Key Vault

[Section titled “Azure Key Vault”](#azure-key-vault)

The provisioning resource type is `Azure.Provisioning.KeyVault.KeyVaultService>, and the built-in roles are defined in the `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultAdministrator`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultCertificatesOfficer`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultCertificateUser`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultContributor`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultCryptoOfficer`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultCryptoServiceEncryptionUser`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultCryptoServiceReleaseUser`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultCryptoUser`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultDataAccessAdministrator`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultDataAccessAdministrator`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultReader`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultSecretsOfficer`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.KeyVaultSecretsUser`
* `Azure.Provisioning.KeyVault.KeyVaultBuiltInRole.ManagedHsmContributor`

For more information, see [Aspire Azure Key Vault integration](/integrations/cloud/azure/azure-key-vault/).

### Azure AI Search

[Section titled “Azure AI Search”](#azure-ai-search)

The provisioning resource type is `Azure.Provisioning.Search.SearchService>, and the built-in roles are defined in the `Azure.Provisioning.Search.SearchBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.Search.SearchBuiltInRole.SearchIndexDataContributor`
* `Azure.Provisioning.Search.SearchBuiltInRole.SearchIndexDataReader`
* `Azure.Provisioning.Search.SearchBuiltInRole.SearchServiceContributor`

For more information, see [Aspire Azure AI Search integration](/integrations/cloud/azure/azure-ai-search/).

### Azure Service Bus

[Section titled “Azure Service Bus”](#azure-service-bus)

The provisioning resource type is `Azure.Provisioning.ServiceBus.ServiceBusNamespace>, and the built-in roles are defined in the `Azure.Provisioning.ServiceBus.ServiceBusBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.ServiceBus.ServiceBusBuiltInRole.AzureServiceBusDataOwner`
* `Azure.Provisioning.ServiceBus.ServiceBusBuiltInRole.AzureServiceBusDataReceiver`
* `Azure.Provisioning.ServiceBus.ServiceBusBuiltInRole.AzureServiceBusDataSender`

For more information, see [Aspire Azure Service Bus integration](/integrations/cloud/azure/azure-service-bus/).

### Azure SignalR Service

[Section titled “Azure SignalR Service”](#azure-signalr-service)

The provisioning resource type is `Azure.Provisioning.SignalR.SignalRService>, and the built-in roles are defined in the `Azure.Provisioning.SignalR.SignalRBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.SignalR.SignalRBuiltInRole.SignalRAccessKeyReader`
* `Azure.Provisioning.SignalR.SignalRBuiltInRole.SignalRAppServer`
* `Azure.Provisioning.SignalR.SignalRBuiltInRole.SignalRContributor`
* `Azure.Provisioning.SignalR.SignalRBuiltInRole.SignalRRestApiOwner`
* `Azure.Provisioning.SignalR.SignalRBuiltInRole.SignalRRestApiReader`
* `Azure.Provisioning.SignalR.SignalRBuiltInRole.SignalRServiceOwner`

For more information, see [Aspire support for Azure SignalR Service](/integrations/cloud/azure/azure-signalr/).

### Azure SQL

[Section titled “Azure SQL”](#azure-sql)

The provisioning resource type is `Azure.Provisioning.Sql.SqlServer>, and the built-in roles are defined in the `Azure.Provisioning.Sql.SqlBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.Sql.SqlBuiltInRole.AzureConnectedSqlServerOnboarding`
* `Azure.Provisioning.Sql.SqlBuiltInRole.SqlDBContributor?displayProperty=nameWithType`
* `Azure.Provisioning.Sql.SqlBuiltInRole.SqlManagedInstanceContributor`
* `Azure.Provisioning.Sql.SqlBuiltInRole.SqlSecurityManager`
* `Azure.Provisioning.Sql.SqlBuiltInRole.SqlServerContributor`

For more information, see [Aspire Azure SQL integration](/integrations/cloud/azure/azure-sql-database/).

### Azure Storage

[Section titled “Azure Storage”](#azure-storage)

The provisioning resource type is `Azure.Provisioning.Storage.StorageAccount`, and the built-in roles are defined in the `Azure.Provisioning.Storage.StorageBuiltInRole` struct. The built-in roles are:

* `Azure.Provisioning.Storage.StorageBuiltInRole.ClassicStorageAccountContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.ClassicStorageAccountKeyOperatorServiceRole`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageAccountBackupContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageAccountContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageAccountKeyOperatorServiceRole`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageBlobDataContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageBlobDataOwner`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageBlobDataReader`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageBlobDelegator`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageFileDataPrivilegedContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageFileDataPrivilegedReader`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageFileDataSmbShareContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageFileDataSmbShareElevatedContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageFileDataSmbShareReader`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageQueueDataContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageQueueDataMessageProcessor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageQueueDataMessageSender`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageQueueDataReader`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageTableDataContributor`
* `Azure.Provisioning.Storage.StorageBuiltInRole.StorageTableDataReader`

For more information, see:

* [Aspire Azure Blob Storage integration](/integrations/cloud/azure/azure-storage-blobs/)
* [Aspire Azure Data Tables integration](/integrations/cloud/azure/azure-storage-queues/)
* [Aspire Azure Queue Storage integration](/integrations/cloud/azure/azure-storage-tables/)

### Azure Web PubSub

[Section titled “Azure Web PubSub”](#azure-web-pubsub)

The provisioning resource type is `Azure.Provisioning.WebPubSub.WebPubSubService>, and the built-in roles are defined in the `Azure.Provisioning.WebPubSub.WebPubSubBuiltInRole> struct. The built-in roles are:

* `Azure.Provisioning.WebPubSub.WebPubSubBuiltInRole.WebPubSubContributor`
* `Azure.Provisioning.WebPubSub.WebPubSubBuiltInRole.WebPubSubServiceOwner`
* `Azure.Provisioning.WebPubSub.WebPubSubBuiltInRole.WebPubSubServiceReader`

For more information, see [Aspire Azure Web PubSub integration](/integrations/cloud/azure/azure-web-pubsub/).

## See also

[Section titled “See also”](#see-also)

* [Aspire Azure integrations overview](/integrations/cloud/azure/overview/)
* [Azure role-based access control (RBAC)](https://learn.microsoft.com/azure/role-based-access-control/overview)

# User-assigned managed identity

> Learn how to configure user-assigned managed identities for Aspire applications in Azure.

In this article, you learn how to add or reference user-assigned managed identities (UMIs). You can add UMIs in your Aspire applications to securely access Azure resources. A UMI is a standalone Azure resource that you can assign to one or more service resources. UMIs give you more control over identity management and resource access.

## Add a user-assigned managed identity

[Section titled “Add a user-assigned managed identity”](#add-a-user-assigned-managed-identity)

To create a new user-assigned managed identity, use the `AddAzureUserAssignedIdentity` API in your distributed application builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sharedMi = builder.AddAzureUserAssignedIdentity("custom-umi");


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding code creates a new managed identity named “custom-umi” that you can use with other resources in your application.

## Reference an existing managed identity

[Section titled “Reference an existing managed identity”](#reference-an-existing-managed-identity)

If you already have a managed identity, you can reference it using the `PublishAsExisting` method. This is useful when you want to use an identity that was created outside of your Aspire project.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var miName = builder.AddParameter("miName");
var miResourceGroup = builder.AddParameter("miResourceGroup");


var sharedMi = builder.AddAzureUserAssignedIdentity("custom-umi")
    .PublishAsExisting(miName, miResourceGroup);


// After adding all resources, run the app...


builder.Build().Run();
```

In the preceding example, you use parameters to provide the name and resource group of the existing identity. This allows you to reference the managed identity without creating a new one.

## Assign roles to managed identities

[Section titled “Assign roles to managed identities”](#assign-roles-to-managed-identities)

You can grant Azure roles to your managed identity using the WithRoleAssignments API. This lets your identity access other Azure resources, such as Azure Key Vault.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sharedMi = builder.AddAzureUserAssignedIdentity("custom-umi");


builder.AddAzureKeyVault("secrets")
    .WithRoleAssignments(sharedMi, BuiltInRole.Reader);


// After adding all resources, run the app...


builder.Build().Run();
```

In this example, you give the Reader role to the managed identity for the Key Vault resource. For more information about role assignments, see [Manage Azure role assignments](/integrations/cloud/azure/role-assignments/).

# Docker integration

> Learn how to use the Aspire Docker hosting integration to deploy your app with Docker Compose.

![Docker logo](/_astro/docker.CnL-arqo_Z1NYjKL.svg)

The Aspire Docker hosting integration enables you to deploy your Aspire applications using Docker Compose. This integration models Docker Compose environments as compute resources that can host your application services. When you use this integration, Aspire generates Docker Compose files that define all the services, networks, and volumes needed to run your application in a containerized environment. It supports:

* Generating Docker Compose files from your app model for deployment
* Orchestrating multiple services, including an Aspire dashboard for telemetry visualization
* Configuring environment variables and service dependencies
* Managing container networking and service discovery

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Docker hosting integration is available in the [📦 Aspire.Hosting.Docker](https://www.nuget.org/packages/Aspire.Hosting.Docker) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Docker package

  ```bash
  aspire add docker
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > docker (Aspire.Hosting.Docker)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Docker@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Docker package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Docker" Version="*" />
  ```

### Add Docker Compose environment resource

[Section titled “Add Docker Compose environment resource”](#add-docker-compose-environment-resource)

The following example demonstrates how to add a Docker Compose environment to your app model using the `AddDockerComposeEnvironment` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var compose = builder.AddDockerComposeEnvironment("compose");


var cache = builder.AddRedis("cache")
                   .PublishAsDockerComposeService();


var api = builder.AddProject<Projects.Api>("api")
                 .WithReference(cache)
                 .PublishAsDockerComposeService();


var web = builder.AddProject<Projects.Web>("web")
                 .WithReference(cache)
                 .WithReference(api)
                 .PublishAsDockerComposeService();


builder.Build().Run();
```

The preceding code:

* Creates a Docker Compose environment named `compose`
* Adds a Redis cache service that will be included in the Docker Compose deployment
* Adds an API service project that will be containerized and included in the deployment
* Adds a web application that references both the cache and API service
* Configures all services to be published as Docker Compose services using `PublishAsDockerComposeService`

Tip

With the `compose` variable assigned, you can pass that to the `WithComputeEnvironment` API to disambiguate compute resources for solutions that define more than one. Otherwise, the `compose` variable isn’t required.

### Add Docker Compose environment resource with properties

[Section titled “Add Docker Compose environment resource with properties”](#add-docker-compose-environment-resource-with-properties)

You can configure various properties of the Docker Compose environment using the `WithProperties` method:

```csharp
builder.AddDockerComposeEnvironment("compose")
       .WithProperties(env =>
       {
           env.DashboardEnabled = true;
       });
```

The `DashboardEnabled` property determines whether to include an Aspire dashboard for telemetry visualization in this environment.

### Add Docker Compose environment resource with compose file

[Section titled “Add Docker Compose environment resource with compose file”](#add-docker-compose-environment-resource-with-compose-file)

You can customize the generated Docker Compose file using the `ConfigureComposeFile` method:

```csharp
builder.AddDockerComposeEnvironment("compose")
       .ConfigureComposeFile(composeFile =>
       {
           composeFile.Networks.Add("custom-network", new()
           {
               Driver = "bridge"
           });
       });
```

### Add Aspire dashboard resource to environment

[Section titled “Add Aspire dashboard resource to environment”](#add-aspire-dashboard-resource-to-environment)

The Docker hosting integration includes an Aspire dashboard for telemetry visualization. You can configure or disable it using the `WithDashboard` method:

```csharp
// Enable dashboard with custom configuration
builder.AddDockerComposeEnvironment("compose")
       .WithDashboard(dashboard =>
       {
           dashboard.WithHostPort(8080)
                    .WithForwardedHeaders(enabled: true);
       });


// Disable dashboard
builder.AddDockerComposeEnvironment("compose")
       .WithDashboard(enabled: false);
```

The `WithHostPort` method configures the port used to access the Aspire dashboard from a browser. The `WithForwardedHeaders` method enables forwarded headers processing when the dashboard is accessed through a reverse proxy or load balancer.

### Publishing and deployment

[Section titled “Publishing and deployment”](#publishing-and-deployment)

Aspire provides a progressive deployment workflow for Docker Compose, allowing you to publish, prepare environments, and deploy in separate steps or all at once.

#### Step 1: Publish the Application

[Section titled “Step 1: Publish the Application”](#step-1-publish-the-application)

To generate Docker Compose files and artifacts without building container images, use the `aspire publish` command:

```bash
aspire publish
```

This command:

* Generates a `docker-compose.yaml` from the app host
* Generates a `.env` file with expected parameters (unfilled)
* Outputs everything to the `aspire-output` directory

#### Step 2: Prepare Environment Configurations

[Section titled “Step 2: Prepare Environment Configurations”](#step-2-prepare-environment-configurations)

To prepare environment-specific configurations and build container images, use the `aspire do prepare-{resource-name}` command, where `{resouce-name}` is the name of the Docker Compose environment resource:

```bash
# For staging environment
aspire do prepare-compose --environment staging


# For production environment
aspire do prepare-compose --environment production
```

These commands:

* Generate a `docker-compose.yaml` from the app host
* Generate environment-specific `.env` files with filled-in values
* Generate container images
* Outputs everything to the `aspire-output` directory

#### Step 3: Deploy to Docker Compose

[Section titled “Step 3: Deploy to Docker Compose”](#step-3-deploy-to-docker-compose)

To perform the complete deployment workflow in one step, use the `aspire deploy` command:

```bash
aspire deploy
```

This command:

* Generates a `docker-compose.yaml` from the app host
* Generates environment-specific `.env` files with filled-in values
* Generates container images
* Outputs everything to the `aspire-output` directory
* Runs `docker compose up` against the generated files

#### Cleaning Up Deployment (Optional)

[Section titled “Cleaning Up Deployment (Optional)”](#cleaning-up-deployment-optional)

To clean up a running Docker Compose deployment, use the `aspire do docker-compose-down-{resource-name}` command:

```bash
aspire do docker-compose-down-compose
```

This command stops and removes all containers, networks, and volumes created by the Docker Compose deployment.

### Environment variables

[Section titled “Environment variables”](#environment-variables)

The Docker hosting integration captures environment variables from your app model and includes them in a `.env` file. This ensures that all configuration is properly passed to the containerized services.

#### Customize environment file

[Section titled “Customize environment file”](#customize-environment-file)

For advanced scenarios, use `ConfigureEnvFile` to customize the generated `.env` file:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddDockerComposeEnvironment("compose")
    .ConfigureEnvFile(env =>
    {
        env["CUSTOM_VAR"] = new CapturedEnvironmentVariable
        {
            Name = "CUSTOM_VAR",
            DefaultValue = "my-value"
        };
    });
```

This is useful when you need to add custom environment variables to the generated `.env` file or modify how environment variables are captured.

## Customize container image push options

[Section titled “Customize container image push options”](#customize-container-image-push-options)

When deploying containers, you can customize how container images are named and tagged when pushed to a registry. This is useful when you need to:

* Use different image names for different environments
* Apply custom tagging strategies (e.g., semantic versioning, Git commit hashes)
* Push to different registries or namespaces

### Set remote image name and tag

[Section titled “Set remote image name and tag”](#set-remote-image-name-and-tag)

Use `WithRemoteImageName` and `WithRemoteImageTag` to customize the image reference:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api")
    .PublishAsDockerComposeService()
    .WithRemoteImageName("myorg/myapi")
    .WithRemoteImageTag("v1.0.0");


// After adding all resources, run the app...
```

### Advanced customization with callbacks

[Section titled “Advanced customization with callbacks”](#advanced-customization-with-callbacks)

For more complex scenarios, use `WithImagePushOptions` to register a callback that can dynamically configure push options:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api")
    .PublishAsDockerComposeService()
    .WithImagePushOptions(context =>
    {
        // Customize the image name based on the resource
        // Note: Ensure resource names are valid for container image names
        var imageName = context.Resource.Name.ToLowerInvariant();
        context.Options.RemoteImageName = $"myorg/{imageName}";


        // Apply a custom tag based on environment or version
        var version = Environment.GetEnvironmentVariable("APP_VERSION") ?? "latest";
        context.Options.RemoteImageTag = version;
    });


// After adding all resources, run the app...
```

For asynchronous operations (such as retrieving configuration from external sources), use the async overload:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api")
    .PublishAsDockerComposeService()
    .WithImagePushOptions(async context =>
    {
        // Retrieve configuration asynchronously
        var config = await LoadConfigurationAsync();
        context.Options.RemoteImageName = config.ImageName;
        context.Options.RemoteImageTag = config.ImageTag;
    });


// After adding all resources, run the app...
```

Multiple callbacks can be registered on the same resource, and they will be invoked in the order they were added.

## Push images to container registries

[Section titled “Push images to container registries”](#push-images-to-container-registries)

You can configure your Aspire application to push container images to registries like GitHub Container Registry (GHCR), Docker Hub, or private registries using the `AddContainerRegistry` method.

Caution

The `AddContainerRegistry` API is experimental and may change in future releases. Use diagnostic code `ASPIRECOMPUTE003` to suppress the experimental warning. For more information, see [ASPIRECOMPUTE003](/diagnostics/aspirecompute003/).

### Configure a container registry

[Section titled “Configure a container registry”](#configure-a-container-registry)

Use the `AddContainerRegistry` method to define a container registry and the `WithContainerRegistry` method to associate resources with that registry:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a container registry
var registry = builder.AddContainerRegistry(
    "ghcr",                              // Registry name
    "ghcr.io",                           // Registry endpoint
    "your-github-username/your-repo"     // Repository path
);


// Associate resources with the registry
var api = builder.AddProject<Projects.Api>("api")
    .PublishAsDockerComposeService()
    .WithContainerRegistry(registry);


// After adding all resources, run the app...
```

For GitHub Container Registry, the registry endpoint is `ghcr.io` and the repository path typically follows the pattern `owner/repository`.

### Using parameters for registry configuration

[Section titled “Using parameters for registry configuration”](#using-parameters-for-registry-configuration)

For more flexible configuration, especially in CI/CD pipelines, you can use parameters with environment variables:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Define parameters from configuration (reads from environment variables)
var registryEndpoint = builder.AddParameterFromConfiguration("REGISTRY_ENDPOINT");
var registryRepository = builder.AddParameterFromConfiguration("REGISTRY_REPOSITORY");


// Add registry with parameters
var registry = builder.AddContainerRegistry(
    "my-registry",
    registryEndpoint,
    registryRepository
);


var api = builder.AddProject<Projects.Api>("api")
    .PublishAsDockerComposeService()
    .WithContainerRegistry(registry);
```

You can then provide parameter values via environment variables:

* Bash

  ```bash
  export REGISTRY_ENDPOINT=ghcr.io
  export REGISTRY_REPOSITORY=your-github-username/your-repo
  ```

* PowerShell

  ```powershell
  $env:REGISTRY_ENDPOINT = "ghcr.io"
  $env:REGISTRY_REPOSITORY = "your-github-username/your-repo"
  ```

### Push images with the Aspire CLI

[Section titled “Push images with the Aspire CLI”](#push-images-with-the-aspire-cli)

After configuring your container registry, use the `aspire do push` command to build and push your container images:

```bash
aspire do push
```

This command:

* Builds container images for all resources configured with a container registry
* Tags the images with the appropriate registry path
* Pushes the images to the specified registry

Before running this command, ensure you are authenticated to your container registry. For GitHub Container Registry:

```bash
echo $GITHUB_TOKEN | docker login ghcr.io -u your-github-username --password-stdin
```

### GitHub Actions workflow example

[Section titled “GitHub Actions workflow example”](#github-actions-workflow-example)

Here’s an example GitHub Actions workflow that builds and pushes images to GHCR:

YAML — .github/workflows/build-and-push.yml

```yaml
name: Build and Push Images


on:
  push:
    branches: [main]


jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write


    steps:
      - uses: actions/checkout@v4


      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'


      - name: Install Aspire CLI
        run: |
          curl -sSL https://aspire.dev/install.sh | bash
          echo "$HOME/.aspire/bin" >> $GITHUB_PATH


      - name: Output Aspire CLI version
        run: aspire --version


      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}


      - name: Build and push images
        env:
          REGISTRY_ENDPOINT: ghcr.io
          REGISTRY_REPOSITORY: ${{ github.repository }}
        run: aspire do push
```

This workflow:

* Checks out your code
* Sets up .NET and installs the Aspire CLI
* Authenticates to GHCR using the built-in `GITHUB_TOKEN`
* Builds and pushes container images using `aspire do push`

## See also

[Section titled “See also”](#see-also)

* [`Aspire.Hosting.Docker` API reference](https://learn.microsoft.com/dotnet/api/aspire.hosting.docker?view=dotnet-aspire-13.0)
* [Deploy your first Aspire app](/get-started/deploy-first-app/)
* [ASPIRECOMPUTE003 - Container registry resource](/diagnostics/aspirecompute003/)
* [What’s new in Aspire 13.1 - Container registry support](/whats-new/aspire-13-1/#container-registry-resource)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)
* [Working with GitHub Container Registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry)

# Kubernetes integration

> Learn how to add Kubernetes resources to your Aspire application.

![Kubernetes logo](/_astro/kubernetes.C_WJle_s_Z1NYjKL.svg)

The Aspire Kubernetes hosting integration enables you to generate Kubernetes deployment manifests from your Aspire application model. This integration allows you to define your application’s infrastructure and deployment configuration using the familiar Aspire AppHost and then publish it as Kubernetes YAML manifests for deployment to any Kubernetes cluster.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Kubernetes hosting integration, install the [📦 Aspire.Hosting.Kubernetes](https://www.nuget.org/packages/Aspire.Hosting.Kubernetes) NuGet package in the AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Kubernetes package

  ```bash
  aspire add kubernetes
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > kubernetes (Aspire.Hosting.Kubernetes)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Kubernetes@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Kubernetes package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Kubernetes" Version="*" />
  ```

## Add Kubernetes environment

[Section titled “Add Kubernetes environment”](#add-kubernetes-environment)

After installing the package, add a Kubernetes environment to your AppHost project using the `AddKubernetesEnvironment` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var k8s = builder.AddKubernetesEnvironment("k8s");


var api = builder.AddProject<Projects.MyApi>("api");


builder.Build().Run();
```

Tip

With the `k8s` variable assigned, you can pass that to the `WithComputeEnvironment` API to disambiguate compute resources for solutions that define more than one. Otherwise, the `k8s` variable isn’t required.

## Configure Kubernetes environment properties

[Section titled “Configure Kubernetes environment properties”](#configure-kubernetes-environment-properties)

You can customize the Kubernetes environment using the `WithProperties` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.MyApi>("api");


builder.AddKubernetesEnvironment("k8s")
       .WithProperties(k8s =>
       {
           k8s.HelmChartName = "my-aspire-app";
       });


builder.Build().Run();
```

The `WithProperties` method allows you to configure various aspects of the Kubernetes deployment, including the Helm chart name that will be used for generating the Kubernetes resources.

## Generate Kubernetes manifests

[Section titled “Generate Kubernetes manifests”](#generate-kubernetes-manifests)

To generate Kubernetes manifests from your Aspire application, use the `aspire publish` command:

```bash
aspire publish -o k8s-artifacts
```

This command generates a complete set of Kubernetes YAML manifests in the specified output directory (`k8s-artifacts` in this example). The generated artifacts include:

* **Deployments** or **StatefulSets** for your application services
* **Services** for network connectivity
* **ConfigMaps** for application configuration
* **Secrets** for sensitive data
* **Helm charts** for easier deployment management

## Supported resources

[Section titled “Supported resources”](#supported-resources)

The Kubernetes hosting integration supports converting various Aspire resources to their Kubernetes equivalents:

* **Project resources** → Deployments or StatefulSets
* **Container resources** → Deployments or StatefulSets
* **Connection strings** → ConfigMaps and Secrets
* **Environment variables** → ConfigMaps and Secrets
* **Endpoints** → Services and ingress configuration
* **Volumes** → PersistentVolumes and PersistentVolumeClaims

## Deployment considerations

[Section titled “Deployment considerations”](#deployment-considerations)

When deploying to Kubernetes, consider the following:

### Container images

[Section titled “Container images”](#container-images)

Ensure your application projects are configured to build container images. The Kubernetes publisher will reference the container images for your projects. If you haven’t specified custom container images, the integration will use parameterized Helm values that you can override during deployment.

### Resource names

[Section titled “Resource names”](#resource-names)

Resource names in Kubernetes must follow DNS naming conventions. The integration automatically converts Aspire resource names to valid Kubernetes resource names by:

* Converting to lowercase
* Replacing invalid characters with hyphens
* Ensuring names don’t start or end with hyphens

### Environment-specific configuration

[Section titled “Environment-specific configuration”](#environment-specific-configuration)

Use [external parameters](/fundamentals/external-parameters/) to configure environment-specific values that should be different between development and production environments.

## See also

[Section titled “See also”](#see-also)

* [Aspire GitHub repo](https://github.com/dotnet/aspire)
* [Kubernetes documentation](https://kubernetes.io/docs/)
* [Helm documentation](https://helm.sh/docs/)

# Create custom client integrations

> Learn how to create a custom Aspire client integration for an existing containerized application.

This article is a continuation of the [Create custom hosting integrations](/integrations/custom-integrations/hosting-integrations/) article. It guides you through creating an Aspire client integration that uses [MailKit](https://github.com/jstedfast/MailKit) to send emails. This integration is then added into the Newsletter app you previously built. The previous example omitted the creation of a client integration and instead relied on the existing .NET `SmtpClient`. It’s best to use MailKit’s `SmtpClient` over the official .NET `SmtpClient` for sending emails, as it’s more modern and supports more features/protocols. For more information, see [.NET SmtpClient: Remarks](https://learn.microsoft.com/dotnet/api/system.net.mail.smtpclient#remarks).

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

If you’re following along, you should have a Newsletter app from the steps in the [Create custom hosting integrations](/integrations/custom-integrations/hosting-integrations/) article.

Tip

This article is inspired by existing Aspire integrations, and based on the team’s official guidance. There are places where said guidance varies, and it’s important to understand the reasoning behind the differences. For more information, see [Aspire integration requirements](https://github.com/dotnet/aspire/blob/f38b6cba86942ad1c45fc04fe7170f0fd4ba7c0b/src/Components/Aspire_Components_Progress.md#net-aspire-integration-requirements).

## Create library for integration

[Section titled “Create library for integration”](#create-library-for-integration)

[Aspire integrations](/integrations/overview/) are delivered as NuGet packages, but in this example, it’s beyond the scope of this article to publish a NuGet package. Instead, you create a class library project that contains the integration and reference it as a project. Aspire integration packages are intended to wrap a client library, such as MailKit, and provide production-ready telemetry, health checks, configurability, and testability. Let’s start by creating a new class library project.

1. Create a new class library project named `MailKit.Client` in the same directory as the `MailDevResource.sln` from the previous article.

   .NET CLI

   ```bash
   dotnet new classlib -o MailKit.Client
   ```

2. Add the project to the solution.

   .NET CLI

   ```bash
   dotnet sln ./MailDevResource.sln add MailKit.Client/MailKit.Client.csproj
   ```

The next step is to add the following NuGet packages that the integration relies on. Add the following package references to your `MailKit.Client.csproj` file:

XML — MailKit.Client.csproj

```diff
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>


+  <ItemGroup>
+    <PackageReference Include="MailKit" Version="4.14.1" />
+    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.0" />
+    <PackageReference Include="Microsoft.Extensions.Resilience" Version="10.0.0" />
+    <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="10.0.0" />
+    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="10.0.0" />
+    <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.14.0" />
+  </ItemGroup>


</Project>
```

## Define integration settings

[Section titled “Define integration settings”](#define-integration-settings)

Whenever you’re creating an Aspire integration, it’s best to understand the client library that you’re mapping to. With MailKit, you need to understand the configuration settings that are required to connect to a Simple Mail Transfer Protocol (SMTP) server. But it’s also important to understand if the library has support for *health checks*, *tracing* and *metrics*. MailKit supports *tracing* and *metrics*, through its [`Telemetry.SmtpClient` class](https://github.com/jstedfast/MailKit/blob/master/MailKit/Telemetry.cs#L112-L189). When adding *health checks*, you should use any established or existing health checks where possible. Otherwise, you might consider implementing your own in the integration. Replace the `Class1.cs` file with the following code to the `MailKit.Client` project in rename it as `MailKitClientSettings.cs`:

C# — MailKitClientSettings.cs

```csharp
using System.Data.Common;


namespace MailKit.Client;


/// <summary>
/// Provides the client configuration settings for connecting MailKit to an SMTP server.
/// </summary>
public sealed class MailKitClientSettings
{
    internal const string DefaultConfigSectionName = "MailKit:Client";


    /// <summary>
    /// Gets or sets the SMTP server <see cref="Uri"/>.
    /// </summary>
    /// <value>
    /// The default value is <see langword="null"/>.
    /// </value>
    public Uri? Endpoint { get; set; }


    /// <summary>
    /// Gets or sets a boolean value that indicates whether the database health check is disabled or not.
    /// </summary>
    /// <value>
    /// The default value is <see langword="false"/>.
    /// </value>
    public bool DisableHealthChecks { get; set; }


    /// <summary>
    /// Gets or sets a boolean value that indicates whether the OpenTelemetry tracing is disabled or not.
    /// </summary>
    /// <value>
    /// The default value is <see langword="false"/>.
    /// </value>
    public bool DisableTracing { get; set; }


    /// <summary>
    /// Gets or sets a boolean value that indicates whether the OpenTelemetry metrics are disabled or not.
    /// </summary>
    /// <value>
    /// The default value is <see langword="false"/>.
    /// </value>
    public bool DisableMetrics { get; set; }


    internal void ParseConnectionString(string? connectionString)
    {
        if (string.IsNullOrWhiteSpace(connectionString))
        {
            throw new InvalidOperationException($"""
                ConnectionString is missing.
                It should be provided in 'ConnectionStrings:<connectionName>'
                or '{DefaultConfigSectionName}:Endpoint' key.'
                configuration section.
                """);
        }


        if (Uri.TryCreate(connectionString, UriKind.Absolute, out var uri))
        {
            Endpoint = uri;
        }
        else
        {
            var builder = new DbConnectionStringBuilder
            {
                ConnectionString = connectionString
            };


            if (builder.TryGetValue("Endpoint", out var endpoint) is false)
            {
                throw new InvalidOperationException($"""
                    The 'ConnectionStrings:<connectionName>' (or 'Endpoint' key in
                    '{DefaultConfigSectionName}') is missing.
                    """);
            }


            if (Uri.TryCreate(endpoint.ToString(), UriKind.Absolute, out uri) is false)
            {
                throw new InvalidOperationException($"""
                    The 'ConnectionStrings:<connectionName>' (or 'Endpoint' key in
                    '{DefaultConfigSectionName}') isn't a valid URI.
                    """);
            }


            Endpoint = uri;
        }
    }
}
```

The preceding code defines the `MailKitClientSettings` class with:

* `Endpoint` property that represents the connection string to the SMTP server.
* `DisableHealthChecks` property that determines whether health checks are enabled.
* `DisableTracing` property that determines whether tracing is enabled.
* `DisableMetrics` property that determines whether metrics are enabled.
* `Credentials` property for storing username and password credentials.

### Parse connection string logic

[Section titled “Parse connection string logic”](#parse-connection-string-logic)

The settings class also contains a `ParseConnectionString` method that parses the connection string into a valid `Uri`. The configuration is expected to be provided in the following format:

* `ConnectionStrings:<connectionName>`: The connection string to the SMTP server.
* `MailKit:Client:ConnectionString`: The connection string to the SMTP server.

If neither of these values are provided, an exception is thrown.

## Expose client functionality

[Section titled “Expose client functionality”](#expose-client-functionality)

The goal of Aspire integrations is to expose the underlying client library to consumers through dependency injection. With MailKit and for this example, the `SmtpClient` class is what you want to expose. You’re not wrapping any functionality, but rather mapping configuration settings to an `SmtpClient` class. It’s common to expose both standard and keyed-service registrations for integrations. Standard registrations are used when there’s only one instance of a service, and keyed-service registrations are used when there are multiple instances of a service. Sometimes, to achieve multiple registrations of the same type you use a factory pattern. Add the following code to the `MailKit.Client` project in a file named `MailKitClientFactory.cs`:

C# — MailKitClientFactory.cs

```csharp
using MailKit.Net.Smtp;


namespace MailKit.Client;


/// <summary>
/// A factory for creating <see cref="ISmtpClient"/> instances
/// given a <paramref name="smtpUri"/> (and optional <paramref name="credentials"/>).
/// </summary>
/// <param name="settings">
/// The <see cref="MailKitClientSettings"/> settings for the SMTP server
/// </param>
public sealed class MailKitClientFactory(MailKitClientSettings settings)
{
    /// <summary>
    /// Gets an <see cref="ISmtpClient"/> instance in the connected state
    /// (and that's been authenticated if configured).
    /// </summary>
    /// <param name="cancellationToken">Used to abort client creation and connection.</param>
    /// <returns>A connected (and authenticated) <see cref="ISmtpClient"/> instance.</returns>
    /// <remarks>
    /// Since both the connection and authentication are considered expensive operations,
    /// the <see cref="ISmtpClient"/> returned is intended to be used for the duration of a request
    /// (registered as 'Scoped') and is automatically disposed of.
    /// </remarks>
    public async Task<ISmtpClient> GetSmtpClientAsync(
        CancellationToken cancellationToken = default)
    {
        var client = new SmtpClient();
        try
        {
            if (settings.Endpoint is not null)
            {
                await client.ConnectAsync(settings.Endpoint, cancellationToken)
                    .ConfigureAwait(false);
            }


            return client;
        }
        catch
        {
            await client.DisconnectAsync(true, cancellationToken);
            client.Dispose();
            throw;
        }
    }
}
```

The `MailKitClientFactory` class is a factory that creates an `ISmtpClient` instance based on the configuration settings. It’s responsible for returning an `ISmtpClient` implementation that has an active connection to a configured SMTP server. Next, you need to expose the functionality for the consumers to register this factory with the dependency injection container. Add the following code to the `MailKit.Client` project in a file named `MailKitExtensions.cs`:

C# — MailKitExtensions.cs

```csharp
using MailKit;
using MailKit.Client;
using MailKit.Net.Smtp;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;


namespace Microsoft.Extensions.Hosting;


/// <summary>
/// Provides extension methods for registering a <see cref="SmtpClient"/> as a
/// scoped-lifetime service in the services provided by the <see cref="IHostApplicationBuilder"/>.
/// </summary>
public static class MailKitExtensions
{
    /// <summary>
    /// Registers 'Scoped' <see cref="MailKitClientFactory" /> for creating
    /// connected <see cref="SmtpClient"/> instance for sending emails.
    /// </summary>
    /// <param name="builder">
    /// The <see cref="IHostApplicationBuilder" /> to read config from and add services to.
    /// </param>
    /// <param name="connectionName">
    /// A name used to retrieve the connection string from the ConnectionStrings configuration section.
    /// </param>
    /// <param name="configureSettings">
    /// An optional delegate that can be used for customizing options.
    /// It's invoked after the settings are read from the configuration.
    /// </param>
    public static void AddMailKitClient(
        this IHostApplicationBuilder builder,
        string connectionName,
        Action<MailKitClientSettings>? configureSettings = null) =>
        AddMailKitClient(
            builder,
            MailKitClientSettings.DefaultConfigSectionName,
            configureSettings,
            connectionName,
            serviceKey: null);


    /// <summary>
    /// Registers 'Scoped' <see cref="MailKitClientFactory" /> for creating
    /// connected <see cref="SmtpClient"/> instance for sending emails.
    /// </summary>
    /// <param name="builder">
    /// The <see cref="IHostApplicationBuilder" /> to read config from and add services to.
    /// </param>
    /// <param name="name">
    /// The name of the component, which is used as the <see cref="ServiceDescriptor.ServiceKey"/> of the
    /// service and also to retrieve the connection string from the ConnectionStrings configuration section.
    /// </param>
    /// <param name="configureSettings">
    /// An optional method that can be used for customizing options. It's invoked after the settings are
    /// read from the configuration.
    /// </param>
    public static void AddKeyedMailKitClient(
        this IHostApplicationBuilder builder,
        string name,
        Action<MailKitClientSettings>? configureSettings = null)
    {
        ArgumentNullException.ThrowIfNull(name);


        AddMailKitClient(
            builder,
            $"{MailKitClientSettings.DefaultConfigSectionName}:{name}",
            configureSettings,
            connectionName: name,
            serviceKey: name);
    }


    private static void AddMailKitClient(
        this IHostApplicationBuilder builder,
        string configurationSectionName,
        Action<MailKitClientSettings>? configureSettings,
        string connectionName,
        object? serviceKey)
    {
        ArgumentNullException.ThrowIfNull(builder);


        var settings = new MailKitClientSettings();


        builder.Configuration
               .GetSection(configurationSectionName)
               .Bind(settings);


        if (builder.Configuration.GetConnectionString(connectionName) is string connectionString)
        {
            settings.ParseConnectionString(connectionString);
        }


        configureSettings?.Invoke(settings);


        if (serviceKey is null)
        {
            builder.Services.AddScoped(CreateMailKitClientFactory);
        }
        else
        {
            builder.Services.AddKeyedScoped(serviceKey, (sp, key) => CreateMailKitClientFactory(sp));
        }


        MailKitClientFactory CreateMailKitClientFactory(IServiceProvider _)
        {
            return new MailKitClientFactory(settings);
        }


        if (settings.DisableHealthChecks is false)
        {
            builder.Services.AddHealthChecks()
                .AddCheck<MailKitHealthCheck>(
                    name: serviceKey is null ? "MailKit" : $"MailKit_{connectionName}",
                    failureStatus: default,
                    tags: []);
        }


        if (settings.DisableTracing is false)
        {
            builder.Services.AddOpenTelemetry()
                .WithTracing(
                    traceBuilder => traceBuilder.AddSource(
                        Telemetry.SmtpClient.ActivitySourceName));
        }


        if (settings.DisableMetrics is false)
        {
            // Required by MailKit to enable metrics
            Telemetry.SmtpClient.Configure();


            builder.Services.AddOpenTelemetry()
                .WithMetrics(
                    metricsBuilder => metricsBuilder.AddMeter(
                        Telemetry.SmtpClient.MeterName));
        }
    }
}
```

The preceding code adds two extension methods on the `IHostApplicationBuilder` type, one for the standard registration of MailKit and another for keyed-registration of MailKit.

Tip

Extension methods for Aspire integrations should extend the `IHostApplicationBuilder` type and follow the `Add<MeaningfulName>` naming convention where the `<MeaningfulName>` is the type or functionality you’re adding. For this article, the `AddMailKitClient` extension method is used to add the MailKit client. It’s likely more in-line with the official guidance to use `AddMailKitSmtpClient` instead of `AddMailKitClient`, since this only registers the `SmtpClient` and not the entire MailKit library.

Both extensions ultimately rely on the private `AddMailKitClient` method to register the `MailKitClientFactory` with the dependency injection container as a [scoped service](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#scoped). The reason for registering the `MailKitClientFactory` as a scoped service is because the connection operations are considered expensive and should be reused within the same scope where possible. In other words, for a single request, the same `ISmtpClient` instance should be used. The factory holds on to the instance of the `SmtpClient` that it creates and disposes of it.

### Configuration binding

[Section titled “Configuration binding”](#configuration-binding)

One of the first things that the private implementation of the `AddMailKitClient` methods does, is to bind the configuration settings to the `MailKitClientSettings` class. The settings class is instantiated and then binding is performed with the specific section of configuration. Then the optional `configureSettings` delegate is invoked with the current settings. This allows the consumer to further configure the settings, ensuring that manual code settings are honored over configuration settings. After that, depending on whether the `serviceKey` value was provided, the `MailKitClientFactory` should be registered with the dependency injection container as either a standard or keyed service.

Caution

It’s intentional that the `implementationFactory` overload is called when registering services. The `CreateMailKitClientFactory` method throws when the configuration is invalid. This ensures that creation of the `MailKitClientFactory` is deferred until it’s needed and it prevents the app from erroring out before logging is available.

The registration of health checks, and telemetry are described in a bit more detail in the following sections.

### Add health checks

[Section titled “Add health checks”](#add-health-checks)

[Health checks](/fundamentals/health-checks/) are a way to monitor the health of an integration. With MailKit, you can check if the connection to the SMTP server is healthy. Add the following code to the `MailKit.Client` project in a file named `MailKitHealthCheck.cs`:

C# — MailKitHealthCheck.cs

```csharp
using Microsoft.Extensions.Diagnostics.HealthChecks;


namespace MailKit.Client;


internal sealed class MailKitHealthCheck(MailKitClientFactory factory) : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        try
        {
            // The factory connects (and authenticates).
            _ = await factory.GetSmtpClientAsync(cancellationToken);


            return HealthCheckResult.Healthy();
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy(exception: ex);
        }
    }
}
```

The preceding health check implementation:

1. Implements the `IHealthCheck` interface.

2. Accepts the `MailKitClientFactory` as a primary constructor parameter.

3. Satisfies the `CheckHealthAsync` method by:

   * Attempting to get an `ISmtpClient` instance from the `factory`. If successful, it returns `HealthCheckResult.Healthy`.
   * If an exception is thrown, it returns `HealthCheckResult.Unhealthy`.

As previously shared in the registration of the `MailKitClientFactory`, the `MailKitHealthCheck` is conditionally registered with the `IHeathChecksBuilder`:

```csharp
if (settings.DisableHealthChecks is false)
{
    builder.Services.AddHealthChecks()
        .AddCheck<MailKitHealthCheck>(
            name: serviceKey is null ? "MailKit" : $"MailKit_{connectionName}",
            failureStatus: default,
            tags: []);
}
```

The consumer could choose to omit health checks by setting the `DisableHealthChecks` property to `true` in the configuration. A common pattern for integrations is to have optional features and Aspire integrations strongly encourages these types of configurations. For more information on health checks and a working sample that includes a user interface, see [Aspire ASP.NET Core HealthChecksUI sample](https://github.com/dotnet/aspire-samples/tree/main/samples/health-checks-ui).

### Wire up telemetry

[Section titled “Wire up telemetry”](#wire-up-telemetry)

As a best practice, the [MailKit client library exposes telemetry](https://github.com/jstedfast/MailKit/blob/master/Telemetry.md). Aspire can take advantage of this telemetry and display it in the [Aspire dashboard](/dashboard/overview/). Depending on whether or not tracing and metrics are enabled, telemetry is wired up as shown in the following code snippet:

```csharp
if (settings.DisableTracing is false)
{
    builder.Services.AddOpenTelemetry()
        .WithTracing(
            traceBuilder => traceBuilder.AddSource(
                SmtpClient.ActivitySourceName));
}


if (settings.DisableMetrics is false)
{
    // Required by MailKit to enable metrics
    SmtpClient.Configure();


    builder.Services.AddOpenTelemetry()
        .WithMetrics(
            metricsBuilder => metricsBuilder.AddMeter(
                SmtpClient.MeterName));
}
```

## Update the Newsletter service

[Section titled “Update the Newsletter service”](#update-the-newsletter-service)

With the integration library created, you can now update the Newsletter service to use the MailKit client. The first step is to add a reference to the `MailKit.Client` project. Add the `MailKit.Client.csproj` project reference to the `MailDevResource.NewsletterService` project:

.NET CLI

```bash
dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailKit.Client/MailKit.Client.csproj
```

Next, add a reference to the `ServiceDefaults` project:

.NET CLI

```bash
dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference MailDevResource.ServiceDefaults/MailDevResource.ServiceDefaults.csproj
```

To make it easier to test the endpoints, add Scalar for a pleasant HTTP request user experience. Add the following NuGet package to the `MailDevResource.NewsletterService` project:

.NET CLI

```bash
dotnet add package Scalar.AspNetCore --project ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj
```

The final step is to replace the existing `Program.cs` file in the `MailDevResource.NewsletterService` project with the following C# code:

C# — Program.cs

```csharp
using System.Net.Mail;
using MailKit.Client;
using MailKit.Net.Smtp;
using MimeKit;
using Scalar.AspNetCore;


var builder = WebApplication.CreateBuilder(args);


builder.AddServiceDefaults();


builder.Services.AddOpenApi();


// Add services to the container.
builder.AddMailKitClient("maildev");


var app = builder.Build();


if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    app.MapScalarApiReference();
}


app.MapDefaultEndpoints();


// Configure the HTTP request pipeline.
app.UseHttpsRedirection();


app.MapPost("/subscribe",
    async (MailKitClientFactory factory, string email) =>
{
    ISmtpClient client = await factory.GetSmtpClientAsync();


    using var message = new MailMessage("newsletter@yourcompany.com", email)
    {
        Subject = "Welcome to our newsletter!",
        Body = "Thank you for subscribing to our newsletter!"
    };


    await client.SendAsync(MimeMessage.CreateFromMailMessage(message));
});


app.MapPost("/unsubscribe",
    async (MailKitClientFactory factory, string email) =>
{
    ISmtpClient client = await factory.GetSmtpClientAsync();


    using var message = new MailMessage("newsletter@yourcompany.com", email)
    {
        Subject = "You are unsubscribed from our newsletter!",
        Body = "Sorry to see you go. We hope you will come back soon!"
    };


    await client.SendAsync(MimeMessage.CreateFromMailMessage(message));
});


app.Run();
```

The most notable changes in the preceding code are:

1. The updated `using` statements that include the `MailKit.Client`, `MailKit.Net.Smtp`, `MimeKit`, and `Scalar.AspNetCore` namespaces.
2. The replacement of the registration for the official .NET `SmtpClient` with the call to the `AddMailKitClient` extension method.
3. The replacement of both `/subscribe` and `/unsubscribe` map post calls to instead inject the `MailKitClientFactory` and use the `ISmtpClient` instance to send the email.

Back in the `AppHost.cs` file, update it to configure the scalar API reference endpoint:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var maildev = builder.AddMailDev("maildev");


builder.AddProject<Projects.MailDevResource_NewsletterService>("newsletterservice")
    .WithUrlForEndpoint("https", e =>
    {
        e.DisplayText = "Scalar";
        e.Url += "/scalar";
    })
    .WithReference(maildev);


builder.Build().Run();
```

## Run the sample

[Section titled “Run the sample”](#run-the-sample)

Now that you’ve created the MailKit client integration and updated the Newsletter service to use it, you can run the sample. From your IDE, select F5 `F5` F5 `F5` F5 `F5` or run `aspire run` from the root directory of the solution to start the application—you should see the [Aspire dashboard](/dashboard/overview/):

![Aspire dashboard: MailDev and Newsletter resources running.](/_astro/maildev-with-newsletterservice-dashboard.Hpf34D_n.png)

Once the application is running, navigate to the Scalar UI by seleting the added Scalar link from the dashboard on the `newsletterservice` resource and test the `/subscribe` and `/unsubscribe` endpoints. Select the down arrow to expand the endpoint:

![Scalar UI: Subscribe endpoint.](/_astro/scalar-ui.qTPNQre4.png)

Then select the `Try it out` button. Enter an email address, and then select the `Execute` button.

![Scalar UI: Subscribe endpoint with email address.](/_astro/scalar-ui-try.D9Cqurs_.png)

Repeat this several times, to add multiple email addresses. You should see the email sent to the MailDev inbox:

![MailDev inbox with multiple emails.](/_astro/maildev-emails.DELI8Svw.png)

Stop the application by selecting Command + C `CommandC` Control + C `ControlC` Control + C `ControlC` in the terminal window where the application is running, or by selecting the stop button in your IDE.

### View MailKit telemetry

[Section titled “View MailKit telemetry”](#view-mailkit-telemetry)

The MailKit client library exposes telemetry that can be viewed in the Aspire dashboard. To view the telemetry, navigate to the Aspire dashboard. Select the `newsletter` resource to view the telemetry on the **Metrics** page:

![Aspire dashboard: MailKit telemetry.](/_astro/mailkit-metrics-dashboard.DOud8f__.png)

Open up the Scalar UI again, and make some requests to the `/subscribe` and `/unsubscribe` endpoints. Then, navigate back to the Aspire dashboard and select the `newsletter` resource. Select a metric under the **mailkit.net.smtp** node, such as `mailkit.net.smtp.client.operation.count`. You should see the telemetry for the MailKit client:

![Aspire dashboard: MailKit telemetry for operation count.](/_astro/mailkit-metrics-graph-dashboard.BlBNXU0g.png)

## Summary

[Section titled “Summary”](#summary)

In this article, you learned how to create an Aspire integration that uses MailKit to send emails. You also learned how to integrate this integration into the Newsletter app you previously built. You learned about the core principles of Aspire integrations, such as exposing the underlying client library to consumers through dependency injection, and how to add health checks and telemetry to the integration. You also learned how to update the Newsletter service to use the MailKit client.

Go forth and build your own Aspire integrations. If you believe that there’s enough community value in the integration you’re building, consider publishing it as a [NuGet package](https://learn.microsoft.com/dotnet/standard/library-guidance/nuget) for others to use. Furthermore, consider submitting a pull request to the [Aspire GitHub repository](https://github.com/dotnet/aspire) for consideration to be included in the official Aspire integrations.

## Next steps

[Section titled “Next steps”](#next-steps)

* [Secure communication between integrations](/integrations/custom-integrations/secure-communication/)

# Create custom hosting integrations

> Learn how to create a custom Aspire hosting integration for an existing containerized application.

Aspire improves the development experience by providing reusable building blocks that can be used to quickly arrange application dependencies and expose them to your own code. One of the key building blocks of an Aspire-based application is the *resource*.

Consider the code below:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var redis = builder.AddRedis("cache");


var db = builder.AddPostgres("pgserver")
    .AddDatabase("inventorydb");


builder.AddProject<Projects.InventoryService>("inventoryservice")
    .WithReference(redis)
    .WithReference(db);
```

In the preceding code there are four resources represented:

1. `cache`: A Redis container.
2. `pgserver`: A Postgres container.
3. `inventorydb`: A database hosted on `pgserver`.
4. `inventoryservice`: An ASP.NET Core application.

Most Aspire-related code that the average developer writes, centers around adding resources to the [app model](/get-started/app-host/) and creating references between them.

## Key elements of a custom resource

[Section titled “Key elements of a custom resource”](#key-elements-of-a-custom-resource)

Building a custom resource in Aspire requires the following:

1. A custom resource type that implements `IResource`
2. An extension method for `IDistributedApplicationBuilder` named `Add{CustomResource}` where `{CustomResource}` is the name of the custom resource.

When custom resource requires optional configuration, developers may wish to implement `With*` suffixed extension methods to make these configuration options discoverable using the *builder pattern*.

## A practical example: MailDev

[Section titled “A practical example: MailDev”](#a-practical-example-maildev)

To help understand how to develop custom resources, this article shows an example of how to build a custom resource for [MailDev](https://maildev.github.io/maildev/). MailDev is an open-source tool which provides a local mail server designed to allow developers to test e-mail sending behaviors within their app. For more information, see [the MailDev GitHub repository](https://github.com/maildev/maildev).

In this example you create a new Aspire project as a test environment for the MailDev resource that you create. While you can create custom resources in existing Aspire projects it’s a good idea to consider whether the custom resource might be used across multiple Aspire-based solutions and should be developed as a reusable integration.

## Set up the starter project

[Section titled “Set up the starter project”](#set-up-the-starter-project)

Create a new Aspire project that is used to test out the new resource that we’re developing.

Aspire CLI — Create new Aspire project

```bash
dotnet new aspire -o MailDevResource
```

[Command reference: `aspire new`](/reference/cli/commands/aspire-new/)

1. When prompted to select a template, choose the **AppHost and service defaults** template — use the Up Arrow `↑` Up Arrow `↑` Up Arrow `↑` and Down Arrow `↓` Down Arrow `↓` Down Arrow `↓` keys to navigate the options. Press Return `Return` Enter `Enter` Enter `Enter` to select the template.

2. Enter a project name, in this example use `MailDevResource`, then press Return `Return` Enter `Enter` Enter `Enter` to continue.

3. Finally, use the Up Arrow `↑` Up Arrow `↑` Up Arrow `↑` and Down Arrow `↓` Down Arrow `↓` Down Arrow `↓` keys to navigate to the desired template version. This example uses 13.1.0.

Change directory

```bash
cd MailDevResource
```

Once the project is created, you should see a listing containing the following:

* `MailDevResource.AppHost`: The [AppHost](/get-started/app-host/) used to test out the custom resource.
* `MailDevResource.ServiceDefaults`: The [service defaults](/fundamentals/service-defaults/) project for use in service-related projects.
* `MailDevResource.sln`: The solution file referencing both projects.

Verify that the project can build and run successfully by executing the following command:

Aspire CLI — run

```bash
aspire run
```

[Command reference: `aspire run`](/reference/cli/commands/aspire-run/)

The console output should look similar to the following:

Aspire CLI — run example output

```bash
🔍  Finding apphosts...
MailDevResource.AppHost\MailDevResource.AppHost.csproj


🗄  Created settings file at '.aspire/settings.json'.


     AppHost:  MailDevResource.AppHost\MailDevResource.AppHost.csproj


   Dashboard:  https://localhost:17099/login?t=11e860924357145f02153fe9eb81f1ab


        Logs:  %USERPROFILE%\.aspire\cli\logs\apphost-24232-2025-12-03-16-34-36.log


               Press CTRL+C to stop the apphost and exit.
```

Select the dashboard link in the browser to see the Aspire dashboard:

![A screenshot of the empty Aspire dashboard for test project.](/_astro/maildevresource-empty-dashboard.wU611G37.png)

Press Command + C `CommandC` Control + C `ControlC` Control + C `ControlC` to shut down the app (you can close the browser tab).

## Create library for resource extension

[Section titled “Create library for resource extension”](#create-library-for-resource-extension)

Aspire resources are just classes and methods contained within a class library that references the Aspire Hosting library (`Aspire.Hosting`). By placing the resource in a separate project, you can more easily share it between Aspire-based apps and potentially package and share it on NuGet.

1. Create the class library project named `MailDev.Hosting`.

   .NET CLI

   ```bash
   dotnet new classlib -o MailDev.Hosting
   ```

2. Add `Aspire.Hosting` to the class library as a package reference.

   .NET CLI

   ```bash
   dotnet add ./MailDev.Hosting/MailDev.Hosting.csproj package Aspire.Hosting --version 13.1.0
   ```

   Note

   The version you specify here should match the Aspire SDK version used in your solution.

3. Add class library reference to the `MailDevResource.AppHost` project.

   .NET CLI

   ```bash
   dotnet add ./MailDevResource.AppHost/MailDevResource.AppHost.csproj reference ./MailDev.Hosting/MailDev.Hosting.csproj
   ```

4. Add class library project to the solution file.

   .NET CLI

   ```bash
   dotnet sln ./MailDevResource.sln add ./MailDev.Hosting/MailDev.Hosting.csproj
   ```

Once the following steps are performed, update the project reference in the `MailDevResource.AppHost.csproj` file to include an additional attribute to suppress a warning that appears when launching the AppHost. To tell Aspire that the project reference should be treated as a nonservice project modify the `MailDevResource.AppHost.csproj` file’s reference to the `MailDev.Hosting` project to be the following:

XML — MailDevResource.AppHost.csproj

```xml
<ItemGroup>
  <!-- The IsAspireProjectResource attribute tells Aspire to treat this
       reference as a standard project reference and not attempt to generate
       a metadata file -->
  <ProjectReference Include="..\MailDev.Hosting\MailDev.Hosting.csproj"
                    IsAspireProjectResource="false" />
</ItemGroup>
```

This is because Aspire treats project references in the AppHost as if they’re service projects.

## Define the resource types

[Section titled “Define the resource types”](#define-the-resource-types)

The `MailDev.Hosting` class library contains the resource type and extension methods for adding the resource to the AppHost. You should first think about the experience that you want to give developers when using your custom resource. In the case of this custom resource, you would want developers to be able to write code like the following:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var maildev = builder.AddMailDev("maildev");


builder.AddProject<Projects.NewsletterService>("newsletterservice")
    .WithReference(maildev);
```

To achieve this, you need a custom resource named `MailDevResource` which implements `IResourceWithConnectionString` so that consumers can use it with the `WithReference` extension to inject the connection details for the MailDev server as a connection string.

MailDev is available as a container resource, so you’ll also want to derive from `ContainerResource` so that we can make use of various pre-existing container-focused extensions in Aspire.

Replace the contents of the `Class1.cs` file in the `MailDev.Hosting` project, and rename the file to `MailDevResource.cs` with the following code:

C# — MailDevResource.cs

```csharp
// For ease of discovery, resource types should be placed in
// the Aspire.Hosting.ApplicationModel namespace. If there is
// likelihood of a conflict on the resource name consider using
// an alternative namespace.
namespace Aspire.Hosting.ApplicationModel;


public sealed class MailDevResource(string name)
    : ContainerResource(name), IResourceWithConnectionString
{
    // Constants used to refer to well known-endpoint names, this is specific
    // for each resource type. MailDev exposes an SMTP endpoint and a HTTP
    // endpoint.
    internal const string SmtpEndpointName = "smtp";
    internal const string HttpEndpointName = "http";


    // An EndpointReference is a core Aspire type used for keeping
    // track of endpoint details in expressions. Simple literal values cannot
    // be used because endpoints are not known until containers are launched.
    private EndpointReference? _smtpReference;


    public EndpointReference SmtpEndpoint =>
        _smtpReference ??= new(this, SmtpEndpointName);


    // Required property on IResourceWithConnectionString. Represents a connection
    // string that applications can use to access the MailDev server. In this case
    // the connection string is composed of the SmtpEndpoint endpoint reference.
    public ReferenceExpression ConnectionStringExpression =>
        ReferenceExpression.Create(
            $"smtp://{SmtpEndpoint.Property(EndpointProperty.HostAndPort)}"
        );
}
```

In the preceding custom resource, the `EndpointReference` and `ReferenceExpression` are examples of several types which implement a collection of interfaces, such as `IManifestExpressionProvider`, `IValueProvider`, and `IValueWithReferences`. For more information about these types and their role in Aspire, see the [technical details section](#technical-details).

## Define the resource extensions

[Section titled “Define the resource extensions”](#define-the-resource-extensions)

To make it easy for developers to use the custom resource an extension method named `AddMailDev` needs to be added to the `MailDev.Hosting` project. The `AddMailDev` extension method is responsible for configuring the resource so it can start successfully as a container.

Add the following code to a new file named `MailDevResourceBuilderExtensions.cs` in the `MailDev.Hosting` project:

C# — MailDevResourceBuilderExtensions.cs

```csharp
using Aspire.Hosting.ApplicationModel;


// Put extensions in the Aspire.Hosting namespace to ease discovery as referencing
// the Aspire hosting package automatically adds this namespace.
namespace Aspire.Hosting;


public static class MailDevResourceBuilderExtensions
{
    /// <summary>
    /// Adds the <see cref="MailDevResource"/> to the given
    /// <paramref name="builder"/> instance. Uses the "2.2.1" tag.
    /// </summary>
    /// <param name="builder">The <see cref="IDistributedApplicationBuilder"/>.</param>
    /// <param name="name">The name of the resource.</param>
    /// <param name="httpPort">The HTTP port.</param>
    /// <param name="smtpPort">The SMTP port.</param>
    /// <returns>
    /// An <see cref="IResourceBuilder{MailDevResource}"/> instance that
    /// represents the added MailDev resource.
    /// </returns>
    public static IResourceBuilder<MailDevResource> AddMailDev(
        this IDistributedApplicationBuilder builder,
        string name,
        int? httpPort = null,
        int? smtpPort = null)
    {
        // The AddResource method is a core API within Aspire and is
        // used by resource developers to wrap a custom resource in an
        // IResourceBuilder<T> instance. Extension methods to customize
        // the resource (if any exist) target the builder interface.
        var resource = new MailDevResource(name);


        return builder.AddResource(resource)
                      .WithImage(MailDevContainerImageTags.Image)
                      .WithImageRegistry(MailDevContainerImageTags.Registry)
                      .WithImageTag(MailDevContainerImageTags.Tag)
                      .WithHttpEndpoint(
                          targetPort: 1080,
                          port: httpPort,
                          name: MailDevResource.HttpEndpointName)
                      .WithEndpoint(
                          targetPort: 1025,
                          port: smtpPort,
                          name: MailDevResource.SmtpEndpointName);
    }
}


// This class just contains constant strings that can be updated periodically
// when new versions of the underlying container are released.
internal static class MailDevContainerImageTags
{
    internal const string Registry = "docker.io";


    internal const string Image = "maildev/maildev";


    internal const string Tag = "2.2.1";
}
```

Tip

This example uses MailDev version 2.2.1. Be sure to check the [MailDev Docker Hub page](https://hub.docker.com/r/maildev/maildev/tags) for the latest version and update the `Tag` constant accordingly.

## Validate custom integration inside the AppHost

[Section titled “Validate custom integration inside the AppHost”](#validate-custom-integration-inside-the-apphost)

Now that the basic structure for the custom resource is complete it’s time to test it in a real AppHost project. Open the `AppHost.cs` file in the `MailDevResource.AppHost` project and update it with the following code:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var maildev = builder.AddMailDev("maildev");


builder.Build().Run();
```

After updating the `AppHost.cs` file, launch the AppHost project and open the dashboard:

Aspire CLI — run

```bash
aspire run
```

After a few moments the dashboard shows that the `maildev` resource is running and a hyperlink will be available that navigates to the MailDev web app, which shows the content of each e-mail that your app sends.

*The Aspire dashboard should look similar to the following:*

![MailDev resource visible in Aspire dashboard.](/_astro/maildev-in-aspire-dashboard.DREPhLNa.png)

*The MailDev web app should look similar to the following:*

![MailDev web-based user interface running as a container managed by Aspire.](/_astro/maildev-web-ui.-9ZgPmXN.png)

## Add a .NET service project to the AppHost for testing

[Section titled “Add a .NET service project to the AppHost for testing”](#add-a-net-service-project-to-the-apphost-for-testing)

Once Aspire can successfully launch the MailDev integration, it’s time to consume the connection information for MailDev within a .NET project. In Aspire it’s common for there to be a *hosting package* and one or more *component packages*. For example consider:

* **Hosting package**: Used to represent resources within the app model.
  * `Aspire.Hosting.Redis`

* **Component packages**: Used to configure and consume client libraries.

  * `Aspire.StackExchange.Redis`
  * `Aspire.StackExchange.Redis.DistributedCaching`
  * `Aspire.StackExchange.Redis.OutputCaching`

In the case of the MailDev resource, the .NET platform already has a simple mail transfer protocol (SMTP) client in the form of `SmtpClient`. In this example you use this existing API for the sake of simplicity, although other resource types may benefit from custom integration libraries to assist developers.

In order to test the end-to-end scenario, you need a .NET project which we can inject the connection information into for the MailDev resource. Add a Web API project:

1. Create a new .NET project named `MailDevResource.NewsletterService`.

   .NET CLI

   ```bash
   dotnet new webapi --use-minimal-apis -o MailDevResource.NewsletterService
   ```

2. Add a reference to the `MailDev.Hosting` project.

   .NET CLI

   ```bash
   dotnet add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj reference ./MailDev.Hosting/MailDev.Hosting.csproj
   ```

3. Add a reference to the `MailDevResource.AppHost` project.

   .NET CLI

   ```bash
   dotnet add ./MailDevResource.AppHost/MailDevResource.AppHost.csproj reference ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj
   ```

4. Add the new project to the solution file.

   .NET CLI

   ```bash
   dotnet sln ./MailDevResource.sln add ./MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj
   ```

After the project has been added and references have been updated, open the `AppHost.cs` of the `MailDevResource.AppHost.csproj` project, and update the source file to look like the following:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var maildev = builder.AddMailDev("maildev");


builder.AddProject<Projects.MailDevResource_NewsletterService>("newsletterservice")
    .WithReference(maildev);


builder.Build().Run();
```

After updating the `AppHost.cs` file, launch the AppHost again. Then verify that the Newsletter Service started and that the environment variable `ConnectionStrings__maildev` was added to the process. From the **Resources** page, find the `newsletterservice` row, and select the **…** button on the **Actions** column, then select **View details**. In the **Environment Variables** section, you should see the following:

![Environment variables for Newsletter Service in Aspire Dashboard.](/_astro/maildev-envvar.Ca6c7Nz2.png)

The preceding screenshot shows the environment variables for the `newsletterservice` project. The `ConnectionStrings__maildev` environment variable is the connection string that was injected into the project by the `maildev` resource.

## Use connection string to send messages

[Section titled “Use connection string to send messages”](#use-connection-string-to-send-messages)

To use the SMTP connection details that were injected into the newsletter service project, you inject an instance of `SmtpClient` into the dependency injection container as a singleton. Add the following code to the `Program.cs` file in the `MailDevResource.NewsletterService` project to set up the singleton service. In the `Program` class, immediately following the `// Add services to the container` comment, add the following code:

C# — Program.cs

```csharp
builder.Services.AddSingleton<SmtpClient>(serviceProvider =>
{
    var connectionString = builder.Configuration.GetConnectionString("maildev");
    var uri = new Uri(connectionString ?? "smtp://localhost:1025");


    return new SmtpClient(uri.Host, uri.Port);
});
```

Caution

This code snippet relies on the official `SmtpClient`, however; this type is obsolete on some platforms and not recommended on others. For a more modern approach using [MailKit](https://github.com/jstedfast/MailKit), see [Create custom Aspire client integrations](/integrations/custom-integrations/client-integrations/).

To test the client, add two simple `subscribe` and `unsubscribe` POST methods to the newsletter service. Add the following code replacing the “weatherforecast” `MapGet` call in the `Program.cs` file of the `MailDevResource.NewsletterService` project to set up the ASP.NET Core routes:

C# — Program.cs

```csharp
app.MapPost("/subscribe", async (string email, SmtpClient client) =>
{
    var message = new MailMessage("noreply@newsletter.local", email)
    {
        Subject = "Welcome to the newsletter!",
        Body = "Welcome! You've subscribed to the newsletter."
    };


    await client.SendMailAsync(message);


    return Results.Ok("Subscribed");
});


app.MapPost("/unsubscribe", async (string email, SmtpClient client) =>
{
    var message = new MailMessage("noreply@newsletter.local", email)
    {
        Subject = "Goodbye from the newsletter",
        Body = "You have been unsubscribed from the newsletter."
    };


    await client.SendMailAsync(message);


    return Results.Ok("Unsubscribed");
});
```

Tip

Remember to reference the `System.Net.Mail` namespaces in `Program.cs` if your code editor doesn’t automatically add them.

Once the `Program.cs` file is updated, launch the AppHost and use your browser, or `curl` to hit the following URLs (alternatively if you’re using Visual Studio you can use `.http` files). The important thing to note, is that you obtain the correct port number from the Aspire dashboard for the `newsletterservice` resource, for example:

HTTP request — subscribe

```http
POST /subscribe?email=test@test.com HTTP/1.1
Host: localhost:7286
Content-Type: application/json
```

Note

Your port number will likely be different to `7286` shown in this example. Be sure to replace it with the correct port number from your Aspire dashboard.

To use this API, you can use `curl` to send the request. The following `curl` command sends an HTTP `POST` request to the `subscribe` endpoint, and it expects an `email` query string value to subscribe to the newsletter. The `Content-Type` header is set to `application/json` to indicate that the request body is in JSON format.

* Bash

  ```bash
  curl -H "Content-Type: application/json" \
      --request POST \
      https://localhost:7286/subscribe?email=test@test.com
  ```

* PowerShell

  ```powershell
  curl -H @{ ContentType = "application/json" } `
      -Method POST `
      https://localhost:7286/subscribe?email=test@test.com
  ```

The next API is the `unsubscribe` endpoint. This endpoint is used to unsubscribe from the newsletter.

HTTP request — unsubscribe

```http
POST /unsubscribe?email=test@test.com HTTP/1.1
Host: localhost:7286
Content-Type: application/json
```

To unsubscribe from the newsletter, you can use the following `curl` command, passing an `email` parameter to the `unsubscribe` endpoint as a query string:

* Bash

  ```bash
  curl -H "Content-Type: application/json" \
      --request POST \
      https://localhost:7286/unsubscribe?email=test@test.com
  ```

* PowerShell

  ```powershell
  curl -H @{ ContentType = "application/json" } `
      -Method POST `
      https://localhost:7286/unsubscribe?email=test@test.com
  ```

If those API calls return a successful response (HTTP 200, Ok) then you should be able to select on the `maildev` resource the dashboard and the MailDev UI will show the emails that have been sent to the SMTP endpoint.

![E-mails visible in the MailDev UI.](/_astro/maildev-emails.DELI8Svw.png)

## Technical details

[Section titled “Technical details”](#technical-details)

In the following sections, various technical details are discussed which are important to understand when developing custom resources for Aspire.

### Secure networking

[Section titled “Secure networking”](#secure-networking)

In this example, the MailDev resource is a container resource which is exposed to the host machine over HTTP and SMTP. The MailDev resource is a development tool and isn’t intended for production use. To instead use HTTPS, see [MailDev: Configure HTTPS](https://github.com/maildev/maildev/blob/1f2c75be259eaf3c2bf9e04f8193f5924cb324ff/docs/https.md).

When developing custom resources that expose network endpoints, it’s important to consider the security implications of the resource. For example, if the resource is a database, it’s important to ensure that the database is secure and that the connection string isn’t exposed to the public internet.

### The `ReferenceExpression` and `EndpointReference` type

[Section titled “The ReferenceExpression and EndpointReference type”](#the-referenceexpression-and-endpointreference-type)

In the preceding code, the `MailDevResource` had two properties:

* `SmtpEndpoint`: An `EndpointReference` type.
* `ConnectionStringExpression`: A `ReferenceExpression` type.

These types are among several which are used throughout Aspire to represent configuration data, which isn’t finalized until the Aspire project is either run or published to the cloud via a tool such as [Azure Developer CLI](https://learn.microsoft.com/azure/developer/azure-developer-cli/overview).

The fundamental problem that these types help to solve, is deferring resolution of concrete configuration information until *all* the information is available.

For example, the `MailDevResource` exposes a property called `ConnectionStringExpression` as required by the `IResourceWithConnectionString` interface. The type of the property is `ReferenceExpression` and is created by passing in an interpolated string to the `ReferenceExpression.Create` method.

```csharp
public ReferenceExpression ConnectionStringExpression =>
    ReferenceExpression.Create(
        $"smtp://{SmtpEndpoint.Property(EndpointProperty.HostAndPort)}"
    );
```

The signature for the `ReferenceExpression.Create` method is as follows:

```csharp
public static ReferenceExpression Create(
    in ExpressionInterpolatedStringHandler handler)
```

This isn’t a regular string argument. The method makes use of the [interpolated string handler pattern](https://learn.microsoft.com//csharp/whats-new/tutorials/interpolated-string-handler), to capture the interpolated string template and the values referenced within it to allow for custom processing. In the case of Aspire, these details are captured in a `ReferenceExpression` which can be evaluated as each value referenced in the interpolated string becomes available.

Here’s how the flow of execution works:

1. A resource which implements `IResourceWithConnectionString` is added to the model (for example, `AddMailDev(...)`).
2. The `IResourceBuilder<MailDevResource>` is passed to the `WithReference` which has a special overload for handling `IResourceWithConnectionString` implementors.
3. The `WithReference` wraps the resource in a `ConnectionStringReference` instance and the object is captured in an `EnvironmentCallbackAnnotation` which is evaluated after the Aspire project is built and starts running.
4. As the process that references the connection string starts Aspire starts evaluating the expression. It first gets the `ConnectionStringReference` and calls its `GetValueAsync` method.
5. The `GetValueAsync` method gets the value of the `IResourceWithConnectionString.ConnectionStringExpression` property to get the `ReferenceExpression` instance.
6. The `ConnectionStringReference.GetValueAsync` method then calls `ReferenceExpression.GetValueAsync` to process the previously captured interpolated string.
7. Because the interpolated string contains references to other reference types such as `EndpointReference` they’re also evaluated and real value substituted (which at this time is now available).

### Manifest publishing

[Section titled “Manifest publishing”](#manifest-publishing)

The `IManifestExpressionProvider` interface is designed to solve the problem of sharing connection information between resources at deployment. Similarly to local development, many of the values are necessary to configure the app, yet they can’t be determined until the app is being deployed.

To solve this problem Aspire produces a *manifest file* which `azd` and other deployment tools interpret. Rather than specifying concrete values for connection information between resources an expression syntax is used which deployment tools evaluate. Generally the manifest file isn’t visible to developers but it’s possible to generate one for manual inspection. The command below can be used on the AppHost to produce a manifest.

Aspire CLI — publish-manifest

```bash
aspire do publish-manifest --output-path aspire-manifest.json
```

[Command reference: `aspire do publish-manifest`](/reference/cli/commands/aspire-do/)

Consider the following example output:

```bash
09:01:18 (pipeline execution) → Starting pipeline execution...
09:01:18 (publish-manifest) → Starting publish-manifest...
09:01:18 (publish-manifest) i [INF] Published manifest to: ./MailDevResource/aspire-manifest.json
09:01:18 (publish-manifest) ✓ publish-manifest completed successfully
09:01:18 (pipeline execution) ✓ Completed successfully
------------------------------------------------------------
✓ 2/2 steps succeeded • Total time: 0.0s


Steps Summary:
   0.0 s  ✓ pipeline execution
   0.0 s  ✓ publish-manifest


✓ PIPELINE SUCCEEDED
------------------------------------------------------------
```

Navigate to the output file specified in the command to inspect the manifest file. This command produces a manifest file like the following:

JSON — aspire-manifest.json

```json
{
  "$schema": "https://json.schemastore.org/aspire-8.0.json",
  "resources": {
    "maildev": {
      "type": "container.v0",
      "connectionString": "smtp://{maildev.bindings.smtp.host}:{maildev.bindings.smtp.port}",
      "image": "docker.io/maildev/maildev:2.2.1",
      "bindings": {
        "http": {
          "scheme": "http",
          "protocol": "tcp",
          "transport": "http",
          "targetPort": 1080
        },
        "smtp": {
          "scheme": "tcp",
          "protocol": "tcp",
          "transport": "tcp",
          "targetPort": 1025
        }
      }
    },
    "newsletterservice": {
      "type": "project.v0",
      "path": "MailDevResource.NewsletterService/MailDevResource.NewsletterService.csproj",
      "env": {
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EXCEPTION_LOG_ATTRIBUTES": "true",
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_EMIT_EVENT_LOG_ATTRIBUTES": "true",
        "OTEL_DOTNET_EXPERIMENTAL_OTLP_RETRY": "in_memory",
        "ASPNETCORE_FORWARDEDHEADERS_ENABLED": "true",
        "HTTP_PORTS": "{newsletterservice.bindings.http.targetPort}",
        "ConnectionStrings__maildev": "{maildev.connectionString}"
      },
      "bindings": {
        "http": {
          "scheme": "http",
          "protocol": "tcp",
          "transport": "http"
        },
        "https": {
          "scheme": "https",
          "protocol": "tcp",
          "transport": "http"
        }
      }
    }
  }
}
```

Because the `MailDevResource` implements `IResourceWithConnectionString` the manifest publishing logic in Aspire knows that even though `MailDevResource` is a container resource, it also needs a `connectionString` field. The `connectionString` field references other parts of the `maildev` resource in the manifest to produce the final string:

```json
{
    // ... other content omitted.
    "connectionString": "smtp://{maildev.bindings.smtp.host}:{maildev.bindings.smtp.port}",
}
```

Aspire knows how to form this string because it looks at `IResourceWithConnectionString.ConnectionStringExpression` and builds up the final string via the `IManifestExpressionProvider` interface (in much the same way as the `IValueProvider` interface is used).

The `MailDevResource` automatically gets included in the manifest because it’s derived from `ContainerResource`. Resource authors can choose to suppress outputting content to the manifest by using the `ExcludeFromManifest` extension method on the resource builder.

C# — MailDevResourceBuilderExtensions.cs

```diff
public static IResourceBuilder<MailDevResource> AddMailDev(
    this IDistributedApplicationBuilder builder,
    string name,
    int? httpPort = null,
    int? smtpPort = null)
{
    var resource = new MailDevResource(name);


    return builder.AddResource(resource)
                  .WithImage(MailDevContainerImageTags.Image)
                  .WithImageRegistry(MailDevContainerImageTags.Registry)
                  .WithImageTag(MailDevContainerImageTags.Tag)
                  .WithHttpEndpoint(
                      targetPort: 1080,
                      port: httpPort,
                      name: MailDevResource.HttpEndpointName)
                  .WithEndpoint(
                      targetPort: 1025,
                      port: smtpPort,
                      name: MailDevResource.SmtpEndpointName)
+                  .ExcludeFromManifest(); // This line was added
}
```

Careful consideration should be given as to whether the resource should be present in the manifest, or whether it should be suppressed. If the resource is being added to the manifest, it should be configured in such a way that it’s safe and secure to use.

## Summary

[Section titled “Summary”](#summary)

In this tutorial, you learned how to create a custom Aspire resource which uses an existing containerized application (MailDev). You then used that to improve the local development experience by making it easy to test e-mail capabilities that might be used within an app. These learnings can be applied to building out other custom resources that can be used in Aspire-based applications. This specific example didn’t include any custom integrations, but it’s possible to build out custom integrations to make it easier for developers to use the resource. In this scenario you were able to rely on the existing `SmtpClient` class in the .NET platform to send e-mails.

# Secure communication between integrations

> Learn how to secure communication between hosting and client integrations.

This article is a continuation of two previous articles demonstrating the creation of [custom hosting integrations](/integrations/custom-integrations/hosting-integrations/) and [custom client integrations](/integrations/custom-integrations/client-integrations/).

One of the primary benefits to Aspire is how it simplifies the configurability of resources and consuming clients (or integrations). This article demonstrates how to share authentication credentials from a custom resource in a hosting integration, to the consuming client in a custom client integration. The custom resource is a MailDev container that allows for either incoming or outgoing credentials. The custom client integration is a MailKit client that sends emails.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

Since this article continues from previous content, you should have already created the resulting solution as a starting point for this article. If you haven’t already, complete the following articles:

1. [Create custom hosting integrations](/integrations/custom-integrations/hosting-integrations/)
2. [Create custom client integrations](/integrations/custom-integrations/client-integrations/)

The resulting solution from these previous articles contains the following projects:

1. `MailDev.Hosting`: Contains the custom resource type for the MailDev container.
2. `MailDevResource.AppHost`: The [AppHost](/get-started/app-host/) that uses the custom resource and defines it as a dependency for a Newsletter service.
3. `MailDevResource.NewsletterService`: An ASP.NET Core Web API project that sends emails using the MailDev container.
4. `MailDevResource.ServiceDefaults`: Contains the [default service configurations](/fundamentals/service-defaults/) intended for sharing.
5. `MailKit.Client`: Contains the custom client integration that exposes the MailKit `SmtpClient` through a factory.

## Update the MailDev resource

[Section titled “Update the MailDev resource”](#update-the-maildev-resource)

To flow authentication credentials from the MailDev resource to the MailKit integration, you need to update the MailDev resource to include the username and password parameters.

The MailDev container supports basic authentication for both incoming and outgoing simple mail transfer protocol (SMTP). To configure the credentials for incoming, you need to set the `MAILDEV_INCOMING_USER` and `MAILDEV_INCOMING_PASS` environment variables. For more information, see [MailDev: Usage](https://maildev.github.io/maildev/#usage). Update the `MailDevResource.cs` file in the `MailDev.Hosting` project, by replacing its contents with the following C# code:

MailDev.Hosting/MailDevResource.cs

```csharp
// For ease of discovery, resource types should be placed in
// the Aspire.Hosting.ApplicationModel namespace. If there is
// likelihood of a conflict on the resource name consider using
// an alternative namespace.
namespace Aspire.Hosting.ApplicationModel;


public sealed class MailDevResource(
    string name,
    ParameterResource? username,
    ParameterResource password)
        : ContainerResource(name), IResourceWithConnectionString
{
    // Constants used to refer to well known-endpoint names, this is specific
    // for each resource type. MailDev exposes an SMTP and HTTP endpoints.
    internal const string SmtpEndpointName = "smtp";
    internal const string HttpEndpointName = "http";


    private const string DefaultUsername = "mail-dev";


    // An EndpointReference is a core Aspire type used for keeping
    // track of endpoint details in expressions. Simple literal values cannot
    // be used because endpoints are not known until containers are launched.
    private EndpointReference? _smtpReference;


    /// <summary>
    /// Gets the parameter that contains the MailDev SMTP server username.
    /// </summary>
    public ParameterResource? UsernameParameter { get; } = username;


    internal ReferenceExpression UserNameReference =>
        UsernameParameter is not null ?
        ReferenceExpression.Create($"{UsernameParameter}") :
        ReferenceExpression.Create($"{DefaultUsername}");


    /// <summary>
    /// Gets the parameter that contains the MailDev SMTP server password.
    /// </summary>
    public ParameterResource PasswordParameter { get; } = password;


    public EndpointReference SmtpEndpoint =>
        _smtpReference ??= new(this, SmtpEndpointName);


    // Required property on IResourceWithConnectionString. Represents a connection
    // string that applications can use to access the MailDev server. In this case
    // the connection string is composed of the SmtpEndpoint endpoint reference.
    public ReferenceExpression ConnectionStringExpression =>
        ReferenceExpression.Create(
            $"Endpoint=smtp://{SmtpEndpoint.Property(EndpointProperty.HostAndPort)};Username={UserNameReference};Password={PasswordParameter}"
        );
}
```

These updates add a `UsernameParameter` and `PasswordParameter` property. These properties are used to store the parameters for the MailDev username and password. The `ConnectionStringExpression` property is updated to include the username and password parameters in the connection string. Next, update the `MailDevResourceBuilderExtensions.cs` file in the `MailDev.Hosting` project with the following C# code:

MailDev.Hosting/MailDevResourceBuilderExtensions.cs

```csharp
using Aspire.Hosting.ApplicationModel;


// Put extensions in the Aspire.Hosting namespace to ease discovery as referencing
// the Aspire hosting package automatically adds this namespace.
namespace Aspire.Hosting;


public static class MailDevResourceBuilderExtensions
{
    private const string UserEnvVarName = "MAILDEV_INCOMING_USER";
    private const string PasswordEnvVarName = "MAILDEV_INCOMING_PASS";


    /// <summary>
    /// Adds the <see cref="MailDevResource"/> to the given
    /// <paramref name="builder"/> instance. Uses the "2.2.1" tag.
    /// </summary>
    /// <param name="builder">The <see cref="IDistributedApplicationBuilder"/>.</param>
    /// <param name="name">The name of the resource.</param>
    /// <param name="httpPort">The HTTP port.</param>
    /// <param name="smtpPort">The SMTP port.</param>
    /// <returns>
    /// An <see cref="IResourceBuilder{MailDevResource}"/> instance that
    /// represents the added MailDev resource.
    /// </returns>
    public static IResourceBuilder<MailDevResource> AddMailDev(
        this IDistributedApplicationBuilder builder,
        string name,
        int? httpPort = null,
        int? smtpPort = null,
        IResourceBuilder<ParameterResource>? username = null,
        IResourceBuilder<ParameterResource>? password = null)
    {
        var passwordParameter = password?.Resource ??
            ParameterResourceBuilderExtensions.CreateDefaultPasswordParameter(
                builder, $"{name}-password");


        // The AddResource method is a core API within Aspire and is
        // used by resource developers to wrap a custom resource in an
        // IResourceBuilder<T> instance. Extension methods to customize
        // the resource (if any exist) target the builder interface.
        var resource = new MailDevResource(
            name, username?.Resource, passwordParameter);


        return builder.AddResource(resource)
                      .WithImage(MailDevContainerImageTags.Image)
                      .WithImageRegistry(MailDevContainerImageTags.Registry)
                      .WithImageTag(MailDevContainerImageTags.Tag)
                      .WithHttpEndpoint(
                          targetPort: 1080,
                          port: httpPort,
                          name: MailDevResource.HttpEndpointName)
                      .WithEndpoint(
                          targetPort: 1025,
                          port: smtpPort,
                          name: MailDevResource.SmtpEndpointName)
                      .WithEnvironment(context =>
                      {
                          context.EnvironmentVariables[UserEnvVarName] = resource.UserNameReference;
                          context.EnvironmentVariables[PasswordEnvVarName] = resource.PasswordParameter;
                      });
    }
}


// This class just contains constant strings that can be updated periodically
// when new versions of the underlying container are released.
internal static class MailDevContainerImageTags
{
    internal const string Registry = "docker.io";


    internal const string Image = "maildev/maildev";


    internal const string Tag = "2.2.1";
}
```

The preceding code updates the `AddMailDev` extension method to include the `userName` and `password` parameters. The `WithEnvironment` method is updated to include the `UserEnvVarName` and `PasswordEnvVarName` environment variables. These environment variables are used to set the MailDev username and password.

## Update the AppHost

[Section titled “Update the AppHost”](#update-the-apphost)

Now that the resource is updated to include the username and password parameters, you need to update the AppHost to include these parameters. Update the `AppHost.cs` file in the `MailDevResource.AppHost` project with the following C# code:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mailDevUsername = builder.AddParameter("maildev-username");
var mailDevPassword = builder.AddParameter("maildev-password");


var maildev = builder.AddMailDev(
    name: "maildev",
    userName: mailDevUsername,
    password: mailDevPassword);


builder.AddProject<Projects.MailDevResource_NewsletterService>("newsletterservice")
    .WithUrlForEndpoint("https", e =>
    {
        e.DisplayText = "Scalar";
        e.Url += "/scalar";
    })
    .WithReference(maildev);


builder.Build().Run();
```

The preceding code adds two parameters for the MailDev username and password. It assigns these parameters to the MailDev resource. The `AddMailDev` method has two chained calls to `WithEnvironment` which includes these environment variables.

Next, configure the secrets for these parameters. Right-click on the `MailDevResource.AppHost` project and select `Manage User Secrets` (from within Visual Studio Code or Visual Studio). Add the following JSON to the `secrets.json` file:

```json
{
  "Parameters:maildev-username": "@admin",
  "Parameters:maildev-password": "t3st1ng"
}
```

Alternatively, you can use the `dotnet user-secrets` CLI to set these parameters:

```bash
dotnet user-secrets set "Parameters:maildev-username" "@admin"
```

```bash
dotnet user-secrets set "Parameters:maildev-password" "t3st1ng"
```

Danger

These credentials are for demonstration purposes only and MailDev is intended for local development. These credentials are fictitious and shouldn’t be used in a production environment.

## Update the MailKit integration

[Section titled “Update the MailKit integration”](#update-the-mailkit-integration)

It’s good practice for client integrations to expect connection strings to contain various key/value pairs, and to parse these pairs into the appropriate properties. Update the `MailKitClientSettings.cs` file in the `MailKit.Client` project with the following C# code:

MailKit.Client/MailKitClientSettings.cs

```csharp
using System.Data.Common;
using System.Net;


namespace MailKit.Client;


/// <summary>
/// Provides the client configuration settings for connecting MailKit to an SMTP server.
/// </summary>
public sealed class MailKitClientSettings
{
    internal const string DefaultConfigSectionName = "MailKit:Client";


    /// <summary>
    /// Gets or sets the SMTP server <see cref="Uri"/>.
    /// </summary>
    /// <value>
    /// The default value is <see langword="null"/>.
    /// </value>
    public Uri? Endpoint { get; set; }


    /// <summary>
    /// Gets or sets the network credentials that are optionally configurable for SMTP
    /// server's that require authentication.
    /// </summary>
    /// <value>
    /// The default value is <see langword="null"/>.
    /// </value>
    public NetworkCredential? Credentials { get; set; }


    /// <summary>
    /// Gets or sets a boolean value that indicates whether the database health check is disabled or not.
    /// </summary>
    /// <value>
    /// The default value is <see langword="false"/>.
    /// </value>
    public bool DisableHealthChecks { get; set; }


    /// <summary>
    /// Gets or sets a boolean value that indicates whether the OpenTelemetry tracing is disabled or not.
    /// </summary>
    /// <value>
    /// The default value is <see langword="false"/>.
    /// </value>
    public bool DisableTracing { get; set; }


    /// <summary>
    /// Gets or sets a boolean value that indicates whether the OpenTelemetry metrics are disabled or not.
    /// </summary>
    /// <value>
    /// The default value is <see langword="false"/>.
    /// </value>
    public bool DisableMetrics { get; set; }


    internal void ParseConnectionString(string? connectionString)
    {
        if (string.IsNullOrWhiteSpace(connectionString))
        {
            throw new InvalidOperationException($"""
                ConnectionString is missing.
                It should be provided in 'ConnectionStrings:<connectionName>'
                or '{DefaultConfigSectionName}:Endpoint' key.'
                configuration section.
                """);
        }


        if (Uri.TryCreate(connectionString, UriKind.Absolute, out var uri))
        {
            Endpoint = uri;
        }
        else
        {
            var builder = new DbConnectionStringBuilder
            {
                ConnectionString = connectionString
            };


            if (builder.TryGetValue("Endpoint", out var endpoint) is false)
            {
                throw new InvalidOperationException($"""
                    The 'ConnectionStrings:<connectionName>' (or 'Endpoint' key in
                    '{DefaultConfigSectionName}') is missing.
                    """);
            }


            if (Uri.TryCreate(endpoint.ToString(), UriKind.Absolute, out uri) is false)
            {
                throw new InvalidOperationException($"""
                    The 'ConnectionStrings:<connectionName>' (or 'Endpoint' key in
                    '{DefaultConfigSectionName}') isn't a valid URI.
                    """);
            }


            Endpoint = uri;


            if (builder.TryGetValue("Username", out var username) &&
                builder.TryGetValue("Password", out var password))
            {
                Credentials = new(
                    username.ToString(), password.ToString());
            }
        }
    }
}
```

The preceding settings class, now includes a `Credentials` property of type `NetworkCredential`. The `ParseConnectionString` method is updated to parse the `Username` and `Password` keys from the connection string. If the `Username` and `Password` keys are present, a `NetworkCredential` is created and assigned to the `Credentials` property.

With the settings class updated to understand and populate the credentials, update the factory to conditionally use the credentials if they’re configured. Update the `MailKitClientFactory.cs` file in the `MailKit.Client` project with the following C# code:

MailKit.Client/MailKitClientFactory.cs

```csharp
using MailKit.Net.Smtp;


namespace MailKit.Client;


/// <summary>
/// A factory for creating <see cref="ISmtpClient"/> instances
/// given a <paramref name="smtpUri"/> (and optional <paramref name="credentials"/>).
/// </summary>
/// <param name="settings">
/// The <see cref="MailKitClientSettings"/> settings for the SMTP server
/// </param>
public sealed class MailKitClientFactory(MailKitClientSettings settings)
    : IDisposable
{
    private readonly SemaphoreSlim _semaphore = new(1, 1);


    private SmtpClient? _client;


    /// <summary>
    /// Gets an <see cref="ISmtpClient"/> instance in the connected state
    /// (and that's been authenticated if configured).
    /// </summary>
    /// <param name="cancellationToken">Used to abort client creation and connection.</param>
    /// <returns>A connected (and authenticated) <see cref="ISmtpClient"/> instance.</returns>
    /// <remarks>
    /// Since both the connection and authentication are considered expensive operations,
    /// the <see cref="ISmtpClient"/> returned is intended to be used for the duration of a request
    /// (registered as 'Scoped') and is automatically disposed of.
    /// </remarks>
    public async Task<ISmtpClient> GetSmtpClientAsync(
        CancellationToken cancellationToken = default)
    {
        await _semaphore.WaitAsync(cancellationToken);


        try
        {
            if (_client is null)
            {
                _client = new SmtpClient();


                await _client.ConnectAsync(settings.Endpoint, cancellationToken)
                    .ConfigureAwait(false);


                if (settings.Credentials is not null)
                {
                    await _client.AuthenticateAsync(settings.Credentials, cancellationToken)
                        .ConfigureAwait(false);
                }
            }
        }
        finally
        {
            _semaphore.Release();
        }


        return _client;
    }


    public void Dispose()
    {
        _client?.Dispose();
        _semaphore.Dispose();
    }
}
```

When the factory determines that credentials have been configured, it authenticates with the SMTP server after connecting before returning the `SmtpClient`.

## Run the sample

[Section titled “Run the sample”](#run-the-sample)

Now that you’ve updated the resource, corresponding integration projects, and the AppHost, you’re ready to run the sample app. To run the sample from your IDE, select F5 `F5` F5 `F5` F5 `F5` or use `aspire run` from the root directory of the solution to start the application—you should see the [Aspire dashboard](/dashboard/overview/). Navigate to the `maildev` container resource and view the details. You should see the username and password parameters as resources.

1. To verify that the credentials are flowing correctly, navigate to the Aspire dashboard and select the `maildev` resource row. You should see the username and password parameters in the resource details, under the **Environment Variables** section:

   ![Aspire Dashboard: MailDev container resource details.](/_astro/maildev-details.DEGkLQo5.png)

2. Likewise, you should see the connection string in the `newsletterservice` resource details, under the **Environment Variables** section:

   ![Aspire Dashboard: Newsletter service resource details.](/_astro/newsletter-details.BEdsquqx.png)

3. Validate that everything is working as expected.

## Summary

[Section titled “Summary”](#summary)

This article demonstrated how to flow authentication credentials from a custom resource to a custom client integration. The custom resource is a MailDev container that allows for either incoming or outgoing credentials. The custom client integration is a MailKit client that sends emails. By updating the resource to include the `username` and `password` parameters, and updating the integration to parse and use these parameters, authentication flows credentials from the hosting integration to the client integration.

# Azure Cosmos DB client integration

> Learn how to use the Azure Cosmos DB client integration to interact with Azure Cosmos DB instances.

![Azure Cosmos DB logo](/_astro/azure-cosmosdb-icon.4tqzZo4Z_Z1sl4nn.webp)

To get started with the Aspire Microsoft Entity Framework Core Cosmos DB integration, install the [📦 Aspire.Microsoft.EntityFrameworkCore.Cosmos](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.Cosmos) NuGet package in the client-consuming project, i.e., the project for the application that uses the Microsoft Entity Framework Core Cosmos DB client.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.Cosmos package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.Cosmos@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.Cosmos package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.Cosmos" Version="*" />
  ```

For an introduction to the Azure Cosmos DB integration, see [Get started with the Azure Cosmos DB integrations](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-get-started/).

## Add Cosmos DB context

[Section titled “Add Cosmos DB context”](#add-cosmos-db-context)

In the `Program.cs` file of your client-consuming project, call the `AddCosmosDbContext` extension method to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter and a database name parameter.

C# — Program.cs

```csharp
builder.AddCosmosDbContext<MyDbContext>("cosmosdb", "databaseName");
```

Alternatively, the database name can be inferred from the connection when there’s a single database in the connection string. In this case, you can omit the database name parameter:

C# — Program.cs

```csharp
builder.AddCosmosDbContext<MyDbContext>("cosmosdb");
```

Tip

The `connectionName` parameter must match the name used when adding the Cosmos DB resource in the AppHost project. In other words, when you call `AddAzureCosmosDB` and provide a name of `cosmosdb` that same name should be used when calling `AddCosmosDbContext`. For more information, see [Add Azure Cosmos DB resource](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-host/#add-azure-cosmos-db-resource).

You can then retrieve the `DbContext` instance using dependency injection. For example, to retrieve the client from a service:

```csharp
public class ExampleService(MyDbContext context)
{
    // Use context...
}
```

For more information on using Entity Framework Core with Azure Cosmos DB, see the [Examples for Azure Cosmos DB for NoSQL SDK for .NET](https://learn.microsoft.com/ef/core/providers/cosmos/?tabs=dotnet-core-cli).

## Properties of the Cosmos DB resources

[Section titled “Properties of the Cosmos DB resources”](#properties-of-the-cosmos-db-resources)

When you add a reference to an Azure Cosmos DB resource in the AppHost, using the `WithReference` method, Aspire injects several properties into the consuming project. These properties are available as environment variables that you can use to connect to and interact with Azure Cosmos DB.

The properties injected depend on the type of resource you reference:

### Azure Cosmos DB account properties

[Section titled “Azure Cosmos DB account properties”](#azure-cosmos-db-account-properties)

When you reference an `AzureCosmosDBResource` (the Cosmos DB account), the following properties are injected:

| Property Name      | Environment Variable          | Description                                                                                                             |
| ------------------ | ----------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `AccountKey`       | `[RESOURCE]_ACCOUNTKEY`       | The account key for the Cosmos DB account (only available for emulator and access key authentication).                  |
| `ConnectionString` | `[RESOURCE]_CONNECTIONSTRING` | The connection string for the Azure Cosmos DB account.                                                                  |
| `Uri`              | `[RESOURCE]_URI`              | The account endpoint URI for the Cosmos DB account, with the format <https://mycosmosaccount.documents.azure.com:443/>. |

### Azure Cosmos DB database properties

[Section titled “Azure Cosmos DB database properties”](#azure-cosmos-db-database-properties)

When you reference an `AzureCosmosDBDatabaseResource`, the following properties are injected, in addition to the properties of the Cosmos DB account:

| Property Name  | Environment Variable      | Description               |
| -------------- | ------------------------- | ------------------------- |
| `DatabaseName` | `[RESOURCE]_DATABASENAME` | The name of the database. |

### Azure Cosmos DB container properties

[Section titled “Azure Cosmos DB container properties”](#azure-cosmos-db-container-properties)

When you reference an `AzureCosmosDBContainerResource`, the following properties are injected, in addition to the properties of the Cosmos DB account and database:

| Property Name   | Environment Variable       | Description                |
| --------------- | -------------------------- | -------------------------- |
| `ContainerName` | `[RESOURCE]_CONTAINERNAME` | The name of the container. |

Here’s an example of how these properties are used when you call `WithReference`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");
var database = cosmos.AddCosmosDatabase("mydb");
var container = database.AddContainer("mycontainer", "/id");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(container);
```

In this example, the `ExampleProject` will have access to the `MYCONTAINER_ACCOUNTKEY`, `MYCONTAINER_CONNECTIONSTRING`, `MYCONTAINER_URI`, `MYCONTAINER_DATABASENAME`, and `MYCONTAINER_CONTAINERNAME` environment variables, which contain the connection information to the Azure Cosmos DB container.

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire Microsoft Entity Framework Core Cosmos DB integration provides multiple options to configure the Azure Cosmos DB connection based on the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `builder.AddCosmosDbContext`:

C# — Program.cs

```csharp
builder.AddCosmosDbContext<MyDbContext>("CosmosConnection");
```

And then the connection string will be retrieved from the `ConnectionStrings` configuration section:

appsettings.json

```json
{
  "ConnectionStrings": {
    "CosmosConnection": "AccountEndpoint=https://{account_name}.documents.azure.com:443/;AccountKey={account_key};"
  }
}
```

For more information, see the [ConnectionString documentation](https://learn.microsoft.com/azure/cosmos-db/nosql/how-to-dotnet-get-started#connect-with-a-connection-string).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Microsoft Entity Framework Core Cosmos DB integration supports `Microsoft.Extensions.Configuration`. It loads the `EntityFrameworkCoreCosmosSettings` from configuration files such as `appsettings.json`. Example `appsettings.json` that configures some of the options:

appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "EntityFrameworkCore": {
        "Cosmos": {
          "DisableTracing": true
        }
      }
    }
  }
}
```

For the complete Cosmos DB client integration JSON schema, see [Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Microsoft.EntityFrameworkCore.Cosmos/ConfigurationSchema.json).

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<EntityFrameworkCoreCosmosSettings> configureSettings` delegate to set up some or all the `EntityFrameworkCoreCosmosSettings` options inline, for example to disable tracing from code:

```csharp
builder.AddCosmosDbContext<MyDbContext>(
    "cosmosdb",
    settings => settings.DisableTracing = true);
```

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

The Aspire Microsoft Entity Framework Core Cosmos DB integration currently doesn’t implement health checks, though this may change in future releases.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

### Logging

[Section titled “Logging”](#logging)

The Aspire Microsoft Entity Framework Core Cosmos DB integration uses the following log categories:

* `Azure-Cosmos-Operation-Request-Diagnostics`
* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Query`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Microsoft Entity Framework Core Cosmos DB integration will emit the following tracing activities using OpenTelemetry:

* `Azure.Cosmos.Operation`
* `OpenTelemetry.Instrumentation.EntityFrameworkCore`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Microsoft Entity Framework Core Cosmos DB integration currently supports the following metrics:

* `Microsoft.EntityFrameworkCore`

  * `ec_Microsoft_EntityFrameworkCore_active_db_contexts`
  * `ec_Microsoft_EntityFrameworkCore_total_queries`
  * `ec_Microsoft_EntityFrameworkCore_queries_per_second`
  * `ec_Microsoft_EntityFrameworkCore_total_save_changes`
  * `ec_Microsoft_EntityFrameworkCore_save_changes_per_second`
  * `ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate`
  * `ec_Microsoft_Entity_total_execution_strategy_operation_failures`
  * `ec_Microsoft_E_execution_strategy_operation_failures_per_second`
  * `ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures`
  * `ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second`

# Get started with the Azure Cosmos DB Entity Framework Core integrations

> Learn how to set up the Aspire Azure Cosmos DB Hosting and Client integrations simply.

![Azure Cosmos DB logo](/_astro/azure-cosmosdb-icon.4tqzZo4Z_Z1sl4nn.webp)

[Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a fully managed NoSQL database service for modern app development. The Aspire Cosmos DB Entity Framework Core integration enables you to connect to existing Cosmos DB instances or create new instances from .NET with the Azure Cosmos DB emulator.

In this introduction, you’ll see how to install and use the Aspire Azure Cosmos DB integrations in a simple configuration. If you already have this knowledge, see [Azure Cosmos DB Hosting integration](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Azure Cosmos DB Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Azure Cosmos DB resources from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.CosmosDB package

  ```bash
  aspire add cosmosdb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > cosmosdb (Aspire.Hosting.Azure.CosmosDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.CosmosDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.CosmosDB package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.CosmosDB" Version="*" />
  ```

Next, in the AppHost project, create instances of Azure Cosmos DB resources, including a database and container, then pass the container to the consuming client projects:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
                    .RunAsEmulator();


var database = cosmos.AddCosmosDatabase("mydb");
var container = database.AddContainer("mycontainer", "/id");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(container)
                            .WithReference(container);
```

Tip

This is the simplest implementation of Azure Cosmos DB resources in the AppHost using the emulator. There are many more options you can choose from to address your requirements. For full details, see [Azure Cosmos DB Hosting integration](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Microsoft Entity Framework Core Cosmos DB integration:

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.Cosmos package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.Cosmos
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.Cosmos@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.Cosmos package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.Cosmos" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddCosmosDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddCosmosDbContext<MyDbContext>(connectionName: "mycontainer");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure Cosmos DB container resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected Cosmos DB properties

[Section titled “Use injected Cosmos DB properties”](#use-injected-cosmos-db-properties)

In the AppHost, when you used the `WithReference` method to pass an Azure Cosmos DB resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `ConnectionString` property of a resource called `mycontainer` becomes `MYCONTAINER_CONNECTIONSTRING`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string connectionString = builder.Configuration.GetValue<string>("MYCONTAINER_CONNECTIONSTRING");
string databaseName = builder.Configuration.GetValue<string>("MYCONTAINER_DATABASENAME");
```

Tip

For the full set of properties that Aspire injects, see [Properties of the Cosmos DB resources](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-client/#properties-of-the-cosmos-db-resources).

### Use Cosmos DB resources in client code

[Section titled “Use Cosmos DB resources in client code”](#use-cosmos-db-resources-in-client-code)

Now that you’ve added the `DbContext` to the builder in the consuming project, you can use the Azure Cosmos DB resource to get and store data. Get the `DbContext` instance using dependency injection. For example, to retrieve your database context object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(MyDbContext context)
{
    // Use context to interact with Cosmos DB...
}
```

Having obtained the database context, you can work with Azure Cosmos DB as you would in any other C# application using Entity Framework Core.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with Azure Cosmos DB integrations up and running, you can use the following reference documents to learn how to configure and interact with the Azure Cosmos DB resources:

[Understand the Azure Cosmos DB hosting integration ](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-host/)Discover how to configure emulator settings, databases, containers, and more.

[Understand the Azure Cosmos DB client integration ](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-client/)Discover how to configure the DbContext, client integration health checks, and more.

# Azure Cosmos DB hosting integration

> Learn how to use the Azure Cosmos DB hosting integration to create and manage Azure Cosmos DB instances.

![Azure Cosmos DB logo](/_astro/azure-cosmosdb-icon.4tqzZo4Z_Z1sl4nn.webp)

The Aspire Azure Cosmos DB hosting integration models Cosmos DB resources as the following types:

* `AzureCosmosDBResource`: Represents an Azure Cosmos DB resource.
* `AzureCosmosDBContainerResource`: Represents an Azure Cosmos DB container resource.
* `AzureCosmosDBDatabaseResource`: Represents an Azure Cosmos DB database resource.
* `AzureCosmosDBEmulatorResource`: Represents an Azure Cosmos DB emulator resource.

To access these types and APIs, add the [📦 Aspire.Hosting.Azure.CosmosDB](https://www.nuget.org/packages/Aspire.Hosting.Azure.CosmosDB) NuGet package to your AppHost project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.CosmosDB package

  ```bash
  aspire add azure-cosmosdb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-cosmosdb (Aspire.Hosting.Azure.CosmosDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.CosmosDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.CosmosDB package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.CosmosDB" Version="*" />
  ```

For an introduction to the Azure Cosmos DB integration, see [Get started with the Azure Cosmos DB integrations](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-get-started/).

## Add Azure Cosmos DB resource

[Section titled “Add Azure Cosmos DB resource”](#add-azure-cosmos-db-resource)

In your AppHost project, call `AddAzureCosmosDB` to add and return an Azure Cosmos DB resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");


// After adding all resources, run the app...
```

When you add an `AzureCosmosDBResource` to the AppHost, it exposes other useful APIs to add databases and containers. In other words, you must add an `AzureCosmosDBResource` before adding any of the other Cosmos DB resources.

Caution

When you call `AddAzureCosmosDB`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

## Connect to an existing Azure Cosmos DB account

[Section titled “Connect to an existing Azure Cosmos DB account”](#connect-to-an-existing-azure-cosmos-db-account)

You might have an existing Azure Cosmos DB account that you want to connect to. Chain a call to annotate that your resource is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingCosmosName = builder.AddParameter("existingCosmosName");
var existingCosmosResourceGroup = builder.AddParameter("existingCosmosResourceGroup");


var cosmosdb = builder.AddAzureCosmosDB("cosmos-db")
    .AsExisting(existingCosmosName, existingCosmosResourceGroup);


builder.AddProject<Projects.ExampleProject>()
    .WithReference(cosmosdb);


// After adding all resources, run the app...
```

For more information on treating Azure Cosmos DB resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

Note

Alternatively, instead of representing an Azure Cosmos DB account resource, you can add a connection string to the AppHost. This approach is weakly-typed and doesn’t work with role assignments or infrastructure customizations.

## Add Azure Cosmos DB database and container resources

[Section titled “Add Azure Cosmos DB database and container resources”](#add-azure-cosmos-db-database-and-container-resources)

Aspire models parent child relationships between Azure Cosmos DB resources. For example, an Azure Cosmos DB account (`AzureCosmosDBResource`) can have multiple databases (`AzureCosmosDBDatabaseResource`), and each database can have multiple containers (`AzureCosmosDBContainerResource`). When you add a database or container resource, you do so on a parent resource.

To add an Azure Cosmos DB database resource, call the `AddCosmosDatabase` method on an `IResourceBuilder<AzureCosmosDBResource>` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");
var db = cosmos.AddCosmosDatabase("db");


// After adding all resources, run the app...
```

When you call `AddCosmosDatabase`, it adds a database named `db` to your Cosmos DB resources and returns the newly created database resource. The database is created in the Cosmos DB account that’s represented by the `AzureCosmosDBResource` that you added earlier. The database is a logical container for collections and users.

An Azure Cosmos DB container is where data is stored. When you create a container, you need to supply a partition key.

To add an Azure Cosmos DB container resource, call the `AddContainer` method on an `IResourceBuilder<AzureCosmosDBDatabaseResource>` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db");
var db = cosmos.AddCosmosDatabase("db");
var container = db.AddContainer("entries", "/id");


// After adding all resources, run the app...
```

The container is created in the database that’s represented by the `AzureCosmosDBDatabaseResource` that you added earlier. For more information, see [Databases, containers, and items in Azure Cosmos DB](https://learn.microsoft.com/azure/cosmos-db/resource-model).

### Parent child resource relationship example

[Section titled “Parent child resource relationship example”](#parent-child-resource-relationship-example)

To better understand the parent-child relationship between Azure Cosmos DB resources, consider the following example, which demonstrates adding an Azure Cosmos DB resource along with a database and container:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos");


var customers = cosmos.AddCosmosDatabase("customers");
var profiles = customers.AddContainer("profiles", "/id");


var orders = cosmos.AddCosmosDatabase("orders");
var details = orders.AddContainer("details", "/id");
var history = orders.AddContainer("history", "/id");


builder.AddProject<Projects.Api>("api")
    .WithReference(profiles)
    .WithReference(details)
    .WithReference(history);


builder.Build().Run();
```

The preceding code adds an Azure Cosmos DB resource named `cosmos` with two databases: `customers` and `orders`. The `customers` database has a single container named `profiles`, while the `orders` database has two containers: `details` and `history`. The partition key for each container is `/id`.

The following diagram illustrates the parent child relationship between the Azure Cosmos DB resources:

![](/_astro/cosmos-resource-relationships.BuZpjyMd.svg)

When your AppHost code expresses parent-child relationships, the client can deep-link to these resources by name. For example, the `customers` database can be referenced by name in the client project, registering a `Microsoft.Azure.Cosmos.Database` instance that connects to the `customers` database. The same applies to named containers, for example, the `details` container can be referenced by name in the client project, registering a `Microsoft.Azure.Cosmos.Container` instance that connects to the `details` container.

## Add Azure Cosmos DB emulator resource

[Section titled “Add Azure Cosmos DB emulator resource”](#add-azure-cosmos-db-emulator-resource)

To add an Azure Cosmos DB emulator resource, chain a call on an `IResourceBuilder<AzureCosmosDBResource>` to the `RunAsEmulator` API:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
  .RunAsEmulator();


// After adding all resources, run the app...
```

When you call `RunAsEmulator`, it configures your Cosmos DB resources to run locally using an emulator. The emulator in this case is the [Azure Cosmos DB Emulator](https://learn.microsoft.com/azure/cosmos-db/local-emulator). The Azure Cosmos DB Emulator provides a free local environment for testing your Azure Cosmos DB apps and it’s a perfect companion to the Aspire Azure hosting integration. The emulator isn’t installed, instead, it’s accessible to Aspire as a container. When you add a container to the AppHost, as shown in the preceding example with the `mcr.microsoft.com/cosmosdb/emulator` image, it creates and starts the container when the AppHost starts.

### Configure Cosmos DB emulator container

[Section titled “Configure Cosmos DB emulator container”](#configure-cosmos-db-emulator-container)

There are various configurations available to container resources, for example, you can configure the container’s ports, environment variables, it’s lifetime, and more.

#### Configure Cosmos DB emulator container gateway port

[Section titled “Configure Cosmos DB emulator container gateway port”](#configure-cosmos-db-emulator-container-gateway-port)

By default, the Cosmos DB emulator container when configured by Aspire, exposes the following endpoints:

| Endpoint | Container port | Host port |
| -------- | -------------- | --------- |
| `https`  | 8081           | dynamic   |

The port that it’s listening on is dynamic by default. When the container starts, the port is mapped to a random port on the host machine. To configure the endpoint port, chain calls on the container resource builder provided by the `RunAsEmulator` method as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithGatewayPort(7777);
    });


// After adding all resources, run the app...
```

The preceding code configures the Cosmos DB emulator container’s existing `https` endpoint to listen on port `8081`. The Cosmos DB emulator container’s port is mapped to the host port as shown in the following table:

| Endpoint name | Port mapping (`container:host`) |
| ------------: | ------------------------------- |
|       `https` | `8081:7777`                     |

#### Configure Cosmos DB emulator container with persistent lifetime

[Section titled “Configure Cosmos DB emulator container with persistent lifetime”](#configure-cosmos-db-emulator-container-with-persistent-lifetime)

To configure the Cosmos DB emulator container with a persistent lifetime, call the `WithLifetime` method on the Cosmos DB emulator container resource and pass `ContainerLifetime.Persistent`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithLifetime(ContainerLifetime.Persistent);
    });


// After adding all resources, run the app...
```

#### Configure Cosmos DB emulator container with data volume

[Section titled “Configure Cosmos DB emulator container with data volume”](#configure-cosmos-db-emulator-container-with-data-volume)

To add a data volume to the Azure Cosmos DB emulator resource, call the `WithDataVolume` method on the Azure Cosmos DB emulator resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithDataVolume();
    });


// After adding all resources, run the app...
```

The data volume is used to persist the Cosmos DB emulator data outside the lifecycle of its container. The data volume is mounted at the `/tmp/cosmos/appdata` path in the Cosmos DB emulator container and when a `name` parameter isn’t provided, the name is generated. The emulator has its `AZURE_COSMOS_EMULATOR_ENABLE_DATA_PERSISTENCE` environment variable set to `true`. For more information on data volumes and details on why they’re preferred over bind mounts, see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

### Configure Cosmos DB emulator container partition count

[Section titled “Configure Cosmos DB emulator container partition count”](#configure-cosmos-db-emulator-container-partition-count)

To configure the partition count of the Cosmos DB emulator container, call the `WithPartitionCount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsEmulator(emulator =>
    {
        emulator.WithPartitionCount(100); // Defaults to 25
    });


// After adding all resources, run the app...
```

The preceding code configures the Cosmos DB emulator container to have a partition count of `100`. This is a shorthand for setting the `AZURE_COSMOS_EMULATOR_PARTITION_COUNT` environment variable.

### Use Linux-based emulator (preview)

[Section titled “Use Linux-based emulator (preview)”](#use-linux-based-emulator-preview)

The [next generation of the Azure Cosmos DB emulator](https://learn.microsoft.com/azure/cosmos-db/emulator-linux) is entirely Linux-based and is available as a Docker container. It supports running on a wide variety of processors and operating systems.

To use the preview version of the Cosmos DB emulator, call the `RunAsPreviewEmulator` method. Since this feature is in preview, you need to explicitly opt into the preview feature by suppressing the `ASPIRECOSMOSDB001` experimental diagnostic.

The preview emulator also supports exposing a “Data Explorer” endpoint which allows you to view the data stored in the Cosmos DB emulator via a web UI. To enable the Data Explorer, call the `WithDataExplorer` method.

```csharp
#pragma warning disable ASPIRECOSMOSDB001


var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos-db")
    .RunAsPreviewEmulator(emulator =>
    {
        emulator.WithDataExplorer();
    });


// After adding all resources, run the app...
```

The preceding code configures the Linux-based preview Cosmos DB emulator container, with the Data Explorer endpoint, to use at run time.

## Provisioning-generated Bicep

[Section titled “Provisioning-generated Bicep”](#provisioning-generated-bicep)

If you’re new to [Bicep](https://learn.microsoft.com/azure/azure-resource-manager/bicep/overview), it’s a domain-specific language for defining Azure resources. With Aspire, you don’t need to write Bicep by-hand, instead the provisioning APIs generate Bicep for you. When you publish your app, the generated Bicep is output alongside the manifest file. When you add an Azure Cosmos DB resource, the following Bicep is generated:

"Generated

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


resource cosmos 'Microsoft.DocumentDB/databaseAccounts@2024-08-15' = {
  name: take('cosmos-${uniqueString(resourceGroup().id)}', 44)
  location: location
  properties: {
    locations: [
      {
        locationName: location
        failoverPriority: 0
      }
    ]
    capabilities: [
      {
        name: 'EnableServerless'
      }
    ]
    consistencyPolicy: {
      defaultConsistencyLevel: 'Session'
    }
    databaseAccountOfferType: 'Standard'
    disableLocalAuth: true
  }
  kind: 'GlobalDocumentDB'
  tags: {
    'aspire-resource-name': 'cosmos'
  }
}


output connectionString string = cosmos.properties.documentEndpoint


output name string = cosmos.name
```

The preceding Bicep is a module that provisions an Azure Cosmos DB account resource. Additionally, role assignments are created for the Azure resource in a separate module:

Generated Bicep — cosmos-roles.bicep

```bicep
@description('The location for the resource(s) to be deployed.')
param location string = resourceGroup().location


param cosmos_outputs_name string


param principalId string


resource cosmos 'Microsoft.DocumentDB/databaseAccounts@2024-08-15' existing = {
  name: cosmos_outputs_name
}


resource cosmos_roleDefinition 'Microsoft.DocumentDB/databaseAccounts/sqlRoleDefinitions@2024-08-15' existing = {
  name: '00000000-0000-0000-0000-000000000002'
  parent: cosmos
}


resource cosmos_roleAssignment 'Microsoft.DocumentDB/databaseAccounts/sqlRoleAssignments@2024-08-15' = {
  name: guid(principalId, cosmos_roleDefinition.id, cosmos.id)
  properties: {
    principalId: principalId
    roleDefinitionId: cosmos_roleDefinition.id
    scope: cosmos.id
  }
  parent: cosmos
}
```

The generated Bicep is a starting point and is influenced by changes to the provisioning infrastructure in C#. Customizations to the Bicep file directly will be overwritten, so make changes through the C# provisioning APIs to ensure they are reflected in the generated files.

### Customize provisioning infrastructure

[Section titled “Customize provisioning infrastructure”](#customize-provisioning-infrastructure)

All Aspire Azure resources are subclasses of the `AzureProvisioningResource` type. This type enables the customization of the generated Bicep by providing a fluent API to configure the Azure resources—using the `ConfigureInfrastructure` API. For example, you can configure the `kind`, `consistencyPolicy`, `locations`, and more. The following example demonstrates how to customize the Azure Cosmos DB resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureCosmosDB("cosmos-db")
    .ConfigureInfrastructure(infra =>
    {
        var cosmosDbAccount = infra.GetProvisionableResources()
                                    .OfType<CosmosDBAccount>()
                                    .Single();


        cosmosDbAccount.Kind = CosmosDBAccountKind.MongoDB;
        cosmosDbAccount.ConsistencyPolicy = new()
        {
            DefaultConsistencyLevel = DefaultConsistencyLevel.Strong,
        };
        cosmosDbAccount.Tags.Add("ExampleKey", "Example value");
    });
```

The preceding code:

* Chains a call to the `ConfigureInfrastructure` API:

  * The `infra` parameter is an instance of the `AzureResourceInfrastructure` type.
  * The provisionable resources are retrieved by calling the `GetProvisionableResources` method.
  * The single `CosmosDBAccount` is retrieved.
  * The `CosmosDBAccount.ConsistencyPolicy` is assigned to a `DefaultConsistencyLevel.Strong`.
  * A tag is added to the Cosmos DB account with a key of `ExampleKey` and a value of `Example value`.

## Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Azure Cosmos DB hosting integration automatically adds a health check for the Cosmos DB resource. The health check verifies that the Cosmos DB is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.CosmosDb](https://www.nuget.org/packages/AspNetCore.HealthChecks.CosmosDb) NuGet package.

# Azure PostgreSQL EF Core Client integration reference

> Learn how to use the Aspire Azure PostgreSQL EF Core Client integration to interact with Azure PostgreSQL databases from your Aspire projects.

![Azure Database for PostgreSQL logo](/_astro/azure-postgresql-icon.BMlm1jYK_ZWuyLk.webp)

To get started with the Aspire Azure PostgreSQL EF Core integrations, follow the [Get started with Azure PostgreSQL integrations](/integrations/databases/efcore/azure-postgresql/azure-postgresql-get-started/) guide.

This article includes full details about the Aspire Azure PostgreSQL EF Core Client integration, which allows you to connect to and interact with Azure PostgreSQL databases from your Aspire consuming projects using Entity Framework Core.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire Azure PostgreSQL Entity Framework Core client integration, install the [📦 Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL](https://www.nuget.org/packages/Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL/) NuGet package in the client-consuming project, that is, the project for the application that uses the Azure PostgreSQL EF Core client. The Aspire Azure PostgreSQL Entity Framework Core client integration registers your desired `DbContext` subclass instances that you can use to interact with PostgreSQL.

* .NET CLI

  .NET CLI — Add Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL package

  ```bash
  dotnet add package Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL" Version="*" />
  ```

## Add Azure Npgsql database context

[Section titled “Add Azure Npgsql database context”](#add-azure-npgsql-database-context)

The Azure PostgreSQL connection can be consumed using the EF Core client integration by calling the `AddAzureNpgsqlDbContext`:

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDbContext<YourDbContext>(
    connectionName: "postgresdb");
```

Note

To use this code, you must create a `DbContext` class called `YourDbContext` in your project. This class defines your database schema using EF Core. For more information on creating and configuring a `DbContext`, see [DbContext Lifetime, Configuration, and Initialization](https://learn.microsoft.com/ef/core/dbcontext-configuration/) in the EF Core documentation.

Tip

The `connectionName` parameter must match the name used when adding the PostgreSQL server resource in the AppHost project.

The preceding code snippet demonstrates how to use the `AddAzureNpgsqlDbContext` method to register a `YourDbContext` (that’s [pooled for performance](https://learn.microsoft.com/ef/core/performance/advanced-performance-topics)) instance that uses Azure authentication ([Microsoft Entra ID](https://learn.microsoft.com/azure/postgresql/flexible-server/concepts-azure-ad-authentication)). This `"postgresdb"` connection name corresponds to a connection string configuration value.

After adding `YourDbContext` to the builder, you can get the `YourDbContext` instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

```csharp
public class ExampleService(YourDbContext context)
{
    // Use context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Properties of the Azure PostgreSQL resources

[Section titled “Properties of the Azure PostgreSQL resources”](#properties-of-the-azure-postgresql-resources)

When you use the `WithReference` method to pass an Azure PostgreSQL flexible server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `postgresdb` becomes `POSTGRESDB_URI`.

### Azure PostgreSQL flexible server resource

[Section titled “Azure PostgreSQL flexible server resource”](#azure-postgresql-flexible-server-resource)

The Azure PostgreSQL flexible server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                                                                                                                                                                                                                |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`                 | The hostname or IP address of the Azure PostgreSQL flexible server                                                                                                                                                                                                                                                                                                         |
| `Port`                 | The port number the PostgreSQL server is listening on                                                                                                                                                                                                                                                                                                                      |
| `Username`             | The username for authentication. This property is emitted when the server is configured for password authentication and may be omitted when using the default Microsoft Entra ID authentication.                                                                                                                                                                           |
| `Password`             | The password for authentication. This property is emitted only when using password authentication and is not present when using Microsoft Entra ID authentication.                                                                                                                                                                                                         |
| `Uri`                  | The connection URI in postgresql:// format that does not embed credentials, for example `postgresql://{Host}:{Port}?sslmode=Require`                                                                                                                                                                                                                                       |
| `JdbcConnectionString` | JDBC-format connection string without embedded credentials, for example `jdbc:postgresql://{Host}:{Port}?sslmode=require&authenticationPluginClassName=com.azure.identity.extensions.jdbc.postgresql.AzurePostgresqlAuthenticationPlugin`. User and password credentials are provided as separate `Username` and `Password` properties when using password authentication. |

### Azure PostgreSQL database resource

[Section titled “Azure PostgreSQL database resource”](#azure-postgresql-database-resource)

The Azure PostgreSQL database resource inherits all properties from its parent `AzurePostgresFlexibleServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                                                                                                                                                                                                                                    |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI in postgresql:// format that does not embed credentials, for example `postgresql://{Host}:{Port}/{DatabaseName}?sslmode=Require`. Credentials are exposed via other properties.                                                                                                                                                                                                             |
| `JdbcConnectionString` | JDBC connection string including the database name without embedded credentials, for example `jdbc:postgresql://{Host}:{Port}/{DatabaseName}?sslmode=require&authenticationPluginClassName=com.azure.identity.extensions.jdbc.postgresql.AzurePostgresqlAuthenticationPlugin`. User and password credentials are provided as separate `Username` and `Password` properties when using password authentication. |
| `DatabaseName`         | The name of the database                                                                                                                                                                                                                                                                                                                                                                                       |

## Enrich an Npgsql database context

[Section titled “Enrich an Npgsql database context”](#enrich-an-npgsql-database-context)

You may prefer to use the standard Entity Framework method to obtain a database context and add it to the dependency injection container:

C# — Program.cs

```csharp
builder.Services.AddDbContext<YourDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("postgresdb")
        ?? throw new InvalidOperationException("Connection string 'postgresdb' not found.")));
```

Note

The connection string name that you pass to the `GetConnectionString` method must match the name used when adding the PostgreSQL server resource in the AppHost project. For more information, see [Add an Azure Database for PostgreSQL resource](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/#add-an-azure-database-for-postgresql-resource).

You have more flexibility when you create the database context in this way, for example:

* You can reuse existing configuration code for the database context without rewriting it for Aspire.
* You can use Entity Framework Core interceptors to modify database operations.
* You can choose not to use Entity Framework Core context pooling, which may perform better in some circumstances.

If you use this method, you can enhance the database context with Aspire retries, health checks, logging, and telemetry features by calling the `EnrichAzureNpgsqlDbContext` method:

C# — Program.cs

```csharp
builder.EnrichAzureNpgsqlDbContext<YourDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30;
    });
```

The `settings` parameter is an instance of the `AzureNpgsqlEntityFrameworkCorePostgreSQLSettings` class.

You might also need to configure specific options of Npgsql, or register a `System.Data.Entity.DbContext` in other ways. In this case, you do so by calling the `EnrichAzureNpgsqlDbContext` extension method, as shown in the following example:

C# — Program.cs

```csharp
var connectionString = builder.Configuration.GetConnectionString("postgresdb");


builder.Services.AddDbContextPool<YourDbContext>(
    dbContextOptionsBuilder => dbContextOptionsBuilder.UseNpgsql(connectionString));


builder.EnrichAzureNpgsqlDbContext<YourDbContext>();
```

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire Azure PostgreSQL EntityFrameworkCore Npgsql integration provides multiple options to configure the database connection based on the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string defined in the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `AddAzureNpgsqlDataSource`:

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDbContext<YourDbContext>("postgresdb");
```

The connection string is retrieved from the `ConnectionStrings` configuration section, for example, consider the following JSON configuration:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "postgresdb": "Host=myserver;Database=test"
  }
}
```

For more information on how to configure the connection string, see the [Npgsql connection string documentation](https://www.npgsql.org/doc/connection-string-parameters.html).

Note

The username and password are automatically inferred from the credential provided in the settings.

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Azure PostgreSQL EntityFrameworkCore Npgsql integration supports `Microsoft.Extensions.Configuration`. It loads the `AzureNpgsqlEntityFrameworkCorePostgreSQLSettings` from configuration using the `Aspire:Npgsql:EntityFrameworkCore:PostgreSQL` key. For example, consider the following *appsettings.json* file that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "EntityFrameworkCore": {
        "PostgreSQL": {
          "DisableHealthChecks": true,
          "DisableTracing": true
        }
      }
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can configure settings in code, by passing the `Action<AzureNpgsqlEntityFrameworkCorePostgreSQLSettings> configureSettings` delegate to set up some or all the options inline, for example to disable health checks from code:

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDbContext<YourDbContext>(
    "postgresdb",
    settings => settings.DisableHealthChecks = true);
```

Alternatively, you can use the `EnrichAzureNpgsqlDbContext` extension method to configure the settings:

```csharp
builder.EnrichAzureNpgsqlDbContext<YourDbContext>(
    settings => settings.DisableHealthChecks = true);
```

Use the `AzureNpgsqlEntityFrameworkCorePostgreSQLSettings.Credential` property to establish a connection. If no credential is configured, the `DefaultAzureCredential` is used.

When the connection string contains a username and password, the credential is ignored.

### Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

In the rare case that the `Username` property isn’t provided and the integration can’t detect it using the application’s Managed Identity, Npgsql throws an exception with a message similar to the following:

> Npgsql.PostgresException (0x80004005): 28P01: password authentication failed for user …

In this case you can configure the `Username` property in the connection string and use `EnrichAzureNpgsqlDbContext`, passing the connection string in `UseNpgsql`:

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<YourDbContext>(
    options => options.UseNpgsql(newConnectionString));


builder.EnrichAzureNpgsqlDbContext<YourDbContext>();
```

## Configure multiple DbContext classes

[Section titled “Configure multiple DbContext classes”](#configure-multiple-dbcontext-classes)

If you want to register more than one `DbContext` with different configuration, you can use `$"Aspire:Npgsql:EntityFrameworkCore:PostgreSQL:{typeof(TContext).Name}"` configuration section name. The json configuration would look like:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "EntityFrameworkCore": {
        "PostgreSQL": {
          "ConnectionString": "<YOUR CONNECTION STRING>",
          "DisableHealthChecks": true,
          "DisableTracing": true,
          "AnotherDbContext": {
            "ConnectionString": "<ANOTHER CONNECTION STRING>",
            "DisableTracing": false
          }
        }
      }
    }
  }
}
```

Then calling the `AddAzureNpgsqlDbContext` method with `AnotherDbContext` type parameter would load the settings from `Aspire:Npgsql:EntityFrameworkCore:PostgreSQL:AnotherDbContext` section.

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDbContext<AnotherDbContext>();
```

By default, the Aspire PostgreSQL Entity Framework Core integrations handles the following:

* Adds the [`DbContextHealthCheck`](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/src/HealthChecks.NpgSql/NpgSqlHealthCheck.cs), which calls EF Core’s `CanConnectAsync` method. The name of the health check is the name of the `TContext` type.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

### Logging

[Section titled “Logging”](#logging)

The Aspire PostgreSQL Entity Framework Core integration uses the following Log categories:

* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Database.Connection`
* `Microsoft.EntityFrameworkCore.Database.Transaction`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Model`
* `Microsoft.EntityFrameworkCore.Model.Validation`
* `Microsoft.EntityFrameworkCore.Query`
* `Microsoft.EntityFrameworkCore.Update`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire PostgreSQL Entity Framework Core integration will emit the following tracing activities using OpenTelemetry:

* `Npgsql`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire PostgreSQL Entity Framework Core integration will emit the following metrics using OpenTelemetry:

* Microsoft.EntityFrameworkCore:

  * `ec_Microsoft_EntityFrameworkCore_active_db_contexts`
  * `ec_Microsoft_EntityFrameworkCore_total_queries`
  * `ec_Microsoft_EntityFrameworkCore_queries_per_second`
  * `ec_Microsoft_EntityFrameworkCore_total_save_changes`
  * `ec_Microsoft_EntityFrameworkCore_save_changes_per_second`
  * `ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate`
  * `ec_Microsoft_Entity_total_execution_strategy_operation_failures`
  * `ec_Microsoft_E_execution_strategy_operation_failures_per_second`
  * `ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures`
  * `ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second`

* Npgsql:

  * `ec_Npgsql_bytes_written_per_second`
  * `ec_Npgsql_bytes_read_per_second`
  * `ec_Npgsql_commands_per_second`
  * `ec_Npgsql_total_commands`
  * `ec_Npgsql_current_commands`
  * `ec_Npgsql_failed_commands`
  * `ec_Npgsql_prepared_commands_ratio`
  * `ec_Npgsql_connection_pools`
  * `ec_Npgsql_multiplexing_average_commands_per_batch`
  * `ec_Npgsql_multiplexing_average_write_time_per_batch`

# Get started with the Azure PostgreSQL EF Core integrations

> Learn how to set up the Aspire Azure PostgreSQL Hosting and EF Core Client integrations simply.

![Azure Database for PostgreSQL logo](/_astro/azure-postgresql-icon.BMlm1jYK_1qfavO.webp)

[Azure Database for PostgreSQL](https://learn.microsoft.com/azure/postgresql/) Flexible Server is a relational database service based on the open-source Postgres database engine. It’s a fully managed database-as-a-service that can handle mission-critical workloads with predictable performance, security, high availability, and dynamic scalability. The Aspire Azure PostgreSQL integration provides a way to connect to existing Azure PostgreSQL databases, or create new instances from .NET with the [`docker.io/library/postgres` container image](https://hub.docker.com/_/postgres). This client integration uses Entity Framework Core (EF Core) to provide a robust, type-safe way to interact with your Azure PostgreSQL databases using .NET objects.

In this introduction, you’ll see how to install and use the Aspire Azure PostgreSQL integrations in a simple configuration. If you already have this knowledge, see [Azure PostgreSQL Hosting integration](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Azure PostgreSQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Azure PostgreSQL flexible server instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.PostgreSQL package

  ```bash
  aspire add azure-postgresql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-postgresql (Aspire.Hosting.Azure.PostgreSQL)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.PostgreSQL" Version="*" />
  ```

Next, in the AppHost project, create instances of Azure PostgreSQL flexible server and database resources, then pass the database to the consuming client projects:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(postgresdb)
                            .WithReference(postgresdb);
```

Tip

This is the simplest implementation of Azure PostgreSQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Azure PostgreSQL Hosting integration](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/).

Caution

When you call `AddAzurePostgresFlexibleServer`, it implicitly calls `AddAzureProvisioning`, which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Azure PostgreSQL Entity Framework Core client integration:

* .NET CLI

  .NET CLI — Add Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL package

  ```bash
  dotnet add package Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddAzureNpgsqlDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddAzureNpgsqlDbContext<ExampleDbContext>(connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure PostgreSQL database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected Azure PostgreSQL properties

[Section titled “Use injected Azure PostgreSQL properties”](#use-injected-azure-postgresql-properties)

In the AppHost, when you used the `WithReference` method to pass an Azure PostgreSQL database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `postgresdb` becomes `POSTGRESDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string postgresHost = builder.Configuration.GetValue<string>("POSTGRESDB_HOST");
string postgresPort = builder.Configuration.GetValue<string>("POSTGRESDB_PORT");
string postgresJDBCConnectionString = builder.Configuration.GetValue<string>("POSTGRESDB_JDBCCONNECTIONSTRING");
```

Tip

The full set of properties that Aspire injects depends on the Azure PostgreSQL resource configuration. For more information, see [Properties of the Azure PostgreSQL resources](/integrations/databases/efcore/azure-postgresql/azure-postgresql-client/#properties-of-the-azure-postgresql-resources).

### Use Azure PostgreSQL resources in client code

[Section titled “Use Azure PostgreSQL resources in client code”](#use-azure-postgresql-resources-in-client-code)

Now that you’ve added `DbContext` to the builder in the consuming project, you can use the Azure PostgreSQL database to get and store data. Get the `DbContext` instance using dependency injection. For example, to retrieve your context object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use database context...
}
```

Having obtained the context, you can work with the Azure PostgreSQL database using Entity Framework Core as you would in any other C# application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with Azure PostgreSQL integrations up and running, you can use the following reference documents to learn how to configure and interact with the Azure PostgreSQL resources:

[Understand the Azure PostgreSQL hosting integration ](/integrations/cloud/azure/azure-postgresql/azure-postgresql-host/)Discover how to configure Azure resources, run as a container, and more.

[Understand the Azure PostgreSQL client integration ](/integrations/databases/efcore/azure-postgresql/azure-postgresql-client/)Learn about the Azure PostgreSQL client integration, including connection strings and observability.

# Azure SQL EF Core Client integration reference

> Learn how to use the Aspire Azure SQL EF Core Client integration to interact with Azure SQL databases from your Aspire projects.

![Azure SQL Database logo](/_astro/azure-sqlserver-icon.Cqcoy_ug_bKS6O.webp)

To get started with the Aspire Azure SQL EF Core integrations, follow the [Get started with Azure SQL integrations](/integrations/databases/efcore/azure-sql/azure-sql-get-started/) guide.

This article includes full details about the Aspire Azure SQL EF Core Client integration, which allows you to connect to and interact with Azure SQL databases from your Aspire consuming projects using Entity Framework Core.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire Azure SQL Server Entity Framework Core client integration, install the [📦 Aspire.Microsoft.EntityFrameworkCore.SqlServer](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.SqlServer) NuGet package in the client-consuming project, that is, the project for the application that uses the Azure SQL Server EF Core client.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.SqlServer" Version="*" />
  ```

## Add SQL Server database context

[Section titled “Add SQL Server database context”](#add-sql-server-database-context)

In the `Program.cs` file of your client-consuming project, call the `AddSqlServerDbContext` extension method on any `IHostApplicationBuilder` to register a `Microsoft.EntityFrameworkCore.DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>(
    connectionName: "database");
```

Note

To use this code, you must create a `DbContext` class called `ExampleDbContext` in your project. This class defines your database schema using EF Core. For more information on creating and configuring a `DbContext`, see [DbContext Lifetime, Configuration, and Initialization](https://learn.microsoft.com/ef/core/dbcontext-configuration/) in the EF Core documentation.

Tip

The `connectionName` parameter must match the name used when adding the SQL Server database resource in the AppHost project. In other words, when you call `AddDatabase` and provide a name of `database` that same name should be used when calling `AddSqlServerDbContext`.

To retrieve `ExampleDbContext` object from a service:

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Properties of the Azure SQL resources

[Section titled “Properties of the Azure SQL resources”](#properties-of-the-azure-sql-resources)

When you use the `WithReference` method to pass an Azure SQL server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `sqldb` becomes `SQLDB_URI`.

### Azure SQL server resource

[Section titled “Azure SQL server resource”](#azure-sql-server-resource)

The Azure SQL server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                                               |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`                 | The hostname or IP address of the Azure SQL Server                                                                                                                                                        |
| `Port`                 | The port number the SQL Server is listening on                                                                                                                                                            |
| `Username`             | The username for authentication                                                                                                                                                                           |
| `Password`             | The password for authentication                                                                                                                                                                           |
| `Uri`                  | The connection URI in mssql:// format, with the format `mssql://{Username}:{Password}@{Host}:{Port}`                                                                                                      |
| `JdbcConnectionString` | JDBC-format connection string, with the format `jdbc:sqlserver://{Host}:{Port};trustServerCertificate=true`. User and password credentials are provided as separate `Username` and `Password` properties. |

**Example connection strings:**

```plaintext
Uri: mssql://sa:p%40ssw0rd1@myserver.database.windows.net:1433
JdbcConnectionString: jdbc:sqlserver://myserver.database.windows.net:1433;trustServerCertificate=true
```

### Azure SQL database resource

[Section titled “Azure SQL database resource”](#azure-sql-database-resource)

The Azure SQL database resource inherits all properties from its parent `AzureSqlServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                                                                       |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI in mssql:// format, with the format `mssql://{Username}:{Password}@{Host}:{Port}/{DatabaseName}`                                                                                                                               |
| `JdbcConnectionString` | JDBC connection string with database name, with the format `jdbc:sqlserver://{Host}:{Port};trustServerCertificate=true;databaseName={DatabaseName}`. User and password credentials are provided as separate `Username` and `Password` properties. |
| `DatabaseName`         | The name of the database                                                                                                                                                                                                                          |

**Example connection strings:**

```plaintext
Uri: mssql://sa:p%40ssw0rd1@myserver.database.windows.net:1433/catalog
JdbcConnectionString: jdbc:sqlserver://myserver.database.windows.net:1433;trustServerCertificate=true;databaseName=catalog
```

## Enrich a SQL Server database context

[Section titled “Enrich a SQL Server database context”](#enrich-a-sql-server-database-context)

You may prefer to use the standard Entity Framework method to obtain a database context and add it to the dependency injection container:

C# — Program.cs

```csharp
builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));
```

Note

The connection string name that you pass to the `Microsoft.Extensions.Configuration.ConfigurationExtensions.GetConnectionString` method must match the name used when adding the SQL server resource in the AppHost project.

You have more flexibility when you create the database context in this way, for example:

* You can reuse existing configuration code for the database context without rewriting it for Aspire.
* You can use Entity Framework Core interceptors to modify database operations.
* You can choose not to use Entity Framework Core context pooling, which may perform better in some circumstances.

If you use this method, you can enhance the database context with Aspire-style retries, health checks, logging, and telemetry features by calling the `EnrichSqlServerDbContext` method:

C# — Program.cs

```csharp
builder.EnrichSqlServerDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

The `settings` parameter is an instance of the `MicrosoftEntityFrameworkCoreSqlServerSettings` class.

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire SQL Server Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use connection string

[Section titled “Use connection string”](#use-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddSqlServerDbContext<TContext>()`:

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>("sql");
```

The connection string is retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "sql": "Data Source=myserver;Initial Catalog=master"
  }
}
```

The `EnrichSqlServerDbContext` won’t make use of the `ConnectionStrings` configuration section since it expects a `DbContext` to be registered at the point it’s called.

For more information, see the [ConnectionString](https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring#remarks).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire SQL Server Entity Framework Core integration supports `Microsoft.Extensions.Configuration`. It loads the `MicrosoftEntityFrameworkCoreSqlServerSettings` from configuration files such as `appsettings.json` by using the `Aspire:Microsoft:EntityFrameworkCore:SqlServer` key. If you have set up your configurations in the `Aspire:Microsoft:EntityFrameworkCore:SqlServer` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` file that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "EntityFrameworkCore": {
        "SqlServer": {
          "ConnectionString": "YOUR_CONNECTIONSTRING",
          "DbContextPooling": true,
          "DisableHealthChecks": true,
          "DisableTracing": true,
          "DisableMetrics": false
        }
      }
    }
  }
}
```

### Use inline configurations

[Section titled “Use inline configurations”](#use-inline-configurations)

You can also pass the `Action<MicrosoftEntityFrameworkCoreSqlServerSettings>` delegate to set up some or all the options inline, for example to turn off the metrics:

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<YourDbContext>(
    "sql",
    static settings =>
        settings.DisableMetrics = true);
```

### Configure multiple DbContext connections

[Section titled “Configure multiple DbContext connections”](#configure-multiple-dbcontext-connections)

If you want to register more than one `DbContext` with different configuration, you can use `$"Aspire.Microsoft.EntityFrameworkCore.SqlServer:{typeof(TContext).Name}"` configuration section name. The json configuration would look like:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "EntityFrameworkCore": {
        "SqlServer": {
          "ConnectionString": "YOUR_CONNECTIONSTRING",
          "DbContextPooling": true,
          "DisableHealthChecks": true,
          "DisableTracing": true,
          "DisableMetrics": false,
          "AnotherDbContext": {
            "ConnectionString": "AnotherDbContext_CONNECTIONSTRING",
            "DisableTracing": false
          }
        }
      }
    }
  }
}
```

Then calling the `AddSqlServerDbContext` method with `AnotherDbContext` type parameter would load the settings from `Aspire:Microsoft:EntityFrameworkCore:SqlServer:AnotherDbContext` section.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<AnotherDbContext>("another-sql");
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the configurable options with corresponding default values:

| Name                  | Description                                                                                                          |
| --------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `ConnectionString`    | The connection string of the SQL Server database to connect to.                                                      |
| `DbContextPooling`    | A boolean value that indicates whether the db context will be pooled or explicitly created every time it’s requested |
| `MaxRetryCount`       | The maximum number of retry attempts. Default value is 6, set it to 0 to disable the retry mechanism.                |
| `DisableHealthChecks` | A boolean value that indicates whether the database health check is disabled or not.                                 |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not.                                 |
| `DisableMetrics`      | A boolean value that indicates whether the OpenTelemetry metrics are disabled or not.                                |
| `Timeout`             | The time in seconds to wait for the command to execute.                                                              |

By default, the Aspire Sql Server Entity Framework Core integration handles the following:

* Adds the [`DbContextHealthCheck`](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/src/HealthChecks.NpgSql/NpgSqlHealthCheck.cs), which calls EF Core’s `CanConnectAsync` method. The name of the health check is the name of the `TContext` type.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

### Logging

[Section titled “Logging”](#logging)

The Aspire SQL Server Entity Framework Core integration uses the following Log categories:

* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Database.Connection`
* `Microsoft.EntityFrameworkCore.Database.Transaction`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Model`
* `Microsoft.EntityFrameworkCore.Model.Validation`
* `Microsoft.EntityFrameworkCore.Query`
* `Microsoft.EntityFrameworkCore.Update`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire SQL Server Entity Framework Core integration will emit the following Tracing activities using OpenTelemetry:

* `OpenTelemetry.Instrumentation.EntityFrameworkCore`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire SQL Server Entity Framework Core integration will emit the following metrics using OpenTelemetry:

* Microsoft.EntityFrameworkCore:

  * `ec_Microsoft_EntityFrameworkCore_active_db_contexts`
  * `ec_Microsoft_EntityFrameworkCore_total_queries`
  * `ec_Microsoft_EntityFrameworkCore_queries_per_second`
  * `ec_Microsoft_EntityFrameworkCore_total_save_changes`
  * `ec_Microsoft_EntityFrameworkCore_save_changes_per_second`
  * `ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate`
  * `ec_Microsoft_Entity_total_execution_strategy_operation_failures`
  * `ec_Microsoft_E_execution_strategy_operation_failures_per_second`
  * `ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures`
  * `ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second`

# Get started with the Azure SQL EF Core integrations

> Learn how to set up the Aspire Azure SQL Hosting and EF Core Client integrations simply.

![Azure SQL Database logo](/_astro/azure-sqlserver-icon.Cqcoy_ug_2usF59.webp)

[Azure SQL](https://azure.microsoft.com/products/azure-sql) is a family of relational database management systems that run in the Azure cloud. The database systems are Platform-as-a-Service (PaaS) products that enable database administrators to implement highly scalable and available databases without maintaining complex infrastructures themselves. The Aspire Azure SQL Server Hosting integration provides methods to create a new Azure Database server and databases from code in your Aspire AppHost project. The client integration uses Entity Framework Core (EF Core) to provide a robust, type-safe way to interact with your Azure SQL databases using .NET objects.

In this introduction, you’ll see how to install and use the Aspire Azure SQL integrations in a simple configuration. If you already have this knowledge, see [Azure SQL Hosting integration](/integrations/databases/efcore/azure-sql/azure-sql-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Azure SQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Azure SQL Database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Sql package

  ```bash
  aspire add azure-sql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-sql (Aspire.Hosting.Azure.Sql)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Sql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Sql package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Sql" Version="*" />
  ```

Next, in the AppHost project, create instances of Azure SQL server and database resources, then pass the database to the consuming client projects:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var azureSql = builder.AddAzureSqlServer("azuresql")
                      .AddDatabase("database");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(azureSql)
                            .WithReference(azureSql);
```

Tip

This is the simplest implementation of Azure SQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Azure SQL Hosting integration](/integrations/databases/efcore/azure-sql/azure-sql-host/).

Caution

When you call `AddAzureSqlServer`, it implicitly calls `AddAzureProvisioning`, which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire SQL Server Entity Framework Core client integration:

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.SqlServer" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddSqlServerDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: "database");
```

Tip

The `connectionName` parameter must match the name used when adding the Azure SQL database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected Azure SQL properties

[Section titled “Use injected Azure SQL properties”](#use-injected-azure-sql-properties)

In the AppHost, when you used the `WithReference` method to pass an Azure SQL database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `database` becomes `DATABASE_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string sqlHost = builder.Configuration.GetValue<string>("DATABASE_HOST");
string sqlPort = builder.Configuration.GetValue<string>("DATABASE_PORT");
string sqlJDBCConnectionString = builder.Configuration.GetValue<string>("DATABASE_JDBCCONNECTIONSTRING");
```

Tip

The full set of properties that Aspire injects depends on the Azure SQL resource configuration. For more information, see [Properties of the Azure SQL resources](/integrations/databases/efcore/azure-sql/azure-sql-client/#properties-of-the-azure-sql-resources).

### Use Azure SQL resources in client code

[Section titled “Use Azure SQL resources in client code”](#use-azure-sql-resources-in-client-code)

Now that you’ve added `DbContext` to the builder in the consuming project, you can use the Azure SQL database to get and store data. Get the `DbContext` instance using dependency injection. For example, to retrieve your context object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use database context...
}
```

Having obtained the context, you can work with the Azure SQL database using Entity Framework Core as you would in any other C# application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with Azure SQL integrations up and running, you can use the following reference documents to learn how to configure and interact with the Azure SQL resources:

[Understand the Azure SQL hosting integration ](/integrations/databases/efcore/azure-sql/azure-sql-host/)Discover how to configure Azure resources, run as a container, and more.

[Understand the Azure SQL client integration ](/integrations/databases/efcore/azure-sql/azure-sql-client/)Learn about the Azure SQL client integration, including connection strings and observability.

# Azure SQL Hosting integration reference

> Learn how to use the Aspire Azure SQL Hosting integration to orchestrate and configure Azure SQL databases in your Aspire projects.

![Azure SQL Database logo](/_astro/azure-sqlserver-icon.Cqcoy_ug_bKS6O.webp)

To get started with the Aspire Azure SQL integrations, follow the [Get started with Azure SQL integrations](/integrations/databases/efcore/azure-sql/azure-sql-get-started/) guide.

This article includes full details about the Aspire Azure SQL Hosting integration, which models Azure SQL server and database resources as the `AzureSqlServerResource` and `AzureSqlDatabaseResource` types. To access these types and APIs, you need to install the Azure SQL Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

The Aspire Azure SQL Database hosting integration models the SQL Server as the `AzureSqlServerResource` type and SQL databases as the `AzureSqlDatabaseResource` type. To access these types and APIs for expressing them within your AppHost project, install the [📦 Aspire.Hosting.Azure.Sql](https://www.nuget.org/packages/Aspire.Hosting.Azure.Sql) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Sql package

  ```bash
  aspire add azure-sql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-sql (Aspire.Hosting.Azure.Sql)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Sql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Sql package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Sql" Version="*" />
  ```

## Add Azure SQL server resource and database resource

[Section titled “Add Azure SQL server resource and database resource”](#add-azure-sql-server-resource-and-database-resource)

In your AppHost project, call `AddAzureSqlServer` to add and return an Azure SQL server resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add an Azure SQL database resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var azureSql = builder.AddAzureSqlServer("azuresql")
    .AddDatabase("database");


var myService = builder.AddProject<Projects.MyService>()
    .WithReference(azureSql);
```

The preceding call to `AddAzureSqlServer` configures the Azure SQL server resource to be deployed as an [Azure SQL Database server](https://learn.microsoft.com/azure/azure-sql/database/sql-database-paas-overview).

Caution

When you call `AddAzureSqlServer`, it implicitly calls `AddAzureProvisioning`—which adds support for generating Azure resources dynamically during app startup. The app must configure the appropriate subscription and location. For more information, see [Local provisioning: Configuration](/integrations/cloud/azure/local-provisioning/#configuration).

Note

When you call `WithReference` in the AppHost to pass Azure SQL resources to a consuming project, Aspire makes several properties available to that project, such as connection strings, URIs, and port numbers. For a complete list of these properties, see [Properties of the Azure SQL resources](/integrations/databases/efcore/azure-sql/azure-sql-client/#properties-of-the-azure-sql-resources).

## Connect to an existing Azure SQL server

[Section titled “Connect to an existing Azure SQL server”](#connect-to-an-existing-azure-sql-server)

You might have an existing Azure SQL Database service that you want to connect to. You can chain a call to annotate that your `AzureSqlServerResource` is an existing resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var existingSqlServerName = builder.AddParameter("existingSqlServerName");
var existingSqlServerResourceGroup = builder.AddParameter("existingSqlServerResourceGroup");


var sqlserver = builder.AddAzureSqlServer("sqlserver")
    .AsExisting(existingSqlServerName, existingSqlServerResourceGroup)
    .AddDatabase("database");


builder.AddProject<Projects.ExampleProject>()
    .WithReference(sqlserver);


// After adding all resources, run the app...
```

For more information on treating Azure SQL resources as existing resources, see [Use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

## Run Azure SQL server resource as a container

[Section titled “Run Azure SQL server resource as a container”](#run-azure-sql-server-resource-as-a-container)

The Azure SQL Server hosting integration supports running the Azure SQL server as a local container. This is beneficial for situations where you want to run the Azure SQL server locally for development and testing purposes, avoiding the need to provision an Azure resource or connect to an existing Azure SQL server.

To run the Azure SQL server as a container, call the `RunAsContainer` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var azureSql = builder.AddAzureSqlServer("azuresql")
    .RunAsContainer();


var azureSqlData = azureSql.AddDatabase("database");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
    .WithReference(azureSqlData);
```

The preceding code configures an Azure SQL Database resource to run locally in a container.

Tip

The `RunAsContainer` method is useful for local development and testing. The API exposes an optional delegate that enables you to customize the underlying `SqlServerServerResource` configuration. For example, you can add a data volume or data bind mount. For more information, see the [Aspire SQL Server hosting integration](/integrations/databases/sql-server/sql-server-host/#add-sql-server-resource-with-data-volume) section.

# Apply EF Core migrations in Aspire

> Learn about how to to apply Entity Framework Core migrations in Aspire.

Since Aspire projects use a containerized architecture, databases are ephemeral and can be recreated at any time. Entity Framework Core (EF Core) uses a feature called [migrations](https://learn.microsoft.com/ef/core/managing-schemas/migrations) to create and update database schemas. Since databases are recreated when the app starts, you need to apply migrations to initialize the database schema each time your app starts. This is accomplished by registering a migration service project in your app that runs migrations during startup.

In this tutorial, you learn how to configure Aspire projects to run EF Core migrations during app startup.

Please be sure that you’re already setup your development environment, see [Prerequisites](/get-started/prerequisites/).

## Obtain the starter app

[Section titled “Obtain the starter app”](#obtain-the-starter-app)

This tutorial uses a sample app that demonstrates how to apply EF Core migrations in Aspire. Use Visual Studio to clone [the sample app from GitHub](https://github.com/MicrosoftDocs/aspire-docs-samples/) or use the following command:

```bash
git clone https://github.com/MicrosoftDocs/aspire-docs-samples/
```

The sample app is in the *SupportTicketApi* folder. Open the solution in Visual Studio or VS Code and take a moment to review the sample app and make sure it runs before proceeding. The sample app is a rudimentary support ticket API, and it contains the following projects:

* **SupportTicketApi.Api**: The ASP.NET Core project that hosts the API.
* **SupportTicketApi.AppHost**: Contains the Aspire AppHost and configuration.
* **SupportTicketApi.Data**: Contains the EF Core contexts and models.
* **SupportTicketApi.ServiceDefaults**: Contains the default service configurations.

Run the app to ensure it works as expected. In the Aspire dashboard, wait until all resources are running and healthy. Then select the **https** Swagger endpoint and test the API’s:

HTTP

```http
GET /api/SupportTickets/1 HTTP/1.1
Host: example.com
Accept: application/json
```

To do this, expand the **GET /api/SupportTickets/1** endpoint by expanding the operation and selecting **Try it out**. Select **Execute** to send the request and view the response:

JSON — example response

```json
[
  {
    "id": 1,
    "title": "Initial Ticket",
    "description": "Test ticket, please ignore."
  }
]
```

Close the browser tabs that display the Swagger endpoint and the Aspire dashboard and then stop debugging.

## Create migrations

[Section titled “Create migrations”](#create-migrations)

Start by creating some migrations to apply.

* .NET CLI

  1. Open a terminal ( ⌘+\` `` ⌘+` `` Control + Backtick `` Ctrl` `` Control + Backtick `` Ctrl` `` in Visual Studio Code).

  2. Set `SupportTicketApi/SupportTicketApi.Api` as the current directory.

  3. Use the [`dotnet ef` command-line tool](https://learn.microsoft.com/ef/core/managing-schemas/migrations/#install-the-tools) to create a new migration to capture the initial state of the database schema:

     .NET CLI

     ```bash
     dotnet ef migrations add InitialCreate --project ../SupportTicketApi.Data/SupportTicketApi.Data.csproj
     ```

     The proceeding command:

     * Runs EF Core migration command-line tool in the *SupportTicketApi.Api* directory. `dotnet ef` is run in this location because the API service is where the DB context is used.
     * Creates a migration named *InitialCreate*.
     * Creates the migration in the in the *Migrations* folder in the *SupportTicketApi.Data* project.

* Package Manager Console

  If you prefer using Visual Studio’s Package Manager Console instead of the command line:

  1. Open the **Package Manager Console** in Visual Studio by selecting **Tools** > **NuGet Package Manager** > **Package Manager Console**.

  2. Set the **Default project** dropdown to *SupportTicketApi.Data*.

  3. Set the **Startup project** to *SupportTicketApi.Api* using the dropdown in the toolbar or by right-clicking the project in Solution Explorer and selecting **Set as Startup Project**.

  4. Run the migration command:

     ```powershell
     Add-Migration InitialCreate
     ```

     Caution

     When using Package Manager Console, ensure the startup project is set to the project that contains the DbContext registration (usually your API or web project), and the default project is set to where you want the migrations to be created (usually your data project). Remember to change the startup project back to your AppHost project when you’re done, or the Aspire dashboard won’t start when you press `F5`.

1. Modify the model so that it includes a new property. Open `SupportTicketApi.Data/Models/SupportTicket.cs` and add a new property to the `SupportTicket` class:

   C# — SupportTicket.cs

   ```csharp
   using System.ComponentModel.DataAnnotations;


   namespace SupportTicketApi.Data.Models;


   public sealed class SupportTicket
   {
       public int Id { get; set; }
       [Required]
       public string Title { get; set; } = string.Empty;
       [Required]
       public string Description { get; set; } = string.Empty;
       public bool Completed { get; set; }
   }
   ```

2. Create another new migration to capture the changes to the model:

   * .NET CLI

     .NET CLI

     ```bash
     dotnet ef migrations add AddCompleted --project ../SupportTicketApi.Data/SupportTicketApi.Data.csproj
     ```

   * Package Manager Console

     Package Manager Console

     ```powershell
     Add-Migration AddCompleted
     ```

Now you’ve got some migrations to apply. Next, you’ll create a migration service that applies these migrations during app startup.

## Troubleshoot migration issues

[Section titled “Troubleshoot migration issues”](#troubleshoot-migration-issues)

When working with EF Core migrations in Aspire projects, you might encounter some common issues. Here are solutions to the most frequent problems:

### “No database provider has been configured” error

[Section titled ““No database provider has been configured” error”](#no-database-provider-has-been-configured-error)

If you get an error like “No database provider has been configured for this DbContext” when running migration commands, it’s because the EF tools can’t find a connection string or database provider configuration. This happens because Aspire projects use service discovery and orchestration that’s only available at runtime.

**Solution**: Temporarily add a connection string to your project’s `appsettings.json` file:

1. In your API project (where the DbContext is registered), open or create an `appsettings.json` file.

2. Add a connection string with the same name used in your Aspire AppHost:

   JSON — appsettings.json

   ```json
   {
     "ConnectionStrings": {
       "ticketdb": "Server=(localdb)\\mssqllocaldb;Database=TicketDb;Trusted_Connection=true"
     }
   }
   ```

3. Run your migration commands as normal.

4. Remove the connection string from `appsettings.json` when you’re done, as Aspire will provide it at runtime.

Tip

The connection string name must match what you use in your AppHost. For example, if you use `builder.AddProject<Projects.SupportTicketApi_Api>().WithReference(sqlServer.AddDatabase("ticketdb"))`, then use “ticketdb” as the connection string name.

### Multiple databases in one solution

[Section titled “Multiple databases in one solution”](#multiple-databases-in-one-solution)

When your Aspire solution has multiple services with different databases, create migrations for each database separately:

1. Navigate to each service project directory that has a DbContext.

2. Run migration commands with the appropriate project reference:

   .NET CLI

   ```bash
   # For the first service/database
   dotnet ef migrations add InitialCreate --project ../FirstService.Data/FirstService.Data.csproj


   # For the second service/database
   dotnet ef migrations add InitialCreate --project ../SecondService.Data/SecondService.Data.csproj
   ```

3. Create separate migration services for each database, or handle multiple DbContexts in a single migration service.

### Startup project configuration

[Section titled “Startup project configuration”](#startup-project-configuration)

Ensure you’re running migration commands from the correct project:

* **CLI**: Navigate to the project directory that contains the DbContext registration (usually your API project)
* **Package Manager Console**: Set the startup project to the one that configures the DbContext, and the default project to where migrations should be created

## Create the migration service

[Section titled “Create the migration service”](#create-the-migration-service)

To execute migrations, call the EF Core `Microsoft.EntityFrameworkCore.Migrations.IMigrator.Migrate` method or the `IMigrator.MigrateAsync` method. In this tutorial, you’ll create a separate worker service to apply migrations. This approach separates migration concerns into a dedicated project, which is easier to maintain and allows migrations to run before other services start.

Note

**Where to create migrations**: Migrations should be created in the project that contains your Entity Framework DbContext and model classes (in this example, *SupportTicketApi.Data*). The migration service project references this data project to apply the migrations at startup.

To create a service that applies the migrations:

1. Add a new Worker Service project to the solution. If using Visual Studio, right-click the solution in Solution Explorer and select `Add > New Project`. Select `Worker Service`, name the project `SupportTicketApi.MigrationService` and target **.NET 10.0**. If using the command line, use the following commands from the solution directory:

   .NET CLI

   ```bash
   dotnet new worker -n SupportTicketApi.MigrationService -f "net10.0"
   dotnet sln add SupportTicketApi.MigrationService
   ```

2. Add the SupportTicketApi.Data`and`SupportTicketApi.ServiceDefaults`project references to the`SupportTicketApi.MigrationService\` project using Visual Studio or the command line:

   .NET CLI

   ```bash
   dotnet add SupportTicketApi.MigrationService reference SupportTicketApi.Data
   dotnet add SupportTicketApi.MigrationService reference SupportTicketApi.ServiceDefaults
   ```

3. Add the [📦 Aspire.Microsoft.EntityFrameworkCore.SqlServer](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.SqlServer) NuGet package reference to the *`SupportTicketApi.MigrationService`* project using Visual Studio or the command line:

   .NET CLI

   ```bash
   cd SupportTicketApi.MigrationService
   dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer -v "13.1.0"
   ```

   Tip

   In some cases, you might also need to add the [📦 Microsoft.EntityFrameworkCore.Tools](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Tools) package to prevent EF Core from failing silently without applying migrations. This is particularly relevant when using databases other than SQL Server, such as PostgreSQL. For more information, see [dotnet/efcore#27215](https://github.com/dotnet/efcore/issues/27215#issuecomment-2045767772).

4. Add the highlighted lines to the *`Program.cs`* file in the *`SupportTicketApi.MigrationService`* project:

   C# — Program.cs

   ```csharp
   using SupportTicketApi.Data.Contexts;
   using SupportTicketApi.MigrationService;


   var builder = Host.CreateApplicationBuilder(args);


   builder.AddServiceDefaults();
   builder.Services.AddHostedService<Worker>();


   builder.Services.AddOpenTelemetry()
       .WithTracing(tracing => tracing.AddSource(Worker.ActivitySourceName));


   builder.AddSqlServerDbContext<TicketContext>("sqldata");


   var host = builder.Build();
   host.Run();
   ```

   In the preceding code:

   * The `AddServiceDefaults` extension method [adds service defaults functionality](https://learn.microsoft.com/dotnet/aspire/fundamentals/service-defaults#add-service-defaults-functionality).
   * The `AddOpenTelemetry` extension method [configures OpenTelemetry functionality](https://learn.microsoft.com/dotnet/aspire/fundamentals/telemetry#net-aspire-opentelemetry-integration).
   * The `AddSqlServerDbContext` extension method adds the `TicketContext` service to the service collection. This service is used to run migrations and seed the database.

5. Replace the contents of the `Worker.cs` file in the *`SupportTicketApi.MigrationService`* project with the following code:

   C# — Worker.cs

   ```csharp
   using System.Diagnostics;


   using Microsoft.EntityFrameworkCore;
   using Microsoft.EntityFrameworkCore.Infrastructure;
   using Microsoft.EntityFrameworkCore.Storage;


   using OpenTelemetry.Trace;


   using SupportTicketApi.Data.Contexts;
   using SupportTicketApi.Data.Models;


   namespace SupportTicketApi.MigrationService;


   public class Worker(
       IServiceProvider serviceProvider,
       IHostApplicationLifetime hostApplicationLifetime) : BackgroundService
   {
       public const string ActivitySourceName = "Migrations";
       private static readonly ActivitySource s_activitySource = new(ActivitySourceName);


       protected override async Task ExecuteAsync(
           CancellationToken cancellationToken)
       {
           using var activity = s_activitySource.StartActivity(
               "Migrating database", ActivityKind.Client);


           try
           {
               using var scope = serviceProvider.CreateScope();
               var dbContext = scope.ServiceProvider.GetRequiredService<TicketContext>();


               await RunMigrationAsync(dbContext, cancellationToken);
               await SeedDataAsync(dbContext, cancellationToken);
           }
           catch (Exception ex)
           {
               activity?.AddException(ex);
               throw;
           }


           hostApplicationLifetime.StopApplication();
       }


       private static async Task RunMigrationAsync(
           TicketContext dbContext, CancellationToken cancellationToken)
       {
           var strategy = dbContext.Database.CreateExecutionStrategy();
           await strategy.ExecuteAsync(async () =>
           {
               // Run migration in a transaction to avoid partial migration if it fails.
               await dbContext.Database.MigrateAsync(cancellationToken);
           });
       }


       private static async Task SeedDataAsync(
           TicketContext dbContext, CancellationToken cancellationToken)
       {
           SupportTicket firstTicket = new()
           {
               Title = "Test Ticket",
               Description = "Default ticket, please ignore!",
               Completed = true
           };


           var strategy = dbContext.Database.CreateExecutionStrategy();
           await strategy.ExecuteAsync(async () =>
           {
               // Seed the database
               await using var transaction = await dbContext.Database
                   .BeginTransactionAsync(cancellationToken);


               await dbContext.Tickets.AddAsync(firstTicket, cancellationToken);
               await dbContext.SaveChangesAsync(cancellationToken);
               await transaction.CommitAsync(cancellationToken);
           });
       }
   }
   ```

   In the preceding code:

   * The `ExecuteAsync` method is called when the worker starts. It in turn performs the following steps:

     1. Gets a reference to the `TicketContext` service from the service provider.
     2. Calls `RunMigrationAsync` to apply any pending migrations.
     3. Calls `SeedDataAsync` to seed the database with initial data.
     4. Stops the worker with `StopApplication`.

   * The `RunMigrationAsync` and `SeedDataAsync` methods both encapsulate their respective database operations using execution strategies to handle transient errors that may occur when interacting with the database. To learn more about execution strategies, see [Connection Resiliency](https://learn.microsoft.com/ef/core/miscellaneous/connection-resiliency).

## Add the migration service to the orchestrator

[Section titled “Add the migration service to the orchestrator”](#add-the-migration-service-to-the-orchestrator)

The migration service is created, but it needs to be added to the Aspire AppHost so that it runs when the app starts.

1. In the *`SupportTicketApi.AppHost`* project, open the *`AppHost.cs`* file.

2. Add the following highlighted code:

   C# — AppHost.cs

   ```csharp
   var builder = DistributedApplication.CreateBuilder(args);


   var sql = builder.AddSqlServer("sql")
       .AddDatabase("sqldata");


   var migrations = builder.AddProject<Projects.SupportTicketApi_MigrationService>("migrations")
       .WithReference(sql)
       .WaitFor(sql);


   builder.AddProject<Projects.SupportTicketApi_Api>("api")
       .WithReference(sql)
       .WithReference(migrations)
       .WaitForCompletion(migrations);


   builder.Build().Run();
   ```

   This code enlists the *`SupportTicketApi.MigrationService`* project as a service in the Aspire AppHost. It also ensures that the API resource doesn’t run until the migrations are complete.

   Note

   In the preceding code, the call to `AddDatabase` adds a representation of a SQL Server database to the Aspire application model with a connection string. It *doesn’t* create a database in the SQL Server container. To ensure that the database is created, the sample project calls the EF Core `IDatabaseCreator.EnsureCreated` method from the support ticket API’s `Program.cs` file.

   Tip

   The code creates the SQL Server container each time it runs and applies migrations to it. Data doesn’t persist across debugging sessions and any new database rows you create during testing will not survive an app restart. If you would prefer to persist this data, add a data volume to your container. For more information, see [Add SQL Server resource with data volume](/integrations/databases/sql-server/sql-server-host/#add-sql-server-resource-with-data-volume).

3. If the code cannot resolve the migration service project, add a reference to the migration service project in the AppHost project:

   .NET CLI

   ```bash
   dotnet add SupportTicketApi.AppHost reference SupportTicketApi.MigrationService
   ```

   Caution

   If you are using Visual Studio, and you selected the **`Enlist in Aspire orchestration`** option when creating the Worker Service project, similar code is added automatically with the service name `supportticketapi-migrationservice`. Replace that code with the preceding code.

## Multiple databases scenario

[Section titled “Multiple databases scenario”](#multiple-databases-scenario)

If your Aspire solution uses multiple databases, you have two options for managing migrations:

### Option 1: Separate migration services (Recommended)

[Section titled “Option 1: Separate migration services (Recommended)”](#option-1-separate-migration-services-recommended)

Create a dedicated migration service for each database. This approach provides better isolation and makes it easier to manage different database schemas independently.

1. Create separate migration service projects for each database:

   .NET CLI

   ```bash
   dotnet new worker -n FirstService.MigrationService -f "net8.0"
   dotnet new worker -n SecondService.MigrationService -f "net8.0"
   ```

2. Configure each migration service to handle its specific database context.

3. Add both migration services to your AppHost:

   C# — AppHost.cs

   ```csharp
   var firstDb = sqlServer.AddDatabase("firstdb");
   var secondDb = postgres.AddDatabase("seconddb");


   var firstMigrations = builder.AddProject<Projects.FirstService_MigrationService>()
       .WithReference(firstDb);


   var secondMigrations = builder.AddProject<Projects.SecondService_MigrationService>()
       .WithReference(secondDb);


   // Ensure services wait for their respective migrations
   builder.AddProject<Projects.FirstService_Api>()
       .WithReference(firstDb)
       .WaitFor(firstMigrations);


   builder.AddProject<Projects.SecondService_Api>()
       .WithReference(secondDb)
       .WaitFor(secondMigrations);
   ```

### Option 2: Single migration service with multiple contexts

[Section titled “Option 2: Single migration service with multiple contexts”](#option-2-single-migration-service-with-multiple-contexts)

Alternatively, you can create one migration service that handles multiple database contexts:

1. Add references to all data projects in the migration service.

2. Register all DbContexts in the migration service’s `Program.cs`.

3. Modify the `Worker.cs` to apply migrations for each context:

   C# — Worker.cs

   ```csharp
   public async Task<bool> RunMigrationAsync(IServiceProvider serviceProvider)
   {
       await using var scope = serviceProvider.CreateAsyncScope();


       var firstContext = scope.ServiceProvider.GetRequiredService<FirstDbContext>();
       var secondContext = scope.ServiceProvider.GetRequiredService<SecondDbContext>();


       await firstContext.Database.MigrateAsync();
       await secondContext.Database.MigrateAsync();


       return true;
   }
   ```

## Remove existing seeding code

[Section titled “Remove existing seeding code”](#remove-existing-seeding-code)

Since the migration service seeds the database, you should remove the existing data seeding code from the API project.

1. In the *`SupportTicketApi.Api`* project, open the *`Program.cs`* file.

2. Delete the highlighted lines.

   C# — Program.cs

   ```csharp
   if (app.Environment.IsDevelopment())
   {
       app.UseSwagger();
       app.UseSwaggerUI();


       using (var scope = app.Services.CreateScope())
       {
           var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
           context.Database.EnsureCreated();


           if(!context.Tickets.Any())
           {
               context.Tickets.Add(new SupportTicket
               {
                   Title = "Initial Ticket",
                   Description = "Test ticket, please ignore."
               });


               context.SaveChanges();
           }
       }
   }
   ```

## Test the migration service

[Section titled “Test the migration service”](#test-the-migration-service)

Now that the migration service is configured, run the app to test the migrations.

1. Run the app and observe the `SupportTicketApi` dashboard.

2. After a short wait, the `migrations` service state will display **Finished**.

   ![A screenshot of the Aspire dashboard with the migration service in a Finished state.](/_astro/dashboard-post-migration.D13d726O_Z1zYX4f.webp)

3. Select the `Console logs` icon on the migration service to investigate the logs showing the SQL commands that were executed.

## Get the code

[Section titled “Get the code”](#get-the-code)

You can find the [completed sample app on GitHub](https://github.com/MicrosoftDocs/aspire-docs-samples/tree/solution/SupportTicketApi).

## More sample code

[Section titled “More sample code”](#more-sample-code)

The [Aspire Shop](https://learn.microsoft.com/samples/dotnet/aspire-samples/aspire-shop/) sample app uses this approach to apply migrations. See the `AspireShop.CatalogDbManager` project for the migration service implementation.

# MySQL Pomelo Entity Framework Core Client integration reference

> Learn how to use the Aspire MySQL Pomelo Entity Framework Core Client integration to interact with MySQL databases from your Aspire projects.

![MySQL logo](/_astro/mysqlconnector-icon.De_epwTX_Z2oKUOp.webp)

To get started with the Aspire MySQL Pomelo Entity Framework Core (EF Core) integrations, follow the [Get started with MySQL Pomelo Entity Framework Core integrations](/integrations/databases/efcore/mysql/mysql-get-started/) guide.

This article includes full details about the Aspire MySQL Pomelo EF Core Client integration, which allows you to connect to and interact with MySQL databases from your Aspire consuming projects using .NET classes to represent and manipulate data.

## Installation

[Section titled “Installation”](#installation)

You need a MySQL server and connection information for accessing the server. To get started with the Aspire MySQL database integration, install the [📦 Aspire.Pomelo.EntityFrameworkCore.MySql](https://www.nuget.org/packages/Aspire.Pomelo.EntityFrameworkCore.MySql) NuGet package in the client-consuming project, that is, the project for the application that uses the MySQL EF Core client. The MySQL client integration registers a `DbContext` instance that you can use to interact with the MySQL server.

* .NET CLI

  .NET CLI — Add Aspire.Pomelo.EntityFrameworkCore.MySql package

  ```bash
  dotnet add package Aspire.Pomelo.EntityFrameworkCore.MySql
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Pomelo.EntityFrameworkCore.MySql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Pomelo.EntityFrameworkCore.MySql package reference

  ```xml
  <PackageReference Include="Aspire.Pomelo.EntityFrameworkCore.MySql" Version="*" />
  ```

## Add MySQL database context

[Section titled “Add MySQL database context”](#add-mysql-database-context)

In the `Program.cs` file of your client-consuming project, call the `AddMySqlDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMySqlDbContext<MyDbContext>(connectionName: "mysqldb");
```

Tip

The `connectionName` parameter must match the name used when adding the MySQL database resource in the AppHost project. For more information, see [Add MySQL server and database resources](/integrations/databases/mysql/mysql-host/#add-mysql-server-resource-and-database-resource).

You can then retrieve the `MyDbContext` instance using dependency injection. For example, to retrieve the data source from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(MyDbContext context)
{
    // Use the MySQL database context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Enrich MySQL database context

[Section titled “Enrich MySQL database context”](#enrich-mysql-database-context)

You may prefer to use the standard Entity Framework method to obtain a database context and add it to the dependency injection container:

C# — Program.cs

```csharp
builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseMySql(builder.Configuration.GetConnectionString("mysqldb")
        ?? throw new InvalidOperationException("Connection string 'mysqldb' not found."), ServerVersion.AutoDetect(builder.Configuration.GetConnectionString("mysqldb"))));
```

Note

The connection string name that you pass to the `GetConnectionString` method must match the name used when adding the MySQL resource in the AppHost project. For more information, see [Add MySQL server and database resources](/integrations/databases/mysql/mysql-host/#add-mysql-server-resource-and-database-resource).

You have more flexibility when you create the database context in this way, for example:

* You can reuse existing configuration code for the database context without rewriting it for Aspire.
* You can use Entity Framework Core interceptors to modify database operations.
* You can choose not to use Entity Framework Core context pooling, which may perform better in some circumstances.

If you use this method, you can enhance the database context with Aspire-style retries, health checks, logging, and telemetry features by calling the `EnrichMySqlDatabaseDbContext` method:

C# — Program.cs

```csharp
builder.EnrichMySqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30 // seconds
    });
```

The `settings` parameter is an instance of the `MySqlEntityFrameworkCoreSettings` class.

## Properties of the MySQL resources

[Section titled “Properties of the MySQL resources”](#properties-of-the-mysql-resources)

When you use the `WithReference` method to pass a MySQL server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `ConnectionString` property of a resource called `mysqldb` becomes `MYSQLDB_CONNECTIONSTRING`.

### MySQL server

[Section titled “MySQL server”](#mysql-server)

The MySQL server resource exposes the following connection properties:

| Property Name | Description                                        |
| ------------- | -------------------------------------------------- |
| `Host`        | The hostname or IP address of the MySQL server     |
| `Port`        | The port number the MySQL server is listening on   |
| `Username`    | The username for authentication (typically `root`) |
| `Password`    | The password for authentication                    |

**Example connection properties:**

```plaintext
Host: localhost
Port: 3306
Username: root
Password: <generated-password>
```

### MySQL database

[Section titled “MySQL database”](#mysql-database)

The MySQL database resource inherits all properties from its parent `MySqlServerResource` and adds:

| Property Name      | Description                                                                                                                         |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| `DatabaseName`     | The MySQL database name                                                                                                             |
| `ConnectionString` | The full connection string in the format `Server={Host};Port={Port};User ID={Username};Password={Password};Database={DatabaseName}` |

**Example connection string:**

```plaintext
Server=localhost;Port=3306;User ID=root;Password=<generated-password>;Database=mysqldb
```

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire MySQL Pomelo EF Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddMySqlDbContext()`:

C# — Program.cs

```csharp
builder.AddMySqlDbContext<ExampleDbContext>(connectionName: "mysqldb");
```

The connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "mysql": "Server=mysql;Database=mysqldb"
  }
}
```

For more information on how to format this connection string, see [MySqlConnector: ConnectionString documentation](https://mysqlconnector.net/connection-options/).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire MySQL database integration supports `Microsoft.Extensions.Configuration` from configuration files such as `appsettings.json` by using the `Aspire:MySqlConnector` key. If you have set up your configurations in the `Aspire:MySqlConnector` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Pomelo": {
      "EntityFrameworkCore": {
        "MySql": {
          "DisableHealthChecks": true,
          "DisableTracing": true
          }
        }
      }
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<MySqlEntityFrameworkCoreSettings>` delegate to set up some or all the options inline, for example to disable health checks from code:

C# — Program.cs

```csharp
builder.AddMySqlDbContext<ExampleDbContext>(
    "mysqldb",
    static settings => settings.DisableHealthChecks = true);
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the configurable options with corresponding default values:

| Name                  | Description                                                                         |
| --------------------- | ----------------------------------------------------------------------------------- |
| `ConnectionString`    | The connection string of the MySQL database to connect to                           |
| `DisableHealthChecks` | A boolean value that indicates whether the database health check is disabled or not |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not |

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

By default, the Aspire MySQL EF Core integration handles the following:

* Adds the health check when `MySqlEntityFrameworkCoreSettings.DisableHealthChecks` is `false`, which verifies that a connection can be made and commands can be run against the MySQL database.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire MySQL client integration uses the following log categories:

* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Database.Connection`
* `Microsoft.EntityFrameworkCore.Database.Transaction`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Model`
* `Microsoft.EntityFrameworkCore.Model.Validation`
* `Microsoft.EntityFrameworkCore.Query`
* `Microsoft.EntityFrameworkCore.Update`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire MySQL client integration emits the following tracing activities using OpenTelemetry:

* `MySqlConnector`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire MySQL EF Core integration emits the following metrics using OpenTelemetry:

* `OpenTelemetry.Instrumentation.EntityFrameworkCore`

## See also

[Section titled “See also”](#see-also)

* [MySQL database](https://www.mysql.com/)
* [MySqlConnector](https://mysqlconnector.net/)
* [Aspire integrations](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the MySQL Pomelo Entity Framework Core integrations

> Learn how to set up the Aspire MySQL Pomelo Entity Framework Core Hosting and Client integrations simply.

![MySQL logo](/_astro/mysqlconnector-icon.De_epwTX_Z2oKUOp.webp)

[MySQL](https://www.mysql.com/) is an open-source Relational Database Management System (RDBMS) that uses Structured Query Language (SQL) to manage and manipulate data. It’s employed in many different environments, from small projects to large-scale enterprise systems and it’s a popular choice to host data that underpins microservices in a cloud-native application. The Aspire Pomelo MySQL Entity Framework Core integration enables you to connect to existing MySQL databases or create new instances from .NET with the [`mysql` container image](https://hub.docker.com/_/mysql). Entity Framework Core (EF Core) is an object-database mapper that simplifies data access by allowing developers to work with databases using .NET objects.

In this introduction, you’ll see how to install and use the Aspire MySQL Pomelo Entity Framework Core integrations in a simple configuration. If you already have this knowledge, see [MySQL Hosting integration](/integrations/databases/mysql/mysql-host/) and [MySQL Pomelo Entity Framework Core Client integration reference](/integrations/databases/efcore/mysql/mysql-client/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire MySQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage MySQL database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.MySql package

  ```bash
  aspire add mysql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > mysql (Aspire.Hosting.MySql)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.MySql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.MySql package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.MySql" Version="*" />
  ```

Next, in the AppHost project, create instances of MySQL server and database resources, then pass the database to the consuming client projects:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
                   .WithLifetime(ContainerLifetime.Persistent);


var mysqldb = mysql.AddDatabase("mysqldb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(mysqldb)
                            .WithReference(mysqldb);
```

Tip

This is the simplest implementation of MySQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [MySQL Hosting integration](/integrations/databases/mysql/mysql-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire MySQL Pomelo EF Core client integration:

* .NET CLI

  .NET CLI — Add Aspire.Pomelo.EntityFrameworkCore.MySql package

  ```bash
  dotnet add package Aspire.Pomelo.EntityFrameworkCore.MySql
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Pomelo.EntityFrameworkCore.MySql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Pomelo.EntityFrameworkCore.MySql package reference

  ```xml
  <PackageReference Include="Aspire.Pomelo.EntityFrameworkCore.MySql" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddMySqlDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use through the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMySqlDbContext<MyDbContext>("mysqldb");
```

Tip

The `connectionName` parameter must match the name used when adding the MySQL database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected MySQL properties

[Section titled “Use injected MySQL properties”](#use-injected-mysql-properties)

In the AppHost, when you used the `WithReference` method to pass a MySQL database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `mysqldb` becomes `MYSQLDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string connectionString = builder.Configuration.GetValue<string>("ConnectionStrings__mysqldb");
string host = builder.Configuration.GetValue<string>("MYSQLDB_HOST");
string databaseName = builder.Configuration.GetValue<string>("MYSQLDB_DATABASENAME");
```

Tip

The full set of properties that Aspire injects depends on the MySQL resource configuration. For more information, see [Properties of the MySQL resources](/integrations/databases/efcore/mysql/mysql-client/#properties-of-the-mysql-resources).

### Use MySQL resources in client code

[Section titled “Use MySQL resources in client code”](#use-mysql-resources-in-client-code)

Now that you’ve added the `DbContext` to the builder in the consuming project, you can use the MySQL database. Get the `DbContext` instance using dependency injection. For example, to retrieve your data source object from an example service, define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(MyDbContext context)
{
    // Use MySQL DB Context...
}
```

Having obtained the data context, you can work with the MySQL database as you would in any other C# application using EF Core.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with MySQL Pomelo EF Core integrations up and running, you can use the following reference documents to learn how to configure and interact with the MySQL resources:

[Understand the MySQL hosting integration ](/integrations/databases/mysql/mysql-host/)Discover how to configure data volumes, phpMyAdmin, and more.

[Understand the MySQL client integration ](/integrations/databases/efcore/mysql/mysql-client/)Learn about the MySQL client integration, including connection strings and observability.

# Oracle Client integration reference

> Learn how to use the Aspire Oracle Client integration to interact with Oracle databases from your Aspire projects.

![Oracle Database logo](/_astro/oracle-icon.CmqMr237_Z1NYjKL.svg)

To get started with the Aspire Oracle integrations, follow the [Get started with Oracle integrations](../oracle-get-started/) guide.

This article includes full details about the Aspire Oracle Client integration, which allows you to connect to and interact with Oracle databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

You need an Oracle database and connection string for accessing the database. To get started with the Aspire Oracle client integration, install the [📦 Aspire.Oracle.EntityFrameworkCore](https://www.nuget.org/packages/Aspire.Oracle.EntityFrameworkCore) NuGet package in the client-consuming project, that is, the project for the application that uses the Oracle client. The Oracle client integration registers a `DbContext` instance that you can use to interact with Oracle.

* .NET CLI

  .NET CLI — Add Aspire.Oracle.EntityFrameworkCore package

  ```bash
  dotnet add package Aspire.Oracle.EntityFrameworkCore
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Oracle.EntityFrameworkCore@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Oracle.EntityFrameworkCore package reference

  ```xml
  <PackageReference Include="Aspire.Oracle.EntityFrameworkCore" Version="*" />
  ```

## Add Oracle client

[Section titled “Add Oracle client”](#add-oracle-client)

In the `Program.cs` file of your client-consuming project, call the `AddOracleDatabaseDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: "oracledb");
```

Tip

The `connectionName` parameter must match the name used when adding the Oracle database resource in the AppHost project. For more information, see [Add Oracle server and database resources](../oracle-host/#add-oracle-server-and-database-resources).

You can then retrieve the `DbContext` instance using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use database context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Enrich Oracle database context

[Section titled “Enrich Oracle database context”](#enrich-oracle-database-context)

You may prefer to use the standard Entity Framework method to obtain a database context and add it to the dependency injection container:

C# — Program.cs

```csharp
builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseOracle(builder.Configuration.GetConnectionString("oracledb")
        ?? throw new InvalidOperationException("Connection string 'oracledb' not found.")));
```

Note

The connection string name that you pass to the `GetConnectionString` method must match the name used when adding the Oracle resource in the AppHost project. For more information, see [Add Oracle server and database resources](../oracle-host/#add-oracle-server-and-database-resources).

You have more flexibility when you create the database context in this way, for example:

* You can reuse existing configuration code for the database context without rewriting it for Aspire.
* You can use Entity Framework Core interceptors to modify database operations.
* You can choose not to use Entity Framework Core context pooling, which may perform better in some circumstances.

If you use this method, you can enhance the database context with Aspire-style retries, health checks, logging, and telemetry features by calling the `EnrichOracleDatabaseDbContext` method:

C# — Program.cs

```csharp
builder.EnrichOracleDatabaseDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30 // seconds
    });
```

The `settings` parameter is an instance of the `OracleEntityFrameworkCoreSettings` class.

## Properties of the Oracle resources

[Section titled “Properties of the Oracle resources”](#properties-of-the-oracle-resources)

When you use the `WithReference` method to pass an Oracle server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

### Oracle database server

[Section titled “Oracle database server”](#oracle-database-server)

The Oracle database server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                      |
| ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`                 | The hostname or IP address of the Oracle server                                                                                                                                  |
| `Port`                 | The port number the Oracle server is listening on                                                                                                                                |
| `Username`             | The username for authentication                                                                                                                                                  |
| `Password`             | The password for authentication                                                                                                                                                  |
| `Uri`                  | The connection URI in oracle:// format, with the format `oracle://{Username}:{Password}@{Host}:{Port}`                                                                           |
| `JdbcConnectionString` | JDBC-format connection string, with the format `jdbc:oracle:thin:@//{Host}:{Port}`. User and password credentials are provided as separate `Username` and `Password` properties. |

**Example connection strings:**

```plaintext
Uri: oracle://system:p%40ssw0rd1@localhost:1521
JdbcConnectionString: jdbc:oracle:thin:@//localhost:1521
```

### Oracle database

[Section titled “Oracle database”](#oracle-database)

The Oracle database resource inherits all properties from its parent `OracleDatabaseServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                                 |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI in oracle:// format, with the format `oracle://{Username}:{Password}@{Host}:{Port}/{DatabaseName}`                                                                                       |
| `JdbcConnectionString` | JDBC connection string with database name, with the format `jdbc:oracle:thin:@//{Host}:{Port}/{DatabaseName}`. User and password credentials are provided as separate `Username` and `Password` properties. |
| `DatabaseName`         | The name of the database                                                                                                                                                                                    |

**Example connection strings:**

```plaintext
Uri: oracle://system:p%40ssw0rd1@localhost:1521/FREEPDB1
JdbcConnectionString: jdbc:oracle:thin:@//localhost:1521/FREEPDB1
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire Oracle Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddOracleDatabaseDbContext<TContext>()`:

C# — Program.cs

```csharp
builder.AddOracleDatabaseDbContext<ExampleDbContext>("oracleConnection");
```

The connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "oracleConnection": "Data Source=TORCL;User Id=OracleUser;Password=Non-default-P@ssw0rd;"
  }
}
```

The `EnrichOracleDatabaseDbContext` won’t make use of the `ConnectionStrings` configuration section since it expects a `DbContext` to be registered at the point it is called.

For more information, see the [ODP.NET documentation](https://www.oracle.com/database/technologies/appdev/dotnet/odp.html).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Oracle Entity Framework Core integration supports `Microsoft.Extensions.Configuration` from configuration files such as `appsettings.json` by using the `Aspire:Oracle:EntityFrameworkCore` key. If you have set up your configurations in the `Aspire:Oracle:EntityFrameworkCore` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Oracle": {
      "EntityFrameworkCore": {
        "DisableHealthChecks": true,
        "DisableTracing": true,
        "DisableRetry": false,
        "CommandTimeout": 30
      }
    }
  }
}
```

Tip

The `CommandTimeout` property is in seconds. When set as shown in the preceding example, the timeout is 30 seconds.

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<OracleEntityFrameworkCoreSettings>` delegate to set up some or all the options inline, for example to disable health checks from code:

C# — Program.cs

```csharp
builder.AddOracleDatabaseDbContext<ExampleDbContext>(
    "oracle",
    static settings => settings.DisableHealthChecks  = true);
```

or

C# — Program.cs

```csharp
builder.EnrichOracleDatabaseDbContext<ExampleDbContext>(
    static settings => settings.DisableHealthChecks  = true);
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the configurable options with corresponding default values:

| Name                  | Description                                                                          |
| --------------------- | ------------------------------------------------------------------------------------ |
| `ConnectionString`    | The connection string of the Oracle database to connect to.                          |
| `DisableHealthChecks` | A boolean value that indicates whether the database health check is disabled or not. |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. |
| `DisableRetry`        | A boolean value that indicates whether command retries should be disabled or not.    |
| `CommandTimeout`      | The time in seconds to wait for the command to execute.                              |

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

By default, the Aspire Oracle Entity Framework Core integration handles the following:

* Checks if the `OracleEntityFrameworkCoreSettings.DisableHealthChecks` is `true`.
* If so, adds the `DbContextHealthCheck`, which calls EF Core’s `CanConnectAsync` method. The name of the health check is the name of the `TContext` type.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire Oracle Entity Framework Core integration uses the following log categories:

* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Database.Connection`
* `Microsoft.EntityFrameworkCore.Database.Transaction`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Model`
* `Microsoft.EntityFrameworkCore.Model.Validation`
* `Microsoft.EntityFrameworkCore.Query`
* `Microsoft.EntityFrameworkCore.Update`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire Oracle Entity Framework Core integration will emit the following tracing activities using OpenTelemetry:

* `OpenTelemetry.Instrumentation.EntityFrameworkCore`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire Oracle Entity Framework Core integration currently supports the following metrics:

* `Microsoft.EntityFrameworkCore`

## See also

[Section titled “See also”](#see-also)

* [Oracle Database](https://www.oracle.com/database/)
* [Oracle Database Documentation](https://docs.oracle.com/en/database/oracle/oracle-database/index.html)
* [Entity Framework Core docs](https://learn.microsoft.com/ef/core)
* [Aspire integrations](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the Oracle integrations

> Learn how to set up the Aspire Oracle Hosting and Client integrations simply.

![Oracle Database logo](/_astro/oracle-icon.CmqMr237_Z1NYjKL.svg)

[Oracle Database](https://www.oracle.com/database/technologies/) is a widely-used relational database management system owned and developed by Oracle. The Aspire Oracle integration enables you to connect to existing Oracle servers or create new servers from Aspire with the [`container-registry.oracle.com/database/free` container image](https://container-registry.oracle.com/).

In this introduction, you’ll see how to install and use the Aspire Oracle integrations in a simple configuration. If you already have this knowledge, see [Oracle Hosting integration](../oracle-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Oracle Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Oracle database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Oracle package

  ```bash
  aspire add oracle
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > oracle (Aspire.Hosting.Oracle)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Oracle@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Oracle package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Oracle" Version="*" />
  ```

Next, in the AppHost project, create instances of Oracle server and database resources, then pass the database to the consuming client projects:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var oracle = builder.AddOracle("oracle")
                    .WithLifetime(ContainerLifetime.Persistent);


var oracledb = oracle.AddDatabase("oracledb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(oracledb)
                            .WithReference(oracledb);
```

Tip

This is the simplest implementation of Oracle resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Oracle Hosting integration](../oracle-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Oracle Entity Framework Core client integration:

* .NET CLI

  .NET CLI — Add Aspire.Oracle.EntityFrameworkCore package

  ```bash
  dotnet add package Aspire.Oracle.EntityFrameworkCore
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Oracle.EntityFrameworkCore@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Oracle.EntityFrameworkCore package reference

  ```xml
  <PackageReference Include="Aspire.Oracle.EntityFrameworkCore" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddOracleDatabaseDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddOracleDatabaseDbContext<ExampleDbContext>(connectionName: "oracledb");
```

Tip

The `connectionName` parameter must match the name used when adding the Oracle database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected Oracle properties

[Section titled “Use injected Oracle properties”](#use-injected-oracle-properties)

In the AppHost, when you used the `WithReference` method to pass an Oracle database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `oracledb` becomes `ORACLEDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string oracleHost = builder.Configuration.GetValue<string>("ORACLEDB_HOST");
string oraclePort = builder.Configuration.GetValue<string>("ORACLEDB_PORT");
string oracleJDBCConnectionString = builder.Configuration.GetValue<string>("ORACLEDB_JDBCCONNECTIONSTRING");
```

Tip

The full set of properties that Aspire injects depends on the Oracle resource configuration. For more information, see [Properties of the Oracle resources](../oracle-client/#properties-of-the-oracle-resources).

### Use Oracle resources in client code

[Section titled “Use Oracle resources in client code”](#use-oracle-resources-in-client-code)

Now that you’ve added `DbContext` to the builder in the consuming project, you can use the Oracle database to get and store data. Get the `DbContext` instance using dependency injection. For example, to retrieve your context object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use database context...
}
```

Having obtained the context, you can work with the Oracle database using Entity Framework Core as you would in any other C# application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with Oracle integrations up and running, you can use the following reference documents to learn how to configure and interact with the Oracle resources:

[Understand the Oracle hosting integration ](/integrations/databases/efcore/oracle/oracle-host/)Discover how to configure database scripts, data volumes, and more.

[Understand the Oracle client integration ](/integrations/databases/efcore/oracle/oracle-client/)Learn about the Oracle client integration, including connection strings and observability.

# Oracle Hosting integration reference

> Learn how to use the Aspire Oracle Hosting integration to orchestrate and configure Oracle databases in your Aspire projects.

![Oracle Database logo](/_astro/oracle-icon.CmqMr237_Z1NYjKL.svg)

To get started with the Aspire Oracle integrations, follow the [Get started with Oracle integrations](../oracle-get-started/) guide.

This article includes full details about the Aspire Oracle Hosting integration, which models Oracle server and database resources as the `OracleDatabaseServerResource` and `OracleDatabaseResource` types. To access these types and APIs, you need to install the Oracle Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

The Aspire Oracle hosting integration models various Oracle resources as the following types:

* `OracleDatabaseServerResource`
* `OracleDatabaseResource`

To access these types and APIs for expressing them as resources in your AppHost project, install the [📦 Aspire.Hosting.Oracle](https://www.nuget.org/packages/Aspire.Hosting.Oracle) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Oracle package

  ```bash
  aspire add oracle
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > oracle (Aspire.Hosting.Oracle)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Oracle@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Oracle package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Oracle" Version="*" />
  ```

## Add Oracle server and database resources

[Section titled “Add Oracle server and database resources”](#add-oracle-server-and-database-resources)

In the AppHost project, call `AddOracle` to add and return an Oracle server resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add an Oracle database to the server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var oracle = builder.AddOracle("oracle")
                    .WithLifetime(ContainerLifetime.Persistent);


var oracledb = oracle.AddDatabase("oracledb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(oracledb)
       .WaitFor(oracledb);


// After adding all resources, run the app...
```

Note

The Oracle database container can be slow to start, so it’s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

When Aspire adds a container image to the AppHost, as shown in the preceding example with the `container-registry.oracle.com/database/free` image, it creates a new Oracle server on your local machine. A reference to your Oracle resource builder (the `oracle` variable) is used to add a database. The database is named `oracledb` and then added to the `ExampleProject`. The Oracle resource includes a random `password` generated using the `CreateDefaultPasswordParameter` method.

The `WithReference` method configures a connection in the `ExampleProject` named `"oracledb"`. For more information, see [Container resource lifecycle](/architecture/resource-model/#built-in-resources-and-lifecycle).

Tip

If you’d rather connect to an existing Oracle server, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add Oracle resource with password parameter

[Section titled “Add Oracle resource with password parameter”](#add-oracle-resource-with-password-parameter)

The Oracle resource includes default credentials with a random password. Oracle supports configuration-based default passwords by using the environment variable `ORACLE_PWD`. When you want to provide a password explicitly, you can provide it as a parameter:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var password = builder.AddParameter("password", secret: true);


var oracle = builder.AddOracle("oracle", password)
                    .WithLifetime(ContainerLifetime.Persistent);


var oracledb = oracle.AddDatabase("oracledb");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(oracledb)
                       .WaitFor(oracledb);
```

The preceding code gets a parameter to pass to the `AddOracle` API, and internally assigns the parameter to the `ORACLE_PWD` environment variable of the Oracle container. The `password` parameter is usually specified as a user secret:

JSON — secrets.json

```json
{
  "Parameters": {
    "password": "Non-default-P@ssw0rd"
  }
}
```

For more information, see [External parameters](/get-started/resources/).

## Add Oracle resource with data volume

[Section titled “Add Oracle resource with data volume”](#add-oracle-resource-with-data-volume)

To add a data volume to the Oracle resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var oracle = builder.AddOracle("oracle")
                    .WithDataVolume()
                    .WithLifetime(ContainerLifetime.Persistent);


var oracledb = oracle.AddDatabase("oracledb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(oracledb)
       .WaitFor(oracledb);


// After adding all resources, run the app...
```

The data volume is used to persist the Oracle data outside the lifecycle of its container. The data volume is mounted at the `/opt/oracle/oradata` path in the Oracle container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-oracle-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

Danger

The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume.

## Add Oracle resource with data bind mount

[Section titled “Add Oracle resource with data bind mount”](#add-oracle-resource-with-data-bind-mount)

To add a data bind mount to the Oracle resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var oracle = builder.AddOracle("oracle")
                    .WithDataBindMount(source: @"C:\Oracle\Data");


var oracledb = oracle.AddDatabase("oracledb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(oracledb)
       .WaitFor(oracledb);


// After adding all resources, run the app...
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the Oracle data across container restarts. The data bind mount is mounted at the `C:\Oracle\Data` on Windows (or `/Oracle/Data` on Unix) path on the host machine in the Oracle container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

When you use the `WithReference` method to pass an Oracle database resource to a non-.NET application (such as Python or JavaScript), Aspire automatically injects environment variables that describe the connection information.

For example, if you reference an Oracle database resource named `oracledb`:

C# — AppHost.cs

```csharp
var oracle = builder.AddOracle("oracle");
var oracledb = oracle.AddDatabase("oracledb");


var pythonApp = builder.AddUvicornApp("api", "./api", "main:app")
    .WithReference(oracledb);
```

The following environment variables are available in the Python application:

* `ConnectionStrings__oracledb` - The connection string for the Oracle database
* `ORACLEDB_HOST` - The hostname of the Oracle server
* `ORACLEDB_PORT` - The port number
* `ORACLEDB_USERNAME` - The username for authentication
* `ORACLEDB_PASSWORD` - The password for authentication
* `ORACLEDB_URI` - The connection URI in oracle:// format
* `ORACLEDB_JDBCCONNECTIONSTRING` - JDBC-format connection string
* `ORACLEDB_DATABASENAME` - The database name

You can access these environment variables in your application code:

Python example

```python
import oracledb
import os


# Get connection properties
host = os.getenv("ORACLEDB_HOST")
port = os.getenv("ORACLEDB_PORT")
username = os.getenv("ORACLEDB_USERNAME")
password = os.getenv("ORACLEDB_PASSWORD")
service_name = os.getenv("ORACLEDB_DATABASENAME")


# Create connection
connection = oracledb.connect(
    user=username,
    password=password,
    dsn=f"{host}:{port}/{service_name}"
)
```

JavaScript example

```javascript
const oracledb = require('oracledb');


// Get connection properties
const host = process.env.ORACLEDB_HOST;
const port = process.env.ORACLEDB_PORT;
const user = process.env.ORACLEDB_USERNAME;
const password = process.env.ORACLEDB_PASSWORD;
const serviceName = process.env.ORACLEDB_DATABASENAME;


// Create connection
const connection = await oracledb.getConnection({
  user: user,
  password: password,
  connectString: `${host}:${port}/${serviceName}`
});
```

## Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Oracle hosting integration automatically adds a health check for the Oracle resource. The health check verifies that the Oracle server is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.Oracle](https://www.nuget.org/packages/AspNetCore.HealthChecks.Oracle) NuGet package.

# Entity Framework Core overview

> Learn how to optimize the performance of Aspire Entity Framework Core integrations using their context objects.

Choose a Aspire Entity Framework Core client integration

SQL Server  PostgreSQL  Oracle  Pomelo MySQL

In a cloud-native solution, such as those Aspire is built to create, microservices often need to store data in relational databases. Aspire includes integrations that you can use to ease that task, some of which use the Entity Framework Core (EF Core) object-relational mapper (O/RM) approach to streamline the process.

Developers use O/RMs to work with databases using code objects instead of SQL queries. EF Core automatically codes database interactions by generating SQL queries based on Language-Integrated Query (LINQ) queries. EF Core supports various database providers, including SQL Server, PostgreSQL, and MySQL, so it’s easy to interact with relational databases while following object-oriented principles.

[![](/_astro/azure-cosmosdb-icon.4tqzZo4Z_Z1GPXbO.webp) Cosmos DB ](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-get-started/)Entity Framework Core integration for Azure Cosmos DB

[![](/_astro/mysqlconnector-icon.De_epwTX_1Imktl.webp) MySQL ](/integrations/databases/efcore/mysql/mysql-get-started/)Pomelo Entity Framework Core integration for MySQL

[![](/_astro/oracle-o-icon.D3wVYmne_VqfTo.webp) Oracle ](/integrations/databases/efcore/oracle/oracle-get-started/)Entity Framework Core integration for Oracle Database

[![](/_astro/postgresql-icon.DTORe-rE_3dPMf.webp) PostgreSQL ](/integrations/databases/efcore/postgres/postgresql-get-started/)Entity Framework Core integration for PostgreSQL

[![](/_astro/sql-icon.CyVgV5Qd_UtnJY.webp) SQL Server ](/integrations/databases/efcore/sql-server/sql-server-get-started/)Entity Framework Core integration for SQL Server

## Overview of EF Core

[Section titled “Overview of EF Core”](#overview-of-ef-core)

O/RMs create a model that matches the schema and relationships defined in the database. Code against this model to query the data, create new records, or make other changes. In EF Core the model consists of:

* A set of entity classes, each of which represents a table in the database and its columns.
* A context class that represents the whole database.

An entity class might look like this:

C# — SupportTicket.cs

```csharp
using System.ComponentModel.DataAnnotations;


namespace SupportDeskProject.Data;


public sealed class SupportTicket
{
    public int Id { get; set; }
    [Required]
    public string Title { get; set; } = string.Empty;
    [Required]
    public string Description { get; set; } = string.Empty;
}
```

This entity class represents a database table with three columns: **Id**, **Title**, and **Description**.

A context class must inherit from `System.Data.Entity.DbContext` and looks like this:

C# — TicketContext.cs

```csharp
using Microsoft.EntityFrameworkCore;
using System.Reflection.Metadata;


namespace SupportDeskProject.Data;


public class TicketContext(DbContextOptions options) : DbContext(options)
{
    public DbSet<SupportTicket> Tickets => Set<SupportTicket>();
}
```

This context represents a database with a single table of support tickets. An instance of the context is usually created for each unit of work in the database. For example, a unit of work might be the creation of a new customer, and require changes in the Customers and Addresses tables. Once the unit of work is complete, you should dispose of the context.

Note

For more information about creating models in EF Core, see [Creating and Configuring a Model](https://learn.microsoft.com/ef/core/modeling/) in the EF Core documentation.

Once you’ve created a model, you can use LINQ to query it:

C# — Querying data with EF Core

```csharp
using (var db = new TicketContext())
{
    var tickets = await db.Tickets
        .Where(t => t.Title = "Unable to log on")
        .OrderBy(t => t.Description)
        .ToListAsync();
}
```

Note

EF Core also supports creating, modifying, and deleted records and complex queries. For more information, see [Querying Data](https://learn.microsoft.com/ef/core/querying/) and [Saving Data](https://learn.microsoft.com/ef/core/saving/)

## How Aspire can help

[Section titled “How Aspire can help”](#how-aspire-can-help)

Aspire is designed to help build observable, production-ready, cloud-native solutions that consist of multiple microservices. It orchestrates multiple projects, each of which may be a microservice written by a dedicated team, and connects them to each other. It provides integrations that make it easy to connect to common services, such as databases.

If you want to use EF Core in any of your microservices, Aspire can help by:

* Managing the database container, or a connection to an existing database, centrally in the AppHost project and passing its reference to any project that uses it.

  Caution

  In Aspire, EF Core is implemented by client integrations, not hosting integrations. The centralized management of the database in the AppHost doesn’t involve EF Core, which runs in consuming microservice projects instead.

* Providing EF Core-aware integrations that make it easy to create contexts in microservice projects. There are EF Core integrations for SQL Server, MySQL, PostgreSQL, Oracle, Cosmos DB, and other popular database systems.

To use EF Core in your microservice, you must:

* Define the EF Core model with entity classes and context classes.
* Create an instance of the data context, using the reference passed from the AppHost, and add it to the Dependency Injection (DI) container.
* When you want to interact with the database, obtain the context from DI and use it to execute LINQ queries against the database as normal for any EF Core code.

![A diagram showing how Aspire utilizes EF Core to interact with a database.](/_astro/ef-core-aspire-architecture.BFLU7i9Y.svg)

Both defining the EF Core model and querying the database are the same in Aspire projects as in any other EF Core app. However, creating the data context differs. In the rest of this article, you’ll learn how to create an configure EF Core contexts in Aspire project.

## Use Aspire to create an EF Core context

[Section titled “Use Aspire to create an EF Core context”](#use-aspire-to-create-an-ef-core-context)

In EF Core, a [**context**](https://learn.microsoft.com/ef/core/dbcontext-configuration/) is a class used to interact with the database. Contexts inherit from the `Microsoft.EntityFrameworkCore.DbContext` class. They provide access to the database through properties of type `DbSet<T>`, where each `DbSet` represents a table or collection of entities in the database. The context also manages database connections, tracks changes to entities, and handles operations like saving data and executing queries.

The Aspire EF Core client integrations each include extension methods named `Add<DatabaseSystem>DbContext`, where **`<DatabaseSystem>`** is the name identifying the database product you’re using. For example, consider the SQL Server EF Core client integration, the method is named `AddSqlServerDbContext` and for the PostgreSQL client integration, the method is named `AddNpgsqlDbContext`.

These Aspire add context methods:

* Check that a context of the same type isn’t already registered in the dependency injection (DI) container.

* Use the connection name you pass to the method to get the connection string from the application builder. This connection name must match the name used when adding the corresponding resource to the AppHost project.

* Apply the `DbContext` options, if you passed them.

* Add the specified `DbContext` to the DI container with context pooling enabled.

* Apply the recommended defaults, unless you’ve disabled them through the Aspire EF Core settings:

  * Enable tracing.
  * Enable health checks.
  * Enable connection resiliency.

Use these Aspire add context methods when you want a simple way to create a context and don’t yet need advanced EF Core customization.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>(
    connectionName: "database");
```

Tip

For more information about SQL Server hosting and client integrations, see [Aspire SQL Server Entity Framework Core integration](/integrations/databases/efcore/sql-server/sql-server-get-started/).

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<ExampleDbContext>(
    connectionName: "database");
```

Tip

For more information about PostgreSQL hosting and client integrations, see [Aspire PostgreSQL Entity Framework Core integration](/integrations/databases/efcore/postgres/postgresql-get-started/).

C# — Program.cs

```csharp
builder.AddOracleDatabaseDbContext<ExampleDbContext>(
    connectionName: "database");
```

Tip

For more information about Oracle Database hosting and client integrations, see [Aspire Oracle Entity Framework Core integration](/integrations/databases/efcore/oracle/oracle-get-started/).

C# — Program.cs

```csharp
builder.AddMySqlDbContext<ExampleDbContext>(
    connectionName: "database");
```

Tip

For more information about MySQL hosting and client integrations, see [Aspire Pomelo MySQL Entity Framework Core integration](/integrations/databases/efcore/mysql/mysql-get-started/).

You obtain the `ExampleDbContext` object from the DI container in the same way as for any other service:

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use context...
}
```

## Use EF Core to add and enrich context

[Section titled “Use EF Core to add and enrich context”](#use-ef-core-to-add-and-enrich-context)

Alternatively, you can add a context to the DI container using the standard EF Core `AddDbContextPool` method, as commonly used in non-Aspire projects:

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>(options =>
{
    var connectionString = builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.");
    options.UseSqlServer(connectionString);
});
```

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>(options =>
{
    var connectionString = builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.");
    options.UseNpgsql(connectionString);
});
```

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>(options =>
{
    var connectionString = builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.");
    options.UseOracle(connectionString);
});
```

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>(options =>
{
    var connectionString = builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.");
    options.UseMySql(connectionString);
});
```

You have more flexibility when you create the context in this way, for example:

* You can reuse existing configuration code for the context without rewriting it for Aspire.
* You can choose not to use EF Core context pooling, which may be necessary in some circumstances. For more information, see [Use EF Core context pooling in Aspire](#use-ef-core-context-pooling-in-aspire)
* You can use EF Core context factories or change the lifetime for the EF Core services. For more information, see [Use EF Core context factories in Aspire](#use-ef-core-context-factories-in-aspire)
* You can use dynamic connection strings. For more information, see [Use EF Core with dynamic connection strings in Aspire](#use-ef-core-with-dynamic-connection-strings-in-aspire)
* You can use [EF Core interceptors](https://learn.microsoft.com/ef/core/logging-events-diagnostics/interceptors) that depend on DI services to modify database operations. For more information, see [Use EF Core interceptors in Aspire](#use-ef-core-interceptors-with-aspire)

By default, a context configured this way doesn’t include Aspire features, such as telemetry and health checks. To add those features, each Aspire EF Core client integration includes a method named `Enrich<DatabaseSystem>DbContext`. These enrich context methods:

* Apply an EF Core settings object, if you passed one.

* Configure connection retry settings.

* Apply the recommended defaults, unless you’ve disabled them through the Aspire EF Core settings:

  * Enable tracing.
  * Enable health checks.
  * Enable connection resiliency.

Note

You must add a context to the DI container before you call an enrich method.

C# — Program.cs

```csharp
builder.EnrichSqlServerDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.EnrichNpgsqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.EnrichOracleDatabaseDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.EnrichMySqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

Obtain the context from the DI container using the same code as the previous example:

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use context...
}
```

### Use EF Core interceptors with Aspire

[Section titled “Use EF Core interceptors with Aspire”](#use-ef-core-interceptors-with-aspire)

EF Core interceptors allow developers to hook into and modify database operations at various points during the execution of database queries and commands. You can use them to log, modify, or suppress operations with your own code. Your interceptor must implement one or more interface from the \`Microsoft.EntityFrameworkCore.Diagnostics.IInterceptor> interface.

Interceptors that depend on DI services are not supported by the Aspire `Add<DatabaseSystem>DbContext` methods. Use the EF Core `AddDbContextPool` method and call the `AddInterceptors` method in the options builder:

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>((serviceProvider, options) =>
    {
        options.UseSqlServer(builder.Configuration.GetConnectionString("database"));
        options.AddInterceptors(serviceProvider.GetRequiredService<ExampleInterceptor>());
    });


builder.EnrichSqlServerDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>((serviceProvider, options) =>
    {
        options.UseNpgsql(builder.Configuration.GetConnectionString("database"));
        options.AddInterceptors(serviceProvider.GetRequiredService<ExampleInterceptor>());
    });


builder.EnrichNpgsqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>((serviceProvider, options) =>
    {
        options.UseOracle(builder.Configuration.GetConnectionString("database"));
        options.AddInterceptors(serviceProvider.GetRequiredService<ExampleInterceptor());
    });


builder.EnrichOracleDatabaseDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.Services.AddDbContextPool<ExampleDbContext>((serviceProvider, options) =>
    {
        options.UseMySql(builder.Configuration.GetConnectionString("database"));
        options.AddInterceptors(serviceProvider.GetRequiredService<ExampleInterceptor>());
    });


builder.EnrichMySqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

Note

For more information about EF Core interceptors and their use, see [Interceptors](https://learn.microsoft.com/ef/core/logging-events-diagnostics/interceptors).

### Use EF Core with dynamic connection strings in Aspire

[Section titled “Use EF Core with dynamic connection strings in Aspire”](#use-ef-core-with-dynamic-connection-strings-in-aspire)

Most microservices always connect to the same database with the same credentials and other settings, so they always use the same connection string unless there’s a major change in infrastructure. However, you may need to change the connection string for each request. For example:

* You might offer your service to multiple tenants and need to use a different database depending on which customer made the request.
* You might need to authenticate the request with a different database user account depending on which customer made the request.

For these requirements, you can use code to formulate a **dynamic connection string** and then use it to reach the database and run queries. However, this technique isn’t supported by the Aspire `Add\<DatabaseSystem\>DbContext` methods. Instead you must use the EF Core method to create the context and then enrich it:

C# — Program.cs

```csharp
var connectionStringWithPlaceHolder = builder.Configuration.GetConnectionString("database")
    ?? throw new InvalidOperationException("Connection string 'database' not found.");


var connectionString = connectionStringWithPlaceHolder.Replace("{DatabaseName}", "ContosoDatabase");


builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseSqlServer(connectionString
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichSqlServerDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
var connectionStringWithPlaceHolder = builder.Configuration.GetConnectionString("database")
    ?? throw new InvalidOperationException("Connection string 'database' not found.");


var connectionString = connectionStringWithPlaceHolder.Replace("{DatabaseName}", "ContosoDatabase");


builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseNpgsql(connectionString
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichNpgsqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
var connectionStringWithPlaceHolder = builder.Configuration.GetConnectionString("database")
    ?? throw new InvalidOperationException("Connection string 'database' not found.");


var connectionString = connectionStringWithPlaceHolder.Replace("{DatabaseName}", "ContosoDatabase");


builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseOracle(connectionString
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichOracleDatabaseDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
var connectionStringWithPlaceHolder = builder.Configuration.GetConnectionString("database")
    ?? throw new InvalidOperationException("Connection string 'database' not found.");


var connectionString = connectionStringWithPlaceHolder.Replace("{DatabaseName}", "ContosoDatabase");


builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseMySql(connectionString
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichMySqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

The above code replaces the place holder `{DatabaseName}` in the connection string with the string `ContosoDatabase`, at run time, before it creates the context and enriches it.

### Use EF Core context factories in Aspire

[Section titled “Use EF Core context factories in Aspire”](#use-ef-core-context-factories-in-aspire)

An EF Core context is an object designed to be used for a single unit of work. For example, if you want to add a new customer to the database, you might need to add a row in the **Customers** table and a row in the **Addresses** table. You should get the EF Core context, add the new customer and address entities to it, call \`Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync\*>, and then dispose the context.

In many types of web application, such as ASP.NET applications, each HTTP request closely corresponds to a single unit of work against the database. If your Aspire microservice is an ASP.NET application or a similar web application, you can use the standard EF Core `AddDbContextPool` method described above to register a context that is tied to the current HTTP request. Remember to call the Aspire `Enrich<DatabaseSystem>DbContext` method to gain health checks, tracing, and other features. When you use this approach, the context lifetime is tied to the web request. You don’t have to call the \`Microsoft.EntityFrameworkCore.DbContext.Dispose\*> method when the unit of work is complete.

Other application types, such as ASP.NET Core Blazor, don’t necessarily align each request with a unit of work, because they use dependency injection with a different service scope. In such apps, you may need to perform multiple units of work, each with a different context, within a single HTTP request and response. To implement this approach, you can register a context factory, by calling the EF Core `AddPooledDbContextFactory` method. This method also partners well with the Aspire `Enrich<DatabaseSystem>DbContext` methods:

C# — Program.cs

```csharp
builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichSqlServerDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichNpgsqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
    options.UseOracle(builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichOracleDatabaseDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

C# — Program.cs

```csharp
builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
    options.UseMySql(builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));


builder.EnrichMySqlDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

Notice that the above code adds and enriches a *context factory* in the DI container. When you retreive this from the container, you must add a line of code to create a *context* from it:

```csharp
public class ExampleService(IDbContextFactory<ExampleDbContext> contextFactory)
{
    using (var context = contextFactory.CreateDbContext())
    {
        // Use context...
    }
}
```

Contexts created from factories in this way aren’t disposed of automatically because they aren’t tied to an HTTP request lifetime. You must make sure your code disposes of them. In this example, the `using` code block ensures the disposal.

## Use EF Core context pooling in Aspire

[Section titled “Use EF Core context pooling in Aspire”](#use-ef-core-context-pooling-in-aspire)

In EF Core a context is relatively quick to create and dispose of so most applications can set them up as needed without impacting their performance. However, the overhead is not zero so, if your microservice intensively creates contexts, you may observe suboptimal performance. In such situations, consider using a context pool.

Context pooling is a feature of EF Core. Contexts are created as normal but, when you dispose of one, it isn’t destroyed but reset and stored in a pool. The next time your code creates a context, the stored one is returned to avoid the extra overhead of creating a new one.

In an Aspire consuming project, there are three ways to use context pooling:

* Use the Aspire `Add<DatabaseSystem>DbContext` methods to create the context. These methods create a context pool automatically.

* Call the EF Core `AddDbContextPool` method instead of the EF Core `AddDbContext` method.

  C# — Program.cs

  ```csharp
  builder.Services.AddDbContextPool<ExampleDbContext>(options =>
      options.UseSqlServer(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

  C# — Program.cs

  ```csharp
  builder.Services.AddDbContextPool<ExampleDbContext>(options =>
      options.UseNpgsql(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

  C# — Program.cs

  ```csharp
  builder.Services.AddDbContextPool<ExampleDbContext>(options =>
      options.UseOracle(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

  C# — Program.cs

  ```csharp
  builder.Services.AddDbContextPool<ExampleDbContext>(options =>
      options.UseMySql(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

* Call the EF Core `AddPooledDbContextFactory` method instead of the EF Core `AddDbContextFactory` method.

  C# — Program.cs

  ```csharp
  builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
      options.UseSqlServer(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

  C# — Program.cs

  ```csharp
  builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
      options.UseNpgsql(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

  C# — Program.cs

  ```csharp
  builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
      options.UseOracle(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

  C# — Program.cs

  ```csharp
  builder.Services.AddPooledDbContextFactory<ExampleDbContext>(options =>
      options.UseMySql(builder.Configuration.GetConnectionString("database")
          ?? throw new InvalidOperationException("Connection string 'database' not found.")));
  ```

Remember to enrich the context after using the last two methods, as described above.

Caution

Only the base context state is reset when it’s returned to the pool. If you’ve manually changed the state of the `DbConnection` or another service, you must also manually reset it. Additionally, context pooling prevents you from using `OnConfiguring` to configure the context. See [DbContext pooling](https://learn.microsoft.com/ef/core/performance/advanced-performance-topics#dbcontext-pooling) for more information.

## See also

[Section titled “See also”](#see-also)

* [Entity Framework Core documentation hub](https://learn.microsoft.com/ef/core)
* [Tutorial: Connect an ASP.NET Core app to SQL Server using Aspire and Entity Framework Core](/integrations/databases/efcore/sql-server/sql-server-get-started/)
* [Apply Entity Framework Core migrations in Aspire](/integrations/databases/efcore/migrations/)
* [DbContext Lifetime, Configuration, and Initialization](https://learn.microsoft.com/ef/core/dbcontext-configuration/)
* [Advanced Performance Topics](https://learn.microsoft.com/ef/core/performance/advanced-performance-topics)
* [Entity Framework Interceptors](https://learn.microsoft.com/ef/core/logging-events-diagnostics/interceptors)

# PostgreSQL client integration

> Learn how to use the PostgreSQL client integration to interact with PostgreSQL instances.

![PostgreSQL logo](/_astro/postgresql-icon.DTORe-rE_Z29K7im.webp)

To get started with the Aspire PostgreSQL Entity Framework Core (EF Core) client integration, install the [📦 Aspire.Npgsql.EntityFrameworkCore.PostgreSQL](https://www.nuget.org/packages/Aspire.Npgsql.EntityFrameworkCore.PostgreSQL) NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The Aspire PostgreSQL EF Core client integration registers your desired `DbContext` subclass instances that you can use to interact with PostgreSQL.

* .NET CLI

  .NET CLI — Add Aspire.Npgsql.EntityFrameworkCore.PostgreSQL package

  ```bash
  dotnet add package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Npgsql.EntityFrameworkCore.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" Version="*" />
  ```

For an introduction to the PostgreSQL EF Core integration, see [Get started with the PostgreSQL Entity Framework Core integrations](/integrations/databases/efcore/postgres/postgresql-get-started/).

## Add Npgsql database context

[Section titled “Add Npgsql database context”](#add-npgsql-database-context)

In the `Program.cs` file of your client-consuming project, call the `AddNpgsqlDbContext` extension method on any `IHostApplicationBuilder` to register your `Microsoft.EntityFrameworkCore.DbContext` subclass for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<YourDbContext>(
    connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the PostgreSQL server resource in the AppHost project. For more information, see [Add PostgreSQL server resource](/integrations/databases/postgres/postgres-host/#add-postgresql-server-resource).

After adding `YourDbContext` to the builder, you can get the `YourDbContext` instance using dependency injection. For example, to retrieve your data source object from an example service, define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

```csharp
public class ExampleService(YourDbContext context)
{
    // Use context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Properties of the PostgreSQL resources

[Section titled “Properties of the PostgreSQL resources”](#properties-of-the-postgresql-resources)

When you add a reference to a PostgreSQL resource in the AppHost, using the `WithReference` method, Aspire injects several properties into the consuming project. These properties are available as environment variables that you can use to connect to and interact with PostgreSQL.

The properties injected depend on the type of resource you reference:

### PostgreSQL server properties

[Section titled “PostgreSQL server properties”](#postgresql-server-properties)

When you reference a `PostgresServerResource` (the server), the following properties are injected:

| Property Name | Environment Variable  | Description                                               |
| ------------- | --------------------- | --------------------------------------------------------- |
| `Host`        | `[RESOURCE]_HOST`     | The hostname or IP address of the PostgreSQL server.      |
| `Port`        | `[RESOURCE]_PORT`     | The port number the PostgreSQL server is listening on.    |
| `Username`    | `[RESOURCE]_USERNAME` | The username for authenticating to the PostgreSQL server. |
| `Password`    | `[RESOURCE]_PASSWORD` | The password for authenticating to the PostgreSQL server. |

### PostgreSQL database properties

[Section titled “PostgreSQL database properties”](#postgresql-database-properties)

When you reference a `PostgresDatabaseResource` (a specific database), the following properties are injected:

| Property Name          | Environment Variable              | Description                                               |
| ---------------------- | --------------------------------- | --------------------------------------------------------- |
| `Host`                 | `[RESOURCE]_HOST`                 | The hostname or IP address of the PostgreSQL server.      |
| `Port`                 | `[RESOURCE]_PORT`                 | The port number the PostgreSQL server is listening on.    |
| `Username`             | `[RESOURCE]_USERNAME`             | The username for authenticating to the PostgreSQL server. |
| `Password`             | `[RESOURCE]_PASSWORD`             | The password for authenticating to the PostgreSQL server. |
| `DatabaseName`         | `[RESOURCE]_DATABASENAME`         | The name of the specific database.                        |
| `ConnectionString`     | `ConnectionStrings__[RESOURCE]`   | The full connection string for the database.              |
| `JDBCConnectionString` | `[RESOURCE]_JDBCCONNECTIONSTRING` | The JDBC connection string for the database.              |

Here’s an example of how these properties are used when you call `WithReference`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(postgresdb);
```

In this example, the `ExampleProject` will have access to environment variables like `POSTGRESDB_HOST`, `POSTGRESDB_PORT`, `POSTGRESDB_USERNAME`, `POSTGRESDB_PASSWORD`, `POSTGRESDB_DATABASENAME`, `POSTGRESDB_JDBCCONNECTIONSTRING`, and the connection string `ConnectionStrings__postgresdb`.

## Enrich an Npgsql database context

[Section titled “Enrich an Npgsql database context”](#enrich-an-npgsql-database-context)

You may prefer to use the standard EF Core method to obtain a database context and add it to the dependency injection container:

C# — Program.cs

```csharp
builder.Services.AddDbContext<YourDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("postgresdb")
        ?? throw new InvalidOperationException("Connection string 'postgresdb' not found.")));
```

Note

The connection string name that you pass to the `GetConnectionString` method must match the name used when adding the PostgreSQL server resource in the AppHost project. For more information, see [Add PostgreSQL server resource](/integrations/databases/postgres/postgres-host/#add-postgresql-server-resource).

You have more flexibility when you create the database context in this way, for example:

* You can reuse existing configuration code for the database context without rewriting it for Aspire.
* You can use Entity Framework Core interceptors to modify database operations.
* You can choose not to use Entity Framework Core context pooling, which may perform better in some circumstances.

If you use this method, you can enhance the database context with Aspire-style retries, health checks, logging, and telemetry features by calling the `EnrichNpgsqlDbContext` method:

C# — Program.cs

```csharp
builder.EnrichNpgsqlDbContext<YourDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30;
    });
```

The `settings` parameter is an instance of the `NpgsqlEntityFrameworkCorePostgreSQLSettings` class.

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire PostgreSQL EF Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling the `AddNpgsqlDbContext` method:

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<MyDbContext>("pgdb");
```

The connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "pgdb": "Host=myserver;Database=test"
  }
}
```

The `EnrichNpgsqlDbContext` won’t make use of the `ConnectionStrings` configuration section since it expects a `DbContext` to be registered at the point it’s called.

For more information, see the [ConnectionString](https://www.npgsql.org/doc/connection-string-parameters.html).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire PostgreSQL EF Core integration supports `Microsoft.Extensions.Configuration`. It loads the `NpgsqlEntityFrameworkCorePostgreSQLSettings` from configuration files such as `appsettings.json` by using the `Aspire:Npgsql:EntityFrameworkCore:PostgreSQL` key. If you have set up your configurations in the `Aspire:Npgsql:EntityFrameworkCore:PostgreSQL` section you can just call the method without passing any parameter.

The following example shows an `appsettings.json` file that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "EntityFrameworkCore": {
        "PostgreSQL": {
          "ConnectionString": "Host=myserver;Database=postgresdb",
          "DisableHealthChecks": true,
          "DisableTracing": true
        }
      }
    }
  }
}
```

For the complete PostgreSQL EF Core client integration JSON schema, see [Aspire.Npgsql.EntityFrameworkCore.PostgreSQL/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Npgsql.EntityFrameworkCore.PostgreSQL/ConfigurationSchema.json).

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<NpgsqlEntityFrameworkCorePostgreSQLSettings>` delegate to set up some or all the options inline, for example to set the `ConnectionString`:

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<YourDbContext>(
    "pgdb",
    static settings => settings.ConnectionString = "<YOUR CONNECTION STRING>");
```

### Configure multiple DbContext classes

[Section titled “Configure multiple DbContext classes”](#configure-multiple-dbcontext-classes)

If you want to register more than one `DbContext` with different configuration, you can use `$"Aspire:Npgsql:EntityFrameworkCore:PostgreSQL:{typeof(TContext).Name}"` configuration section name. The json configuration would look like:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "EntityFrameworkCore": {
        "PostgreSQL": {
          "ConnectionString": "<YOUR CONNECTION STRING>",
          "DisableHealthChecks": true,
          "DisableTracing": true,
          "AnotherDbContext": {
            "ConnectionString": "<ANOTHER CONNECTION STRING>",
            "DisableTracing": false
          }
        }
      }
    }
  }
}
```

Then calling the `AddNpgsqlDbContext` method with `AnotherDbContext` type parameter would load the settings from `AnotherDbContext` section.

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<AnotherDbContext>();
```

By default, the Aspire PostgreSQL EF Core integrations handles the following:

* Adds the [`DbContextHealthCheck`](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/src/HealthChecks.NpgSql/NpgSqlHealthCheck.cs), which calls EF Core’s `CanConnectAsync` method. The name of the health check is the name of the `TContext` type.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations.

### Logging

[Section titled “Logging”](#logging)

The Aspire PostgreSQL Entity Framework Core integration uses the following Log categories:

* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Database.Connection`
* `Microsoft.EntityFrameworkCore.Database.Transaction`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Model`
* `Microsoft.EntityFrameworkCore.Model.Validation`
* `Microsoft.EntityFrameworkCore.Query`
* `Microsoft.EntityFrameworkCore.Update`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire PostgreSQL EF Core integration will emit the following tracing activities using OpenTelemetry:

* `Npgsql`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire PostgreSQL EF Core integration will emit the following metrics using OpenTelemetry:

* Microsoft.EntityFrameworkCore:

  * `ec_Microsoft_EntityFrameworkCore_active_db_contexts`
  * `ec_Microsoft_EntityFrameworkCore_total_queries`
  * `ec_Microsoft_EntityFrameworkCore_queries_per_second`
  * `ec_Microsoft_EntityFrameworkCore_total_save_changes`
  * `ec_Microsoft_EntityFrameworkCore_save_changes_per_second`
  * `ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate`
  * `ec_Microsoft_Entity_total_execution_strategy_operation_failures`
  * `ec_Microsoft_E_execution_strategy_operation_failures_per_second`
  * `ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures`
  * `ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second`

* Npgsql:

  * `ec_Npgsql_bytes_written_per_second`
  * `ec_Npgsql_bytes_read_per_second`
  * `ec_Npgsql_commands_per_second`
  * `ec_Npgsql_total_commands`
  * `ec_Npgsql_current_commands`
  * `ec_Npgsql_failed_commands`
  * `ec_Npgsql_prepared_commands_ratio`
  * `ec_Npgsql_connection_pools`
  * `ec_Npgsql_multiplexing_average_commands_per_batch`
  * `ec_Npgsql_multiplexing_average_write_time_per_batch`

# Get started with the PostgreSQL Entity Framework Core integrations

> Learn how to set up the Aspire PostgreSQL Hosting and Client integrations simply.

![PostgreSQL logo](/_astro/postgresql-icon.DTORe-rE_Z29K7im.webp)

[PostgreSQL](https://www.postgresql.org/) is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The Aspire PostgreSQL Entity Framework Core (EF Core) integration provides a way to connect to existing PostgreSQL databases, or create new instances from the [`docker.io/library/postgres` container image](https://hub.docker.com/_/postgres).

In this introduction, you’ll see how to install and use the Aspire PostgreSQL Entity Framework Core integrations in a simple configuration. The same hosting integration is used with both the EF Core and the non-EF Core client integrations. If you already have this knowledge, see [PostgreSQL Hosting integration](/integrations/databases/postgres/postgres-host/) and [PostgreSQL EF Core client integration](/integrations/databases/efcore/postgres/postgresql-client/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire PostgreSQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage PostgreSQL database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.PostgreSQL package

  ```bash
  aspire add postgresql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > postgresql (Aspire.Hosting.PostgreSQL)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.PostgreSQL" Version="*" />
  ```

Next, in the AppHost project, create instances of PostgreSQL server and database resources, then pass the database to the consuming client projects:

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(postgresdb)
                            .WithReference(postgresdb);
```

Tip

This is the simplest implementation of PostgreSQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [PostgreSQL Hosting integration](/integrations/databases/postgres/postgres-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the EF Core client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire PostgreSQL EF Core client integration:

* .NET CLI

  .NET CLI — Add Aspire.Npgsql.EntityFrameworkCore.PostgreSQL package

  ```bash
  dotnet add package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Npgsql.EntityFrameworkCore.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Npgsql.EntityFrameworkCore.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Npgsql.EntityFrameworkCore.PostgreSQL" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddNpgsqlDbContext` extension method on any `IHostApplicationBuilder` to register your `DbContext` subclass for use through the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<MyDbContext>(connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the PostgreSQL database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected PostgreSQL properties

[Section titled “Use injected PostgreSQL properties”](#use-injected-postgresql-properties)

In the AppHost, when you used the `WithReference` method to pass a PostgreSQL database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Host` property of a resource called `postgresdb` becomes `POSTGRESDB_HOST`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string hostname = builder.Configuration.GetValue<string>("POSTGRESDB_HOST");
string databasePort = builder.Configuration.GetValue<string>("POSTGRESDB_PORT");
string databaseName = builder.Configuration.GetValue<string>("POSTGRESDB_DATABASENAME");
```

Tip

For the full set of properties that Aspire injects, see [Properties of the PostgreSQL resources](/integrations/databases/efcore/postgres/postgresql-client/#properties-of-the-postgresql-resources).

### Use PostgreSQL resources in client code

[Section titled “Use PostgreSQL resources in client code”](#use-postgresql-resources-in-client-code)

Now that you’ve added the `DbContext` to the builder in the consuming project, you can use the PostgreSQL resource to get and store data. Get the `DbContext` instance using dependency injection. For example, to retrieve your database context object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(MyDbContext context)
{
    // Use context to interact with the database...
}
```

Having obtained the database context, you can work with the PostgreSQL database as you would in any other C# application using EF Core.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with PostgreSQL EF Core integrations up and running, you can use the following reference documents to learn how to configure and interact with the PostgreSQL resources:

[Understand the PostgreSQL hosting integration ](/integrations/databases/postgres/postgres-host/)Discover how to configure persistence, pgAdmin resources, and more.

[Understand the PostgreSQL EF Core client integration ](/integrations/databases/efcore/postgres/postgresql-client/)Discover how to enrich DbContext, configure settings, and more.

# Seed data in a database using Aspire

> Learn about how to seed database data in Aspire

Choose a Aspire Entity Framework Core client integration

SQL Server  PostgreSQL  Pomelo MySQL

In this article, you learn how to configure Aspire projects to seed data in a database during app startup. Aspire enables you to seed data using database scripts or Entity Framework Core (EF Core) for common platforms such as SQL Server, PostgreSQL, and MySQL.

## When to seed data

[Section titled “When to seed data”](#when-to-seed-data)

Seeding data pre-populates database tables with rows of data so they’re ready for testing your app. You may want to seed data for the following scenarios:

* You want to develop and test different features of your app manually against a meaningful set of data, such as a product catalog or a list of customers.
* You want to run test suites to verify that features behave correctly with a given set of data.

Manually seeding data is tedious and time consuming, so you should automate the process whenever possible. You can seed your database either by running database scripts for Aspire projects during startup or by using tools like EF Core, which handles many underlying concerns for you.

## Understand containerized databases

[Section titled “Understand containerized databases”](#understand-containerized-databases)

By default, Aspire database integrations rely on containerized databases, which create the following challenges when trying to seed data:

* By default, Aspire destroys and recreates containers every time the app restarts, which means you have to re-seed your database on each run.
* Depending on your selected database technology, the new container instance may or may not create a default database, which means you might also have to create the database itself.
* Even if a default database exists, it most likely won’t have the desired name or schema for your specific app.

Aspire enables you to resolve these challenges using volumes, bind mounts, and a few configurations to seed data effectively.

Tip

Container hosts like Docker and Podman support volumes and bind mounts, both of which provide locations for data that persist when a container restarts. Volumes are the recommended solution, because they offer better performance, portability, and security. The container host creates and remains in control of volumes. Each volume can store data for multiple containers. Bind mounts have relatively limited functionality in comparison but enable you to access the data from the host machine.

Note

Visit the [Database Container Sample App](https://github.com/dotnet/aspire-samples/blob/main/samples/DatabaseContainers/DatabaseContainers.AppHost/AppHost.cs) to view the full project and file structure for each database option.

## Seed data using SQL scripts

[Section titled “Seed data using SQL scripts”](#seed-data-using-sql-scripts)

The recommended method for executing database seeding scripts depends on the database server you use:

With Aspire, you can use the `WithCreationScript` method to ensure a T-SQL script is run when the database is created. Add SQL code to this script that creates and populates the database, the necessary tables, and other database objects.

The following code is an example T-SQL script that creates and populates an address book database:

SQL Server — init.sql

```sql
-- SQL Server init script


-- Create the AddressBook database
IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = N'AddressBook')
BEGIN
  CREATE DATABASE AddressBook;
END;
GO


USE AddressBook;
GO


-- Create the Contacts table
IF OBJECT_ID(N'Contacts', N'U') IS NULL
BEGIN
    CREATE TABLE Contacts
    (
        Id        INT PRIMARY KEY IDENTITY(1,1) ,
        FirstName VARCHAR(255) NOT NULL,
        LastName  VARCHAR(255) NOT NULL,
        Email     VARCHAR(255) NULL,
        Phone     VARCHAR(255) NULL
    );
END;
GO


-- Ensure that either the Email or Phone column is populated
IF OBJECT_ID(N'chk_Contacts_Email_Phone', N'C') IS NULL
BEGIN
    ALTER TABLE Contacts
    ADD CONSTRAINT chk_Contacts_Email_Phone CHECK
    (
        Email IS NOT NULL OR Phone IS NOT NULL
    );
END;
GO


-- Insert some sample data into the Contacts table
IF (SELECT COUNT(*) FROM Contacts) = 0
BEGIN
    INSERT INTO Contacts (FirstName, LastName, Email, Phone)
    VALUES
        ('John', 'Doe', 'john.doe@example.com', '555-123-4567'),
        ('Jane', 'Doe', 'jane.doe@example.com', '555-234-5678');
END;
GO
```

You must ensure that this script is copied to the AppHost’s output directory, so that Aspire can execute it. Add the following XML to your *.csproj* file:

DatabaseContainers.AppHost.csproj

```xml
<Project Sdk="Aspire.AppHost.Sdk/13.1.0">


  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <UserSecretsId>a664d119-7412-4e3e-8b8d-19191387b8f1</UserSecretsId>
  </PropertyGroup>


  <ItemGroup>
    <None Include="..\DatabaseContainers.ApiService\data\sqlserver\init.sql" Link="init.sql">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>


  <ItemGroup>
    <ProjectReference Include="..\DatabaseContainers.ApiService\DatabaseContainers.ApiService.csproj" />
  </ItemGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.MySql" Version="13.1.0" />
    <PackageReference Include="Aspire.Hosting.PostgreSQL" Version="13.1.0" />
    <PackageReference Include="Aspire.Hosting.SqlServer" Version="13.1.0" />
  </ItemGroup>


</Project>
```

Adjust the `Include` parameter to match the path to your SQL script in the project.

Next, in the *AppHost.cs* file, create the database and run the creation script:

C# — AppHost.cs

```csharp
var sqlserver = builder.AddSqlServer("sqlserver")
    // Configure the container to store data in a volume so that it persists across instances.
    .WithDataVolume()
    // Keep the container running between app host sessions.
    .WithLifetime(ContainerLifetime.Persistent);


// Add the database to the application model so that it can be referenced by other resources.
var initScriptPath = Path.Join(Path.GetDirectoryName(typeof(Program).Assembly.Location), "init.sql");
var addressBookDb = sqlserver.AddDatabase("AddressBook")
    .WithCreationScript(File.ReadAllText(initScriptPath));
```

The preceding code:

* Create a SQL Server container by calling `builder.AddSqlServer()`.
* Ensures that data is persisted across debugging sessions by calling `WithDataVolume()` and `WithLifetime(ContainerLifetime.Persistent)`.
* Obtains the path to the T-SQL script in the output folder.
* Calls `WithCreationScript()` to create and seed the database.

With Aspire, you can use the `WithCreationScript()` method in the PostgreSQL integration but, because there is no `USE DATABASE` in PostgreSQL, it only supports operations against the default database. For example, you can issue `CREATE DATABASE` statements to create other databases, but you can’t populate them with tables and data. Instead, you must use a bind mount and deploy the setup SQL script to it, so that the data is seeded when the container initializes the database.

The following code is an example PostgreSQL script that creates and populates a to do list database:

PostgreSQL — init.sql

```sql
-- Postgres init script


-- Create the Todos table
CREATE TABLE IF NOT EXISTS Todos
(
    Id SERIAL PRIMARY KEY,
    Title text UNIQUE NOT NULL,
    IsComplete boolean NOT NULL DEFAULT false
);


-- Insert some sample data into the Todos table
INSERT INTO Todos (Title, IsComplete)
VALUES
    ('Give the dog a bath', false),
    ('Wash the dishes', false),
    ('Do the groceries', false)
ON CONFLICT DO NOTHING;
```

In the *AppHost.cs* file, create the database and mount the folder that contains the SQL script as a bind mount:

C# — AppHost.cs

```csharp
// PostgreSQL container is configured with an auto-generated password by default
// and supports setting the default database name via an environment variable & running *.sql/*.sh scripts in a bind mount.
var todosDbName = "Todos";


var postgres = builder.AddPostgres("postgres")
    // Set the name of the default database to auto-create on container startup.
    .WithEnvironment("POSTGRES_DB", todosDbName)
    // Mount the SQL scripts directory into the container so that the init scripts run.
    .WithBindMount("../DatabaseContainers.ApiService/data/postgres", "/docker-entrypoint-initdb.d")
    // Configure the container to store data in a volume so that it persists across instances.
    .WithDataVolume()
    .WithPgWeb()
    // Keep the container running between app host sessions.
    .WithLifetime(ContainerLifetime.Persistent);


// Add the default database to the application model so that it can be referenced by other resources.
var todosDb = postgres.AddDatabase(todosDbName);
```

With Aspire, you can use the `WithCreationScript` method to ensure a MySQL script is run when the database is created. Add SQL code to this script that creates and populates the database, the necessary tables, and other database objects.

In the following AppHost code, the script is created as a string and passed to the `WithCreationScript` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogDbName = "catalog";


var mysql = builder.AddMySql("mysql")
                   .WithEnvironment("MYSQL_DATABASE", catalogDbName)
                   .WithDataVolume()
                   .WithLifetime(ContainerLifetime.Persistent)
                   .WithPhpMyAdmin();


var creationScript = $$"""
USE catalog;
CREATE TABLE IF NOT EXISTS `catalog`
(
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(255) NOT NULL,
    `description` varchar(255) NOT NULL,
    `price` DECIMAL(18,2) NOT NULL,
    PRIMARY KEY (`id`)
);


-- Insert some sample data into the Catalog table only if the table is empty
INSERT INTO catalog (name, description, price)
SELECT *
FROM (
        SELECT '.NET Bot Black Hoodie', 'This hoodie will keep you warm while looking cool and representing .NET!', 19.5 UNION ALL
        SELECT '.NET Black & White Mug', 'The perfect place to keep your favorite beverage while you code.', 8.5 UNION ALL
        SELECT 'Prism White T-Shirt', "It's a t-shirt, it's white, and it can be yours.", 12
    ) data
-- This clause ensures the rows are only inserted if the table is empty
WHERE NOT EXISTS (SELECT NULL FROM catalog)
""";


var mysqldb = mysql.AddDatabase(catalogDbName)
                   .WithCreationScript(creationScript);


builder.Build().Run();
```

The preceding code:

* Create a MySQL container by calling `builder.AddMySql()`.
* Uses the `MYSQL_DATABASE` environment variable to name the database `catalog`.
* Ensures that data is persisted across debugging sessions by calling `WithDataVolume()` and `WithLifetime(ContainerLifetime.Persistent)`.
* Create a second container that runs the PHP My Admin user interface for MySQL.
* Calls `WithCreationScript()` to create and seed the database.

If you run this code, you can use the PHP My Admin resource to check that a table called **catalog** has been created and populated with products.

## Seed data using EF Core

[Section titled “Seed data using EF Core”](#seed-data-using-ef-core)

To seed data, call `UseSeeding` or `UseAsyncSeeding` methods to configure database seeding directly during context configuration. This approach is cleaner than manually running migrations during startup and integrates better with EF Core’s lifecycle management.

Caution

These types of configurations should only be done during development, so make sure to add a conditional that checks your current environment context.

### Seed data with UseSeeding and UseAsyncSeeding methods

[Section titled “Seed data with UseSeeding and UseAsyncSeeding methods”](#seed-data-with-useseeding-and-useasyncseeding-methods)

Add the following code to the `Program.cs` file of your **API Service** project:

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<TicketContext>("TicketsDB",
    configureDbContextOptions: options =>
{
    if (builder.Environment.IsDevelopment())
    {
        options.UseSeeding((context, _) =>
        {
            var testTicket = context.Set<SupportTicket>()
                .FirstOrDefault(t => t.Title == "Test Ticket 1");
            if (testTicket is null)
            {
                context.Set<SupportTicket>().Add(new SupportTicket
                {
                    Title = "Test Ticket 1",
                    Description = "This is a test ticket"
                });
                context.SaveChanges();
            }


        });


        options.UseAsyncSeeding(async (context, _, cancellationToken) =>
        {
            var testTicket = await context.Set<SupportTicket>()
                .FirstOrDefaultAsync(t => t.Title == "Test Ticket 1", cancellationToken);
            if (testTicket is null)
            {
                context.Set<SupportTicket>().Add(new SupportTicket
                {
                    Title = "Test Ticket 1",
                    Description = "This is a test ticket"
                });
                await context.SaveChangesAsync(cancellationToken);
            }
        });
    }
});


var app = builder.Build();


app.MapDefaultEndpoints();


if (app.Environment.IsDevelopment())
{
    // Ensure database is created and seeded
    using (var scope = app.Services.CreateScope())
    {
        var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
        await context.Database.EnsureCreatedAsync();
    }
}
```

C# — Program.cs

```csharp
builder.AddNpgsqlDbContext<TicketContext>("TicketsDB",
    configureDbContextOptions: options =>
{
    if (builder.Environment.IsDevelopment())
    {
        options.UseSeeding((context, _) =>
        {
            var testTicket = context.Set<SupportTicket>()
                .FirstOrDefault(t => t.Title == "Test Ticket 1");
            if (testTicket is null)
            {
                context.Set<SupportTicket>().Add(new SupportTicket
                {
                    Title = "Test Ticket 1",
                    Description = "This is a test ticket"
                });
                context.SaveChanges();
            }


        });


        options.UseAsyncSeeding(async (context, _, cancellationToken) =>
        {
            var testTicket = await context.Set<SupportTicket>()
                .FirstOrDefaultAsync(t => t.Title == "Test Ticket 1", cancellationToken);
            if (testTicket is null)
            {
                context.Set<SupportTicket>().Add(new SupportTicket
                {
                    Title = "Test Ticket 1",
                    Description = "This is a test ticket"
                });
                await context.SaveChangesAsync(cancellationToken);
            }
        });
    }
});


var app = builder.Build();


app.MapDefaultEndpoints();


if (app.Environment.IsDevelopment())
{
    // Ensure database is created and seeded
    using (var scope = app.Services.CreateScope())
    {
        var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
        await context.Database.EnsureCreatedAsync();
    }
}
```

C# — Program.cs

```csharp
builder.AddMySqlDbContext<TicketContext>("TicketsDB",
    configureDbContextOptions: options =>
{
    if (builder.Environment.IsDevelopment())
    {
        options.UseSeeding((context, _) =>
        {
            var testTicket = context.Set<SupportTicket>()
                .FirstOrDefault(t => t.Title == "Test Ticket 1");
            if (testTicket is null)
            {
                context.Set<SupportTicket>().Add(new SupportTicket
                {
                    Title = "Test Ticket 1",
                    Description = "This is a test ticket"
                });
                context.SaveChanges();
            }


        });


        options.UseAsyncSeeding(async (context, _, cancellationToken) =>
        {
            var testTicket = await context.Set<SupportTicket>()
                .FirstOrDefaultAsync(t => t.Title == "Test Ticket 1", cancellationToken);
            if (testTicket is null)
            {
                context.Set<SupportTicket>().Add(new SupportTicket
                {
                    Title = "Test Ticket 1",
                    Description = "This is a test ticket"
                });
                await context.SaveChangesAsync(cancellationToken);
            }
        });
    }
});


var app = builder.Build();


app.MapDefaultEndpoints();


if (app.Environment.IsDevelopment())
{
    // Ensure database is created and seeded
    using (var scope = app.Services.CreateScope())
    {
        var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
        await context.Database.EnsureCreatedAsync();
    }
}
```

Note

`UseSeeding` is called from the `EnsureCreated` method, and `UseAsyncSeeding` is called from the `EnsureCreatedAsync` method. When using this feature, it’s recommended to implement both `UseSeeding` and `UseAsyncSeeding` methods using similar logic, even if the code using EF is asynchronous. EF Core tooling currently relies on the synchronous version of the method and will not seed the database correctly if the `UseSeeding` method isn’t implemented.

The `UseSeeding` and `UseAsyncSeeding` methods provide several advantages over manual seeding approaches:

* **Integrated lifecycle**: Seeding is automatically triggered when the database is created or when migrations are applied.
* **Conditional execution**: The seeding logic only runs when the database is first created, preventing duplicate data on subsequent runs.
* **Better performance**: The seeding methods are optimized for bulk operations and integrate with EF Core’s change tracking.
* **Cleaner code**: Seeding configuration is co-located with the context configuration, making it easier to maintain.

### Seed data manually

[Section titled “Seed data manually”](#seed-data-manually)

You can also seed data in Aspire projects using EF Core by explicitly running migrations during startup. EF Core handles underlying database connections and schema creation for you, which eliminates the need to use volumes or run SQL scripts during container startup.

Caution

These types of configurations should only be done during development, so make sure to add a conditional that checks your current environment context.

Add the following code to the `Program.cs` file of your **API Service** project.

C# — Program.cs

```csharp
// Register DbContext class
builder.AddSqlServerDbContext<TicketContext>("sqldata");


var app = builder.Build();


app.MapDefaultEndpoints();


if (app.Environment.IsDevelopment())
{
    // Retrieve an instance of the DbContext class and manually run migrations during startup
    using (var scope = app.Services.CreateScope())
    {
        var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
        context.Database.Migrate();


        // Manually seed data
        if (!context.Tickets.Any())
        {
            context.Tickets.AddRange(
                new Ticket
                {
                    Title = "Example Ticket",
                    Description = "This is a sample ticket for testing"
                }
            );
            context.SaveChanges();
        }
    }
}
```

C# — Program.cs

```csharp
// Register DbContext class
builder.AddNpgsqlDbContext<TicketContext>("sqldata");


var app = builder.Build();


app.MapDefaultEndpoints();


if (app.Environment.IsDevelopment())
{
    // Retrieve an instance of the DbContext class and manually run migrations during startup
    using (var scope = app.Services.CreateScope())
    {
        var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
        context.Database.Migrate();


        // Manually seed data
        if (!context.Tickets.Any())
        {
            context.Tickets.AddRange(
                new Ticket
                {
                    Title = "Example Ticket",
                    Description = "This is a sample ticket for testing"
                }
            );
            context.SaveChanges();
        }
    }
}
```

C# — Program.cs

```csharp
// Register DbContext class
builder.AddMySqlDataSource<TicketContext>("sqldata");


var app = builder.Build();


app.MapDefaultEndpoints();


if (app.Environment.IsDevelopment())
{
    // Retrieve an instance of the DbContext class and manually run migrations during startup
    using (var scope = app.Services.CreateScope())
    {
        var context = scope.ServiceProvider.GetRequiredService<TicketContext>();
        context.Database.Migrate();


        // Manually seed data
        if (!context.Tickets.Any())
        {
            context.Tickets.AddRange(
                new Ticket
                {
                    Title = "Example Ticket",
                    Description = "This is a sample ticket for testing"
                }
            );
            context.SaveChanges();
        }
    }
}
```

## Next steps

[Section titled “Next steps”](#next-steps)

Database seeding is useful in a variety of app development scenarios. Try combining these techniques with the resource implementations demonstrated in the following articles:

* [Tutorial: Apply Entity Framework Core migrations in Aspire](/integrations/databases/efcore/migrations/)
* [Aspire orchestration overview](/get-started/app-host/)

# SQL Server Entity Framework Core client integration

> Learn how to use the Aspire SQL Server EF Core client integration to connect to SQL Server databases.

![SQL Server logo](/_astro/sql-icon.CyVgV5Qd_Z1td4Jv.webp)

To get started with the Aspire SQL Server Entity Framework Core (EF Core) integration, install the [📦 Aspire.Microsoft.EntityFrameworkCore.SqlServer](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.SqlServer) NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server EF Core client.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.SqlServer" Version="*" />
  ```

For an introduction to working with the SQL Server EF Core client integration, see [Get started with the SQL Server EF Core integrations](/integrations/databases/efcore/sql-server/sql-server-get-started/).

Note

Before using the Aspire SQL Server EF Core client integration in a project, ensure that the Aspire SQL Server Hosting integration is set up in the AppHost project. For more information, see [SQL Server Hosting integration](/integrations/databases/sql-server/sql-server-host/).

## Add SQL Server database context

[Section titled “Add SQL Server database context”](#add-sql-server-database-context)

In the `Program.cs` file of your client-consuming project, call the `AddSqlServerDbContext` extension method on any `IHostApplicationBuilder` to register a `Microsoft.EntityFrameworkCore.DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: "database");
```

Tip

The `connectionName` parameter must match the name used when adding the SQL Server database resource in the AppHost project. In other words, when you call `AddDatabase` and provide a name of `database` that same name should be used when calling `AddSqlServerDbContext`. For more information, see [Add SQL Server resource and database resource](/integrations/databases/sql-server/sql-server-host/#add-sql-server-resource-and-database-resource).

To retrieve `ExampleDbContext` object from a service:

C# — ExampleService.cs

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Properties of the SQL Server resources

[Section titled “Properties of the SQL Server resources”](#properties-of-the-sql-server-resources)

When you use the `WithReference` method to pass a SQL Server server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Host` property of a resource called `sql` becomes `SQL_HOST`.

### SQL Server server resource

[Section titled “SQL Server server resource”](#sql-server-server-resource)

The SQL Server server resource exposes the following connection properties:

| Property Name | Description                                      |
| ------------- | ------------------------------------------------ |
| `Host`        | The hostname or IP address of the SQL Server     |
| `Port`        | The port number the SQL Server is listening on   |
| `Username`    | The username for authentication (defaults to sa) |
| `Password`    | The password for authentication                  |
| `Uri`         | The URI of the SQL Server                        |

### SQL Server database resource

[Section titled “SQL Server database resource”](#sql-server-database-resource)

The SQL Server database resource inherits all properties from its parent `SqlServerServerResource` and adds:

| Property Name          | Description                                                                                                                                                                             |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `DatabaseName`         | The name of the database                                                                                                                                                                |
| `ConnectionString`     | The connection string for the database, with the format `Server={Host},{Port};User ID={Username};Password={Password};Database={DatabaseName};Encrypt=true;TrustServerCertificate=false` |
| `JdbcConnectionString` | The JDBC connection string for the database, with the format `jdbc:sqlserver://{Host}:{Port};database={DatabaseName};user={Username};password={Password};encrypt=true;`                 |

For example, if you reference a database resource named `sqldb` in your AppHost project, the following environment variables will be available in the consuming project:

* `SQLDB_HOST`
* `SQLDB_PORT`
* `SQLDB_URI`
* `SQLDB_USERNAME`
* `SQLDB_PASSWORD`
* `SQLDB_DATABASENAME`
* `ConnectionStrings__sqldb` (the full connection string)
* `SQLDB_JDBCCONNECTIONSTRING`

## Enrich a SQL Server database context

[Section titled “Enrich a SQL Server database context”](#enrich-a-sql-server-database-context)

You may prefer to use the standard EF Core method to obtain a database context and add it to the dependency injection container:

C# — Program.cs

```csharp
builder.Services.AddDbContext<ExampleDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("database")
        ?? throw new InvalidOperationException("Connection string 'database' not found.")));
```

Note

The connection string name that you pass to the `Microsoft.Extensions.Configuration.ConfigurationExtensions.GetConnectionString` method must match the name used when adding the SQL server resource in the AppHost project. For more information, see [Add SQL Server resource and database resource](/integrations/databases/sql-server/sql-server-host/#add-sql-server-resource-and-database-resource).

You have more flexibility when you create the database context in this way, for example:

* You can reuse existing configuration code for the database context without rewriting it for Aspire.
* You can use EF Core interceptors to modify database operations.
* You can choose not to use EF Core context pooling, which may perform better in some circumstances.

If you use this method, you can enhance the database context with Aspire-style retries, health checks, logging, and telemetry features by calling the `EnrichSqlServerDbContext` method:

C# — Program.cs

```csharp
builder.EnrichSqlServerDbContext<ExampleDbContext>(
    configureSettings: settings =>
    {
        settings.DisableRetry = false;
        settings.CommandTimeout = 30; // seconds
    });
```

The `settings` parameter is an instance of the `MicrosoftEntityFrameworkCoreSqlServerSettings` class.

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire SQL Server Entity Framework Core integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use connection string

[Section titled “Use connection string”](#use-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddSqlServerDbContext<TContext>()`:

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>("sql");
```

The connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "sql": "Data Source=myserver;Initial Catalog=master"
  }
}
```

The `EnrichSqlServerDbContext` won’t make use of the `ConnectionStrings` configuration section since it expects a `DbContext` to be registered at the point it’s called.

For more information, see the [ConnectionString](https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring#remarks).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire SQL Server EF Core integration supports [Microsoft.Extensions.Configuration](https://learn.microsoft.com/dotnet/api/microsoft.extensions.configuration). It loads the `MicrosoftEntityFrameworkCoreSqlServerSettings` from configuration files such as `appsettings.json` by using the `Aspire:Microsoft:EntityFrameworkCore:SqlServer` key. If you have set up your configurations in the `Aspire:Microsoft:EntityFrameworkCore:SqlServer` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` file that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "EntityFrameworkCore": {
        "SqlServer": {
          "ConnectionString": "YOUR_CONNECTIONSTRING",
          "DbContextPooling": true,
          "DisableHealthChecks": true,
          "DisableTracing": true,
          "DisableMetrics": false
        }
      }
    }
  }
}
```

### Use inline configurations

[Section titled “Use inline configurations”](#use-inline-configurations)

You can also pass the `Action<MicrosoftEntityFrameworkCoreSqlServerSettings>` delegate to set up some or all the options inline, for example to turn off the metrics:

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<YourDbContext>(
    "sql",
    static settings =>
        settings.DisableMetrics = true);
```

### Configure multiple DbContext connections

[Section titled “Configure multiple DbContext connections”](#configure-multiple-dbcontext-connections)

If you want to register more than one `DbContext` with different configuration, you can use `$"Aspire.Microsoft.EntityFrameworkCore.SqlServer:{typeof(TContext).Name}"` configuration section name. The json configuration would look like:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "EntityFrameworkCore": {
        "SqlServer": {
          "ConnectionString": "YOUR_CONNECTIONSTRING",
          "DbContextPooling": true,
          "DisableHealthChecks": true,
          "DisableTracing": true,
          "DisableMetrics": false
        },
        "AnotherDbContext": {
          "ConnectionString": "AnotherDbContext_CONNECTIONSTRING",
          "DisableTracing": false
        }
      }
    }
  }
}
```

Then calling the `AddSqlServerDbContext` method with `AnotherDbContext` type parameter would load the settings from `Aspire:Microsoft:EntityFrameworkCore:SqlServer:AnotherDbContext` section.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<AnotherDbContext>("another-sql");
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the configurable options with corresponding default values:

| Name                  | Description                                                                                                          |
| --------------------- | -------------------------------------------------------------------------------------------------------------------- |
| `ConnectionString`    | The connection string of the SQL Server database to connect to.                                                      |
| `DbContextPooling`    | A boolean value that indicates whether the db context will be pooled or explicitly created every time it’s requested |
| `MaxRetryCount`       | The maximum number of retry attempts. Default value is 6, set it to 0 to disable the retry mechanism.                |
| `DisableHealthChecks` | A boolean value that indicates whether the database health check is disabled or not.                                 |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not.                                 |
| `DisableMetrics`      | A boolean value that indicates whether the OpenTelemetry metrics are disabled or not.                                |
| `Timeout`             | The time in seconds to wait for the command to execute.                                                              |

## Health checks

[Section titled “Health checks”](#health-checks)

By default, the Aspire Sql Server Entity Framework Core integration handles the following:

* Adds the [`DbContextHealthCheck`](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/src/HealthChecks.SqlServer/SqlServerHealthCheck.cs), which calls EF Core’s `CanConnectAsync` method. The name of the health check is the name of the `TContext` type.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability

[Section titled “Observability”](#observability)

### Logging

[Section titled “Logging”](#logging)

The Aspire SQL Server Entity Framework Core integration uses the following Log categories:

* `Microsoft.EntityFrameworkCore.ChangeTracking`
* `Microsoft.EntityFrameworkCore.Database.Command`
* `Microsoft.EntityFrameworkCore.Database.Connection`
* `Microsoft.EntityFrameworkCore.Database.Transaction`
* `Microsoft.EntityFrameworkCore.Infrastructure`
* `Microsoft.EntityFrameworkCore.Migrations`
* `Microsoft.EntityFrameworkCore.Model`
* `Microsoft.EntityFrameworkCore.Model.Validation`
* `Microsoft.EntityFrameworkCore.Query`
* `Microsoft.EntityFrameworkCore.Update`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire SQL Server Entity Framework Core integration will emit the following Tracing activities using OpenTelemetry:

* “OpenTelemetry.Instrumentation.EntityFrameworkCore”

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire SQL Server Entity Framework Core integration will emit the following metrics using OpenTelemetry:

* Microsoft.EntityFrameworkCore:

  * `ec_Microsoft_EntityFrameworkCore_active_db_contexts`
  * `ec_Microsoft_EntityFrameworkCore_total_queries`
  * `ec_Microsoft_EntityFrameworkCore_queries_per_second`
  * `ec_Microsoft_EntityFrameworkCore_total_save_changes`
  * `ec_Microsoft_EntityFrameworkCore_save_changes_per_second`
  * `ec_Microsoft_EntityFrameworkCore_compiled_query_cache_hit_rate`
  * `ec_Microsoft_Entity_total_execution_strategy_operation_failures`
  * `ec_Microsoft_E_execution_strategy_operation_failures_per_second`
  * `ec_Microsoft_EntityFramew_total_optimistic_concurrency_failures`
  * `ec_Microsoft_EntityF_optimistic_concurrency_failures_per_second`

# Get started with the SQL Server Entity Framework Core integrations

> Learn how to set up the Aspire SQL Server EF Core Hosting and Client integrations simply.

![SQL Server logo](/_astro/sql-icon.CyVgV5Qd_Z1td4Jv.webp)

[SQL Server](https://www.microsoft.com/sql-server) is a relational database management system developed by Microsoft. The Aspire SQL Server Entity Framework Core (EF Core) integration enables you to connect to existing SQL Server instances or create new instances from .NET with the [`mcr.microsoft.com/mssql/server` container image](https://hub.docker.com/_/microsoft-mssql-server).

In this introduction, you’ll see how to install and use the Aspire SQL Server EF Core integrations in a simple configuration. If you already have this knowledge, see the links below for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire SQL Server Hosting integration in your Aspire AppHost project. This integration allows you to create and manage SQL Server database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.SqlServer package

  ```bash
  aspire add sqlserver
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > sqlserver (Aspire.Hosting.SqlServer)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.SqlServer" Version="*" />
  ```

Note

The [Aspire SQL Server Hosting integration](/integrations/databases/sql-server/sql-server-host/) is used in the App Host with both the EF Core and non-EF Core client integrations.

Next, in the AppHost project, create instances of SQL Server server and database resources, then pass the database to the consuming client projects:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql");
var sqldb = sql.AddDatabase("sqldb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("exampleproject")
                            .WaitFor(sqldb)
                            .WithReference(sqldb);


builder.Build().Run();
```

Tip

This is the simplest implementation of SQL Server resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [SQL Server Hosting integration](/integrations/databases/sql-server/sql-server-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the Aspire SQL Server EF Core client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire SQL Server EF Core client integration:

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package

  ```bash
  dotnet add package Aspire.Microsoft.EntityFrameworkCore.SqlServer
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.EntityFrameworkCore.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.EntityFrameworkCore.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.EntityFrameworkCore.SqlServer" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddSqlServerDbContext` extension method on any `IHostApplicationBuilder` to register a `DbContext` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqlServerDbContext<ExampleDbContext>(connectionName: "sqldb");
```

Tip

The `connectionName` parameter must match the name used when adding the SQL Server database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

### Use injected SQL Server properties

[Section titled “Use injected SQL Server properties”](#use-injected-sql-server-properties)

In the AppHost, when you used the `WithReference` method to pass a SQL Server database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `sqldb` becomes `SQLDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string sqlHost = builder.Configuration.GetValue<string>("SQLDB_HOST");
string sqlPort = builder.Configuration.GetValue<string>("SQLDB_PORT");
string sqlJDBCConnectionString = builder.Configuration.GetValue<string>("SQLDB_JDBCCONNECTIONSTRING");
```

Tip

The full set of properties that Aspire injects depends on the SQL Server resource configuration. For more information, see [Properties of the SQL Server resources](/integrations/databases/efcore/sql-server/sql-server-client/#properties-of-the-sql-server-resources).

### Use SQL Server resources in client code

[Section titled “Use SQL Server resources in client code”](#use-sql-server-resources-in-client-code)

You can now retrieve the `ExampleDbContext` instance using dependency injection. For example, to retrieve the context from a service:

C# — ExampleService.cs

```csharp
public class ExampleService(ExampleDbContext context)
{
    // Use context...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Next steps

[Section titled “Next steps”](#next-steps)

[SQL Server Hosting integration ](/integrations/databases/sql-server/sql-server-host/)Learn about the SQL Server hosting integration features and capabilities.

[SQL Server Client integration ](/integrations/databases/efcore/sql-server/sql-server-client/)Learn about the SQL Server EF Core client integration features and capabilities.

# Elasticsearch client integration

> Learn how to use the Elasticsearch client integration to interact with Elasticsearch instances.

![Elasticsearch logo](/_astro/elastic-icon.C7IAv20j_zxdpW.webp)

To get started with the Aspire Elasticsearch client integration, install the [📦 Aspire.Elastic.Clients.Elasticsearch](https://www.nuget.org/packages/Aspire.Elastic.Clients.Elasticsearch) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.Elastic.Clients.Elasticsearch package

  ```bash
  dotnet add package Aspire.Elastic.Clients.Elasticsearch
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Elastic.Clients.Elasticsearch@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Elastic.Clients.Elasticsearch package reference

  ```xml
  <PackageReference Include="Aspire.Elastic.Clients.Elasticsearch" Version="*" />
  ```

The Elasticsearch client integration registers an [ElasticsearchClient](https://github.com/elastic/elasticsearch-net) instance that you can use to interact with Elasticsearch.

For an introduction to the Elasticsearch integration, see [Get started with the Elasticsearch integrations](/integrations/databases/elasticsearch/elasticsearch-get-started/).

## Add Elasticsearch client

[Section titled “Add Elasticsearch client”](#add-elasticsearch-client)

In the `Program.cs` file of your client-consuming project, call the `AddElasticsearchClient` extension method to register an `ElasticsearchClient` for use via the dependency injection container:

```csharp
builder.AddElasticsearchClient(connectionName: "elasticsearch");
```

Tip

The `connectionName` parameter must match the name used when adding the Elasticsearch resource in the AppHost project.

You can then retrieve the `ElasticsearchClient` instance using dependency injection. For example, to retrieve the connection from an example service:

```csharp
public class ExampleService(ElasticsearchClient client)
{
    // Use client...
}
```

## Add keyed Elasticsearch client

[Section titled “Add keyed Elasticsearch client”](#add-keyed-elasticsearch-client)

There might be situations where you want to register multiple `ElasticsearchClient` instances with different connection names. To register keyed Elasticsearch clients, call the `AddKeyedElasticsearchClient` method:

```csharp
builder.AddKeyedElasticsearchClient(name: "products");
builder.AddKeyedElasticsearchClient(name: "orders");
```

Then you can retrieve the `ElasticsearchClient` instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("products")] ElasticsearchClient productsClient,
    [FromKeyedServices("orders")] ElasticsearchClient ordersClient)
{
    // Use clients...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Configuration

[Section titled “Configuration”](#configuration)

The Elasticsearch integration provides multiple options to configure the server connection based on the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddElasticsearchClient`:

```csharp
builder.AddElasticsearchClient("elasticsearch");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "elasticsearch": "http://elastic:password@localhost:27011"
  }
}
```

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Elasticsearch integration supports `Microsoft.Extensions.Configuration`. It loads the `ElasticClientsElasticsearchSettings` from configuration using the `Aspire:Elastic:Clients:Elasticsearch` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "Elastic": {
      "Clients": {
        "Elasticsearch": {
          "DisableHealthChecks": false,
          "DisableTracing": false,
          "HealthCheckTimeout": "00:00:03",
          "ApiKey": "<Valid ApiKey>",
          "Endpoint": "http://elastic:password@localhost:27011",
          "CloudId": "<Valid CloudId>"
        }
      }
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the `Action<ElasticClientsElasticsearchSettings>` delegate to set up options inline:

```csharp
builder.AddElasticsearchClient(
    "elasticsearch",
    static settings =>
        settings.Endpoint = new Uri("http://elastic:password@localhost:27011"));
```

### Use CloudId and ApiKey with configuration providers

[Section titled “Use CloudId and ApiKey with configuration providers”](#use-cloudid-and-apikey-with-configuration-providers)

When using [Elastic Cloud](https://www.elastic.co/cloud), you can provide the `CloudId` and `ApiKey` in the configuration:

```csharp
builder.AddElasticsearchClient("elasticsearch");
```

Example `appsettings.json`:

```json
{
  "Aspire": {
    "Elastic": {
      "Clients": {
        "Elasticsearch": {
          "ApiKey": "<Valid ApiKey>",
          "CloudId": "<Valid CloudId>"
        }
      }
    }
  }
}
```

### Use CloudId and ApiKey with inline delegates

[Section titled “Use CloudId and ApiKey with inline delegates”](#use-cloudid-and-apikey-with-inline-delegates)

```csharp
builder.AddElasticsearchClient(
    "elasticsearch",
    static settings =>
    {
        settings.ApiKey = "<Valid ApiKey>";
        settings.CloudId = "<Valid CloudId>";
    });
```

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Elasticsearch integration uses the configured client to perform a `PingAsync`. If the result is an HTTP 200 OK, the health check is considered healthy, otherwise it’s unhealthy.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

### Tracing

[Section titled “Tracing”](#tracing)

The Elasticsearch integration will emit the following tracing activities using OpenTelemetry:

* `Elastic.Transport`

# Get started with the Elasticsearch integrations

> Learn how to set up the Aspire Elasticsearch Hosting and Client integrations simply.

![Elasticsearch logo](/_astro/elastic-icon.C7IAv20j_zxdpW.webp)

[Elasticsearch](https://www.elastic.co/elasticsearch) is a distributed, RESTful search and analytics engine, scalable data store, and vector database capable of addressing a growing number of use cases. The Aspire Elasticsearch integration provides a way to connect to existing Elasticsearch instances, or create new instances from the [`docker.io/library/elasticsearch` container image](https://hub.docker.com/_/elasticsearch).

In this introduction, you’ll see how to install and use the Aspire Elasticsearch integrations in a simple configuration. If you already have this knowledge, see [Elasticsearch Hosting integration](/integrations/databases/elasticsearch/elasticsearch-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Elasticsearch Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Elasticsearch instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Elasticsearch package

  ```bash
  aspire add elasticsearch
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > elasticsearch (Aspire.Hosting.Elasticsearch)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Elasticsearch@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Elasticsearch package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Elasticsearch" Version="*" />
  ```

Next, in the AppHost project, create an instance of an Elasticsearch resource, then pass it to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(elasticsearch)
                            .WithReference(elasticsearch);
```

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(elasticsearch)
                            .WithReference(elasticsearch);
```

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(elasticsearch)
                 .WithReference(elasticsearch);
```

Tip

This is the simplest implementation of Elasticsearch resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Elasticsearch Hosting integration](/integrations/databases/elasticsearch/elasticsearch-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Elasticsearch client integration:

* .NET CLI

  .NET CLI — Add Aspire.Elastic.Clients.Elasticsearch package

  ```bash
  dotnet add package Aspire.Elastic.Clients.Elasticsearch
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Elastic.Clients.Elasticsearch@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Elastic.Clients.Elasticsearch package reference

  ```xml
  <PackageReference Include="Aspire.Elastic.Clients.Elasticsearch" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddElasticsearchClient` extension method on any `IHostApplicationBuilder` to register an `ElasticsearchClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddElasticsearchClient(connectionName: "elasticsearch");
```

Tip

The `connectionName` parameter must match the name used when adding the Elasticsearch resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with Elasticsearch in your Python consuming projects, you need to include the official Elasticsearch Python client library. You can install this library using pip:

```bash
pip install elasticsearch
```

Ensure that you `import` the Elasticsearch client in code files that interact with Elasticsearch. You should also import the `os` module to access environment variables:

Python - Import elasticsearch

```python
from elasticsearch import Elasticsearch
import os
```

To interact with Elasticsearch in your JavaScript consuming projects, you need to include the official Elasticsearch JavaScript client library. You can install this library using npm:

```bash
npm install @elastic/elasticsearch
```

Ensure that you import the Elasticsearch client in code files that interact with Elasticsearch:

JavaScript - Import @elastic/elasticsearch

```javascript
import { Client } from '@elastic/elasticsearch';
```

### Use injected Elasticsearch properties

[Section titled “Use injected Elasticsearch properties”](#use-injected-elasticsearch-properties)

In the AppHost, when you used the `WithReference` method to pass an Elasticsearch resource to a consuming client project, Aspire injects a connection string property that you can use in the consuming project. Aspire exposes the connection string as an environment variable named `ConnectionStrings__elasticsearch`.

Use the `GetValue()` method to obtain this environment variable in consuming projects:

C# - Obtain configuration properties

```csharp
string endpoint = builder.Configuration.GetValue<string>("ConnectionStrings__elasticsearch");
```

Use the `os.getenv()` method to obtain this environment variable in consuming projects:

Python - Obtain configuration properties

```python
elasticsearch_endpoint = os.getenv("ConnectionStrings__elasticsearch")
```

Use the `process.env` method to obtain this environment variable in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const elasticsearchEndpoint = process.env.ConnectionStrings__elasticsearch;
```

### Use Elasticsearch resources in client code

[Section titled “Use Elasticsearch resources in client code”](#use-elasticsearch-resources-in-client-code)

Now that you’ve added `ElasticsearchClient` to the builder in the consuming project, you can use the Elasticsearch resource to interact with the search engine. Get the `ElasticsearchClient` instance using dependency injection. For example, to retrieve your client object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(ElasticsearchClient client)
{
    // Use client to interact with Elasticsearch...
}
```

Having obtained the client, you can work with Elasticsearch as you would in any other C# application.

Use the information you have obtained about the Elasticsearch resource to connect to the search engine. Here is an example of how to connect using the official Python client:

Python - Connect to Elasticsearch

```python
es = Elasticsearch(elasticsearch_endpoint)
```

Having obtained the client, you can work with Elasticsearch as you would in any other Python application.

Use the information you have obtained about the Elasticsearch resource to connect to the search engine. Here is an example of how to connect using the official JavaScript client:

JavaScript - Connect to Elasticsearch

```javascript
const client = new Client({
  node: elasticsearchEndpoint
});
```

Having obtained the client, you can work with Elasticsearch as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now, that you have an Aspire app with Elasticsearch integrations up and running, you can use the following reference documents to learn how to configure and interact with the Elasticsearch resources:

[Understand the Elasticsearch hosting integration ](/integrations/databases/elasticsearch/elasticsearch-host/)Discover how to configure persistence, passwords, and more.

[Understand the Elasticsearch client integration ](/integrations/databases/elasticsearch/elasticsearch-client/)Discover how to configure keyed clients, client integration health checks, and more.

# Elasticsearch hosting integration

> Learn how to use the Elasticsearch hosting integration to create and manage Elasticsearch instances.

![Elasticsearch logo](/_astro/elastic-icon.C7IAv20j_zxdpW.webp)

The Elasticsearch hosting integration models an Elasticsearch instance as the `ElasticsearchResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Elasticsearch](https://www.nuget.org/packages/Aspire.Hosting.Elasticsearch) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Elasticsearch package

  ```bash
  aspire add elasticsearch
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > elasticsearch (Aspire.Hosting.Elasticsearch)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Elasticsearch@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Elasticsearch package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Elasticsearch" Version="*" />
  ```

For an introduction to the Elasticsearch integration, see [Get started with the Elasticsearch integrations](/integrations/databases/elasticsearch/elasticsearch-get-started/).

## Add Elasticsearch resource

[Section titled “Add Elasticsearch resource”](#add-elasticsearch-resource)

In your AppHost project, call `AddElasticsearch` on the builder instance to add an Elasticsearch resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(elasticsearch);
```

When Aspire adds a container image to the AppHost, it creates a new Elasticsearch instance on your local machine. The Elasticsearch resource includes default credentials with a `username` of `"elastic"` and a randomly generated password.

Tip

If you’d rather connect to an existing Elasticsearch instance, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add Elasticsearch resource with data volume

[Section titled “Add Elasticsearch resource with data volume”](#add-elasticsearch-resource-with-data-volume)

To add a data volume to the Elasticsearch resource, call the `WithDataVolume` method on the Elasticsearch resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch")
                           .WithDataVolume(isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(elasticsearch);
```

The data volume is used to persist the Elasticsearch data outside the lifecycle of its container. The data volume is mounted at the `/usr/share/elasticsearch/data` path in the Elasticsearch container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over bind mounts, see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

## Add Elasticsearch resource with data bind mount

[Section titled “Add Elasticsearch resource with data bind mount”](#add-elasticsearch-resource-with-data-bind-mount)

To add a data bind mount to the Elasticsearch resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch")
                           .WithDataBindMount(
                               source: @"C:\Elasticsearch\Data",
                               isReadOnly: false);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(elasticsearch);
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

Data bind mounts rely on the host machine’s filesystem to persist the Elasticsearch data across container restarts. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Add Elasticsearch resource with password parameter

[Section titled “Add Elasticsearch resource with password parameter”](#add-elasticsearch-resource-with-password-parameter)

When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var password = builder.AddParameter("password", secret: true);
var elasticsearch = builder.AddElasticsearch("elasticsearch", password);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(elasticsearch);
```

For more information on providing parameters, see [External parameters](/get-started/resources/).

## Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Elasticsearch hosting integration automatically adds a health check for the Elasticsearch resource. The health check verifies that the Elasticsearch instance is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.Elasticsearch](https://www.nuget.org/packages/AspNetCore.HealthChecks.Elasticsearch) NuGet package.

## Use the integration with non-.NET languages

[Section titled “Use the integration with non-.NET languages”](#use-the-integration-with-non-net-languages)

You can use the Elasticsearch hosting integration in non-.NET consuming projects such as Python or JavaScript. When you add a reference to an Elasticsearch resource in a non-.NET project, Aspire injects connection properties into the consuming project’s environment variables, which you can use to interact with Elasticsearch.

Consider the following example where a Python app is added to the Aspire app model and referenced to an Elasticsearch resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var elasticsearch = builder.AddElasticsearch("elasticsearch");


var pythonApp = builder.AddPythonApp("python-app", "./python_app", "main.py")
                       .WithReference(elasticsearch);
```

In the Python app, you can access the Elasticsearch connection information using the environment variable that Aspire injects. Here’s an example of how to connect to Elasticsearch in Python using the official `elasticsearch` client:

Python - Connect to Elasticsearch

```python
from elasticsearch import Elasticsearch
import os


# Get the Elasticsearch endpoint from environment variables
elasticsearch_endpoint = os.getenv("ConnectionStrings__elasticsearch")


# Create Elasticsearch client
es = Elasticsearch(elasticsearch_endpoint)


# Use the client
response = es.ping()
print(f"Elasticsearch connection status: {response}")
```

Similarly, in a JavaScript app, you can use the environment variables to connect to Elasticsearch:

JavaScript - Connect to Elasticsearch

```javascript
import { Client } from '@elastic/elasticsearch';


// Get the Elasticsearch endpoint from environment variables
const elasticsearchEndpoint = process.env.ConnectionStrings__elasticsearch;


// Create Elasticsearch client
const client = new Client({
  node: elasticsearchEndpoint
});


// Use the client
const response = await client.ping();
console.log('Elasticsearch connection status:', response);
```

# KurrentDB integration

> Learn how to use the KurrentDB hosting and client integration to run the KurrentDB container and access it via the KurrentDB client.

⭐ Community Toolkit ![KurrentDB logo](/_astro/kurrent-icon.DqAKa12N.png)

[KurrentDB](https://www.kurrent.io/) is an event store database designed for Event Sourcing, offering high availability and reliability for storing events. The Aspire KurrentDB integration enables you to connect to existing KurrentDB instances or create new instances from Aspire using the KurrentDB container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To run the KurrentDB container, install the [📦 CommunityToolkit.Aspire.Hosting.KurrentDB](https://nuget.org/packages/CommunityToolkit.Aspire.Hosting.KurrentDB) NuGet package in the AppHost project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.KurrentDB package

  ```bash
  aspire add communitytoolkit-kurrentdb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-kurrentdb (CommunityToolkit.Aspire.Hosting.KurrentDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.KurrentDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.KurrentDB package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.KurrentDB" Version="*" />
  ```

### Add KurrentDB resource

[Section titled “Add KurrentDB resource”](#add-kurrentdb-resource)

In the AppHost project, register and consume the KurrentDB integration using the `AddKurrentDB` extension method to add the KurrentDB container to the application builder.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kurrentdb = builder.AddKurrentDB("kurrentdb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kurrentdb);


// After adding all resources, run the app...
```

### Add KurrentDB resource with data volume

[Section titled “Add KurrentDB resource with data volume”](#add-kurrentdb-resource-with-data-volume)

To add a data volume to the KurrentDB resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kurrentdb = builder.AddKurrentDB("kurrentdb")
                       .WithDataVolume();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kurrentdb);


// After adding all resources, run the app...
```

The data volume is used to persist the KurrentDB data outside the lifecycle of its container. The data volume is mounted at the `/var/lib/kurrentdb` path in the KurrentDB container.

### Add KurrentDB resource with data bind mount

[Section titled “Add KurrentDB resource with data bind mount”](#add-kurrentdb-resource-with-data-bind-mount)

To add a data bind mount to the KurrentDB resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kurrentdb = builder.AddKurrentDB("kurrentdb")
                       .WithDataBindMount(source: @"C:\KurrentDB\Data");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kurrentdb);


// After adding all resources, run the app...
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The KurrentDB hosting integration automatically adds a health check for the KurrentDB resource. The health check verifies that the KurrentDB instance is running and that a connection can be established to it.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire KurrentDB client integration, install the [📦 CommunityToolkit.Aspire.KurrentDB](https://nuget.org/packages/CommunityToolkit.Aspire.KurrentDB) NuGet package in the client-consuming project:

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.KurrentDB package

  ```bash
  dotnet add package CommunityToolkit.Aspire.KurrentDB
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.KurrentDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.KurrentDB package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.KurrentDB" Version="*" />
  ```

### Add KurrentDB client

[Section titled “Add KurrentDB client”](#add-kurrentdb-client)

In the `Program.cs` file of your client-consuming project, call the `AddKurrentDBClient` extension to register an `KurrentDBClient` for use via the dependency injection container.

```csharp
builder.AddKurrentDBClient(connectionName: "kurrentdb");
```

Tip

The `connectionName` parameter must match the name used when adding the KurrentDB resource in the AppHost project.

You can then retrieve the `KurrentDBClient` instance using dependency injection. For example, to retrieve the client from a service:

```csharp
public class ExampleService(KurrentDBClient client)
{
    // Use client...
}
```

### Add keyed KurrentDB client

[Section titled “Add keyed KurrentDB client”](#add-keyed-kurrentdb-client)

There might be situations where you want to register multiple `KurrentDBClient` instances with different connection names. To register keyed KurrentDB clients, call the `AddKeyedKurrentDBClient` method:

```csharp
builder.AddKeyedKurrentDBClient(name: "events");
builder.AddKeyedKurrentDBClient(name: "audit");
```

Then retrieve the instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("events")] KurrentDBClient eventsClient,
    [FromKeyedServices("audit")] KurrentDBClient auditClient)
{
    // Use clients...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The KurrentDB client integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddKurrentDBClient`:

```csharp
builder.AddKurrentDBClient("kurrentdb");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "kurrentdb": "kurrentdb://localhost:22113?tls=false"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The KurrentDB client integration supports `Microsoft.Extensions.Configuration`. It loads the `KurrentDBSettings` from configuration using the `Aspire:KurrentDB:Client` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "KurrentDB": {
      "Client": {
        "ConnectionString": "kurrentdb://localhost:22113?tls=false",
        "DisableHealthChecks": false,
        "DisableTracing": false
      }
    }
  }
}
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the delegate to set up options inline:

```csharp
builder.AddKurrentDBClient(
    "kurrentdb",
    static settings => settings.DisableHealthChecks = true);
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The KurrentDB integration adds a health check that verifies the KurrentDB instance is reachable and can execute commands.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The KurrentDB integration uses the following log categories:

* `Aspire.KurrentDB`

#### Tracing

[Section titled “Tracing”](#tracing)

The KurrentDB integration emits tracing activities using OpenTelemetry when tracing is not disabled.

## See also

[Section titled “See also”](#see-also)

* [KurrentDB](https://www.kurrent.io/)
* [KurrentDB .NET Client](https://github.com/kurrent-io/KurrentDB-Client-Dotnet)
* [Aspire Community Toolkit GitHub repo](https://github.com/CommunityToolkit/Aspire)

# Meilisearch integration

> Learn how to use the Meilisearch hosting and client integration to run the Meilisearch container and access it via the Meilisearch client.

⭐ Community Toolkit ![Meilisearch logo](/_astro/meilisearch-icon.CR2umVYU_16M3f7.webp)

[Meilisearch](https://meilisearch.com) is a fast, open-source search engine that makes search and discovery easy. The Aspire Meilisearch integration enables you to connect to existing Meilisearch instances or create new instances from Aspire using the `docker.io/getmeili/meilisearch` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To run the Meilisearch container, install the [📦 CommunityToolkit.Aspire.Hosting.Meilisearch](https://nuget.org/packages/CommunityToolkit.Aspire.Hosting.Meilisearch) NuGet package in the AppHost project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Meilisearch package

  ```bash
  aspire add communitytoolkit-meilisearch
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-meilisearch (CommunityToolkit.Aspire.Hosting.Meilisearch)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Meilisearch@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Meilisearch package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Meilisearch" Version="*" />
  ```

### Add Meilisearch resource

[Section titled “Add Meilisearch resource”](#add-meilisearch-resource)

In the AppHost project, register and consume the Meilisearch integration using the `AddMeilisearch` extension method to add the Meilisearch container to the application builder.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var meilisearch = builder.AddMeilisearch("meilisearch");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(meilisearch);


// After adding all resources, run the app...
```

The Meilisearch resource includes a randomly generated master key when one wasn’t provided.

### Add Meilisearch resource with data volume

[Section titled “Add Meilisearch resource with data volume”](#add-meilisearch-resource-with-data-volume)

To add a data volume to the Meilisearch resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var meilisearch = builder.AddMeilisearch("meilisearch")
                         .WithDataVolume();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(meilisearch);


// After adding all resources, run the app...
```

The data volume is used to persist the Meilisearch data outside the lifecycle of its container. The data volume is mounted at the `/meili_data` path in the Meilisearch container.

### Add Meilisearch resource with data bind mount

[Section titled “Add Meilisearch resource with data bind mount”](#add-meilisearch-resource-with-data-bind-mount)

To add a data bind mount to the Meilisearch resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var meilisearch = builder.AddMeilisearch("meilisearch")
                         .WithDataBindMount(source: @"C:\Meilisearch\Data");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(meilisearch);


// After adding all resources, run the app...
```

Data bind mounts rely on the host machine’s filesystem to persist the Meilisearch data across container restarts.

### Add Meilisearch resource with master key parameter

[Section titled “Add Meilisearch resource with master key parameter”](#add-meilisearch-resource-with-master-key-parameter)

When you want to explicitly provide the master key used by the container image, you can provide these credentials as parameters:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var masterkey = builder.AddParameter("masterkey", secret: true);
var meilisearch = builder.AddMeilisearch("meilisearch", masterkey);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(meilisearch);


// After adding all resources, run the app...
```

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Meilisearch client integration, install the [📦 CommunityToolkit.Aspire.Meilisearch](https://nuget.org/packages/CommunityToolkit.Aspire.Meilisearch) NuGet package in the client-consuming project.

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.Meilisearch package

  ```bash
  dotnet add package CommunityToolkit.Aspire.Meilisearch
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Meilisearch@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Meilisearch package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Meilisearch" Version="*" />
  ```

### Add Meilisearch client

[Section titled “Add Meilisearch client”](#add-meilisearch-client)

In the `Program.cs` file of your client-consuming project, call the `AddMeilisearchClient` extension method to register a `MeilisearchClient` for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddMeilisearchClient(connectionName: "meilisearch");
```

Tip

The `connectionName` parameter must match the name used when adding the Meilisearch resource in the AppHost project.

You can then retrieve the `MeilisearchClient` instance using dependency injection:

```csharp
public class ExampleService(MeilisearchClient client)
{
    // Use client...
}
```

### Add keyed Meilisearch client

[Section titled “Add keyed Meilisearch client”](#add-keyed-meilisearch-client)

There might be situations where you want to register multiple `MeilisearchClient` instances with different connection names. To register keyed Meilisearch clients, call the `AddKeyedMeilisearchClient` method:

```csharp
builder.AddKeyedMeilisearchClient(name: "products");
builder.AddKeyedMeilisearchClient(name: "orders");
```

Then you can retrieve the `MeilisearchClient` instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("products")] MeilisearchClient productsClient,
    [FromKeyedServices("orders")] MeilisearchClient ordersClient)
{
    // Use clients...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire Meilisearch client integration provides multiple options to configure the server connection.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name of the connection string:

```csharp
builder.AddMeilisearchClient("meilisearch");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "meilisearch": "Endpoint=http://localhost:19530/;MasterKey=123456!@#$%"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Meilisearch Client integration supports configuration. It loads the settings from configuration using the `Aspire:Meilisearch:Client` key:

```json
{
  "Aspire": {
    "Meilisearch": {
      "Client": {
        "Endpoint": "http://localhost:19530/",
        "MasterKey": "123456!@#$%"
      }
    }
  }
}
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

The Aspire Meilisearch integration uses the configured client to perform a health check.

## See also

[Section titled “See also”](#see-also)

* [Meilisearch](https://meilisearch.com)
* [Meilisearch Client](https://github.com/meilisearch/meilisearch-dotnet)
* [Aspire Community Toolkit GitHub repo](https://github.com/CommunityToolkit/Aspire)

# Milvus Client integration reference

> Learn how to use the Aspire Milvus Client integration to interact with Milvus vector databases from your Aspire projects.

![Milvus logo](/_astro/milvus-icon.QcNRKvVY_ZN4fwB.webp)

To get started with the Aspire Milvus integrations, follow the [Get started with Milvus integrations](../milvus-get-started/) guide.

This article includes full details about the Aspire Milvus Client integration, which allows you to connect to and interact with Milvus vector databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

Caution

The client integration is currently in preview.

You need a Milvus server and connection information for accessing the server. To get started with the Aspire Milvus client integration, install the [📦 Aspire.Milvus.Client](https://www.nuget.org/packages/Aspire.Milvus.Client) NuGet package in the client-consuming project, that is, the project for the application that uses the Milvus client. The Milvus client integration registers a `MilvusClient` instance that you can use to interact with Milvus.

* .NET CLI

  .NET CLI — Add Aspire.Milvus.Client package

  ```bash
  dotnet add package Aspire.Milvus.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Milvus.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Milvus.Client package reference

  ```xml
  <PackageReference Include="Aspire.Milvus.Client" Version="*" />
  ```

## Add Milvus client

[Section titled “Add Milvus client”](#add-milvus-client)

In the `Program.cs` file of your client-consuming project, call the `AddMilvusClient` extension method on any `IHostApplicationBuilder` to register a `MilvusClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMilvusClient(connectionName: "milvusdb");
```

Tip

The `connectionName` parameter must match the name used when adding the Milvus database resource in the AppHost project. For more information, see [Add Milvus server and database resources](../milvus-host/#add-milvus-server-and-database-resources).

You can then retrieve the `MilvusClient` instance using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(MilvusClient client)
{
    // Use the Milvus Client...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Add keyed Milvus client

[Section titled “Add keyed Milvus client”](#add-keyed-milvus-client)

There might be situations where you want to register multiple `MilvusClient` instances with different connection strings. To register keyed Milvus clients, call the `AddKeyedMilvusClient` method:

C# — Program.cs

```csharp
builder.AddKeyedMilvusClient(name: "mainDb");
builder.AddKeyedMilvusClient(name: "loggingDb");
```

Then retrieve the instances using dependency injection:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("mainDb")] MilvusClient mainDbClient,
    [FromKeyedServices("loggingDb")] MilvusClient loggingDbClient)
{
    // Use clients...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Properties of the Milvus resources

[Section titled “Properties of the Milvus resources”](#properties-of-the-milvus-resources)

When you use the `WithReference` method to pass a Milvus server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `vectordb` becomes `VECTORDB_URI`.

### Milvus server

[Section titled “Milvus server”](#milvus-server)

The Milvus server resource exposes the following connection properties:

| Property Name | Description                                                   |
| ------------- | ------------------------------------------------------------- |
| `Host`        | The hostname or IP address of the Milvus server               |
| `Port`        | The gRPC port exposed by the Milvus server                    |
| `Token`       | The authentication token, with the format `root:{ApiKey}`     |
| `Uri`         | The gRPC endpoint URI, with the format `http://{Host}:{Port}` |

**Example connection strings:**

```plaintext
Uri: http://localhost:19530
Token: root:Milvus
```

### Milvus database

[Section titled “Milvus database”](#milvus-database)

The Milvus database resource inherits all properties from its parent `MilvusServerResource` and adds:

| Property Name  | Description              |
| -------------- | ------------------------ |
| `DatabaseName` | The Milvus database name |

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire Milvus client integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddMilvusClient()`:

C# — Program.cs

```csharp
builder.AddMilvusClient("milvus");
```

The connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "milvus": "Endpoint=http://localhost:19530/;Key=root:Non-default-P@ssw0rd"
  }
}
```

For more information about the Milvus connection string format, see the [Milvus documentation](https://milvus.io/).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Milvus client integration supports `Microsoft.Extensions.Configuration` from configuration files such as `appsettings.json` by using the `Aspire:Milvus:Client` key. If you have set up your configurations in the `Aspire:Milvus:Client` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Milvus": {
      "Client": {
        "Endpoint": "http://localhost:19530/",
        "Database": "milvusdb",
        "Key": "root:Non-default-P@ssw0rd",
        "DisableHealthChecks": false
      }
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<MilvusSettings>` delegate to set up some or all the options inline, for example to set the API key from code:

C# — Program.cs

```csharp
builder.AddMilvusClient(
    "milvus",
    static settings => settings.Key = "root:Non-default-P@ssw0rd");
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the available configurable options:

| Name                  | Description                                                                 |
| --------------------- | --------------------------------------------------------------------------- |
| `Endpoint`            | The endpoint URI of the Milvus server to connect to.                        |
| `Database`            | The name of the Milvus database.                                            |
| `Key`                 | The authentication key used for authentication (format: `root:{password}`). |
| `DisableHealthChecks` | A boolean value that indicates whether the health check is disabled or not. |

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

By default, the Aspire Milvus client integration handles the following:

* Checks if the `MilvusSettings.DisableHealthChecks` is `true`.
* If not disabled, adds a health check that verifies the Milvus server is reachable and a connection can be established.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire Milvus client integration uses the following log categories:

* `Milvus.Client`

### Tracing and Metrics

[Section titled “Tracing and Metrics”](#tracing-and-metrics)

The Milvus integration doesn’t currently emit tracing activities or metrics because they are not supported by the `Milvus.Client` library.

## See also

[Section titled “See also”](#see-also)

* [Milvus](https://milvus.io/)
* [Milvus Documentation](https://milvus.io/docs)
* [Aspire integrations](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the Milvus integrations

> Learn how to set up the Aspire Milvus Hosting and Client integrations simply.

![Milvus logo](/_astro/milvus-icon.QcNRKvVY_ZN4fwB.webp)

[Milvus](https://milvus.io/) is an open-source vector database system that efficiently stores, indexes, and searches large-scale vector data. It’s commonly used in machine learning, artificial intelligence, and data science applications. The Aspire Milvus integration enables you to connect to existing Milvus servers or create new servers from Aspire with the [`milvusdb/milvus` container image](https://hub.docker.com/r/milvusdb/milvus).

In this introduction, you’ll see how to install and use the Aspire Milvus integrations in a simple configuration. If you already have this knowledge, see [Milvus Hosting integration](../milvus-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Milvus Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Milvus vector database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Milvus package

  ```bash
  aspire add milvus
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > milvus (Aspire.Hosting.Milvus)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Milvus@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Milvus package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Milvus" Version="*" />
  ```

Next, in the AppHost project, create instances of Milvus server and database resources, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("exampleProject")
                            .WaitFor(milvusdb)
                            .WithReference(milvusdb);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(milvusdb)
                            .WithReference(milvusdb);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(milvusdb)
                 .WithReference(milvusdb);
```

Tip

This is the simplest implementation of Milvus resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Milvus Hosting integration](../milvus-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Milvus client integration:

* .NET CLI

  .NET CLI — Add Aspire.Milvus.Client package

  ```bash
  dotnet add package Aspire.Milvus.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Milvus.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Milvus.Client package reference

  ```xml
  <PackageReference Include="Aspire.Milvus.Client" Version="*" />
  ```

Caution

The client integration is currently in preview.

In the `Program.cs` file of your client-consuming project, call the `AddMilvusClient` extension method on any `IHostApplicationBuilder` to register a `MilvusClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMilvusClient(connectionName: "milvusdb");
```

Tip

The `connectionName` parameter must match the name used when adding the Milvus database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with Milvus vector databases in your Python consuming projects, you need to include a Milvus client library. The official option is `pymilvus`, which is Milvus’s Python SDK. You can install this library using pip:

```bash
pip install pymilvus
```

Ensure that you import the `MilvusClient` in code files that interact with the vector database. You should also import the `os` module to access environment variables:

Python - Import pymilvus

```python
from pymilvus import MilvusClient
import os
```

To interact with Milvus vector databases in your JavaScript consuming projects, you need to include a Milvus client library. The official option is `@zilliz/milvus2-sdk-node`, which is Milvus’s Node.js SDK. You can install this library using npm:

```bash
npm install @zilliz/milvus2-sdk-node
```

Ensure that you import the `MilvusClient` in code files that interact with the vector database:

JavaScript - Import @zilliz/milvus2-sdk-node

```javascript
const { MilvusClient } = require('@zilliz/milvus2-sdk-node');
```

### Use injected Milvus properties

[Section titled “Use injected Milvus properties”](#use-injected-milvus-properties)

In the AppHost, when you used the `WithReference` method to pass a Milvus database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `milvusdb` becomes `MILVUSDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string connectionUri = builder.Configuration.GetValue<string>("ConnectionStrings__milvusdb");
string token = builder.Configuration.GetValue<string>("MILVUSDB_TOKEN");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python - Obtain configuration properties

```python
connection_uri = os.getenv("ConnectionStrings__milvusdb")
host = os.getenv("MILVUSDB_HOST")
port = os.getenv("MILVUSDB_PORT")
token = os.getenv("MILVUSDB_TOKEN")
database_name = os.getenv("MILVUSDB_DATABASENAME")
```

Use the `process.env` method to obtain these environment variables in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const connectionUri = process.env.ConnectionStrings__milvusdb;
const host = process.env.MILVUSDB_HOST;
const port = process.env.MILVUSDB_PORT;
const token = process.env.MILVUSDB_TOKEN;
const databaseName = process.env.MILVUSDB_DATABASENAME;
```

Tip

The full set of properties that Aspire injects depends on the Milvus resource configuration. For more information, see [Properties of the Milvus resources](../milvus-client/#properties-of-the-milvus-resources).

### Use Milvus resources in client code

[Section titled “Use Milvus resources in client code”](#use-milvus-resources-in-client-code)

Now that you’ve added the `MilvusClient` to the builder in the consuming project, you can use the Milvus vector database to store and search vector data. Get the `MilvusClient` instance using dependency injection. For example, to retrieve your client object from an example service, define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(MilvusClient client)
{
    // Use Milvus client...
}
```

Having obtained the client, you can work with the Milvus vector database as you would in any other C# application.

Use the information you have obtained about the Milvus resource to connect to the vector database. Here is an example of how to connect using `pymilvus`:

Python - Connect to Milvus

```python
# Create Milvus client
# The token format is "username:password"
client = MilvusClient(
    uri=f"http://{host}:{port}",
    token=token,
    db_name=database_name
)


# Verify connection
print(f"Connected to Milvus database: {database_name}")
```

Having obtained the client, you can work with the Milvus vector database as you would in any other Python application.

Use the information you have obtained about the Milvus resource to connect to the vector database. Here is an example of how to connect using `@zilliz/milvus2-sdk-node`:

JavaScript - Connect to Milvus

```javascript
// Create Milvus client
const client = new MilvusClient({
  address: `${host}:${port}`,
  token: token,
  database: databaseName
});


// Verify connection
console.log(`Connected to Milvus database: ${databaseName}`);
```

Having obtained the client, you can work with the Milvus vector database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with Milvus integrations up and running, you can use the following reference documents to learn how to configure and interact with the Milvus resources:

[Understand the Milvus hosting integration ](/integrations/databases/milvus/milvus-host/)Discover how to configure data volumes, Attu GUI, and more.

[Understand the Milvus client integration ](/integrations/databases/milvus/milvus-client/)Learn about the Milvus client integration, including connection strings and observability.

# Milvus Hosting integration reference

> Learn how to use the Aspire Milvus Hosting integration to orchestrate and configure Milvus vector databases in your Aspire projects.

![Milvus logo](/_astro/milvus-icon.QcNRKvVY_ZN4fwB.webp)

To get started with the Aspire Milvus integrations, follow the [Get started with Milvus integrations](../milvus-get-started/) guide.

This article includes full details about the Aspire Milvus Hosting integration, which models Milvus server and database resources as the `MilvusServerResource` and `MilvusDatabaseResource` types. To access these types and APIs, you need to install the Milvus Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

The Aspire Milvus hosting integration models the Milvus vector database server as the following types:

* `MilvusServerResource`
* `MilvusDatabaseResource`

To access these types and APIs for expressing them as resources in your AppHost project, install the [📦 Aspire.Hosting.Milvus](https://www.nuget.org/packages/Aspire.Hosting.Milvus) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Milvus package

  ```bash
  aspire add milvus
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > milvus (Aspire.Hosting.Milvus)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Milvus@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Milvus package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Milvus" Version="*" />
  ```

## Add Milvus server and database resources

[Section titled “Add Milvus server and database resources”](#add-milvus-server-and-database-resources)

In the AppHost project, call `AddMilvus` to add and return a Milvus server resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add a Milvus database to the server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(milvusdb)
       .WaitFor(milvusdb);


// After adding all resources, run the app...
```

Note

The Milvus container can be slow to start, so it’s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

When Aspire adds a container image to the AppHost, as shown in the preceding example with the `milvusdb/milvus` image, it creates a new Milvus server on your local machine. A reference to your Milvus resource builder (the `milvus` variable) is used to add a database. The database is named `milvusdb` and then added to the `ExampleProject`.

The `WithReference` method configures a connection in the `ExampleProject` named `"milvusdb"`. For more information, see [Container resource lifecycle](/architecture/resource-model/#built-in-resources-and-lifecycle).

Tip

If you’d rather connect to an existing Milvus server, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add Milvus resource with API key parameter

[Section titled “Add Milvus resource with API key parameter”](#add-milvus-resource-with-api-key-parameter)

The Milvus resource includes default credentials with a `username` of `root` and the password `Milvus`. To change the default password in the container, pass an `apiKey` parameter:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiKey = builder.AddParameter("apiKey", secret: true);


var milvus = builder.AddMilvus("milvus", apiKey)
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(milvusdb)
                       .WaitFor(milvusdb);
```

The preceding code gets a parameter to pass to the `AddMilvus` API, and internally assigns the parameter to the Milvus container configuration. The `apiKey` parameter is usually specified as a user secret:

JSON — secrets.json

```json
{
  "Parameters": {
    "apiKey": "your-secure-password"
  }
}
```

For more information, see [External parameters](/get-started/resources/).

## Add Milvus resource with data volume

[Section titled “Add Milvus resource with data volume”](#add-milvus-resource-with-data-volume)

To add a data volume to the Milvus resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithDataVolume()
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(milvusdb)
       .WaitFor(milvusdb);


// After adding all resources, run the app...
```

The data volume is used to persist the Milvus data outside the lifecycle of its container. The data volume is mounted at the `/var/lib/milvus` path in the Milvus container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-milvus-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

## Add Milvus resource with data bind mount

[Section titled “Add Milvus resource with data bind mount”](#add-milvus-resource-with-data-bind-mount)

To add a data bind mount to the Milvus resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithDataBindMount(source: @"C:\Milvus\Data")
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(milvusdb)
       .WaitFor(milvusdb);


// After adding all resources, run the app...
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the Milvus data across container restarts. The data bind mount is mounted at the `C:\Milvus\Data` on Windows (or `/Milvus/Data` on Unix) path on the host machine in the Milvus container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Create an Attu resource

[Section titled “Create an Attu resource”](#create-an-attu-resource)

[Attu](https://zilliz.com/attu) is a graphical user interface (GUI) and management tool designed to interact with Milvus and its databases. To use Attu, call the `WithAttu` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var milvus = builder.AddMilvus("milvus")
                    .WithAttu()
                    .WithLifetime(ContainerLifetime.Persistent);


var milvusdb = milvus.AddDatabase("milvusdb");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(milvusdb)
                       .WaitFor(milvusdb);
```

When you debug the Aspire solution, you’ll see an Attu container listed in the resources. Select the resource’s endpoint to open the GUI.

## Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

When you use the `WithReference` method to pass a Milvus database resource to a non-.NET application (such as Python or JavaScript), Aspire automatically injects environment variables that describe the connection information.

For example, if you reference a Milvus database resource named `milvusdb`:

C# — AppHost.cs

```csharp
var milvus = builder.AddMilvus("milvus");
var milvusdb = milvus.AddDatabase("milvusdb");


var pythonApp = builder.AddUvicornApp("api", "./api", "main:app")
    .WithReference(milvusdb);
```

The following environment variables are available in the Python application:

* `ConnectionStrings__milvusdb` - The connection string for the Milvus database
* `MILVUSDB_HOST` - The hostname of the Milvus server
* `MILVUSDB_PORT` - The gRPC port number
* `MILVUSDB_TOKEN` - The authentication token (format: `root:{password}`)
* `MILVUSDB_URI` - The gRPC connection URI
* `MILVUSDB_DATABASENAME` - The database name

You can access these environment variables in your application code:

Python example

```python
from pymilvus import MilvusClient
import os


# Get connection properties
host = os.getenv("MILVUSDB_HOST")
port = os.getenv("MILVUSDB_PORT")
token = os.getenv("MILVUSDB_TOKEN")
database_name = os.getenv("MILVUSDB_DATABASENAME")


# Create Milvus client
client = MilvusClient(
    uri=f"http://{host}:{port}",
    token=token,
    db_name=database_name
)
```

JavaScript example

```javascript
const { MilvusClient } = require('@zilliz/milvus2-sdk-node');


// Get connection properties
const host = process.env.MILVUSDB_HOST;
const port = process.env.MILVUSDB_PORT;
const token = process.env.MILVUSDB_TOKEN;
const databaseName = process.env.MILVUSDB_DATABASENAME;


// Create Milvus client
const client = new MilvusClient({
  address: `${host}:${port}`,
  token: token,
  database: databaseName
});
```

# MongoDB Client integration reference

> Learn how to use the Aspire MongoDB Client integration to interact with MongoDB databases from your Aspire projects.

![MongoDB logo](/_astro/mongodb-icon.KisFuM9l_p6JLn.webp)

To get started with the Aspire MongoDB integrations, follow the [Get started with MongoDB integrations](/integrations/databases/mongodb/mongodb-get-started/) guide.

This article includes full details about the Aspire MongoDB Client integration, which allows you to connect to and interact with MongoDB databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

You need a MongoDB server and connection information for accessing the server. To get started with the Aspire MongoDB client integration, install the [📦 Aspire.MongoDB.Driver](https://www.nuget.org/packages/Aspire.MongoDB.Driver) NuGet package in the client-consuming project, that is, the project for the application that uses the MongoDB client. The MongoDB client integration registers an `IMongoClient` instance that you can use to interact with MongoDB.

* .NET CLI

  .NET CLI — Add Aspire.MongoDB.Driver package

  ```bash
  dotnet add package Aspire.MongoDB.Driver
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.MongoDB.Driver@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.MongoDB.Driver package reference

  ```xml
  <PackageReference Include="Aspire.MongoDB.Driver" Version="*" />
  ```

Danger

The `Aspire.MongoDB.Driver` NuGet package depends on the `MongoDB.Driver` NuGet package. With the release of version 3.0.0 of `MongoDB.Driver`, a binary breaking change was introduced. To address this, a new client integration package, `Aspire.MongoDB.Driver.v3`, was created. The original `Aspire.MongoDB.Driver` package continues to reference `MongoDB.Driver` version 2.30.0. The new `Aspire.MongoDB.Driver.v3` package references `MongoDB.Driver` version 3.0.0. In a future version of Aspire, the `Aspire.MongoDB.Driver` will be updated to version 3.x and the `Aspire.MongoDB.Driver.v3` package will be deprecated. For more information, see [Upgrade to version 3.0](https://www.mongodb.com/docs/drivers/csharp/v3.0/upgrade/v3/).

## Add MongoDB client

[Section titled “Add MongoDB client”](#add-mongodb-client)

In the `Program.cs` file of your client-consuming project, call the `AddMongoDBClient` extension method on any `IHostApplicationBuilder` to register a `IMongoClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMongoDBClient(connectionName: "mongodb");
```

Tip

The `connectionName` parameter must match the name used when adding the MongoDB database resource in the AppHost project. For more information, see [Add MongoDB server and database resources](/integrations/databases/mongodb/mongodb-host/#add-mongodb-server-and-database-resources).

You can then retrieve the `IMongoClient` instance using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(IMongoClient client)
{
    // Use the MongoDB Client...
}
```

The `IMongoClient` is used to interact with the MongoDB server resource. When you define a MongoDB database resource in your AppHost, you could instead require that the dependency injection container provides an `IMongoDatabase` instance:

C# — ExampleService.cs

```csharp
public class ExampleService(IMongoDatabase database)
{
    // Use the MongoDB Database...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Add keyed MongoDB client

[Section titled “Add keyed MongoDB client”](#add-keyed-mongodb-client)

There might be situations where you want to register multiple `IMongoDatabase` instances with different connection names. To register keyed MongoDB clients, call the `AddKeyedMongoDBClient` method:

C# — Program.cs

```csharp
builder.AddKeyedMongoDBClient(name: "mainDb");
builder.AddKeyedMongoDBClient(name: "loggingDb");
```

Danger

When using keyed services, it’s expected that your MongoDB resource configured two named databases, one for the `mainDb` and one for the `loggingDb`.

Then you can retrieve the `IMongoDatabase` instances using dependency injection:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("mainDb")] IMongoDatabase mainDatabase,
    [FromKeyedServices("loggingDb")] IMongoDatabase loggingDatabase)
{
    // Use databases...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Properties of the MongoDB resources

[Section titled “Properties of the MongoDB resources”](#properties-of-the-mongodb-resources)

When you use the `WithReference` method to pass a MongoDB server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

### MongoDB server

[Section titled “MongoDB server”](#mongodb-server)

The MongoDB server resource exposes the following connection properties:

| Property Name             | Description                                                                                                                                                      |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`                    | The hostname or IP address of the MongoDB server                                                                                                                 |
| `Port`                    | The port number the MongoDB server is listening on                                                                                                               |
| `Username`                | The username for authentication                                                                                                                                  |
| `Password`                | The password for authentication (available when a password parameter is configured)                                                                              |
| `AuthenticationDatabase`  | The authentication database (available when a password parameter is configured)                                                                                  |
| `AuthenticationMechanism` | The authentication mechanism (available when a password parameter is configured)                                                                                 |
| `Uri`                     | The connection URI, with the format `mongodb://{Username}:{Password}@{Host}:{Port}/?authSource={AuthenticationDatabase}&authMechanism={AuthenticationMechanism}` |

**Example connection string:**

```plaintext
Uri: mongodb://admin:p%40ssw0rd1@localhost:27017/?authSource=admin&authMechanism=SCRAM-SHA-256
```

### MongoDB database

[Section titled “MongoDB database”](#mongodb-database)

The MongoDB database resource inherits all properties from its parent `MongoDBServerResource` and adds:

| Property Name  | Description               |
| -------------- | ------------------------- |
| `DatabaseName` | The MongoDB database name |

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire MongoDB client integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddMongoDBClient()`:

C# — Program.cs

```csharp
builder.AddMongoDBClient("mongo");
```

The connection string is retrieved from the `ConnectionStrings` configuration section. Consider the following MongoDB example JSON configuration:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "mongo": "mongodb://server:port/test"
  }
}
```

Alternatively, consider the following MongoDB Atlas example JSON configuration:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "mongo": "mongodb+srv://username:password@server.mongodb.net/"
  }
}
```

For more information on how to format this connection string, see [MongoDB: ConnectionString documentation](https://www.mongodb.com/docs/v3.0/reference/connection-string).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The MongoDB integration supports `Microsoft.Extensions.Configuration` from configuration files such as `appsettings.json` by using the `Aspire:MongoDB:Driver` key. If you have set up your configurations in the `Aspire:MongoDB:Driver` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "MongoDB": {
      "Driver": {
        "ConnectionString": "mongodb://server:port/test",
        "DisableHealthChecks": false,
        "HealthCheckTimeout": 10000,
        "DisableTracing": false
      }
    }
  }
}
```

### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The MongoDB integration supports named configuration, which allows you to configure multiple instances of the same resource type with different settings:

JSON — appsettings.json

```json
{
  "Aspire": {
    "MongoDB": {
      "Driver": {
        "mongo1": {
          "ConnectionString": "mongodb://server1:port/test",
          "DisableHealthChecks": false,
          "HealthCheckTimeout": 10000
        },
        "mongo2": {
          "ConnectionString": "mongodb://server2:port/test",
          "DisableTracing": true,
          "HealthCheckTimeout": 5000
        }
      }
    }
  }
}
```

In this example, the `mongo1` and `mongo2` connection names can be used when calling `AddMongoDBClient`:

C# — Program.cs

```csharp
builder.AddMongoDBClient("mongo1");
builder.AddMongoDBClient("mongo2");
```

Named configuration takes precedence over the top-level configuration. If both are provided, the settings from the named configuration override the top-level settings.

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<MongoDBSettings>` delegate to set up some or all the options inline, for example to set the connection string from code:

C# — Program.cs

```csharp
builder.AddMongoDBClient(
    "mongodb",
    static settings => settings.ConnectionString = "mongodb://server:port/test");
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the configurable options with corresponding default values:

| Name                  | Description                                                                         |
| --------------------- | ----------------------------------------------------------------------------------- |
| `ConnectionString`    | The connection string of the MongoDB database to connect to                         |
| `DisableHealthChecks` | A boolean value that indicates whether the database health check is disabled or not |
| `HealthCheckTimeout`  | An `int?` value that indicates the MongoDB health check timeout in milliseconds     |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not |

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

By default, the Aspire MongoDB client integration handles the following:

* Adds a health check when enabled that verifies that a connection can be made and commands can be run against the MongoDB database
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire MongoDB client integration uses the following log categories:

* `MongoDB[.*]`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire MongoDB client integration emits the following tracing activities using OpenTelemetry:

* `MongoDB.Driver.Core.Extensions.DiagnosticSources`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire MongoDB client integration doesn’t currently expose any OpenTelemetry metrics.

## See also

[Section titled “See also”](#see-also)

* [MongoDB](https://www.mongodb.com)
* [MongoDB Atlas](https://mdb.link/atlas)
* [MongoDB Documentation](https://www.mongodb.com/docs/)
* [Aspire integrations](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# MongoDB hosting extensions

⭐ Community Toolkit ![MongoDB logo](/_astro/mongodb-icon.KisFuM9l_p6JLn.webp)

The Aspire Community Toolkit MongoDB hosting extensions package provides extra functionality to the [Aspire.Hosting.MongoDB](https://www.nuget.org/packages/Aspire.Hosting.MongoDB) hosting package.

This package provides the following features:

* [DbGate](https://dbgate.org/) management UI

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Community Toolkit MongoDB hosting extensions, install the [CommunityToolkit.Aspire.Hosting.MongoDB.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.MongoDB.Extensions) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.MongoDB.Extensions package

  ```bash
  aspire add communitytoolkit-mongodb-extensions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-mongodb-extensions (CommunityToolkit.Aspire.Hosting.MongoDB.Extensions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.MongoDB.Extensions@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.MongoDB.Extensions package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.MongoDB.Extensions" Version="*" />
  ```

## Add DbGate management UI

[Section titled “Add DbGate management UI”](#add-dbgate-management-ui)

**DbGate** is a comprehensive database management tool that provides a web-based interface for managing your MongoDB databases. To add the DbGate management UI to your MongoDB resource, call the `WithDbGate` method on the `MongoDBResourceBuilder` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongodb = builder.AddMongoDB("mongodb")
                     .WithDbGate();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mongodb);


// After adding all resources, run the app...
```

This adds a new DbGate resource to the app host which is available from the Aspire dashboard.

## See also

[Section titled “See also”](#see-also)

* [DbGate documentation](https://dbgate.org/)
* [MongoDB integration](/integrations/databases/mongodb/mongodb-get-started/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the MongoDB integrations

> Learn how to set up the Aspire MongoDB Hosting and Client integrations simply.

![MongoDB logo](/_astro/mongodb-icon.KisFuM9l_p6JLn.webp)

[MongoDB](https://www.mongodb.com) is a NoSQL database that provides high performance, high availability, and easy scalability. The MongoDB integration enables you to connect to existing MongoDB instances (including [MongoDB Atlas](https://mdb.link/atlas)) or create new instances from Aspire with the `docker.io/library/mongo` container image.

In this introduction, you’ll see how to install and use the Aspire MongoDB integrations in a simple configuration. If you already have this knowledge, see [MongoDB Hosting integration](/integrations/databases/mongodb/mongodb-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](/get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire MongoDB Hosting integration in your Aspire AppHost project. This integration allows you to create and manage MongoDB database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.MongoDB package

  ```bash
  aspire add mongodb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > mongodb (Aspire.Hosting.MongoDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.MongoDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.MongoDB package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.MongoDB" Version="*" />
  ```

Next, in the AppHost project, create instances of MongoDB server and database resources, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(mongodb)
                            .WithReference(mongodb);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(mongodb)
                            .WithReference(mongodb);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(mongodb)
                 .WithReference(mongodb);
```

Tip

This is the simplest implementation of MongoDB resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [MongoDB Hosting integration](/integrations/databases/mongodb/mongodb-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire MongoDB client integration:

* .NET CLI

  .NET CLI — Add Aspire.MongoDB.Driver package

  ```bash
  dotnet add package Aspire.MongoDB.Driver
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.MongoDB.Driver@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.MongoDB.Driver package reference

  ```xml
  <PackageReference Include="Aspire.MongoDB.Driver" Version="*" />
  ```

Danger

The `Aspire.MongoDB.Driver` NuGet package depends on the `MongoDB.Driver` NuGet package. With the release of version 3.0.0 of `MongoDB.Driver`, a binary breaking change was introduced. To address this, a new client integration package, `Aspire.MongoDB.Driver.v3`, was created. The original `Aspire.MongoDB.Driver` package continues to reference `MongoDB.Driver` version 2.30.0. The new `Aspire.MongoDB.Driver.v3` package references `MongoDB.Driver` version 3.0.0. In a future version of Aspire, the `Aspire.MongoDB.Driver` will be updated to version 3.x and the `Aspire.MongoDB.Driver.v3` package will be deprecated. For more information, see [Upgrade to version 3.0](https://www.mongodb.com/docs/drivers/csharp/v3.0/upgrade/v3/).

In the `Program.cs` file of your client-consuming project, call the `AddMongoDBClient` extension method on any `IHostApplicationBuilder` to register a `IMongoClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMongoDBClient(connectionName: "mongodb");
```

Tip

The `connectionName` parameter must match the name used when adding the MongoDB database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with MongoDB databases in your Python consuming projects, you need to include a MongoDB client library. The official option is `pymongo`, which is MongoDB’s Python driver. You can install this library using pip:

```bash
pip install pymongo
```

Ensure that you import the `MongoClient` in code files that interact with the database. You should also import the `os` module to access environment variables:

Python - Import pymongo

```python
from pymongo import MongoClient
import os
```

To interact with MongoDB databases in your JavaScript consuming projects, you need to include a MongoDB client library. The official option is `mongodb`, which is MongoDB’s Node.js driver. You can install this library using npm:

```bash
npm install mongodb
```

Ensure that you import the `MongoClient` in code files that interact with the database:

JavaScript - Import mongodb

```javascript
const { MongoClient } = require('mongodb');
```

### Use injected MongoDB properties

[Section titled “Use injected MongoDB properties”](#use-injected-mongodb-properties)

In the AppHost, when you used the `WithReference` method to pass a MongoDB database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `mongodb` becomes `MONGODB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string connectionUri = builder.Configuration.GetConnectionString("mongodb");
string host = builder.Configuration.GetValue<string>("MONGODB_HOST");
string databaseName = builder.Configuration.GetValue<string>("MONGODB_DATABASENAME");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python - Obtain configuration properties

```python
connection_uri = os.getenv("ConnectionStrings__mongodb")
host = os.getenv("MONGODB_HOST")
port = os.getenv("MONGODB_PORT")
username = os.getenv("MONGODB_USERNAME")
password = os.getenv("MONGODB_PASSWORD")
database_name = os.getenv("MONGODB_DATABASENAME")
```

Use the `process.env` method to obtain these environment variables in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const connectionUri = process.env.ConnectionStrings__mongodb;
const host = process.env.MONGODB_HOST;
const port = process.env.MONGODB_PORT;
const username = process.env.MONGODB_USERNAME;
const password = process.env.MONGODB_PASSWORD;
const databaseName = process.env.MONGODB_DATABASENAME;
```

Tip

The full set of properties that Aspire injects depends on the MongoDB resource configuration. For more information, see [Properties of the MongoDB resources](/integrations/databases/mongodb/mongodb-client/#properties-of-the-mongodb-resources).

### Use MongoDB resources in client code

[Section titled “Use MongoDB resources in client code”](#use-mongodb-resources-in-client-code)

Now that you’ve added the `IMongoClient` to the builder in the consuming project, you can use the MongoDB database. Get the `IMongoClient` instance using dependency injection. For example, to retrieve your client object from an example service, define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(IMongoClient client)
{
    // Use MongoDB client...
}
```

Alternatively, if you defined a MongoDB database resource in your AppHost, you can instead require that the dependency injection container provides an `IMongoDatabase` instance:

C# — ExampleService.cs

```csharp
public class ExampleService(IMongoDatabase database)
{
    // Use MongoDB database...
}
```

Having obtained the client or database, you can work with the MongoDB database as you would in any other C# application.

Use the information you have obtained about the MongoDB resource to connect to the database. Here is an example of how to connect using `pymongo`:

Python - Connect to MongoDB

```python
# Create MongoDB client using connection URI
client = MongoClient(connection_uri)


# Get database
db = client[database_name]


# Verify connection
print(f"Connected to MongoDB database: {database_name}")
```

Having obtained the client, you can work with the MongoDB database as you would in any other Python application.

Use the information you have obtained about the MongoDB resource to connect to the database. Here is an example of how to connect using the `mongodb` package:

JavaScript - Connect to MongoDB

```javascript
// Create MongoDB client using connection URI
const client = new MongoClient(connectionUri);


// Connect to MongoDB
await client.connect();


// Get database
const db = client.db(databaseName);


// Verify connection
console.log(`Connected to MongoDB database: ${databaseName}`);
```

Having obtained the client, you can work with the MongoDB database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now, that you have an Aspire app with MongoDB integrations up and running, you can use the following reference documents to learn how to configure and interact with the MongoDB resources:

[Understand the MongoDB hosting integration ](/integrations/databases/mongodb/mongodb-host/)Discover how to configure data volumes, MongoDB Express, and more.

[Understand the MongoDB client integration ](/integrations/databases/mongodb/mongodb-client/)Learn about the MongoDB client integration, including connection strings and observability.

[Community extensions ](/integrations/databases/mongodb/mongodb-extensions/)Explore community-contributed extensions for MongoDB, including DbGate management UI.

# MongoDB Hosting integration reference

> Learn how to use the Aspire MongoDB Hosting integration to orchestrate and configure MongoDB databases in your Aspire projects.

![MongoDB logo](/_astro/mongodb-icon.KisFuM9l_p6JLn.webp)

To get started with the Aspire MongoDB integrations, follow the [Get started with MongoDB integrations](/integrations/databases/mongodb/mongodb-get-started/) guide.

This article includes full details about the Aspire MongoDB Hosting integration, which models MongoDB server and database resources as the `MongoDBServerResource` and `MongoDBDatabaseResource` types. To access these types and APIs, you need to install the MongoDB Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

The Aspire MongoDB hosting integration models the MongoDB database server as the following types:

* `MongoDBServerResource`
* `MongoDBDatabaseResource`

To access these types and APIs for expressing them as resources in your AppHost project, install the [📦 Aspire.Hosting.MongoDB](https://www.nuget.org/packages/Aspire.Hosting.MongoDB) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.MongoDB package

  ```bash
  aspire add mongodb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > mongodb (Aspire.Hosting.MongoDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.MongoDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.MongoDB package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.MongoDB" Version="*" />
  ```

## Add MongoDB server and database resources

[Section titled “Add MongoDB server and database resources”](#add-mongodb-server-and-database-resources)

In the AppHost project, call `AddMongoDB` to add and return a MongoDB server resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add a MongoDB database to the server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mongodb)
       .WaitFor(mongodb);


// After adding all resources, run the app...
```

Note

The MongoDB container can be slow to start, so it’s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

When Aspire adds a container image to the AppHost, as shown in the preceding example with the `docker.io/library/mongo` image, it creates a new MongoDB server on your local machine. A reference to your MongoDB resource builder (the `mongo` variable) is used to add a database. The database is named `mongodb` and then added to the `ExampleProject`.

The MongoDB server resource includes default credentials:

* `MONGO_INITDB_ROOT_USERNAME`: A value of `admin`
* `MONGO_INITDB_ROOT_PASSWORD`: Random password generated using the default password parameter

The password is stored in the AppHost’s secret store in the `Parameters` section:

```json
{
  "Parameters:mongo-password": "<THE_GENERATED_PASSWORD>"
}
```

The `WithReference` method configures a connection in the `ExampleProject` named `"mongodb"`. For more information, see [Container resource lifecycle](/architecture/resource-model/#built-in-resources-and-lifecycle).

Tip

If you’d rather connect to an existing MongoDB server, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add MongoDB server resource with parameters

[Section titled “Add MongoDB server resource with parameters”](#add-mongodb-server-resource-with-parameters)

When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("username");
var password = builder.AddParameter("password", secret: true);


var mongo = builder.AddMongoDB("mongo", username, password);
var mongodb = mongo.AddDatabase("mongodb");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(mongodb)
                       .WaitFor(mongodb);
```

The username and password parameters are usually specified as user secrets:

JSON — secrets.json

```json
{
  "Parameters": {
    "username": "admin",
    "password": "your-secure-password"
  }
}
```

For more information, see [External parameters](/get-started/resources/).

## Add MongoDB server resource with data volume

[Section titled “Add MongoDB server resource with data volume”](#add-mongodb-server-resource-with-data-volume)

To add a data volume to the MongoDB server resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithDataVolume()
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mongodb)
       .WaitFor(mongodb);


// After adding all resources, run the app...
```

The data volume is used to persist the MongoDB server data outside the lifecycle of its container. The data volume is mounted at the `/data/db` path in the MongoDB server container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-mongodb-server-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

Caution

The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume.

Danger

Some database integrations, including the MongoDB integration, can’t successfully use data volumes after deployment to Azure Container Apps (ACA). This is because ACA uses Server Message Block (SMB) to connect containers to data volumes, and some systems can’t use this connection. In the Aspire Dashboard, a database affected by this issue has a status of **Activating** or **Activation Failed** but is never listed as **Running**.

You can resolve the problem by deploying to a Kubernetes cluster, such as Azure Kubernetes Services (AKS). For more information, see [Deploy your first Aspire app](/get-started/deploy-first-app/).

## Add MongoDB server resource with data bind mount

[Section titled “Add MongoDB server resource with data bind mount”](#add-mongodb-server-resource-with-data-bind-mount)

To add a data bind mount to the MongoDB server resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithDataBindMount(source: @"C:\MongoDB\Data")
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mongodb)
       .WaitFor(mongodb);


// After adding all resources, run the app...
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the MongoDB server data across container restarts. The data bind mount is mounted at the `C:\MongoDB\Data` on Windows (or `/MongoDB/Data` on Unix) path on the host machine in the MongoDB server container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Add MongoDB server resource with initialization data bind mount

[Section titled “Add MongoDB server resource with initialization data bind mount”](#add-mongodb-server-resource-with-initialization-data-bind-mount)

To add an initialization folder data bind mount to the MongoDB server resource, call the `WithInitBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithInitBindMount(source: @"C:\MongoDB\Init")
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mongodb)
       .WaitFor(mongodb);


// After adding all resources, run the app...
```

The initialization data bind mount is used to initialize the MongoDB server with data. MongoDB executes the scripts found in this folder, which is useful for loading data into the database.

## Create a MongoDB Express resource

[Section titled “Create a MongoDB Express resource”](#create-a-mongodb-express-resource)

[MongoDB Express](https://github.com/mongo-express/mongo-express) is a web-based MongoDB admin user interface. To add a MongoDB Express resource that corresponds to the `docker.io/library/mongo-express` container image, call the `WithMongoExpress` method on the MongoDB server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mongo = builder.AddMongoDB("mongo")
                   .WithMongoExpress()
                   .WithLifetime(ContainerLifetime.Persistent);


var mongodb = mongo.AddDatabase("mongodb");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(mongodb)
                       .WaitFor(mongodb);
```

Tip

To configure the host port for the MongoDB Express resource, chain a call to the `WithHostPort` API and provide the desired port number.

When you debug the Aspire solution, you’ll see a MongoDB Express container listed in the resources. Select the resource’s endpoint to open the GUI.

The MongoDB Express resource is configured to connect to the MongoDB server resource. The default credentials are:

* `ME_CONFIG_MONGODB_SERVER`: The name assigned to the parent `MongoDBServerResource`
* `ME_CONFIG_BASICAUTH`: A value of `false`
* `ME_CONFIG_MONGODB_PORT`: Assigned from the primary endpoint’s target port
* `ME_CONFIG_MONGODB_ADMINUSERNAME`: The same username as configured in the parent
* `ME_CONFIG_MONGODB_ADMINPASSWORD`: The same password as configured in the parent

Additionally, the `WithMongoExpress` API exposes an optional `configureContainer` parameter that you use to configure the MongoDB Express container resource.

## Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

When you use the `WithReference` method to pass a MongoDB database resource to a non-.NET application (such as Python or JavaScript), Aspire automatically injects environment variables that describe the connection information.

For example, if you reference a MongoDB database resource named `mongodb`:

C# — AppHost.cs

```csharp
var mongo = builder.AddMongoDB("mongo");
var mongodb = mongo.AddDatabase("mongodb");


var pythonApp = builder.AddUvicornApp("api", "./api", "main:app")
    .WithReference(mongodb);
```

The following environment variables are available in the Python application:

* `ConnectionStrings__mongodb` - The connection string for the MongoDB database
* `MONGODB_HOST` - The hostname of the MongoDB server
* `MONGODB_PORT` - The port number
* `MONGODB_USERNAME` - The username for authentication
* `MONGODB_PASSWORD` - The password for authentication
* `MONGODB_AUTHENTICATIONDATABASE` - The authentication database
* `MONGODB_AUTHENTICATIONMECHANISM` - The authentication mechanism
* `MONGODB_URI` - The full connection URI
* `MONGODB_DATABASENAME` - The database name

You can access these environment variables in your application code:

Python example

```python
from pymongo import MongoClient
import os


# Get connection properties
connection_uri = os.getenv("ConnectionStrings__mongodb")
database_name = os.getenv("MONGODB_DATABASENAME")


# Create MongoDB client
client = MongoClient(connection_uri)


# Get database
db = client[database_name]
```

JavaScript example

```javascript
const { MongoClient } = require('mongodb');


// Get connection properties
const connectionUri = process.env.ConnectionStrings__mongodb;
const databaseName = process.env.MONGODB_DATABASENAME;


// Create MongoDB client
const client = new MongoClient(connectionUri);


// Connect and get database
await client.connect();
const db = client.db(databaseName);
```

## Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The MongoDB hosting integration automatically adds a health check for the MongoDB server resource. The health check verifies that the MongoDB server resource is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.MongoDb](https://www.nuget.org/packages/AspNetCore.HealthChecks.MongoDb) NuGet package.

# MySQL Client integration reference

> Learn how to use the Aspire MySQL Client integration to query MySQL databases from your Aspire projects.

![MySQL logo](/_astro/mysqlconnector-icon.De_epwTX_Z2oKUOp.webp)

To get started with the Aspire MySQL integrations, follow the [Get started with MySQL integrations](../mysql-get-started/) guide.

This article includes full details about the Aspire MySQL Client integration, which allows you to connect to and interact with MySQL databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire MySQL client integration, install the [📦 Aspire.MySqlConnector](https://www.nuget.org/packages/Aspire.MySqlConnector) NuGet package in the client-consuming project, that is, the project for the application that uses the MySQL client. The MySQL client integration registers a `MySqlConnector.MySqlDataSource` instance that you can use to interact with MySQL.

* .NET CLI

  .NET CLI — Add Aspire.MySqlConnector package

  ```bash
  dotnet add package Aspire.MySqlConnector
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.MySqlConnector@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.MySqlConnector package reference

  ```xml
  <PackageReference Include="Aspire.MySqlConnector" Version="*" />
  ```

## Add a MySQL data source

[Section titled “Add a MySQL data source”](#add-a-mysql-data-source)

In the `Program.cs` file of your client-consuming project, call the `AddMySqlDataSource` extension method to register a `MySqlDataSource` for use via the dependency injection container:

C# — Program.cs

```csharp
builder.AddMySqlDataSource(connectionName: "mysqldb");
```

Tip

The `connectionName` parameter must match the name used when adding the MySQL database resource in the AppHost project.

You can then retrieve the `MySqlConnector.MySqlDataSource` instance using dependency injection:

C# — ExampleService.cs

```csharp
public class ExampleService(MySqlDataSource dataSource)
{
    // Use dataSource...
}
```

## Add keyed MySQL data source

[Section titled “Add keyed MySQL data source”](#add-keyed-mysql-data-source)

There might be situations where you want to register multiple `MySqlDataSource` instances with different connection names. To register keyed MySQL data sources, call the `AddKeyedMySqlDataSource` method:

C# — Program.cs

```csharp
builder.AddKeyedMySqlDataSource(name: "mainDb");
builder.AddKeyedMySqlDataSource(name: "loggingDb");
```

Danger

When using keyed services, it’s expected that your MySQL resource configured two named databases, one for the `mainDb` and one for the `loggingDb`.

Then you can retrieve the `MySqlDataSource` instances using dependency injection:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("mainDb")] MySqlDataSource mainDataSource,
    [FromKeyedServices("loggingDb")] MySqlDataSource loggingDataSource)
{
    // Use data sources...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Properties of the MySQL resources

[Section titled “Properties of the MySQL resources”](#properties-of-the-mysql-resources)

When you use the `WithReference` method to pass a MySQL server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `mysqldb` becomes `MYSQLDB_URI`.

### MySQL server resource

[Section titled “MySQL server resource”](#mysql-server-resource)

The MySQL server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                               |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`                 | The hostname or IP address of the MySQL server                                                                                                                            |
| `Port`                 | The port number the MySQL server is listening on                                                                                                                          |
| `Username`             | The username for authentication                                                                                                                                           |
| `Password`             | The password for authentication                                                                                                                                           |
| `Uri`                  | The connection URI in mysql:// format, with the format `mysql://{Username}:{Password}@{Host}:{Port}`                                                                      |
| `JdbcConnectionString` | JDBC-format connection string, with the format `jdbc:mysql://{Host}:{Port}`. User and password credentials are provided as separate `Username` and `Password` properties. |

### MySQL database resource

[Section titled “MySQL database resource”](#mysql-database-resource)

The MySQL database resource inherits all properties from its parent `MySqlServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                          |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI with the database name, with the format `mysql://{Username}:{Password}@{Host}:{Port}/{DatabaseName}`                                                                              |
| `JdbcConnectionString` | JDBC connection string with database name, with the format `jdbc:mysql://{Host}:{Port}/{DatabaseName}`. User and password credentials are provided as separate `Username` and `Password` properties. |
| `DatabaseName`         | The name of the database                                                                                                                                                                             |

## Configuration

[Section titled “Configuration”](#configuration)

The MySQL database integration provides multiple options to configure the connection based on the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling `AddMySqlDataSource`:

C# — Program.cs

```csharp
builder.AddMySqlDataSource(connectionName: "mysql");
```

Then the connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "mysql": "Server=mysql;Database=mysqldb"
  }
}
```

For more information on how to format this connection string, see [MySqlConnector: ConnectionString documentation](https://mysqlconnector.net/connection-options/).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The MySQL database integration supports `Microsoft.Extensions.Configuration`. It loads the `MySqlConnectorSettings` from configuration using the `Aspire:MySqlConnector` key. Example `appsettings.json`:

JSON — appsettings.json

```json
{
  "Aspire": {
    "MySqlConnector": {
      "ConnectionString": "YOUR_CONNECTIONSTRING",
      "DisableHealthChecks": true,
      "DisableTracing": true
    }
  }
}
```

For the complete MySQL client integration JSON schema, see [Aspire.MySqlConnector/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.MySqlConnector/ConfigurationSchema.json).

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the `Action<MySqlConnectorSettings>` delegate to set up some or all the options inline:

C# — Program.cs

```csharp
builder.AddMySqlDataSource(
    "mysql",
    static settings => settings.DisableHealthChecks = true);
```

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The MySQL database integration:

* Adds the health check when `DisableHealthChecks` is `false`, which verifies that a connection can be made and commands can be run against the MySQL database
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The MySQL integration uses the following log categories:

* `MySqlConnector.ConnectionPool`
* `MySqlConnector.MySqlBulkCopy`
* `MySqlConnector.MySqlCommand`
* `MySqlConnector.MySqlConnection`
* `MySqlConnector.MySqlDataSource`

### Tracing

[Section titled “Tracing”](#tracing)

The MySQL integration emits the following tracing activities using OpenTelemetry:

* `MySqlConnector`

### Metrics

[Section titled “Metrics”](#metrics)

The MySQL integration will emit the following metrics using OpenTelemetry:

* MySqlConnector

  * `db.client.connections.create_time`
  * `db.client.connections.use_time`
  * `db.client.connections.wait_time`
  * `db.client.connections.idle.max`
  * `db.client.connections.idle.min`
  * `db.client.connections.max`
  * `db.client.connections.pending_requests`
  * `db.client.connections.timeouts`
  * `db.client.connections.usage`

# MySQL hosting extensions

⭐ Community Toolkit ![MySQL logo](/_astro/mysqlconnector-icon.De_epwTX_Z2oKUOp.webp)

The Aspire Community Toolkit MySQL hosting extensions package provides extra functionality to the [Aspire.Hosting.MySql](https://www.nuget.org/packages/Aspire.Hosting.MySql) hosting package.

This package provides the following features:

* [Adminer](https://adminer.org/) management UI
* [DbGate](https://dbgate.org/) management UI

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Community Toolkit MySQL hosting extensions, install the [CommunityToolkit.Aspire.Hosting.MySql.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.MySql.Extensions) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.MySql.Extensions package

  ```bash
  aspire add communitytoolkit-mysql-extensions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-mysql-extensions (CommunityToolkit.Aspire.Hosting.MySql.Extensions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.MySql.Extensions@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.MySql.Extensions package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.MySql.Extensions" Version="*" />
  ```

## Add management UI

[Section titled “Add management UI”](#add-management-ui)

### DbGate management UI

[Section titled “DbGate management UI”](#dbgate-management-ui)

To add the DbGate management UI to your MySQL resource, call the `WithDbGate` method on the `MySqlServerResourceBuilder` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
                   .WithDbGate();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mysql);


// After adding all resources, run the app...
```

This adds a new DbGate resource to the app host which is available from the Aspire dashboard. DbGate is a comprehensive database management tool that provides a web-based interface for managing your MySQL databases.

### Adminer management UI

[Section titled “Adminer management UI”](#adminer-management-ui)

To add the Adminer management UI to your MySQL resource, call the `WithAdminer` method on the `MySqlServerResourceBuilder` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
                   .WithAdminer();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mysql);


// After adding all resources, run the app...
```

This adds a new Adminer resource to the app host which is available from the Aspire dashboard. Adminer is a lightweight database management tool that provides a simple web interface for database operations.

### Using both management UIs

[Section titled “Using both management UIs”](#using-both-management-uis)

You can use both management UIs together on the same MySQL resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
                   .WithDbGate()
                   .WithAdminer();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mysql);


// After adding all resources, run the app...
```

## See also

[Section titled “See also”](#see-also)

* [Adminer documentation](https://www.adminer.org/)
* [DbGate documentation](https://dbgate.org/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](../../../overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the MySQL integrations

> Learn how to set up the Aspire MySQL Hosting and Client integrations simply.

![MySQL logo](/_astro/mysqlconnector-icon.De_epwTX_Z2oKUOp.webp)

[MySQL](https://www.mysql.com/) is an open-source Relational Database Management System (RDBMS) that uses Structured Query Language (SQL) to manage and manipulate data. It’s employed in many different environments, from small projects to large-scale enterprise systems and it’s a popular choice to host data that underpins microservices in a cloud-native application. The Aspire MySQL integration provides a way to connect to existing MySQL databases, or create new instances from the [`mysql` container image](https://hub.docker.com/_/mysql).

In this introduction, you’ll see how to install and use the Aspire MySQL integrations in a simple configuration. If you already have this knowledge, see [MySQL Hosting integration](../mysql-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire MySQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage MySQL database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.MySql package

  ```bash
  aspire add mysql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > mysql (Aspire.Hosting.MySql)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.MySql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.MySql package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.MySql" Version="*" />
  ```

Next, in the AppHost project, create instances of MySQL server and database resources, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql");
var mysqldb = mysql.AddDatabase("mysqldb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(mysqldb)
                            .WithReference(mysqldb);
```

apphost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql");
var mysqldb = mysql.AddDatabase("mysqldb");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(mysqldb)
                            .WithReference(mysqldb);
```

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql");
var mysqldb = mysql.AddDatabase("mysqldb");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(mysqldb)
                 .WithReference(mysqldb);
```

Tip

This is the simplest implementation of MySQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [MySQL Hosting integration](../mysql-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire MySQL client integration:

* .NET CLI

  .NET CLI — Add Aspire.MySqlConnector package

  ```bash
  dotnet add package Aspire.MySqlConnector
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.MySqlConnector@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.MySqlConnector package reference

  ```xml
  <PackageReference Include="Aspire.MySqlConnector" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddMySqlDataSource` extension method on any `IHostApplicationBuilder` to register a `MySqlDataSource` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddMySqlDataSource(connectionName: "mysqldb");
```

Tip

The `connectionName` parameter must match the name used when adding the MySQL database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with MySQL databases in your Python consuming projects, you need to include a MySQL adapter library. A popular option is `mysql-connector-python` (the official Oracle connector). You can install this library using pip:

```bash
pip install mysql-connector-python
```

Ensure that you import both `mysql.connector` and `os` in code files that interact with the database. Use `mysql.connector` to interact with the database and `os` to access environment variables:

Python - Import mysql.connector and os

```python
import mysql.connector
import os
```

To interact with MySQL databases in your JavaScript consuming projects, you need to include a MySQL client library. A popular option is `mysql2` (a fast, modern MySQL client). You can install this library using npm:

```bash
npm install mysql2
```

Ensure that you import `mysql2` in code files that interact with the database. Use the `mysql2` library to access the database:

JavaScript - Import mysql2

```javascript
import mysql from 'mysql2/promise';
```

### Use injected MySQL properties

[Section titled “Use injected MySQL properties”](#use-injected-mysql-properties)

In the AppHost, when you used the `WithReference` method to pass a MySQL server or database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `mysqldb` becomes `MYSQLDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string hostname = builder.Configuration.GetValue<string>("MYSQLDB_HOST");
string databaseport = builder.Configuration.GetValue<string>("MYSQLDB_PORT");
string jdbcconnectionstring = builder.Configuration.GetValue<string>("MYSQLDB_JDBCCONNECTIONSTRING");
string databasename = builder.Configuration.GetValue<string>("MYSQLDB_DATABASE");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python - Obtain configuration properties

```python
mysql_host = os.getenv("MYSQLDB_HOST")
mysql_port = os.getenv("MYSQLDB_PORT")
mysql_user = os.getenv("MYSQLDB_USERNAME")
mysql_password = os.getenv("MYSQLDB_PASSWORD")
mysql_database = os.getenv("MYSQLDB_DATABASE")
mysql_uri = os.getenv("MYSQLDB_URI")
mysql_name = os.getenv("MYSQLDB_DATABASE", "mysqldb")
```

Use the `process.env` method to obtain these environment variables in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const mysqlHost = process.env.MYSQLDB_HOST;
const mysqlPort = process.env.MYSQLDB_PORT;
const mysqlUser = process.env.MYSQLDB_USERNAME;
const mysqlPassword = process.env.MYSQLDB_PASSWORD;
const mysqlDatabase = process.env.MYSQLDB_DATABASE;
```

Tip

The full set of properties that Aspire injects depends on whether you passed a MySQL server or database resource. For more information, see [Properties of the MySQL resources](../mysql-client/#properties-of-the-mysql-resources).

### Use MySQL resources in client code

[Section titled “Use MySQL resources in client code”](#use-mysql-resources-in-client-code)

Now that you’ve added `MySqlDataSource` to the builder in the consuming project, you can use the MySQL resource to get and store data. Get the `MySqlDataSource` instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(MySqlDataSource dataSource)
{
    // Use dataSource to query the database...
}
```

Having obtained the data source, you can work with the MySQL database as you would in any other C# application.

Use the information you have obtained about the MySQL resource to connect to the database. Here is an example of how to connect using `mysql-connector-python`:

Python - Connect to MySQL

```python
connection = mysql.connector.connect(
    host=mysql_host,
    port=mysql_port,
    user=mysql_user,
    password=mysql_password,
    database=mysql_database
)


cursor = connection.cursor()
```

Having obtained the connection, you can work with the MySQL database as you would in any other Python application.

Use the information you have obtained about the MySQL resource to connect to the database. Here is an example of how to connect using `mysql2`:

JavaScript - Connect to MySQL

```javascript
const connection = await mysql.createConnection({
  host: mysqlHost,
  port: mysqlPort,
  user: mysqlUser,
  password: mysqlPassword,
  database: mysqlDatabase
});
```

Having obtained the connection, you can work with the MySQL database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now, that you have an Aspire app with MySQL integrations up and running, you can use the following reference documents to learn how to configure and interact with the MySQL resources:

[Understand the MySQL hosting integration ](/integrations/databases/mysql/mysql-host/)Discover how to configure persistence, phpMyAdmin resources, and more.

[Understand the MySQL client integration ](/integrations/databases/mysql/mysql-client/)Discover how to configure keyed clients, client integration health checks, and more.

[Understand the MySQL community extensions ](/integrations/databases/mysql/mysql-extensions/)Discover how to add the DbGate management user interface, and more.

# MySQL Hosting integration reference

> Learn how to use the Aspire MySQL Hosting integration to create and manage MySQL server and database resources in your Aspire projects.

![MySQL logo](/_astro/mysqlconnector-icon.De_epwTX_Z2oKUOp.webp)

To get started with the Aspire MySQL integrations, follow the [Get started with MySQL integrations](/integrations/databases/mysql/mysql-get-started/) guide. If you prefer to use Entity Framework Core (EF Core) to interact with your MySQL database, see the [Get started with MySQL and EF Core](/integrations/databases/efcore/mysql/mysql-get-started/) guide.

This article includes full details about the Aspire MySQL Hosting integration, which models the server as the `MySqlServerResource` type and the database as the `MySqlDatabaseResource` type. To access these types and APIs, you need to install the MySQL Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire MySQL hosting integration, install the [📦 Aspire.Hosting.MySql](https://www.nuget.org/packages/Aspire.Hosting.MySql) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.MySql package

  ```bash
  aspire add mysql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > mysql (Aspire.Hosting.MySql)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.MySql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.MySql package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.MySql" Version="*" />
  ```

## Add MySQL server resource and database resource

[Section titled “Add MySQL server resource and database resource”](#add-mysql-server-resource-and-database-resource)

In your AppHost project, call `AddMySql` to add and return a MySQL resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add a MySQL database resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
    .WithLifetime(ContainerLifetime.Persistent);


var mysqldb = mysql.AddDatabase("mysqldb");


var myService = builder.AddProject<Projects.ExampleProject>()
    .WithReference(mysqldb)
    .WaitFor(mysqldb);
```

Note

The MySQL container is slow to start, so it’s best to use a *persistent* lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

When Aspire adds a container image to the AppHost, it creates a new MySQL instance on your local machine. The MySQL resource includes default credentials with a `username` of `root` and a random password generated using the default password parameter.

When the AppHost runs, the password is stored in the AppHost’s secret store in the `Parameters` section:

```json
{
  "Parameters:mysql-password": "<THE_GENERATED_PASSWORD>"
}
```

The `WithReference` method configures a connection in the `ExampleProject` named `mysqldb`.

Tip

If you’d rather connect to an existing MySQL server, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add MySQL server resource with database scripts

[Section titled “Add MySQL server resource with database scripts”](#add-mysql-server-resource-with-database-scripts)

You can use the `WithCreationScript` method to execute SQL scripts when the database is created. This is useful for initializing database schema or seeding data:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
    .WithLifetime(ContainerLifetime.Persistent);


var mysqldb = mysql.AddDatabase("mysqldb")
    .WithCreationScript("""
        CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            email VARCHAR(255) NOT NULL
        );
        """);


var myService = builder.AddProject<Projects.ExampleProject>()
    .WithReference(mysqldb)
    .WaitFor(mysqldb);
```

Note

The script is executed only when the database is first created. If you need to run scripts on every startup, consider using init bind mounts or application-level migrations instead.

## Add a MySQL resource with a data volume

[Section titled “Add a MySQL resource with a data volume”](#add-a-mysql-resource-with-a-data-volume)

To add a data volume to the MySQL resource, call the `WithDataVolume` method on the MySQL resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
    .WithDataVolume();


var mysqldb = mysql.AddDatabase("mysqldb");


var myService = builder.AddProject<Projects.ExampleProject>()
    .WithReference(mysqldb)
    .WaitFor(mysqldb);
```

The data volume is used to persist the MySQL server data outside the lifecycle of its container. The data volume is mounted at the `/var/lib/mysql` path in the MySQL container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over bind mounts, see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

Caution

The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume.

Danger

Some database integrations, including the MySQL integration, can’t successfully use data volumes after deployment to Azure Container Apps (ACA). This is because ACA uses Server Message Block (SMB) to connect containers to data volumes, and some systems can’t use this connection. In the Aspire Dashboard, a database affected by this issue has a status of **Activating** or **Activation Failed** but is never listed as **Running**.

You can resolve the problem by deploying to a Kubernetes cluster, such as Azure Kubernetes Services (AKS). For more information, see [Deploy your first Aspire app](/get-started/deploy-first-app/).

## Add a MySQL resource with a data bind mount

[Section titled “Add a MySQL resource with a data bind mount”](#add-a-mysql-resource-with-a-data-bind-mount)

To add a data bind mount to the MySQL resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
    .WithDataBindMount(source: @"C:\MySql\Data");


var mysqldb = mysql.AddDatabase("mysqldb");


var myService = builder.AddProject<Projects.ExampleProject>()
    .WithReference(mysqldb)
    .WaitFor(mysqldb);
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

Data bind mounts rely on the host machine’s filesystem to persist the MySQL data across container restarts. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Add MySQL resource with parameters

[Section titled “Add MySQL resource with parameters”](#add-mysql-resource-with-parameters)

When you want to provide a root MySQL password explicitly, you can pass it as a parameter:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var password = builder.AddParameter("password", secret: true);


var mysql = builder.AddMySql("mysql", password)
    .WithLifetime(ContainerLifetime.Persistent);


var mysqldb = mysql.AddDatabase("mysqldb");


var myService = builder.AddProject<Projects.ExampleProject>()
    .WithReference(mysqldb)
    .WaitFor(mysqldb);
```

For more information, see [External parameters](/get-started/resources/).

## Add a PhpMyAdmin resource

[Section titled “Add a PhpMyAdmin resource”](#add-a-phpmyadmin-resource)

[**phpMyAdmin**](https://www.phpmyadmin.net/) is a popular web-based administration tool for MySQL. To use phpMyAdmin within your Aspire solution, call the `WithPhpMyAdmin` method. This method adds a new container resource that hosts phpMyAdmin and connects it to the MySQL container:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mysql = builder.AddMySql("mysql")
    .WithPhpMyAdmin();


var mysqldb = mysql.AddDatabase("mysqldb");


var myService = builder.AddProject<Projects.ExampleProject>()
    .WithReference(mysqldb)
    .WaitFor(mysqldb);
```

When you run the solution, the Aspire dashboard displays the phpMyAdmin resources with an endpoint. Select the link to the endpoint to view phpMyAdmin in a new browser tab.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The MySQL hosting integration automatically adds a health check for the MySQL resource. The health check verifies that the MySQL server is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.MySql](https://www.nuget.org/packages/AspNetCore.HealthChecks.MySql) NuGet package.

# PostgreSQL Client integration reference

> Learn how to use the Aspire PostgreSQL Client integration to query PostgreSQL databases from your Aspire projects.

![PostgreSQL logo](/_astro/postgresql-icon.DTORe-rE_Z29K7im.webp)

To get started with the Aspire PostgreSQL integrations, follow the [Get started with PostgreSQL integrations](../postgres-get-started/) guide.

This article includes full details about the Aspire PostgreSQL Client integration, which allows you to connect to and interact with PostgreSQL databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire PostgreSQL client integration, install the [📦 Aspire.Npgsql](https://www.nuget.org/packages/Aspire.Npgsql) NuGet package in the client-consuming project, that is, the project for the application that uses the PostgreSQL client. The PostgreSQL client integration registers an [NpgsqlDataSource](https://www.npgsql.org/doc/api/Npgsql.NpgsqlDataSource.html) instance that you can use to interact with PostgreSQL.

* .NET CLI

  .NET CLI — Add Aspire.Npgsql package

  ```bash
  dotnet add package Aspire.Npgsql
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Npgsql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Npgsql package reference

  ```xml
  <PackageReference Include="Aspire.Npgsql" Version="*" />
  ```

## Add Npgsql client

[Section titled “Add Npgsql client”](#add-npgsql-client)

In the `Program.cs` file of your client-consuming project, call the `AddNpgsqlDataSource` extension method on any `IHostApplicationBuilder` to register an `NpgsqlDataSource` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddNpgsqlDataSource(connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the PostgreSQL server resource in the AppHost project. For more information, see [Add PostgreSQL server resource](../postgres-host/#add-postgresql-server-resource).

After adding `NpgsqlDataSource` to the builder, you can get the `NpgsqlDataSource` instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(NpgsqlDataSource dataSource)
{
    // Use dataSource...
}
```

## Add keyed Npgsql client

[Section titled “Add keyed Npgsql client”](#add-keyed-npgsql-client)

There might be situations where you want to register multiple `NpgsqlDataSource` instances with different connection names. To register keyed Npgsql clients, call the `AddKeyedNpgsqlDataSource` method:

C# — Program.cs

```csharp
builder.AddKeyedNpgsqlDataSource(name: "chat");
builder.AddKeyedNpgsqlDataSource(name: "queue");
```

Then you can retrieve the `NpgsqlDataSource` instances using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] NpgsqlDataSource chatDataSource,
    [FromKeyedServices("queue")] NpgsqlDataSource queueDataSource)
{
    // Use data sources...
}
```

## Properties of the PostgreSQL resources

[Section titled “Properties of the PostgreSQL resources”](#properties-of-the-postgresql-resources)

When you use the `WithReference` method to pass a PostgreSQL server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

### PostgreSQL server resource

[Section titled “PostgreSQL server resource”](#postgresql-server-resource)

The PostgreSQL server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                    |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Host`                 | The hostname or IP address of the PostgreSQL server                                                                                                                            |
| `Port`                 | The port number the PostgreSQL server is listening on                                                                                                                          |
| `Username`             | The username for authentication                                                                                                                                                |
| `Password`             | The password for authentication                                                                                                                                                |
| `Uri`                  | The connection URI in postgresql:// format, with the format `postgresql://{Username}:{Password}@{Host}:{Port}`                                                                 |
| `JdbcConnectionString` | JDBC-format connection string, with the format `jdbc:postgresql://{Host}:{Port}`. User and password credentials are provided as separate `Username` and `Password` properties. |

### PostgreSQL database resource

[Section titled “PostgreSQL database resource”](#postgresql-database-resource)

The PostgreSQL database resource inherits all properties from its parent `PostgresServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                               |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI with the database name, with the format `postgresql://{Username}:{Password}@{Host}:{Port}/{DatabaseName}`                                                                              |
| `JdbcConnectionString` | JDBC connection string with database name, with the format `jdbc:postgresql://{Host}:{Port}/{DatabaseName}`. User and password credentials are provided as separate `Username` and `Password` properties. |
| `DatabaseName`         | The name of the database                                                                                                                                                                                  |

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire PostgreSQL integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling the `AddNpgsqlDataSource` method:

C# — Program.cs

```csharp
builder.AddNpgsqlDataSource("postgresdb");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "postgresdb": "Host=myserver;Database=postgresdb"
  }
}
```

For more information, see the [ConnectionString](https://www.npgsql.org/doc/connection-string-parameters.html).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire PostgreSQL integration supports `Microsoft.Extensions.Configuration`. It loads the `NpgsqlSettings` from `appsettings.json` or other configuration files by using the `Aspire:Npgsql` key. Example `appsettings.json` that configures some of the options:

The following example shows an `appsettings.json` file that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Npgsql": {
      "ConnectionString": "Host=myserver;Database=postgresdb",
      "DisableHealthChecks": false,
      "DisableTracing": true,
      "DisableMetrics": false
    }
  }
}
```

For the complete PostgreSQL client integration JSON schema, see [Aspire.Npgsql/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/v9.1.0/src/Components/Aspire.Npgsql/ConfigurationSchema.json).

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<NpgsqlSettings> configureSettings` delegate to set up some or all the options inline, for example to disable health checks:

C# — Program.cs

```csharp
builder.AddNpgsqlDataSource(
    "postgresdb",
     static settings => settings.DisableHealthChecks = true);
```

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire *client integrations* have health checks enabled for all services. Similarly, many Aspire *hosting integrations* also enable health check endpoints. For more information, see:

* Adds the [`NpgSqlHealthCheck`](https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks/blob/master/src/HealthChecks.NpgSql/NpgSqlHealthCheck.cs), which verifies that commands can be successfully executed against the underlying Postgres database.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire PostgreSQL integration uses the following log categories:

* `Npgsql.Connection`
* `Npgsql.Command`
* `Npgsql.Transaction`
* `Npgsql.Copy`
* `Npgsql.Replication`
* `Npgsql.Exception`

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire PostgreSQL integration will emit the following tracing activities using OpenTelemetry:

* `Npgsql`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire PostgreSQL integration will emit the following metrics using OpenTelemetry:

* Npgsql:

  * `ec_Npgsql_bytes_written_per_second`
  * `ec_Npgsql_bytes_read_per_second`
  * `ec_Npgsql_commands_per_second`
  * `ec_Npgsql_total_commands`
  * `ec_Npgsql_current_commands`
  * `ec_Npgsql_failed_commands`
  * `ec_Npgsql_prepared_commands_ratio`
  * `ec_Npgsql_connection_pools`
  * `ec_Npgsql_multiplexing_average_commands_per_batch`
  * `ec_Npgsql_multiplexing_average_write_time_per_batch`

# Get started with the PostgreSQL integrations

> Learn how to set up the Aspire PostgreSQL Hosting and Client integrations simply.

![PostgreSQL logo](/_astro/postgresql-icon.DTORe-rE_Z29K7im.webp)

[PostgreSQL](https://www.postgresql.org/) is a powerful, open source object-relational database system with many years of active development that has earned it a strong reputation for reliability, feature robustness, and performance. The Aspire PostgreSQL integration provides a way to connect to existing PostgreSQL databases, or create new instances from the [`docker.io/library/postgres` container image](https://hub.docker.com/_/postgres).

In this introduction, you’ll see how to install and use the Aspire PostgreSQL integrations in a simple configuration. If you already have this knowledge, see [PostgreSQL Hosting integration](../postgres-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire PostgreSQL Hosting integration in your Aspire AppHost project. This integration allows you to create and manage PostgreSQL database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.PostgreSQL package

  ```bash
  aspire add postgresql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > postgresql (Aspire.Hosting.PostgreSQL)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.PostgreSQL" Version="*" />
  ```

Next, in the AppHost project, create instances of PostgreSQL server and database resources, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(postgresdb)
                            .WithReference(postgresdb);
```

apphost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(postgresdb)
                            .WithReference(postgresdb);
```

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(postgresdb)
                 .WithReference(postgresdb);
```

Tip

This is the simplest implementation of PostgreSQL resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [PostgreSQL Hosting integration](../postgres-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire PostgreSQL client integration:

* .NET CLI

  .NET CLI — Add Aspire.Npgsql package

  ```bash
  dotnet add package Aspire.Npgsql
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Npgsql@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Npgsql package reference

  ```xml
  <PackageReference Include="Aspire.Npgsql" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddNpgsqlDataSource` extension method on any `IHostApplicationBuilder` to register an `NpgsqlDataSource` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddNpgsqlDataSource(connectionName: "postgresdb");
```

Tip

The `connectionName` parameter must match the name used when adding the PostgreSQL server resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with PostgreSQL databases in your Python consuming projects, you need to include a PostgreSQL adapter library. Two popular options are `psycopg` (synchronous) and `asyncpg` (asynchronous). You can install either of these libraries using pip. In this article, example code uses `psycopg`:

```bash
pip install psycopg[binary]
```

Ensure that you `import psycopg` in code files that interact with the database. You should also import the `os` module to access environment variables:

Python - Import psycopg

```python
import psycopg
import os
```

To interact with PostgreSQL databases in your JavaScript consuming projects, you need to include a PostgreSQL client library. A popular option is `pg`. You can install this library using npm:

```bash
npm install pg
```

Ensure that you `import pg` in code files that interact with the database:

JavaScript - Import pg

```javascript
import pg from 'pg';
```

### Use injected PostgreSQL properties

[Section titled “Use injected PostgreSQL properties”](#use-injected-postgresql-properties)

In the AppHost, when you used the `WithReference` method to pass a PostgreSQL server or database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `postgresdb` becomes `POSTGRESDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string hostname = builder.Configuration.GetValue<string>("POSTGRESDB_HOST");
string databaseport = builder.Configuration.GetValue<string>("POSTGRESDB_PORT");
string jdbcconnectionstring = builder.Configuration.GetValue<string>("POSTGRESDB_JDBCCONNECTIONSTRING");
string databasename = builder.Configuration.GetValue<string>("POSTGRESDB_DATABASE");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python - Obtain configuration properties

```python
postgres_uri = os.getenv("POSTGRESDB_URI")
postgres_name = os.getenv("POSTGRESDB_DATABASE", "db")
```

Use the `process.env` method to obtain these environment variables in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const pguser = process.env.POSTGRESDB_USERNAME;
const pgpassword = process.env.POSTGRESDB_PASSWORD;
const pghost = process.env.POSTGRESDB_HOST;
const pgport = process.env.POSTGRESDB_PORT;
const pgdatabase = process.env.POSTGRESDB_DATABASE;
```

Tip

The full set of properties that Aspire injects depends on whether you passed a PostgreSQL server or database resource. For more information, see [Properties of the PostgreSQL resources](../postgres-client/#properties-of-the-postgresql-resources).

### Use PostgreSQL resources in client code

[Section titled “Use PostgreSQL resources in client code”](#use-postgresql-resources-in-client-code)

Now that you’ve added `NpgsqlDataSource` to the builder in the consuming project, you can use the PostgreSQL resource to get and store data. Get the `NpgsqlDataSource` instance using dependency injection. For example, to retrieve your data source object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(NpgsqlDataSource dataSource)
{
    // Use dataSource to query the database...
}
```

Having obtained the data source, you can work with the PostgreSQL database as you would in any other C# application.

Use the information you have obtained about the PostgreSQL resource to connect to the database. Here is an example of how to connect using `psycopg`:

Python - Connect to PostgreSQL

```python
async with await psycopg.AsyncConnection.connect(postgres_uri, autocommit=True) as conn:
```

Having obtained the connection, you can work with the PostgreSQL database as you would in any other Python application.

Use the information you have obtained about the PostgreSQL resource to connect to the database. Here is an example of how to connect using `pg`:

JavaScript - Connect to PostgreSQL

```javascript
const client = new pg.Client({
  user: pguser,
  host: pghost,
  database: pgdatabase,
  password: pgpassword,
  port: pgport,
});


client.connect();
```

Having obtained the connection, you can work with the PostgreSQL database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now, that you have an Aspire app with PostgreSQL integrations up and running, you can use the following reference documents to learn how to configure and interact with the PostgreSQL resources:

[Understand the PostgreSQL hosting integration ](/integrations/databases/postgres/postgres-host/)Discover how to configure persistence, pgAdmin resources, and more.

[Understand the PostgreSQL client integration ](/integrations/databases/postgres/postgres-client/)Discover how to configure keyed clients, client integration health checks, and more.

[Understand the PostgreSQL community extensions ](/integrations/databases/postgres/postgresql-extensions/)Discover how to add the DbGate management user interface, and more.

# PostgreSQL Hosting integration

> Learn how to use the Aspire PostgreSQL Hosting integration to orchestrate and confgure a PostgreSQL database in an Aspire solution.

![PostgreSQL logo](/_astro/postgresql-icon.DTORe-rE_Z29K7im.webp)

To get started with the Aspire PostgreSQL integrations, follow the [Get started with PostgreSQL integrations](/integrations/databases/postgres/postgres-get-started/) guide. If you want to learn how to use the PostgreSQL Entity Framework Core (EF Core) client integration, see [Get started with the PostgreSQL Entity Framework Core integrations](/integrations/databases/efcore/postgres/postgresql-get-started/).

This article includes full details on the Aspire PostgreSQL Hosting integration, which allows you to model PostgreSQL server and database resources in your [`AppHost`](/get-started/app-host/) project.

## Installation

[Section titled “Installation”](#installation)

The PostgreSQL hosting integration models various PostgreSQL resources as the following types.

* `PostgresServerResource`
* `PostgresDatabaseResource`
* `PostgresPgAdminContainerResource`
* `PostgresPgWebContainerResource`

To access these types and APIs for expressing them as resources in your [`AppHost`](/get-started/app-host/) project, install the [📦 Aspire.Hosting.PostgreSQL](https://www.nuget.org/packages/Aspire.Hosting.PostgreSQL) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.PostgreSQL package

  ```bash
  aspire add postgresql
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > postgresql (Aspire.Hosting.PostgreSQL)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.PostgreSQL@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.PostgreSQL package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.PostgreSQL" Version="*" />
  ```

## Add PostgreSQL server resource

[Section titled “Add PostgreSQL server resource”](#add-postgresql-server-resource)

In your AppHost project, call `AddPostgres` on the `builder` instance to add a PostgreSQL server resource then call `AddDatabase` on the `postgres` instance to add a database resource as shown in the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

1. When Aspire adds a container image to the app host, as shown in the preceding example with the `docker.io/library/postgres` image, it creates a new PostgreSQL server instance on your local machine. A reference to your PostgreSQL server and database instance (the `postgresdb` variable) are used to add a dependency to the `ExampleProject`.

2. When adding a database resource to the app model, the database is created if it doesn’t already exist. The creation of the database relies on the AppHost eventing APIs, specifically `ResourceReadyEvent`. In other words, when the `postgres` resource is *ready*, the event is raised and the database resource is created.

3. The PostgreSQL server resource includes default credentials with a `username` of `"postgres"` and randomly generated `password` using the `CreateDefaultPasswordParameter` method.

4. The `WithReference` method configures a connection in the `ExampleProject` named `"messaging"`.

Tip

If you’d rather connect to an existing PostgreSQL server, chain a call to `AsExisting` instead—passing the appropriate parameters.

Note

When you call `WithReference` in the AppHost to pass PostgreSQL resources to a consuming project, Aspire makes several properties available to that project, such as connection strings, URIs, and port numbers. For a complete list of these properties, see [Properties of the PostgreSQL resources](../postgres-client/#properties-of-the-postgresql-resources).

## Add PostgreSQL resource with database scripts

[Section titled “Add PostgreSQL resource with database scripts”](#add-postgresql-resource-with-database-scripts)

By default, when you add a `PostgresDatabaseResource`, it relies on the following script to create the database:

SQL — Default database creation script

```sql
CREATE DATABASE "<QUOTED_DATABASE_NAME>"
```

To alter the default script, chain a call to the `WithCreationScript` method on the database resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres");


var databaseName = "app_db";
var creationScript = $$"""
    -- Create the database
    CREATE DATABASE {{databaseName}};


    """;


var db = postgres.AddDatabase(databaseName)
                 .WithCreationScript(creationScript);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...
```

The preceding example creates a database named `app_db`. The script is run when the database resource is created. The script is passed as a string to the `WithCreationScript` method, which is then run in the context of the PostgreSQL resource.

Note

The connect to a database command (`\c`) isn’t supported when using the creation script.

## Add PostgreSQL pgAdmin resource

[Section titled “Add PostgreSQL pgAdmin resource”](#add-postgresql-pgadmin-resource)

When adding PostgreSQL resources to the `builder` with the `AddPostgres` method, you can chain calls to `WithPgAdmin` to add the [**dpage/pgadmin4**](https://www.pgadmin.org/) container. This container is a cross-platform client for PostgreSQL databases, that serves a web-based admin dashboard. Consider the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithPgAdmin();


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

The preceding code adds a container based on the `docker.io/dpage/pgadmin4` image. The container is used to manage the PostgreSQL server and database resources. The `WithPgAdmin` method adds a container that serves a web-based admin dashboard for PostgreSQL databases.

### Configure the pgAdmin host port

[Section titled “Configure the pgAdmin host port”](#configure-the-pgadmin-host-port)

To configure the host port for the pgAdmin container, call the `WithHostPort` method on the PostgreSQL server resource. The following example shows how to configure the host port for the pgAdmin container:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithPgAdmin(pgAdmin => pgAdmin.WithHostPort(5050));


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

The preceding code adds and configures the host port for the pgAdmin container. The host port is otherwise randomly assigned.

## Add PostgreSQL pgWeb resource

[Section titled “Add PostgreSQL pgWeb resource”](#add-postgresql-pgweb-resource)

When adding PostgreSQL resources to the `builder` with the `AddPostgres` method, you can chain calls to `WithPgWeb` to add the [**sosedoff/pgweb**](https://sosedoff.github.io/pgweb/) container. This container is a cross-platform client for PostgreSQL databases, that serves a web-based admin dashboard. Consider the following example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithPgWeb();


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

The preceding code adds a container based on the `docker.io/sosedoff/pgweb` image. All registered `PostgresDatabaseResource` instances are used to create a configuration file per instance, and each config is bound to the **pgweb** container bookmark directory. For more information, see [PgWeb docs: Server connection bookmarks](https://github.com/sosedoff/pgweb/wiki/Server-Connection-Bookmarks).

### Configure the pgWeb host port

[Section titled “Configure the pgWeb host port”](#configure-the-pgweb-host-port)

To configure the host port for the pgWeb container, call the `WithHostPort` method on the PostgreSQL server resource. The following example shows how to configure the host port for the pgAdmin container:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithPgWeb(pgWeb => pgWeb.WithHostPort(5050));


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

The preceding code adds and configures the host port for the pgWeb container. The host port is otherwise randomly assigned.

## Add PostgreSQL server resource with data volume

[Section titled “Add PostgreSQL server resource with data volume”](#add-postgresql-server-resource-with-data-volume)

To add a data volume to the PostgreSQL server resource, call the `WithDataVolume` method on the PostgreSQL server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithDataVolume(isReadOnly: false);


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

The data volume is used to persist the PostgreSQL server data outside the lifecycle of its container. The data volume is mounted at the `/var/lib/postgresql/data` path in the PostgreSQL server container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-postgresql-server-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

Caution

Some database integrations, including the Aspire PostgreSQL integration, can’t successfully use data volumes after deployment to Azure Container Apps (ACA). This is because ACA uses Server Message Block (SMB) to connect containers to data volumes, and some systems can’t use this connection. In the Aspire Dashboard, a database affected by this issue has a status of **Activating** or **Activation Failed** but is never listed as **Running**.

You can resolve the problem by using the managed service **Azure Database for PostgreSQL** to host the deployed database instead of a container in ACA, which is the recommended approach regardless of this issue. The following AppHost code shows how to deploy a database to Azure Database for PostgreSQL, but run it as a container, with a data volume, during development:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddAzurePostgresFlexibleServer("postgres")
                    .RunAsContainer(container =>
                    {
                        container.WithDataVolume();
                    });


builder.Build().Run();
```

## Add PostgreSQL server resource with data bind mount

[Section titled “Add PostgreSQL server resource with data bind mount”](#add-postgresql-server-resource-with-data-bind-mount)

To add a data bind mount to the PostgreSQL server resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithDataBindMount(
                          source: "/PostgreSQL/Data",
                          isReadOnly: false);


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the PostgreSQL server data across container restarts. The data bind mount is mounted at the `C:\PostgreSQL\Data` on Windows (or `/PostgreSQL/Data` on Unix) path on the host machine in the PostgreSQL server container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Add PostgreSQL server resource with init bind mount

[Section titled “Add PostgreSQL server resource with init bind mount”](#add-postgresql-server-resource-with-init-bind-mount)

To add an init bind mount to the PostgreSQL server resource, call the `WithInitBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithInitBindMount(@"C:\PostgreSQL\Init");


var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

The init bind mount relies on the host machine’s filesystem to initialize the PostgreSQL server database with the containers *init* folder. This folder is used for initialization, running any executable shell scripts or *.sql* command files after the *postgres-data* folder is created. The init bind mount is mounted at the `C:\PostgreSQL\Init` on Windows (or `/PostgreSQL/Init` on Unix) path on the host machine in the PostgreSQL server container.

## Add PostgreSQL server resource with parameters

[Section titled “Add PostgreSQL server resource with parameters”](#add-postgresql-server-resource-with-parameters)

When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("username", secret: true);
var password = builder.AddParameter("password", secret: true);


var postgres = builder.AddPostgres("postgres", username, password);
var postgresdb = postgres.AddDatabase("postgresdb");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(postgresdb);


// After adding all resources, run the app...
```

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a PostgreSQL resource using `WithReference`, the following connection properties are made available to the consuming project:

#### PostgreSQL server

[Section titled “PostgreSQL server”](#postgresql-server)

The PostgreSQL server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                    |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Host`                 | The hostname or IP address of the PostgreSQL server                                                                                                                            |
| `Port`                 | The port number the PostgreSQL server is listening on                                                                                                                          |
| `Username`             | The username for authentication                                                                                                                                                |
| `Password`             | The password for authentication                                                                                                                                                |
| `Uri`                  | The connection URI in postgresql:// format, with the format `postgresql://{Username}:{Password}@{Host}:{Port}`                                                                 |
| `JdbcConnectionString` | JDBC-format connection string, with the format `jdbc:postgresql://{Host}:{Port}`. User and password credentials are provided as separate `Username` and `Password` properties. |

**Example connection strings:**

```plaintext
Uri: postgresql://postgres:p%40ssw0rd1@localhost:5432
JdbcConnectionString: jdbc:postgresql://localhost:5432
```

#### PostgreSQL database

[Section titled “PostgreSQL database”](#postgresql-database)

The PostgreSQL database resource inherits all properties from its parent `PostgresServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                               |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI with the database name, with the format `postgresql://{Username}:{Password}@{Host}:{Port}/{DatabaseName}`                                                                              |
| `JdbcConnectionString` | JDBC connection string with database name, with the format `jdbc:postgresql://{Host}:{Port}/{DatabaseName}`. User and password credentials are provided as separate `Username` and `Password` properties. |
| `DatabaseName`         | The name of the database                                                                                                                                                                                  |

**Example connection strings:**

```plaintext
Uri: postgresql://postgres:p%40ssw0rd1@localhost:5432/catalog
JdbcConnectionString: jdbc:postgresql://localhost:5432/catalog
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `db1` becomes `DB1_URI`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The PostgreSQL hosting integration automatically adds a health check for the PostgreSQL server resource. The health check verifies that the PostgreSQL server is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.Npgsql](https://www.nuget.org/packages/AspNetCore.HealthChecks.Npgsql) NuGet package.

### Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

The PostgreSQL hosting integration can be used with any application technology, not just .NET applications. When you use `WithReference` to reference a PostgreSQL resource, connection information is automatically injected as environment variables into the referencing application.

For applications that don’t use the [client integration](/integrations/databases/postgres/postgres-client/), you can access the connection information through environment variables. Here’s an example of how to configure environment variables for a non-.NET application:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
    .WithLifetime(ContainerLifetime.Persistent);


var database = postgres.AddDatabase("myDatabase");


// Example: Configure a non-.NET application with PostgreSQL access
var app = builder.AddExecutable("my-app", "node", "app.js", ".")
    .WithReference(database) // Provides ConnectionStrings__myDatabase
    .WithEnvironment(context =>
    {
        // Additional individual connection details as environment variables
        context.EnvironmentVariables["POSTGRES_HOST"] = postgres.Resource.PrimaryEndpoint.Property(EndpointProperty.Host);
        context.EnvironmentVariables["POSTGRES_PORT"] = postgres.Resource.PrimaryEndpoint.Property(EndpointProperty.Port);
        context.EnvironmentVariables["POSTGRES_USER"] = postgres.Resource.UserNameParameter;
        context.EnvironmentVariables["POSTGRES_PASSWORD"] = postgres.Resource.PasswordParameter;
        context.EnvironmentVariables["POSTGRES_DATABASE"] = database.Resource.DatabaseName;
    });


builder.Build().Run();
```

This configuration provides the non-.NET application with several environment variables:

* `ConnectionStrings__myDatabase`: The complete PostgreSQL connection string
* `POSTGRES_HOST`: The hostname/IP address of the PostgreSQL server
* `POSTGRES_PORT`: The port number the PostgreSQL server is listening on
* `POSTGRES_USER`: The database username
* `POSTGRES_PASSWORD`: The dynamically generated password
* `POSTGRES_DATABASE`: The name of the database

Your non-.NET application can then read these environment variables to connect to the PostgreSQL database using the appropriate database driver for that technology (for example, `psycopg2` for Python, `pg` for Node.js, or `pq` for Go).

# PostgreSQL hosting extensions

⭐ Community Toolkit ![PostgreSQL logo](/_astro/postgresql-icon.DTORe-rE_Z29K7im.webp)

The Aspire Community Toolkit PostgreSQL hosting extensions package provides extra functionality to the [Aspire.Hosting.PostgreSQL](https://www.nuget.org/packages/Aspire.Hosting.PostgreSQL) hosting package.

This package provides the following features:

* [Adminer](https://adminer.org/) management UI
* [DbGate](https://dbgate.org/) management UI

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Community Toolkit PostgreSQL hosting extensions, install the [CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions package

  ```bash
  aspire add communitytoolkit-postgresql-extensions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-postgresql-extensions (CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions" Version="*" />
  ```

## Add management UI

[Section titled “Add management UI”](#add-management-ui)

### DbGate management UI

[Section titled “DbGate management UI”](#dbgate-management-ui)

To add the DbGate management UI to your PostgreSQL resource, call the `WithDbGate` method on the `PostgresServerResource` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithDbGate();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(postgres);


// After adding all resources, run the app...
```

This adds a new DbGate resource to the app host which is available from the Aspire dashboard. DbGate is a comprehensive database management tool that provides a web-based interface for managing your PostgreSQL databases.

### Adminer management UI

[Section titled “Adminer management UI”](#adminer-management-ui)

To add the Adminer management UI to your PostgreSQL resource, call the `WithAdminer` method on the `PostgresServerResource` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithAdminer();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(postgres);


// After adding all resources, run the app...
```

This adds a new Adminer resource to the app host which is available from the Aspire dashboard. Adminer is a lightweight database management tool that provides a simple web interface for database operations.

### Using both management UIs

[Section titled “Using both management UIs”](#using-both-management-uis)

You can use both management UIs together on the same PostgreSQL resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
                      .WithDbGate()
                      .WithAdminer();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(postgres);


// After adding all resources, run the app...
```

## See also

[Section titled “See also”](#see-also)

* [Adminer documentation](https://www.adminer.org/)
* [DbGate documentation](https://dbgate.org/)
* [PostgreSQL integration](/integrations/databases/postgres/postgres-host/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Qdrant Client integration reference

> Learn how to use the Aspire Qdrant Client integration to interact with Qdrant vector databases from your Aspire projects.

![Qdrant logo](/_astro/qdrant-icon.wEc8LmZK_Z1NYjKL.svg)

To get started with the Aspire Qdrant integrations, follow the [Get started with Qdrant integrations](../qdrant-get-started/) guide.

This article includes full details about the Aspire Qdrant Client integration, which allows you to connect to and interact with Qdrant vector databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

You need a Qdrant server and connection information for accessing the server. To get started with the Aspire Qdrant client integration, install the [📦 Aspire.Qdrant.Client](https://www.nuget.org/packages/Aspire.Qdrant.Client) NuGet package in the client-consuming project, that is, the project for the application that uses the Qdrant client. The Qdrant client integration registers a `QdrantClient` instance that you can use to interact with Qdrant.

* .NET CLI

  .NET CLI — Add Aspire.Qdrant.Client package

  ```bash
  dotnet add package Aspire.Qdrant.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Qdrant.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Qdrant.Client package reference

  ```xml
  <PackageReference Include="Aspire.Qdrant.Client" Version="*" />
  ```

## Add Qdrant client

[Section titled “Add Qdrant client”](#add-qdrant-client)

In the `Program.cs` file of your client-consuming project, call the `AddQdrantClient` extension method on any `IHostApplicationBuilder` to register a `QdrantClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddQdrantClient(connectionName: "qdrant");
```

Tip

The `connectionName` parameter must match the name used when adding the Qdrant resource in the AppHost project. For more information, see [Add Qdrant resource](../qdrant-host/#add-qdrant-resource).

You can then retrieve the `QdrantClient` instance using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(QdrantClient client)
{
    // Use Qdrant client...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Add keyed Qdrant client

[Section titled “Add keyed Qdrant client”](#add-keyed-qdrant-client)

There might be situations where you want to register multiple `QdrantClient` instances with different connection strings. To register keyed Qdrant clients, call the `AddKeyedQdrantClient` method:

C# — Program.cs

```csharp
builder.AddKeyedQdrantClient(name: "mainQdrant");
builder.AddKeyedQdrantClient(name: "loggingQdrant");
```

Then retrieve the instances using dependency injection:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("mainQdrant")] QdrantClient mainQdrantClient,
    [FromKeyedServices("loggingQdrant")] QdrantClient loggingQdrantClient)
{
    // Use clients...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Properties of the Qdrant resources

[Section titled “Properties of the Qdrant resources”](#properties-of-the-qdrant-resources)

When you use the `WithReference` method to pass a Qdrant server resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `qdrant` becomes `QDRANT_URI`.

### Qdrant server

[Section titled “Qdrant server”](#qdrant-server)

The Qdrant server resource exposes the following connection properties:

| Property Name | Description                                                             |
| ------------- | ----------------------------------------------------------------------- |
| `GrpcHost`    | The gRPC hostname of the Qdrant server                                  |
| `GrpcPort`    | The gRPC port of the Qdrant server                                      |
| `HttpHost`    | The HTTP hostname of the Qdrant server                                  |
| `HttpPort`    | The HTTP port of the Qdrant server                                      |
| `ApiKey`      | The API key for authentication                                          |
| `Uri`         | The gRPC connection URI, with the format `http://{GrpcHost}:{GrpcPort}` |
| `HttpUri`     | The HTTP connection URI, with the format `http://{HttpHost}:{HttpPort}` |

**Example connection strings:**

```plaintext
Uri: http://localhost:6334
HttpUri: http://localhost:6333
```

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire Qdrant client integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you provide the name of the connection string when calling `builder.AddQdrantClient()`:

C# — Program.cs

```csharp
builder.AddQdrantClient("qdrant");
```

The connection string is retrieved from the `ConnectionStrings` configuration section. By default the `QdrantClient` uses the gRPC API endpoint:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "qdrant": "Endpoint=http://localhost:6334;Key=123456!@#$%"
  }
}
```

For more information about the Qdrant connection string format, see the [Qdrant documentation](https://qdrant.tech/).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Qdrant client integration supports `Microsoft.Extensions.Configuration` from configuration files such as `appsettings.json` by using the `Aspire:Qdrant:Client` key. If you have set up your configurations in the `Aspire:Qdrant:Client` section you can just call the method without passing any parameter.

The following is an example of an `appsettings.json` that configures some of the available options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Qdrant": {
      "Client": {
        "Endpoint": "http://localhost:6334/",
        "Key": "123456!@#$%"
      }
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<QdrantSettings>` delegate to set up some or all the options inline, for example to set the API key from code:

C# — Program.cs

```csharp
builder.AddQdrantClient(
    "qdrant",
    settings => settings.Key = "12345!@#$%");
```

### Configuration options

[Section titled “Configuration options”](#configuration-options)

Here are the configurable options with corresponding default values:

| Name                  | Description                                                                          |
| --------------------- | ------------------------------------------------------------------------------------ |
| `Endpoint`            | The endpoint URI of the Qdrant server to connect to.                                 |
| `Key`                 | The API key used for authentication.                                                 |
| `DisableHealthChecks` | A boolean value that indicates whether the health check is disabled or not.          |
| `DisableTracing`      | A boolean value that indicates whether the OpenTelemetry tracing is disabled or not. |

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

By default, the Aspire Qdrant client integration handles the following:

* Checks if the `QdrantSettings.DisableHealthChecks` is `true`.
* If not disabled, adds a health check that verifies the Qdrant server is reachable.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire Qdrant client integration uses the following log categories:

* `Qdrant.Client`

### Tracing and Metrics

[Section titled “Tracing and Metrics”](#tracing-and-metrics)

The Qdrant integration doesn’t currently emit tracing activities or metrics because they are not supported by the `Qdrant.Client` library.

## See also

[Section titled “See also”](#see-also)

* [Qdrant](https://qdrant.tech/)
* [Qdrant Documentation](https://qdrant.tech/documentation/)
* [.NET Qdrant Client](https://github.com/qdrant/qdrant-dotnet/)
* [Aspire integrations](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the Qdrant integrations

> Learn how to set up the Aspire Qdrant Hosting and Client integrations simply.

![Qdrant logo](/_astro/qdrant-icon.wEc8LmZK_Z1NYjKL.svg)

[Qdrant](https://qdrant.tech/) is an open-source vector similarity search engine that efficiently stores, indexes, and searches large-scale vector data. It’s commonly used in machine learning, artificial intelligence, and data science applications. The Aspire Qdrant integration enables you to connect to existing Qdrant servers or create new servers from Aspire with the [`qdrant/qdrant` container image](https://hub.docker.com/r/qdrant/qdrant).

In this introduction, you’ll see how to install and use the Aspire Qdrant integrations in a simple configuration. If you already have this knowledge, see [Qdrant Hosting integration](../qdrant-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire Qdrant Hosting integration in your Aspire AppHost project. This integration allows you to create and manage Qdrant vector database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Qdrant package

  ```bash
  aspire add qdrant
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > qdrant (Aspire.Hosting.Qdrant)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Qdrant@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Qdrant package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Qdrant" Version="*" />
  ```

Next, in the AppHost project, create instances of Qdrant server resources, then pass the server to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var qdrant = builder.AddQdrant("qdrant")
                    .WithLifetime(ContainerLifetime.Persistent);


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(qdrant)
                            .WithReference(qdrant);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var qdrant = builder.AddQdrant("qdrant")
                    .WithLifetime(ContainerLifetime.Persistent);


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(qdrant)
                            .WithReference(qdrant);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var qdrant = builder.AddQdrant("qdrant")
                    .WithLifetime(ContainerLifetime.Persistent);


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(qdrant)
                 .WithReference(qdrant);
```

Tip

This is the simplest implementation of Qdrant resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [Qdrant Hosting integration](../qdrant-host/).

Tip

The `qdrant/qdrant` container image includes a web UI that you can use to explore your vectors and administer the database. To access this tool, start your Aspire solution and then, in the Aspire dashboard, select the endpoint for the Qdrant resource. In your browser’s address bar, append **/dashboard** and press Enter.

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire Qdrant client integration:

* .NET CLI

  .NET CLI — Add Aspire.Qdrant.Client package

  ```bash
  dotnet add package Aspire.Qdrant.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Qdrant.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Qdrant.Client package reference

  ```xml
  <PackageReference Include="Aspire.Qdrant.Client" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddQdrantClient` extension method on any `IHostApplicationBuilder` to register a `QdrantClient` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddQdrantClient(connectionName: "qdrant");
```

Tip

The `connectionName` parameter must match the name used when adding the Qdrant resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with Qdrant vector databases in your Python consuming projects, you need to include a Qdrant client library. The official option is `qdrant-client`, which is Qdrant’s Python SDK. You can install this library using pip:

```bash
pip install qdrant-client
```

Ensure that you import the `QdrantClient` in code files that interact with the vector database. You should also import the `os` module to access environment variables:

Python - Import qdrant-client

```python
from qdrant_client import QdrantClient
import os
```

To interact with Qdrant vector databases in your JavaScript consuming projects, you need to include a Qdrant client library. The official option is `@qdrant/js-client-rest`, which is Qdrant’s JavaScript/TypeScript SDK. You can install this library using npm:

```bash
npm install @qdrant/js-client-rest
```

Ensure that you import the `QdrantClient` in code files that interact with the vector database:

JavaScript - Import @qdrant/js-client-rest

```javascript
const { QdrantClient } = require('@qdrant/js-client-rest');
```

### Use injected Qdrant properties

[Section titled “Use injected Qdrant properties”](#use-injected-qdrant-properties)

In the AppHost, when you used the `WithReference` method to pass a Qdrant resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `qdrant` becomes `QDRANT_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string connectionString = builder.Configuration.GetValue<string>("ConnectionStrings__qdrant");
string apiKey = builder.Configuration.GetValue<string>("QDRANT_APIKEY");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python - Obtain configuration properties

```python
connection_string = os.getenv("ConnectionStrings__qdrant")
api_key = os.getenv("QDRANT_APIKEY")
grpc_host = os.getenv("QDRANT_GRPCHOST")
grpc_port = os.getenv("QDRANT_GRPCPORT")
```

Use the `process.env` property to obtain these environment variables in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const connectionString = process.env.ConnectionStrings__qdrant;
const apiKey = process.env.QDRANT_APIKEY;
const grpcHost = process.env.QDRANT_GRPCHOST;
const grpcPort = process.env.QDRANT_GRPCPORT;
```

Tip

The full set of properties that Aspire injects depends on the Qdrant resource configuration. For more information, see [Properties of the Qdrant resources](../qdrant-client/#properties-of-the-qdrant-resources).

### Use Qdrant resources in client code

[Section titled “Use Qdrant resources in client code”](#use-qdrant-resources-in-client-code)

Now that you’ve added the `QdrantClient` to the builder in the consuming project, you can use the Qdrant vector database to store and search vector data. Get the `QdrantClient` instance using dependency injection. For example, to retrieve your client object from an example service, define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(QdrantClient client)
{
    // Use Qdrant client...
}
```

Having obtained the client, you can work with the Qdrant vector database as you would in any other C# application.

Use the information you have obtained about the Qdrant resource to connect to the vector database. Here is an example of how to connect using `qdrant-client`:

Python - Connect to Qdrant

```python
# Create Qdrant client
client = QdrantClient(
    host=grpc_host,
    port=int(grpc_port),
    api_key=api_key,
    prefer_grpc=True
)


# Verify connection
print(client.get_collections())
```

Having obtained the client, you can work with the Qdrant vector database as you would in any other Python application.

Use the information you have obtained about the Qdrant resource to connect to the vector database. Here is an example of how to connect using `@qdrant/js-client-rest`:

JavaScript - Connect to Qdrant

```javascript
// Create Qdrant client
const client = new QdrantClient({
  url: `http://${httpHost}:${httpPort}`,
  apiKey: apiKey
});


// Verify connection
const collections = await client.getCollections();
console.log('Collections:', collections);
```

Having obtained the client, you can work with the Qdrant vector database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with Qdrant integrations up and running, you can use the following reference documents to learn how to configure and interact with the Qdrant resources:

[Understand the Qdrant hosting integration ](/integrations/databases/qdrant/qdrant-host/)Discover how to configure data volumes, API keys, and more.

[Understand the Qdrant client integration ](/integrations/databases/qdrant/qdrant-client/)Learn about the Qdrant client integration, including connection strings and observability.

# Qdrant Hosting integration reference

> Learn how to use the Aspire Qdrant Hosting integration to orchestrate and configure Qdrant vector databases in your Aspire projects.

![Qdrant logo](/_astro/qdrant-icon.wEc8LmZK_Z1NYjKL.svg)

To get started with the Aspire Qdrant integrations, follow the [Get started with Qdrant integrations](../qdrant-get-started/) guide.

This article includes full details about the Aspire Qdrant Hosting integration, which models Qdrant server resources as the `QdrantServerResource` type.

## Installation

[Section titled “Installation”](#installation)

The Aspire Qdrant hosting integration models the Qdrant vector database server as the `QdrantServerResource` type.

To access these types and APIs for expressing them as resources in your AppHost project, install the [📦 Aspire.Hosting.Qdrant](https://www.nuget.org/packages/Aspire.Hosting.Qdrant) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Qdrant package

  ```bash
  aspire add qdrant
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > qdrant (Aspire.Hosting.Qdrant)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Qdrant@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Qdrant package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Qdrant" Version="*" />
  ```

## Add Qdrant resource

[Section titled “Add Qdrant resource”](#add-qdrant-resource)

In the AppHost project, call `AddQdrant` to add and return a Qdrant server resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var qdrant = builder.AddQdrant("qdrant")
                    .WithLifetime(ContainerLifetime.Persistent);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(qdrant)
       .WaitFor(qdrant);


// After adding all resources, run the app...
```

Note

The Qdrant container can be slow to start, so it’s best to use a persistent lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

When Aspire adds a container image to the AppHost, as shown in the preceding example with the `qdrant/qdrant` image, it creates a new Qdrant server on your local machine. A reference to your Qdrant resource builder (the `qdrant` variable) is used to connect your application.

The `WithReference` method configures a connection in the `ExampleProject` named `"qdrant"`. For more information, see [Container resource lifecycle](/architecture/resource-model/#built-in-resources-and-lifecycle).

Tip

If you’d rather connect to an existing Qdrant server, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add Qdrant resource with API key parameter

[Section titled “Add Qdrant resource with API key parameter”](#add-qdrant-resource-with-api-key-parameter)

The Qdrant resource includes a default, randomly generated API key. Qdrant supports configuration-based API keys. When you want to provide an API key explicitly, you can provide it as a parameter:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiKey = builder.AddParameter("apiKey", secret: true);


var qdrant = builder.AddQdrant("qdrant", apiKey)
                    .WithLifetime(ContainerLifetime.Persistent);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(qdrant)
                       .WaitFor(qdrant);
```

The preceding code gets a parameter to pass to the `AddQdrant` API, and internally assigns the parameter to the Qdrant container configuration. The `apiKey` parameter is usually specified as a user secret:

JSON — secrets.json

```json
{
  "Parameters": {
    "apiKey": "your-secure-api-key"
  }
}
```

For more information, see [External parameters](/get-started/resources/).

## Add Qdrant resource with data volume

[Section titled “Add Qdrant resource with data volume”](#add-qdrant-resource-with-data-volume)

To add a data volume to the Qdrant resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var qdrant = builder.AddQdrant("qdrant")
                    .WithDataVolume()
                    .WithLifetime(ContainerLifetime.Persistent);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(qdrant)
       .WaitFor(qdrant);


// After adding all resources, run the app...
```

The data volume is used to persist the Qdrant data outside the lifecycle of its container. The data volume is mounted at the `/qdrant/storage` path in the Qdrant container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-qdrant-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

## Add Qdrant resource with data bind mount

[Section titled “Add Qdrant resource with data bind mount”](#add-qdrant-resource-with-data-bind-mount)

To add a data bind mount to the Qdrant resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var qdrant = builder.AddQdrant("qdrant")
                    .WithDataBindMount(source: @"C:\Qdrant\Data")
                    .WithLifetime(ContainerLifetime.Persistent);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(qdrant)
       .WaitFor(qdrant);


// After adding all resources, run the app...
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the Qdrant data across container restarts. The data bind mount is mounted at the `C:\Qdrant\Data` on Windows (or `/Qdrant/Data` on Unix) path on the host machine in the Qdrant container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

When you use the `WithReference` method to pass a Qdrant resource to a non-.NET application (such as Python or JavaScript), Aspire automatically injects environment variables that describe the connection information.

For example, if you reference a Qdrant resource named `qdrant`:

C# — AppHost.cs

```csharp
var qdrant = builder.AddQdrant("qdrant");


var pythonApp = builder.AddUvicornApp("api", "./api", "main:app")
    .WithReference(qdrant);
```

The following environment variables are available in the Python application:

* `ConnectionStrings__qdrant` - The connection string for the Qdrant server
* `QDRANT_GRPCHOST` - The gRPC hostname of the Qdrant server
* `QDRANT_GRPCPORT` - The gRPC port number
* `QDRANT_HTTPHOST` - The HTTP hostname of the Qdrant server
* `QDRANT_HTTPPORT` - The HTTP port number
* `QDRANT_APIKEY` - The API key for authentication
* `QDRANT_URI` - The gRPC connection URI
* `QDRANT_HTTPURI` - The HTTP connection URI

You can access these environment variables in your application code:

Python example

```python
from qdrant_client import QdrantClient
import os


# Get connection properties
grpc_host = os.getenv("QDRANT_GRPCHOST")
grpc_port = os.getenv("QDRANT_GRPCPORT")
api_key = os.getenv("QDRANT_APIKEY")


# Create Qdrant client
client = QdrantClient(
    host=grpc_host,
    port=int(grpc_port),
    api_key=api_key,
    prefer_grpc=True
)
```

JavaScript example

```javascript
const { QdrantClient } = require('@qdrant/js-client-rest');


// Get connection properties
const httpHost = process.env.QDRANT_HTTPHOST;
const httpPort = process.env.QDRANT_HTTPPORT;
const apiKey = process.env.QDRANT_APIKEY;


// Create Qdrant client
const client = new QdrantClient({
  url: `http://${httpHost}:${httpPort}`,
  apiKey: apiKey
});
```

## Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Qdrant hosting integration automatically adds a health check for the Qdrant resource. The health check verifies that the Qdrant server is running and that a connection can be established to it.

# RavenDB integration

> Learn how to use the RavenDB hosting and client integration to run a RavenDB container and access it via the RavenDB client.

⭐ Community Toolkit ![RavenDB logo](/_astro/ravendb-icon.BflXREOW.png)

[RavenDB](https://ravendb.net/) is a high-performance, open-source NoSQL database designed for fast, efficient, and scalable data storage. It supports advanced features like ACID transactions, distributed data replication, and time-series data management, making it an excellent choice for modern application development. The Aspire RavenDB integration enables you to connect to existing RavenDB instances or create new instances from Aspire using the `docker.io/ravendb/ravendb` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The RavenDB hosting integration models the server as the `RavenDBServerResource` type and the database as the `RavenDBDatabaseResource` type. To access these types and APIs, install the [📦 CommunityToolkit.Aspire.Hosting.RavenDB](https://nuget.org/packages/CommunityToolkit.Aspire.Hosting.RavenDB) NuGet package in the AppHost project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.RavenDB package

  ```bash
  aspire add communitytoolkit-ravendb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-ravendb (CommunityToolkit.Aspire.Hosting.RavenDB)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.RavenDB@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.RavenDB package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.RavenDB" Version="*" />
  ```

### Add RavenDB server resource and database resource

[Section titled “Add RavenDB server resource and database resource”](#add-ravendb-server-resource-and-database-resource)

To set up RavenDB in your AppHost project, call the `AddRavenDB` extension method to add a RavenDB server resource, then call `AddDatabase` on the server resource to add a database:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var ravenServer = builder.AddRavenDB("ravenServer");
var ravendb = ravenServer.AddDatabase("ravendb");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(ravendb)
       .WaitFor(ravendb);


// After adding all resources, build and run the app...
```

Caution

A valid RavenDB license is required. If you don’t have one yet, you can request a free Community license at [ravendb.net/license/request/community](https://ravendb.net/license/request/community).

### Add RavenDB server resource with data volume

[Section titled “Add RavenDB server resource with data volume”](#add-ravendb-server-resource-with-data-volume)

To add a data volume to the RavenDB server resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var ravenServer = builder.AddRavenDB("ravenServer")
                         .WithDataVolume();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(ravenServer)
       .WaitFor(ravenServer);
```

The data volume remains available after the container’s lifecycle ends, preserving RavenDB data. The data volume is mounted at the `/var/lib/ravendb/data` path in the RavenDB container and when a `name` parameter isn’t provided, the name is generated at random.

### Add RavenDB server resource with data bind mount

[Section titled “Add RavenDB server resource with data bind mount”](#add-ravendb-server-resource-with-data-bind-mount)

To add a data bind mount to the RavenDB server resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var ravenServer = builder.AddRavenDB("ravenServer")
                         .WithDataBindMount(source: @"C:\RavenDb\Data");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(ravenServer)
       .WaitFor(ravenServer);
```

Data bind mounts rely on the host machine’s filesystem to persist the RavenDB data across container restarts.

### Add secured RavenDB server resource

[Section titled “Add secured RavenDB server resource”](#add-secured-ravendb-server-resource)

To create a new secured RavenDB instance using settings from a pre-configured `settings.json` file or a self-signed certificate, use the `RavenDBServerSettings.Secured` method or `RavenDBServerSettings.SecuredWithLetsEncrypt` for Let’s Encrypt configurations:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var serverSettings = RavenDBServerSettings.SecuredWithLetsEncrypt(
    domainUrl: "https://mycontainer.development.run",
    certificatePath: "/etc/ravendb/security/cluster.server.certificate.mycontainer.pfx");


var ravendb = builder.AddRavenDB("ravenSecuredServer", serverSettings)
    .WithBindMount("C:/RavenDB/Server/Security", "/etc/ravendb/security", false)
    .AddDatabase("ravendbSecured");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(ravendb)
       .WaitFor(ravendb);
```

Caution

Ensure the certificate path is accessible to the container by bind-mounting it to `/etc/ravendb/security`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The RavenDB hosting integration automatically adds a health check for the RavenDB server resource, verifying that the server is running and reachable.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire RavenDB client integration, install the [📦 CommunityToolkit.Aspire.RavenDB.Client](https://nuget.org/packages/CommunityToolkit.Aspire.RavenDB.Client) NuGet package in the client-consuming project. The RavenDB client integration registers an `IDocumentStore` instance, which serves as the entry point for interacting with the RavenDB server. If your AppHost includes RavenDB database resources, the associated `IDocumentSession` and `IAsyncDocumentSession` instances are also registered for dependency injection.

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.RavenDB.Client package

  ```bash
  dotnet add package CommunityToolkit.Aspire.RavenDB.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.RavenDB.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.RavenDB.Client package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.RavenDB.Client" Version="*" />
  ```

### Add RavenDB client

[Section titled “Add RavenDB client”](#add-ravendb-client)

In the `Program.cs` file of your client-consuming project, call the `AddRavenDBClient` extension method to register an `IDocumentStore` for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddRavenDBClient(connectionName: "ravendb");
```

Tip

The `connectionName` parameter must match the name used when adding the RavenDB server resource (or the database resource, if provided) in the AppHost project.

You can then retrieve the `IDocumentStore` instance using dependency injection:

```csharp
public class ExampleService(IDocumentStore client)
{
    // Use client...
}
```

#### Add RavenDB client using settings

[Section titled “Add RavenDB client using settings”](#add-ravendb-client-using-settings)

The `AddRavenDBClient` method provides overloads that accept a `RavenDBClientSettings` object:

```csharp
var settings = new RavenDBClientSettings
{
    Urls = new[] { serverUrl },
    DatabaseName = myDatabaseName,
    Certificate = myCertificate
};


builder.AddRavenDBClient(settings: settings);
```

Note

These methods are ideal for connecting to an existing RavenDB instance without relying on the hosting integration.

### Add keyed RavenDB client

[Section titled “Add keyed RavenDB client”](#add-keyed-ravendb-client)

If your application requires multiple `IDocumentStore` instances with different connection configurations, you can register keyed RavenDB clients:

```csharp
builder.AddKeyedRavenDBClient(serviceKey: "production", connectionName: "production");
builder.AddKeyedRavenDBClient(serviceKey: "testing", connectionName: "testing");
```

Then you can retrieve the `IDocumentStore` instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("production")] IDocumentStore production,
    [FromKeyedServices("testing")] IDocumentStore testing)
{
    // Use databases...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire RavenDB Client integration provides multiple configuration approaches and options to meet the requirements and conventions of your project.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name of the connection string:

```csharp
builder.AddRavenDBClient("ravendb");
```

The connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "ravendb": "Url=http://localhost:8080/;Database=ravendb"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire RavenDB integration supports configuration. It loads the `RavenDBClientSettings` from the configuration using the `Aspire:RavenDB:Client` key:

```json
{
  "Aspire": {
    "RavenDB": {
      "Client": {
        "ConnectionString": "URL=http://localhost:8080;Database=ravendb",
        "DisableHealthChecks": false,
        "HealthCheckTimeout": 10000,
        "DisableTracing": false
      }
    }
  }
}
```

#### Use inline configurations

[Section titled “Use inline configurations”](#use-inline-configurations)

You can also pass an `Action<RavenDBClientSettings>` delegate to set up options inline:

```csharp
builder.AddRavenDBClient(connectionName: "ravendb", configureSettings:
    settings =>
    {
        settings.CreateDatabase = true;
        settings.Certificate = myCertificate;
        settings.DisableTracing = true;
    });
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

The Aspire RavenDB client integration uses the configured client to perform a health check. If successful, the health check is considered healthy.

## See also

[Section titled “See also”](#see-also)

* [RavenDB](https://ravendb.net/)
* [RavenDB Dockerfile guide](https://docs.ravendb.net/6.2/start/containers/dockerfile/guide/)
* [Aspire Community Toolkit GitHub repo](https://github.com/CommunityToolkit/Aspire)

# SQL Server Client integration reference

> Learn how to use the Aspire SQL Server Client integration to query SQL Server databases from your Aspire projects.

![SQL Server logo](/_astro/sql-icon.CyVgV5Qd_Z1td4Jv.webp)

To get started with the Aspire SQL Server integrations, follow the [Get started with SQL Server integrations](../sql-server-get-started/) guide.

This article includes full details about the Aspire SQL Server Client integration, which allows you to connect to and interact with SQL Server databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire SQL Server client integration, install the [📦 Aspire.Microsoft.Data.SqlClient](https://www.nuget.org/packages/Aspire.Microsoft.Data.SqlClient) NuGet package in the client-consuming project, that is, the project for the application that uses the SQL Server client. The SQL Server client integration registers a `SqlConnection` instance that you can use to interact with SQL Server.

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.Data.SqlClient package

  ```bash
  dotnet add package Aspire.Microsoft.Data.SqlClient
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.Data.SqlClient@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.Data.SqlClient package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.Data.SqlClient" Version="*" />
  ```

## Add SQL Server client

[Section titled “Add SQL Server client”](#add-sql-server-client)

In the *Program.cs* file of your client-consuming project, call the `AddSqlServerClient` extension method on any `IHostApplicationBuilder` to register a `SqlConnection` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqlServerClient(connectionName: "database");
```

Tip

The `connectionName` parameter must match the name used when adding the SQL Server database resource in the AppHost project. In other words, when you call `AddDatabase` and provide a name of `database` that same name should be used when calling `AddSqlServerClient`. For more information, see [Add SQL Server resource and database resource](../sql-server-host/#add-sql-server-resource-and-database-resource).

You can then retrieve the `SqlConnection` instance using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(SqlConnection connection)
{
    // Use connection...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Add keyed SQL Server client

[Section titled “Add keyed SQL Server client”](#add-keyed-sql-server-client)

There might be situations where you want to register multiple `SqlConnection` instances with different connection names. To register keyed SQL Server clients, call the `AddKeyedSqlServerClient` method:

C# — Program.cs

```csharp
builder.AddKeyedSqlServerClient(name: "mainDb");
builder.AddKeyedSqlServerClient(name: "loggingDb");
```

Caution

When using keyed services, it’s expected that your SQL Server resource configured two named databases, one for the `mainDb` and one for the `loggingDb`.

Then you can retrieve the `SqlConnection` instances using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("mainDb")] SqlConnection mainDbConnection,
    [FromKeyedServices("loggingDb")] SqlConnection loggingDbConnection)
{
    // Use connections...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Properties of the SQL Server resources

[Section titled “Properties of the SQL Server resources”](#properties-of-the-sql-server-resources)

When you use the `WithReference` method to pass a SQL Server server or database resource from the AppHost project to a consuming client project, several properties are available to use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `sqldb` becomes `SQLDB_URI`.

### SQL Server server resource

[Section titled “SQL Server server resource”](#sql-server-server-resource)

The SQL Server server resource exposes the following connection properties:

| Property Name          | Description                                                                                                                                                                                               |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Host`                 | The hostname or IP address of the SQL Server                                                                                                                                                              |
| `Port`                 | The port number the SQL Server is listening on                                                                                                                                                            |
| `Username`             | The username for authentication                                                                                                                                                                           |
| `Password`             | The password for authentication                                                                                                                                                                           |
| `Uri`                  | The connection URI in mssql:// format, with the format `mssql://{Username}:{Password}@{Host}:{Port}`                                                                                                      |
| `JdbcConnectionString` | JDBC-format connection string, with the format `jdbc:sqlserver://{Host}:{Port};trustServerCertificate=true`. User and password credentials are provided as separate `Username` and `Password` properties. |

**Example connection strings:**

```plaintext
Uri: mssql://sa:p%40ssw0rd1@localhost:1433
JdbcConnectionString: jdbc:sqlserver://localhost:1433;trustServerCertificate=true
```

### SQL Server database resource

[Section titled “SQL Server database resource”](#sql-server-database-resource)

The SQL Server database resource inherits all properties from its parent `SqlServerServerResource` and adds:

| Property Name          | Description                                                                                                                                                                                                                                       |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Uri`                  | The connection URI in mssql:// format, with the format `mssql://{Username}:{Password}@{Host}:{Port}/{DatabaseName}`                                                                                                                               |
| `JdbcConnectionString` | JDBC connection string with database name, with the format `jdbc:sqlserver://{Host}:{Port};trustServerCertificate=true;databaseName={DatabaseName}`. User and password credentials are provided as separate `Username` and `Password` properties. |
| `DatabaseName`         | The name of the database                                                                                                                                                                                                                          |

**Example connection strings:**

```plaintext
Uri: mssql://sa:p%40ssw0rd1@localhost:1433/catalog
JdbcConnectionString: jdbc:sqlserver://localhost:1433;trustServerCertificate=true;databaseName=catalog
```

## Configuration

[Section titled “Configuration”](#configuration)

The Aspire SQL Server integration provides multiple options to configure the connection based on the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling the `AddSqlServerClient` method:

C# — Program.cs

```csharp
builder.AddSqlServerClient(connectionName: "sql");
```

Then the connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "database": "Data Source=myserver;Initial Catalog=master"
  }
}
```

For more information on how to format this connection string, see the [ConnectionString](https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring#remarks).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire SQL Server integration supports `Microsoft.Extensions.Configuration`. It loads the `MicrosoftDataSqlClientSettings` from configuration by using the `Aspire:Microsoft:Data:SqlClient` key. The following snippet is an example of a `appsettings.json` file that configures some of the options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Microsoft": {
      "Data": {
        "SqlClient": {
          "ConnectionString": "YOUR_CONNECTIONSTRING",
          "DisableHealthChecks": false,
          "DisableMetrics": true
        }
      }
    }
  }
}
```

For the complete SQL Server client integration JSON schema, see [Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/main/src/Components/Aspire.Microsoft.Data.SqlClient/ConfigurationSchema.json).

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

Also you can pass the `Action<MicrosoftDataSqlClientSettings> configureSettings` delegate to set up some or all the options inline, for example to disable health checks from code:

C# — Program.cs

```csharp
builder.AddSqlServerClient(
    "database",
    static settings => settings.DisableHealthChecks = true);
```

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

The Aspire SQL Server integration:

* Adds the health check when `MicrosoftDataSqlClientSettings.DisableHealthChecks` is `false`, which attempts to connect to the SQL Server.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire SQL Server integration currently doesn’t enable logging by default due to limitations of the `SqlClient`.

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire SQL Server integration emits the following tracing activities using OpenTelemetry:

* `OpenTelemetry.Instrumentation.SqlClient`

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire SQL Server integration will emit the following metrics using OpenTelemetry:

* Microsoft.Data.SqlClient.EventSource

  * `active-hard-connections`
  * `hard-connects`
  * `hard-disconnects`
  * `active-soft-connects`
  * `soft-connects`
  * `soft-disconnects`
  * `number-of-non-pooled-connections`
  * `number-of-pooled-connections`
  * `number-of-active-connection-pool-groups`
  * `number-of-inactive-connection-pool-groups`
  * `number-of-active-connection-pools`
  * `number-of-inactive-connection-pools`
  * `number-of-active-connections`
  * `number-of-free-connections`
  * `number-of-stasis-connections`
  * `number-of-reclaimed-connections`

# SQL Server hosting extensions

⭐ Community Toolkit ![SQL Server logo](/_astro/sql-icon.CyVgV5Qd_Z1td4Jv.webp)

The Aspire Community Toolkit SQL Server hosting extensions package provides extra functionality to the [Aspire.Hosting.SqlServer](https://www.nuget.org/packages/Aspire.Hosting.SqlServer) hosting package.

This package provides the following features:

* [Adminer](https://adminer.org/) management UI
* [DbGate](https://dbgate.org/) management UI

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Community Toolkit SQL Server hosting extensions, install the [CommunityToolkit.Aspire.Hosting.SqlServer.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.SqlServer.Extensions) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.SqlServer.Extensions package

  ```bash
  aspire add communitytoolkit-sqlserver-extensions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-sqlserver-extensions (CommunityToolkit.Aspire.Hosting.SqlServer.Extensions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.SqlServer.Extensions@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.SqlServer.Extensions package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.SqlServer.Extensions" Version="*" />
  ```

## Add management UI

[Section titled “Add management UI”](#add-management-ui)

### DbGate management UI

[Section titled “DbGate management UI”](#dbgate-management-ui)

To add the DbGate management UI to your SQL Server resource, call the `WithDbGate` method on the `SqlServerResourceBuilder` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlserver = builder.AddSqlServer("sqlserver")
                       .WithDbGate();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(sqlserver);


// After adding all resources, run the app...
```

This adds a new DbGate resource to the app host which is available from the Aspire dashboard. DbGate is a comprehensive database management tool that provides a web-based interface for managing your SQL Server databases.

### Adminer management UI

[Section titled “Adminer management UI”](#adminer-management-ui)

To add the Adminer management UI to your SQL Server resource, call the `WithAdminer` method on the `SqlServerResourceBuilder` instance:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlserver = builder.AddSqlServer("sqlserver")
                       .WithAdminer();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(sqlserver);


// After adding all resources, run the app...
```

This adds a new Adminer resource to the app host which is available from the Aspire dashboard. Adminer is a lightweight database management tool that provides a simple web interface for database operations.

### Using both management UIs

[Section titled “Using both management UIs”](#using-both-management-uis)

You can use both management UIs together on the same SQL Server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlserver = builder.AddSqlServer("sqlserver")
                       .WithDbGate()
                       .WithAdminer();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(sqlserver);


// After adding all resources, run the app...
```

## See also

[Section titled “See also”](#see-also)

* [Adminer documentation](https://www.adminer.org/)
* [DbGate documentation](https://dbgate.org/)
* [SQL Server hosting integration](/integrations/databases/sql-server/sql-server-host/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Get started with the SQL Server integrations

> Learn how to set up the Aspire SQL Server Hosting and Client integrations simply.

![SQL Server logo](/_astro/sql-icon.CyVgV5Qd_Z1td4Jv.webp)

[SQL Server](https://www.microsoft.com/sql-server) is a relational database management system developed by Microsoft. The Aspire SQL Server integrations enable you to connect to existing SQL Server instances or create new instances from Aspire with the [`mcr.microsoft.com/mssql/server` container image](https://hub.docker.com/_/microsoft-mssql-server).

In this introduction, you’ll see how to install and use the Aspire SQL Server integrations in a simple configuration. If you already have this knowledge, see [SQL Server Hosting integration](../sql-server-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire SQL Server Hosting integration in your Aspire AppHost project. This integration allows you to create and manage SQL Server database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.SqlServer package

  ```bash
  aspire add sqlserver
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > sqlserver (Aspire.Hosting.SqlServer)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.SqlServer" Version="*" />
  ```

Next, in the AppHost project, create instances of SQL Server server and database resources, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql");
var sqldb = sql.AddDatabase("sqldb");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WaitFor(sqldb)
                            .WithReference(sqldb);
```

apphost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql");
var sqldb = sql.AddDatabase("sqldb");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WaitFor(sqldb)
                            .WithReference(sqldb);
```

AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql");
var sqldb = sql.AddDatabase("sqldb");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WaitFor(sqldb)
                 .WithReference(sqldb);
```

Tip

This is the simplest implementation of SQL Server resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [SQL Server Hosting integration](../sql-server-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire SQL Server client integration:

* .NET CLI

  .NET CLI — Add Aspire.Microsoft.Data.SqlClient package

  ```bash
  dotnet add package Aspire.Microsoft.Data.SqlClient
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Microsoft.Data.SqlClient@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Microsoft.Data.SqlClient package reference

  ```xml
  <PackageReference Include="Aspire.Microsoft.Data.SqlClient" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddSqlServerClient` extension method on any `IHostApplicationBuilder` to register a `SqlConnection` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqlServerClient(connectionName: "sqldb");
```

Tip

The `connectionName` parameter must match the name used when adding the SQL Server database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with SQL Server databases in your Python consuming projects, you need to include a SQL Server adapter library. A popular option is `pyodbc` (the Python ODBC database driver). You can install this library using pip:

```bash
pip install pyodbc
```

Ensure that you `import pyodbc` in code files that interact with the database. You should also import the `os` module to access environment variables:

Python - Import pyodbc

```python
import pyodbc
import os
```

Note

You may also need to install the Microsoft ODBC Driver for SQL Server. For instructions, see [Microsoft ODBC Driver for SQL Server](https://learn.microsoft.com/sql/connect/odbc/download-odbc-driver-for-sql-server).

To interact with SQL Server databases in your JavaScript consuming projects, you need to include a SQL Server client library. A popular option is `mssql` (the official SQL Server client for Node.js). You can install this library using npm:

```bash
npm install mssql
```

Ensure that you `import mssql` in code files that interact with the database:

JavaScript - Import mssql

```javascript
import sql from 'mssql';
```

### Use injected SQL Server properties

[Section titled “Use injected SQL Server properties”](#use-injected-sql-server-properties)

In the AppHost, when you used the `WithReference` method to pass a SQL Server server or database resource to a consuming client project, Aspire injects several configuration properties that you can use in the consuming project.

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `sqldb` becomes `SQLDB_URI`.

Use the `GetValue()` method to obtain these environment variables in consuming projects:

C# - Obtain configuration properties

```csharp
string hostname = builder.Configuration.GetValue<string>("SQLDB_HOST");
string port = builder.Configuration.GetValue<string>("SQLDB_PORT");
string jdbcconnectionstring = builder.Configuration.GetValue<string>("SQLDB_JDBCCONNECTIONSTRING");
string databasename = builder.Configuration.GetValue<string>("SQLDB_DATABASE");
```

Use the `os.getenv()` method to obtain these environment variables in consuming projects:

Python - Obtain configuration properties

```python
sql_host = os.getenv("SQLDB_HOST")
sql_port = os.getenv("SQLDB_PORT", "1433")
sql_user = os.getenv("SQLDB_USERNAME")
sql_password = os.getenv("SQLDB_PASSWORD")
sql_database = os.getenv("SQLDB_DATABASE", "sqldb")
```

Use the `process.env` method to obtain these environment variables in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const sqlHost = process.env.SQLDB_HOST;
const sqlPort = process.env.SQLDB_PORT;
const sqlUser = process.env.SQLDB_USERNAME;
const sqlPassword = process.env.SQLDB_PASSWORD;
const sqlDatabase = process.env.SQLDB_DATABASE;
```

Tip

The full set of properties that Aspire injects depends on whether you passed a server or database resource. For more information, see [Properties of the SQL Server resources](../sql-server-client/#properties-of-the-sql-server-resources).

### Use SQL Server resources in client code

[Section titled “Use SQL Server resources in client code”](#use-sql-server-resources-in-client-code)

Now that you’ve added `SqlConnection` to the builder in the consuming project, you can use the SQL Server resource to get and store data. Get the `SqlConnection` instance using dependency injection. For example, to retrieve your connection object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(SqlConnection connection)
{
    // Use connection to query the database...
}
```

Having obtained the connection, you can work with the SQL Server database as you would in any other C# application.

Use the information you have obtained about the SQL Server resource to connect to the database. Here is an example of how to connect using `pyodbc`:

Python - Connect to SQL Server

```python
connection_string = (
    "DRIVER={{ODBC Driver 18 for SQL Server}};"
    f"SERVER={sql_host},{sql_port};"
    f"DATABASE={sql_database};"
    f"UID={sql_user};"
    "PWD={sql_password};"
)


connection = pyodbc.connect(connection_string)
cursor = connection.cursor()
```

Having obtained the connection, you can work with the SQL Server database as you would in any other Python application.

Use the information you have obtained about the SQL Server resource to connect to the database. Here is an example of how to connect using `mssql`:

JavaScript - Connect to SQL Server

```javascript
const config = {
  server: sqlHost,
  port: parseInt(sqlPort),
  user: sqlUser,
  password: sqlPassword,
  database: sqlDatabase
};


const pool = await sql.connect(config);
```

Having obtained the connection, you can work with the SQL Server database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now that you have an Aspire app with SQL Server integrations up and running, you can use the following reference documents to learn how to configure and interact with the SQL Server resources:

[Understand the SQL Server hosting integration ](/integrations/databases/sql-server/sql-server-host/)Discover how to configure persistence, database scripts, and more.

[Understand the SQL Server client integration ](/integrations/databases/sql-server/sql-server-client/)Discover how to configure keyed clients, client integration health checks, and more.

[Understand the SQL Server community extensions ](/integrations/databases/sql-server/sql-server-extensions/)Discover how to add the DbGate management user interface, and more.

# SQL Server Hosting integration reference

> Learn how to use the Aspire SQL Server Hosting integration to create and manage SQL Server server and database resources in your Aspire projects.

![SQL Server logo](/_astro/sql-icon.CyVgV5Qd_Z1td4Jv.webp)

To get started with the Aspire SQL Server integrations, follow the [Get started with SQL Server integrations](/integrations/databases/sql-server/sql-server-get-started/) guide. If you want to use SQL Server with Entity Framework Core (EF Core) in your Aspire client project, see [Get started with the SQL Server EF Core integrations](/integrations/databases/efcore/sql-server/sql-server-get-started/).

This article includes full details about the Aspire SQL Server Hosting integration, which models the server as the `SqlServerServerResource` type and the database as the `SqlServerDatabaseResource` type. To access these types and APIs, you need to install the SQL Server Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire SQL Server hosting integration, install the [📦 Aspire.Hosting.SqlServer](https://www.nuget.org/packages/Aspire.Hosting.SqlServer) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.SqlServer package

  ```bash
  aspire add sqlserver
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > sqlserver (Aspire.Hosting.SqlServer)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.SqlServer@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.SqlServer package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.SqlServer" Version="*" />
  ```

## Add SQL Server resource and database resource

[Section titled “Add SQL Server resource and database resource”](#add-sql-server-resource-and-database-resource)

In your AppHost project, call `AddSqlServer` to add and return a SQL Server resource builder. Chain a call to the returned resource builder to `AddDatabase`, to add SQL Server database resource.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .WithLifetime(ContainerLifetime.Persistent);


var db = sql.AddDatabase("database");


builder.AddProject<Projects.ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

Note

The SQL Server container is slow to start, so it’s best to use a *persistent* lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

When Aspire adds a container image to the AppHost, as shown in the preceding example with the `mcr.microsoft.com/mssql/server` image, it creates a new SQL Server instance on your local machine. A reference to your SQL Server resource builder (the `sql` variable) is used to add a database. The database is named `database` and then added to the `ExampleProject`.

When adding a database resource to the app model, the database is created if it doesn’t already exist. The creation of the database relies on the [AppHost eventing APIs](/app-host/eventing/), specifically `ResourceReadyEvent`. In other words, when the `sql` resource is *ready*, the event is raised and the database resource is created.

The SQL Server resource includes default credentials with a `username` of `sa` and a random `password` generated using the `CreateDefaultPasswordParameter` method.

When the AppHost runs, the password is stored in the AppHost’s secret store. It’s added to the `Parameters` section, for example:

```json
{
  "Parameters:sql-password": "<THE_GENERATED_PASSWORD>"
}
```

The name of the parameter is `sql-password`, but really it’s just formatting the resource name with a `-password` suffix. For more information, see [Safe storage of app secrets in development in ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/app-secrets) and [Add SQL Server resource with parameters](#add-sql-server-resource-with-parameters).

The `WithReference` method configures a connection in the `ExampleProject` named `database`.

Tip

If you’d rather connect to an existing SQL Server, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

## Add SQL Server resource with database scripts

[Section titled “Add SQL Server resource with database scripts”](#add-sql-server-resource-with-database-scripts)

By default, when you add a `SqlServerDatabaseResource`, it relies on the following SQL script to create the database:

SQL — Default database creation script

```sql
IF
(
    NOT EXISTS
    (
        SELECT 1
        FROM sys.databases
        WHERE name = @DatabaseName
    )
)
CREATE DATABASE [<QUOTED_DATABASE_NAME>];
```

To alter the default script, chain a call to the `WithCreationScript` method on the database resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .WithLifetime(ContainerLifetime.Persistent);


var databaseName = "app-db";
var creationScript = $$"""
    IF DB_ID('{{databaseName}}') IS NULL
        CREATE DATABASE [{{databaseName}}];
    GO


    -- Use the database
    USE [{{databaseName}}];
    GO


    -- Create the todos table
    CREATE TABLE todos (
        id INT PRIMARY KEY IDENTITY(1,1),        -- Unique ID for each todo
        title VARCHAR(255) NOT NULL,             -- Short description of the task
        description TEXT,                        -- Optional detailed description
        is_completed BIT DEFAULT 0,              -- Completion status
        due_date DATE,                           -- Optional due date
        created_at DATETIME DEFAULT GETDATE()    -- Creation timestamp
    );
    GO


    """;


var db = sql.AddDatabase(databaseName)
            .WithCreationScript(creationScript);


builder.AddProject<Projects.AspireApp_ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding example creates a database named `app-db` with a single `todos` table. The SQL script is executed when the database resource is created. The script is passed as a string to the `WithCreationScript` method, which is then executed in the context of the SQL Server resource.

## Add SQL Server resource with data volume

[Section titled “Add SQL Server resource with data volume”](#add-sql-server-resource-with-data-volume)

To add a data volume to the SQL Server resource, call the `WithDataVolume` method on the SQL Server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .WithDataVolume();


var db = sql.AddDatabase("database");


builder.AddProject<Projects.AspireApp_ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

The data volume is used to persist the SQL Server data outside the lifecycle of its container. The data volume is mounted at the `/var/opt/mssql` path in the SQL Server container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-sql-server-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

Caution

The password is stored in the data volume. When using a data volume and if the password changes, it will not work until you delete the volume.

## Add SQL Server resource with data bind mount

[Section titled “Add SQL Server resource with data bind mount”](#add-sql-server-resource-with-data-bind-mount)

To add a data bind mount to the SQL Server resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .WithDataBindMount(source: @"C:\SqlServer\Data");


var db = sql.AddDatabase("database");


builder.AddProject<Projects.AspireApp_ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the SQL Server data across container restarts. The data bind mount is mounted at the `C:\SqlServer\Data` on Windows (or `/SqlServer/Data` on Unix) path on the host machine in the SQL Server container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

## Add SQL Server resource with parameters

[Section titled “Add SQL Server resource with parameters”](#add-sql-server-resource-with-parameters)

When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var password = builder.AddParameter("password", secret: true);


var sql = builder.AddSqlServer("sql", password);
var db = sql.AddDatabase("database");


builder.AddProject<Projects.AspireApp_ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

For more information on providing parameters, see [External parameters](/get-started/resources/).

## Use a specific SQL Server container image tag

[Section titled “Use a specific SQL Server container image tag”](#use-a-specific-sql-server-container-image-tag)

If you want to use a specific tag for the SQL Server container image, you can call the `WithImageTag` method to override the default tag. This is useful when you need to test against a specific version of SQL Server:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .WithImageTag("2025-RTM-ubuntu-24.04-preview");


var db = sql.AddDatabase("database");


builder.AddProject<Projects.AspireApp_ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

The preceding code uses the `2025-RTM-ubuntu-24.04-preview` tag for the SQL Server container image. For a list of available tags, see [SQL Server container image tags](https://mcr.microsoft.com/en-us/artifact/mar/mssql/server/tags).

## Connect to database resources

[Section titled “Connect to database resources”](#connect-to-database-resources)

When the Aspire AppHost runs, the server’s database resources can be accessed from external tools, such as [SQL Server Management Studio (SSMS)](https://learn.microsoft.com/sql/ssms/download-sql-server-management-studio-ssms) or [MSSQL for Visual Studio Code](https://learn.microsoft.com/sql/tools/visual-studio-code-extensions/mssql/mssql-extension-visual-studio-code). The connection string for the database resource is available in the dependent resources environment variables and is accessed using the [Aspire dashboard: Resource details](/dashboard/explore/#resource-details) pane. The environment variable is named `ConnectionStrings__{name}` where `{name}` is the name of the database resource, in this example it’s `database`. Use the connection string to connect to the database resource from external tools. Imagine that you have a database named `todos` with a single `dbo.Todos` table.

* SQL Server Management Studio

  To connect to the database resource from SQL Server Management Studio, follow these steps:

  1. Open SSMS.

  2. In the **Connect to Server** dialog, select the **Additional Connection Parameters** tab.

  3. Paste the connection string into the **Additional Connection Parameters** field and select **Connect**.

     ![SQL Server Management Studio: Connect to Server dialog.](/_astro/ssms-new-connection.CSTsse6X_Z1IxapS.webp)

  4. If you’re connected, you can see the database resource in the **Object Explorer**:

     ![SQL Server Management Studio: Connected to database.](/_astro/ssms-connected.B8KiRNdS_X0oLV.webp)

  For more information, see [SQL Server Management Studio: Connect to a server](https://learn.microsoft.com/sql/ssms/quickstarts/ssms-connect-query-sql-server).

* MSSQL for Visual Studio Code

  To connect to the database resource from MSSQL for Visual Studio Code, follow these steps:

  1. Open the **SQL SERVER** extension.

  2. Select the **Add Connection** option under **CONNECTIONS**.

     ![MSSQL for Visual Studio Code: Connections / add connection screen capture.](/_astro/mssql-vscode-add-connection.DzIZSgG0_Z1F8vXq.webp)

  3. Change the **Input type** to **Connection string** and paste the connection string into the **Connection string** field.

  4. Select **Connect**.

     ![MSSQL for Visual Studio Code: Connection string input details.](/_astro/mssql-vscode-connection-details.BmZrpkeF_zLnJW.webp)

  5. Once you’re connected, you can see the database resource in the active tab and run queries against it:

     ![MSSQL for Visual Studio Code: Connected to database.](/_astro/mssql-vscode-connected.DyrWoAuF_1NrJ9z.webp)

  For more information, see [MSSQL for Visual Studio Code](https://learn.microsoft.com/sql/tools/visual-studio-code-extensions/mssql/mssql-extension-visual-studio-code).

## Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The SQL Server hosting integration automatically adds a health check for the SQL Server resource. The health check verifies that the SQL Server is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.SqlServer](https://www.nuget.org/packages/AspNetCore.HealthChecks.SqlServer) NuGet package.

## Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

When you use the `WithReference` method to pass a SQL Server database resource to a non-.NET application (such as Python or JavaScript), Aspire automatically injects environment variables that describe the connection information. These environment variables follow the naming convention `[RESOURCE]_[PROPERTY]`, where `RESOURCE` is the uppercase name of the resource and `PROPERTY` is the name of the connection property.

For example, if you reference a SQL Server database resource named `sqldb`:

C# — AppHost.cs

```csharp
var sqldb = sql.AddDatabase("sqldb");


var pythonApp = builder.AddUvicornApp("api", "./api", "main:app")
    .WithReference(sqldb);
```

The following environment variables are available in the Python application:

* `SQLDB_HOST` - The hostname or IP address
* `SQLDB_PORT` - The port number
* `SQLDB_USERNAME` - The username for authentication
* `SQLDB_PASSWORD` - The password for authentication
* `SQLDB_DATABASE` - The database name
* `SQLDB_URI` - The full connection URI
* `SQLDB_JDBCCONNECTIONSTRING` - JDBC-format connection string

You can access these environment variables in your application code:

Python example

```python
import os
import pyodbc


sql_host = os.getenv("SQLDB_HOST")
sql_port = os.getenv("SQLDB_PORT", "1433")
sql_user = os.getenv("SQLDB_USERNAME")
sql_password = os.getenv("SQLDB_PASSWORD")
sql_database = os.getenv("SQLDB_DATABASE")


connection_string = (
    f"DRIVER={{ODBC Driver 18 for SQL Server}};"
    f"SERVER={sql_host},{sql_port};"
    f"DATABASE={sql_database};"
    f"UID={sql_user};"
    f"PWD={sql_password};"
)


connection = pyodbc.connect(connection_string)
```

JavaScript example

```javascript
import sql from 'mssql';


const config = {
  server: process.env.SQLDB_HOST,
  port: parseInt(process.env.SQLDB_PORT),
  user: process.env.SQLDB_USERNAME,
  password: process.env.SQLDB_PASSWORD,
  database: process.env.SQLDB_DATABASE
};


const pool = await sql.connect(config);
```

For the complete list of properties available, see [Properties of the SQL Server resources](../sql-server-client/#properties-of-the-sql-server-resources).

## Client integration

[Section titled “Client integration”](#client-integration)

To learn how to connect to and interact with SQL Server databases from your consuming projects, see [SQL Server Client integration](../sql-server-client/).

# SQLite Client integration reference

> Learn how to use the Aspire SQLite Client integration to query SQLite databases from your Aspire projects.

⭐ Community Toolkit ![SQLite logo](/_astro/sqlite-icon.5bKv4aj0_ZRG78f.webp)

To get started with the Aspire SQLite integrations, follow the [Get started with SQLite integrations](../sqlite-get-started/) guide.

This article includes full details about the Aspire SQLite Client integration, which allows you to connect to and interact with SQLite databases from your Aspire consuming projects.

## Installation

[Section titled “Installation”](#installation)

To get started with the Aspire SQLite client integration, install the [📦 CommunityToolkit.Aspire.Microsoft.Data.Sqlite](https://www.nuget.org/packages/CommunityToolkit.Aspire.Microsoft.Data.Sqlite) NuGet package in the client-consuming project, that is, the project for the application that uses the SQLite client. The SQLite client integration registers a [`SqliteConnection`](https://learn.microsoft.com/dotnet/api/microsoft.data.sqlite.sqliteconnection) instance that you can use to interact with SQLite.

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.Microsoft.Data.Sqlite package

  ```bash
  dotnet add package CommunityToolkit.Aspire.Microsoft.Data.Sqlite
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Microsoft.Data.Sqlite@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Microsoft.Data.Sqlite package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Microsoft.Data.Sqlite" Version="*" />
  ```

## Add SQLite client

[Section titled “Add SQLite client”](#add-sqlite-client)

In the `Program.cs` file of your client-consuming project, call the `AddSqliteConnection` extension method to register a `SqliteConnection` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqliteConnection(connectionName: "sqlite");
```

Tip

The `connectionName` parameter must match the name used when adding the SQLite resource in the AppHost project. For more information, see [Add SQLite resource](../sqlite-host/#add-sqlite-resource).

After adding `SqliteConnection` to the builder, you can get the `SqliteConnection` instance using dependency injection. For example, to retrieve your connection object from an example service define it as a constructor parameter:

C# — ExampleService.cs

```csharp
public class ExampleService(SqliteConnection connection)
{
    // Use connection...
}
```

For more information on dependency injection, see [.NET dependency injection](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection).

## Add keyed SQLite client

[Section titled “Add keyed SQLite client”](#add-keyed-sqlite-client)

There might be situations where you want to register multiple `SqliteConnection` instances with different connection names. To register keyed SQLite clients, call the `AddKeyedSqliteConnection` method:

C# — Program.cs

```csharp
builder.AddKeyedSqliteConnection(name: "chat");
builder.AddKeyedSqliteConnection(name: "queue");
```

Caution

Your consuming app can only obtain two keyed SQLite clients like this, if the AppHost project configures two SQLite resources or named databases, one for `chat` and one for `queue`.

Then you can retrieve the `SqliteConnection` instances using dependency injection:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] SqliteConnection chatConnection,
    [FromKeyedServices("queue")] SqliteConnection queueConnection)
{
    // Use connections...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

## Properties of the SQLite resources

[Section titled “Properties of the SQLite resources”](#properties-of-the-sqlite-resources)

When you use the `WithReference` method to pass a SQLite database resource from the AppHost project to a consuming client project, Aspire exposes the data source as an environment variable with a standardized naming convention:

| Property Name | Description                                             | Environment Variable Format   |
| ------------- | ------------------------------------------------------- | ----------------------------- |
| `DataSource`  | The data source path containing the database file path. | `C:\{Path}\{Databasefile}.db` |

Note

Aspire exposes the data source as an environment variable named `{ResourceName}_DATASOURCE`. For instance, a resource called `sqlite` would have its data source string available as `SQLITE_DATASOURCE`.

## Configuration

[Section titled “Configuration”](#configuration)

The SQLite client integration provides multiple options to configure the connection based on the requirements and conventions of your project.

### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling the `AddSqliteConnection` method:

C# — Program.cs

```csharp
builder.AddSqliteConnection("sqlite");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "sqlite": "Data Source=C:\\Database\\Location\\my-database.db"
  }
}
```

For more information on how to format this connection string, see [Microsoft.Data.Sqlite connection strings](https://learn.microsoft.com/dotnet/standard/data/sqlite/connection-strings).

### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The SQLite client integration supports `Microsoft.Extensions.Configuration`. It loads the settings from configuration using the `Aspire:Sqlite:Client` key. Example `appsettings.json` that configures some of the options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "Sqlite": {
      "Client": {
        "ConnectionString": "Data Source=C:\\Database\\Location\\my-database.db",
        "DisableHealthCheck": true
      }
    }
  }
}
```

### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<SqliteConnectionSettings>` delegate to set up some or all the options inline:

C# — Program.cs

```csharp
builder.AddSqliteConnection(
    "sqlite",
    static settings => settings.DisableHealthCheck = true);
```

## Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable [health checks](/fundamentals/health-checks/) for all services. For more information, see [Aspire integrations overview](/integrations/overview/).

The Aspire SQLite integration:

* Adds the health check when `SqliteConnectionSettings.DisableHealthCheck` is `false`, which attempts to open a connection to the SQLite database.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations may only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

### Logging

[Section titled “Logging”](#logging)

The Aspire SQLite integration uses standard .NET logging mechanisms for database operations.

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire SQLite integration will emit tracing activities for database operations using OpenTelemetry when configured.

### Metrics

[Section titled “Metrics”](#metrics)

The Aspire SQLite integration currently has limited metrics support compared to other database integrations due to the nature of SQLite as an embedded database engine.

# Get started with the SQLite integrations

> Learn how to set up the Aspire SQLite Hosting and Client integrations simply.

⭐ Community Toolkit ![SQLite logo](/_astro/sqlite-icon.5bKv4aj0_ZRG78f.webp)

[SQLite](https://www.sqlite.org/index.html) is a lightweight, serverless, self-contained SQL database engine that is widely used for local data storage in applications. The Aspire SQLite integration provides a way to use SQLite databases within your Aspire applications, and access them via the [`Microsoft.Data.Sqlite`](https://www.nuget.org/packages/Microsoft.Data.Sqlite) client.

In this introduction, you’ll see how to install and use the Aspire SQLite integrations in a simple configuration. If you already have this knowledge, see [SQLite Hosting integration](../sqlite-host/) for full reference details.

Note

To follow this guide, you must have created an Aspire solution to work with. To learn how to do that, see [Build your first Aspire app](../../../../get-started/first-app/).

## Set up hosting integration

[Section titled “Set up hosting integration”](#set-up-hosting-integration)

To begin, install the Aspire SQLite Hosting integration in your Aspire AppHost project. This integration allows you to create and manage SQLite database instances from your Aspire hosting projects:

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.SQLite package

  ```bash
  aspire add sqlite
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > sqlite (CommunityToolkit.Aspire.Hosting.SQLite)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.SQLite@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.SQLite package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.SQLite" Version="*" />
  ```

Next, in the AppHost project, create an instance of a SQLite database resource, then pass the database to the consuming client projects:

Select your programming language to get started

C#  Python  JavaScript

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("sqlite");


var exampleProject = builder.AddProject<Projects.ExampleProject>("apiservice")
                            .WithReference(sqlite);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("sqlite");


var exampleProject = builder.AddUvicornApp("api", "./api", "main:app")
                            .WithExternalHttpEndpoints()
                            .WithReference(sqlite);
```

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("sqlite");


var api = builder.AddNodeApp("api", "./api", scriptPath: "index.js")
                 .WithExternalHttpEndpoints()
                 .WithReference(sqlite);
```

Tip

This is the simplest implementation of SQLite resources in the AppHost. There are many more options you can choose from to address your requirements. For full details, see [SQLite Hosting integration](../sqlite-host/).

## Use the integration in client projects

[Section titled “Use the integration in client projects”](#use-the-integration-in-client-projects)

Now that the hosting integration is ready, the next step is to install and configure the client integration in any projects that need to use it.

### Set up client projects

[Section titled “Set up client projects”](#set-up-client-projects)

In each of these consuming client projects, install the Aspire SQLite client integration:

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.Microsoft.Data.Sqlite package

  ```bash
  dotnet add package CommunityToolkit.Aspire.Microsoft.Data.Sqlite
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Microsoft.Data.Sqlite@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Microsoft.Data.Sqlite package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Microsoft.Data.Sqlite" Version="*" />
  ```

In the `Program.cs` file of your client-consuming project, call the `AddSqliteConnection` extension method on any `IHostApplicationBuilder` to register a `SqliteConnection` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddSqliteConnection("sqlite");
```

Tip

The parameter must match the name used when adding the SQLite database resource in the AppHost project. For more information, see [Set up hosting integration](#set-up-hosting-integration).

To interact with SQLite databases in your Python consuming projects, you can use the built-in `sqlite3` module (included in Python’s standard library). No additional installation is required:

Python - Import sqlite3

```python
import sqlite3
import os
```

To interact with SQLite databases in your JavaScript consuming projects, you need to include a SQLite client library. A popular option is `sqlite3`. You can install this library using npm:

```bash
npm install sqlite3
```

Ensure that you `import sqlite3` in code files that interact with the database:

JavaScript - Import sqlite3

```javascript
import sqlite3 from 'sqlite3';
```

### Use injected SQLite properties

[Section titled “Use injected SQLite properties”](#use-injected-sqlite-properties)

In the AppHost, when you used the `WithReference` method to pass a SQLite database resource to a consuming client project, Aspire injects the data source configuration property that you can use in the consuming project.

Aspire exposes the property as an environment variable named `[RESOURCE]_DATASOURCE`. For instance, the data source of a resource called `sqlite` becomes `SQLITE_DATASOURCE`.

Use the `GetValue()` method to obtain this environment variable in consuming projects:

C# - Obtain configuration properties

```csharp
string sqldatasource = builder.Configuration.GetValue<string>("SQLITE_DATASOURCE");
```

Use the `os.getenv()` method to obtain this environment variable in consuming projects:

Python - Obtain configuration properties

```python
connection_string = os.getenv("SQLITE_DATASOURCE")
```

Use the `process.env` method to obtain this environment variable in consuming projects:

JavaScript - Obtain configuration properties

```javascript
const connectionString = process.env.SQLITE_DATASOURCE;
```

Tip

The full set of properties that Aspire injects depends on the SQLite resource configuration. For more information, see [Properties of the SQLite resources](../sqlite-client/#properties-of-the-sqlite-resources).

### Use SQLite resources in client code

[Section titled “Use SQLite resources in client code”](#use-sqlite-resources-in-client-code)

Now that you’ve added `SqliteConnection` to the builder in the consuming project, you can use the SQLite resource to get and store data. Get the `SqliteConnection` instance using dependency injection. For example, to retrieve your connection object from an example service define it as a constructor parameter and ensure the `ExampleService` class is registered with the dependency injection container:

C# — ExampleService.cs

```csharp
public class ExampleService(SqliteConnection connection)
{
    // Use connection to query the database...
}
```

Having obtained the connection, you can work with the SQLite database as you would in any other C# application.

Use the information you have obtained about the SQLite resource to connect to the database. Here is an example of how to connect using `sqlite3`:

Python - Connect to SQLite

```python
connection = sqlite3.connect(connection_string)
cursor = connection.cursor()
```

Having obtained the connection, you can work with the SQLite database as you would in any other Python application.

Use the information you have obtained about the SQLite resource to connect to the database. Here is an example of how to connect using `sqlite3`:

JavaScript - Connect to SQLite

```javascript
const db = new sqlite3.Database(connectionString);
```

Having obtained the connection, you can work with the SQLite database as you would in any other JavaScript application.

## Next steps

[Section titled “Next steps”](#next-steps)

Now, that you have an Aspire app with SQLite integrations up and running, you can use the following reference documents to learn how to configure and interact with the SQLite resources:

[Understand the SQLite hosting integration ](/integrations/databases/sqlite/sqlite-host/)Discover how to configure custom database locations, SQLiteWeb interface, and more.

[Understand the SQLite client integration ](/integrations/databases/sqlite/sqlite-client/)Discover how to configure keyed clients, client integration health checks, and more.

# SQLite Hosting integration reference

> Learn how to use the Aspire SQLite Hosting integration to create and manage SQLite database resources in your Aspire projects.

⭐ Community Toolkit ![SQLite logo](/_astro/sqlite-icon.5bKv4aj0_ZRG78f.webp)

To get started with the Aspire SQLite integrations, follow the [Get started with SQLite integrations](../sqlite-get-started/) guide.

This article includes full details about the Aspire SQLite Hosting integration, which models a SQLite database as the `SQLiteResource` type. To access these types and APIs, you need to install the SQLite Hosting integration in your AppHost project.

## Installation

[Section titled “Installation”](#installation)

The SQLite hosting integration models a SQLite database as the `SQLiteResource` type and will create the database file in the specified location. To get started with the Aspire SQLite hosting integration, install the [📦 CommunityToolkit.Aspire.Hosting.SQLite](https://nuget.org/packages/CommunityToolkit.Aspire.Hosting.SQLite) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.SQLite package

  ```bash
  aspire add communitytoolkit-sqlite
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-sqlite (CommunityToolkit.Aspire.Hosting.SQLite)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.SQLite@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.SQLite package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.SQLite" Version="*" />
  ```

## Add SQLite resource

[Section titled “Add SQLite resource”](#add-sqlite-resource)

In the AppHost project, register and consume the SQLite integration using the `AddSqlite` extension method to add the SQLite database to the application builder.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("my-database");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(sqlite);
```

When Aspire adds a SQLite database to the AppHost, as shown in the preceding example, it creates a new SQLite database file in the user’s temp directory.

Alternatively, if you want to specify a custom location for the SQLite database file, provide the relevant arguments to the `AddSqlite` method.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("my-database", "C:\\Database\\Location", "my-database.db");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(sqlite);
```

The preceding code creates a SQLite database file at `C:\Database\Location\my-database.db`. The database file is created if it doesn’t already exist.

## Add SQLiteWeb resource

[Section titled “Add SQLiteWeb resource”](#add-sqliteweb-resource)

When adding the SQLite resource, you can also add the SQLiteWeb resource, which provides a web interface to interact with the SQLite database. To do this, use the `WithSqliteWeb` extension method.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("my-database")
                    .WithSqliteWeb();


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(sqlite);
```

This code adds a container based on `ghcr.io/coleifer/sqlite-web` to the AppHost, which provides a web interface to interact with the SQLite database it is connected to. Each SQLiteWeb instance is connected to a single SQLite database, meaning that if you add multiple SQLiteWeb instances, there will be multiple SQLiteWeb containers.

When you run the solution, the Aspire dashboard displays the SQLiteWeb resource with an endpoint. Select the link to the endpoint to view SQLiteWeb in a new browser tab.

## Adding SQLite extensions

[Section titled “Adding SQLite extensions”](#adding-sqlite-extensions)

SQLite supports extensions that can be added to the SQLite database. Extensions can either be provided via a NuGet package, or via a location on disk. Use either the `WithNuGetExtension` or `WithLocalExtension` extension methods to add extensions to the SQLite database.

C# — AppHost.cs (NuGet extension)

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("my-database")
                    .WithNuGetExtension("SQLitePCLRaw.lib.e_sqlite3");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(sqlite);
```

C# — AppHost.cs (Local extension)

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqlite = builder.AddSqlite("my-database")
                    .WithLocalExtension("C:\\Extensions\\my-extension.dll");


var exampleProject = builder.AddProject<Projects.ExampleProject>()
                            .WithReference(sqlite);
```

Note

The SQLite extensions support is considered experimental and produces a `CTASPIRE002` warning.

## Using with non-.NET applications

[Section titled “Using with non-.NET applications”](#using-with-non-net-applications)

When you use the `WithReference` method to pass a SQLite database resource to a non-.NET application (such as Python or JavaScript), Aspire automatically injects environment variables that describe the connection information.

For example, if you reference a SQLite database resource named `sqlite`:

C# — AppHost.cs

```csharp
var sqlite = builder.AddSqlite("sqlite");


var pythonApp = builder.AddUvicornApp("api", "./api", "main:app")
    .WithReference(sqlite);
```

The following environment variable is available in the Python application:

* `SQLITE_DATASOURCE` - The connection string for the `sqlite` resource, containing the database file path

You can access this environment variable in your application code:

Python example

```python
import os
import sqlite3


connection_string = os.getenv("SQLITE_DATASOURCE")


connection = sqlite3.connect(connection_string)
cursor = connection.cursor()
```

JavaScript example

```javascript
import sqlite3 from 'sqlite3';


const connectionString = process.env.SQLITE_DATASOURCE;


const db = new sqlite3.Database(connectionString);
```

For the complete list of properties available, see [Properties of the SQLite resources](../sqlite-client/#properties-of-the-sqlite-resources).

# SurrealDB integration

> Learn how to use the SurrealDB hosting and client integration to run the SurrealDB container and access it via the SurrealDB client.

⭐ Community Toolkit ![SurrealDB logo](/_astro/surrealdb-icon.CLbq5g3b_1SR2yT.webp)

[SurrealDB](https://surrealdb.com) is a native, open-source, multi-model database that lets you store and manage data across relational, document, graph, time-series, vector & search, and geospatial models—all in one place. The Aspire SurrealDB integration enables you to connect to existing SurrealDB instances or create new instances from Aspire using the `docker.io/surrealdb/surrealdb` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To run the SurrealDB container, install the [📦 CommunityToolkit.Aspire.Hosting.SurrealDb](https://nuget.org/packages/CommunityToolkit.Aspire.Hosting.SurrealDb) NuGet package in the AppHost project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.SurrealDb package

  ```bash
  aspire add communitytoolkit-surrealdb
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-surrealdb (CommunityToolkit.Aspire.Hosting.SurrealDb)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.SurrealDb@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.SurrealDb package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.SurrealDb" Version="*" />
  ```

### Add SurrealDB resource

[Section titled “Add SurrealDB resource”](#add-surrealdb-resource)

In the AppHost project, register and consume the SurrealDB integration using the `AddSurrealServer` extension method to add the SurrealDB container to the application builder. Chain a call to the returned resource builder to `AddNamespace` and then `AddDatabase`, to add SurrealDB database resource.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddSurrealServer("surreal")
                .AddNamespace("ns")
                .AddDatabase("db");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...
```

The SurrealDB resource includes default credentials with a `username` of `root` and a random `password` generated using the `CreateDefaultPasswordParameter` method.

When the AppHost runs, the password is stored in the AppHost’s secret store. It’s added to the `Parameters` section, for example:

```json
{
  "Parameters:surreal-password": "<THE_GENERATED_PASSWORD>"
}
```

The name of the parameter is `surreal-password`, but really it’s just formatting the resource name with a `-password` suffix. For more information, see [Safe storage of app secrets in development in ASP.NET Core](https://learn.microsoft.com/aspnet/core/security/app-secrets) and [Add SurrealDB resource with parameters](#add-surrealdb-resource-with-parameters).

### Add Surrealist

[Section titled “Add Surrealist”](#add-surrealist)

To add [Surrealist](https://hub.docker.com/r/surrealdb/surrealist) to the SurrealDB server resource, call the `WithSurrealist` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var surreal = builder.AddSurrealServer("surreal")
                     .WithSurrealist();


var db = surreal
           .AddNamespace("ns")
           .AddDatabase("db");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(db)
       .WaitFor(db);
```

Surrealist is a user interface for interacting with your SurrealDB database visually. It enables you to seamlessly connect to any SurrealDB instance, allowing you to execute queries, explore your tables, design your schemas, etc..

For more information on providing parameters, see [External parameters](/get-started/resources/).

### Add SurrealDB resource with data bind mount

[Section titled “Add SurrealDB resource with data bind mount”](#add-surrealdb-resource-with-data-bind-mount)

To add a data bind mount to the SurrealDB resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddSurrealServer("surreal")
                .WithDataBindMount("./data/surreal/data")
                .AddNamespace("ns")
                .AddDatabase("db");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...
```

Data bind mounts rely on the host machine’s filesystem to persist the SurrealDB data across container restarts.

### Add SurrealDB resource with parameters

[Section titled “Add SurrealDB resource with parameters”](#add-surrealdb-resource-with-parameters)

When you want to explicitly provide the password used by the container image, you can provide these credentials as parameters. Consider the following alternative example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var password = builder.AddParameter("password", secret: true);


var db = builder.AddSurrealServer("surreal", password: password)
                .AddNamespace("ns")
                .AddDatabase("db");


builder.AddProject<Projects.AspireApp_ExampleProject>("exampleproject")
       .WithReference(db)
       .WaitFor(db);


// After adding all resources, run the app...


builder.Build().Run();
```

### Configure logging

[Section titled “Configure logging”](#configure-logging)

To configure logging for the SurrealDB container resource, call the `WithLogLevel` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var surreal = builder.AddSurrealServer("surreal")
                     .WithLogLevel(Microsoft.Extensions.Logging.LogLevel.Debug);


var db = surreal
           .AddNamespace("ns")
           .AddDatabase("db");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(db);


// After adding all resources, run the app...
```

The `WithLogLevel` method enables logging in the SurrealDB container.

### Health checks

[Section titled “Health checks”](#health-checks)

The SurrealDB hosting integration automatically adds a health check for the SurrealDB namespace and database resources. The health check verifies that a SurrealDB component is running and that a connection can be established to it.

The hosting integration uses a custom `SurrealDbHealthCheck` that uses both the `/health` endpoint and a simple raw query to perform health checks.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire SurrealDB client integration, install the [📦 CommunityToolkit.Aspire.SurrealDb](https://nuget.org/packages/CommunityToolkit.Aspire.SurrealDb) NuGet package in the client-consuming project.

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.SurrealDb package

  ```bash
  dotnet add package CommunityToolkit.Aspire.SurrealDb
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.SurrealDb@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.SurrealDb package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.SurrealDb" Version="*" />
  ```

### Add SurrealDB client

[Section titled “Add SurrealDB client”](#add-surrealdb-client)

In the `Program.cs` file of your client-consuming project, call the `AddSurrealClient` extension method to register a `SurrealDbClient` for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddSurrealClient(connectionName: "db");
```

Tip

The `connectionName` parameter must match the name used when adding the SurrealDB resource in the AppHost project.

You can then retrieve the `SurrealDbClient` instance using dependency injection:

```csharp
public class ExampleService(SurrealDbClient client)
{
    // Use client...
}
```

### Add keyed SurrealDB client

[Section titled “Add keyed SurrealDB client”](#add-keyed-surrealdb-client)

There might be situations where you want to register multiple `SurrealDbClient` instances with different connection names. To register keyed SurrealDB clients, call the `AddKeyedSurrealClient` method:

```csharp
builder.AddKeyedSurrealClient(name: "products");
builder.AddKeyedSurrealClient(name: "orders");
```

Then you can retrieve the `SurrealDbClient` instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("products")] SurrealDbClient productsClient,
    [FromKeyedServices("orders")] SurrealDbClient ordersClient)
{
    // Use clients...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire SurrealDB client integration provides multiple options to configure the server connection.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name of the connection string:

```csharp
builder.AddSurrealClient(connectionName: "db");
```

Then the connection string will be retrieved from the `ConnectionStrings` configuration section:

```json
{
  "ConnectionStrings": {
    "db": "Endpoint=ws://localhost:19530/;Namespace=ns;Database=db;Username=root;Password=123456!@#$%"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire Surreal Client integration supports configuration. It loads the settings from configuration using the `Aspire:Surreal:Client` key:

```json
{
  "Aspire": {
    "Surreal": {
      "Client": {
        "Endpoint": "ws://localhost:19530/",
        "Namespace": "ns",
        "Database": "db",
        "Username": "root",
        "Password": "123456!@#$%"
      }
    }
  }
}
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

The Aspire SurrealDB integration uses the configured client to perform a health check.

## See also

[Section titled “See also”](#see-also)

* [SurrealDB](https://surrealdb.com)
* [SurrealDB documentation](https://surrealdb.com/docs/surrealdb)
* [.NET SDK for SurrealDB](https://github.com/surrealdb/surrealdb.net)
* [Aspire Community Toolkit GitHub repo](https://github.com/CommunityToolkit/Aspire)

# Data API builder integration

> Learn how to use Data API builder with Aspire.

⭐ Community Toolkit ![Data API builder logo](/_astro/data-api-builder-icon.DhVUjYqn_hTmYg.webp)

[Data API Builder](https://learn.microsoft.com/azure/data-api-builder/overview) (DAB) is an open-source tool that provides a REST and GraphQL API on top of your database. The Aspire Data API Builder hosting integration enables you to run Data API Builder alongside your .NET projects in the Aspire app host.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Data API Builder hosting integration, install the [CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder package

  ```bash
  aspire add communitytoolkit-azure-dataapibuilder
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-azure-dataapibuilder (CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder" Version="*" />
  ```

### Add Data API Builder resource

[Section titled “Add Data API Builder resource”](#add-data-api-builder-resource)

To add Data API Builder to your app host, use the `AddDataAPIBuilder` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sqldb = builder.AddSqlServer("sql")
                   .AddDatabase("sqldb");


var dab = builder.AddDataAPIBuilder("dab")
                 .WithReference(sqldb);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(dab);


// After adding all resources, run the app...
```

The Data API Builder integration automatically discovers and uses `dab-config.json` configuration files in your project.

### Multiple configuration files

[Section titled “Multiple configuration files”](#multiple-configuration-files)

Data API Builder supports multiple configuration files for different databases. To specify multiple configuration files:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .AddDatabase("sqldb");


var postgres = builder.AddPostgres("postgres")
                      .AddDatabase("postgresdb");


var dab = builder.AddDataAPIBuilder("dab", ["dab-config.SqlServer.json", "dab-config.PostgreSQL.json"])
                 .WithReference(sql)
                 .WithReference(postgres);


// After adding all resources, run the app...
```

### Custom container images

[Section titled “Custom container images”](#custom-container-images)

To use a custom Data API Builder container image, use the container image methods:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var dab = builder.AddDataAPIBuilder("dab")
                 .WithImageRegistry("myregistry.azurecr.io")
                 .WithImage("custom-dab")
                 .WithImageTag("1.0.0");


// After adding all resources, run the app...
```

### Database references

[Section titled “Database references”](#database-references)

Data API Builder requires references to the databases it exposes. Use `WithReference` to connect Data API Builder to your databases:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .AddDatabase("sqldb");


var cosmos = builder.AddAzureCosmosDB("cosmos")
                    .AddDatabase("cosmosdb");


var dab = builder.AddDataAPIBuilder("dab")
                 .WithReference(sql)
                 .WithReference(cosmos);


// After adding all resources, run the app...
```

### Configuration file structure

[Section titled “Configuration file structure”](#configuration-file-structure)

Data API Builder uses `dab-config.json` files to define the API. Here’s an example configuration:

```json
{
  "$schema": "https://github.com/Azure/data-api-builder/releases/download/v0.10.23/dab.draft.schema.json",
  "data-source": {
    "database-type": "mssql",
    "connection-string": "@env('DATABASE_CONNECTION_STRING')"
  },
  "runtime": {
    "rest": {
      "enabled": true,
      "path": "/api"
    },
    "graphql": {
      "enabled": true,
      "path": "/graphql"
    }
  },
  "entities": {
    "Product": {
      "source": "dbo.Products",
      "permissions": [
        {
          "role": "anonymous",
          "actions": ["read"]
        }
      ]
    }
  }
}
```

The Aspire integration automatically injects the database connection strings from the referenced resources.

### Endpoints

[Section titled “Endpoints”](#endpoints)

Data API Builder exposes two endpoints:

* **REST API**: Available at `/api` by default
* **GraphQL API**: Available at `/graphql` by default

Both endpoints are configured in the `dab-config.json` file.

## See also

[Section titled “See also”](#see-also)

* [Data API Builder documentation](https://learn.microsoft.com/azure/data-api-builder/)
* [Data API Builder GitHub repository](https://github.com/Azure/data-api-builder)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Dev Tunnels integration

> Learn how to use the Dev Tunnels integration for exposing local web services to the internet.

![Dev Tunnels logo](/_astro/dev-tunnels-icon.Bn_RqgUr_Z1k8iGn.svg)

[Dev tunnels](https://learn.microsoft.com/azure/developer/dev-tunnels/overview) allow developers to securely share local web services across the internet. Enabling you to connect your local development environment with cloud services, share work in progress with colleagues or aid in building webhooks. Dev tunnels is for adhoc testing and development, not for production workloads.

Danger

Dev tunnels are for ad-hoc testing and development, not for production workloads.

Dev tunnels are useful for:

* Sharing a running local service (for example, a Web API) with teammates, mobile devices, or webhooks
* Testing incoming callbacks from external SaaS systems (GitHub / Stripe / etc.) without deploying
* Quickly publishing a temporary, TLS-terminated endpoint during development

Note

By default tunnels require authentication and are available only to the user who created them. You can selectively enable anonymous (public) access per tunnel or per individual port.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

Before you create a dev tunnel, you first need to download and install the devtunnel CLI (Command Line Interface) tool that corresponds to your operating system. See the [devtunnel CLI installation documentation](https://learn.microsoft.com/azure/developer/dev-tunnels/get-started#install) for more details.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Dev Tunnels integration, install the [📦 Aspire.Hosting.DevTunnels](https://www.nuget.org/packages/Aspire.Hosting.DevTunnels) NuGet package in the AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.DevTunnels package

  ```bash
  aspire add devtunnels
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > devtunnels (Aspire.Hosting.DevTunnels)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.DevTunnels@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.DevTunnels package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.DevTunnels" Version="*" />
  ```

### Add a dev tunnel resource

[Section titled “Add a dev tunnel resource”](#add-a-dev-tunnel-resource)

In the AppHost project, add a dev tunnel and configure it to expose specific resources:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var web = builder.AddProject<Projects.Web>("web");


var tunnel = builder.AddDevTunnel("my-tunnel")
                    .WithReference(web);
```

When you run the AppHost, the dev tunnel is created to expose the web application endpoints publicly. The tunnel URLs are shown in the Aspire dashboard. By default, the tunnel requires authentication and is available only to the user who created it.

### Allow anonymous access

[Section titled “Allow anonymous access”](#allow-anonymous-access)

To allow anonymous (public) access to the entire tunnel, chain a call to the `WithAnonymousAccess` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var web = builder.AddProject<Projects.Web>("web");


var tunnel = builder.AddDevTunnel("public-api")
                    .WithReference(web)
                    .WithAnonymousAccess();
```

### Configure dev tunnel options

[Section titled “Configure dev tunnel options”](#configure-dev-tunnel-options)

To configure other options for the dev tunnel, provide the `DevTunnelOptions` to the `AddDevTunnel` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var web = builder.AddProject<Projects.Web>("web");


var options = new DevTunnelOptions
{
    TunnelId = "my-tunnel-id",
    Description = "QA environment tunnel",
    Labels = new[] { "qa", "testing" },
    AllowAnonymous = false
};


var tunnel = builder.AddDevTunnel("qa", options)
                    .WithReference(web);
```

### Configure for mixed access

[Section titled “Configure for mixed access”](#configure-for-mixed-access)

To allow anonymous access to specific endpoints, use the appropriate `WithReference` overload:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api");


var tunnel = builder.AddDevTunnel("mixed-access")
                    .WithReference(api, "public", allowAnonymous: true)
                    .WithReference(api, "admin", allowAnonymous: false);
```

The preceding code exposes:

* The `public` endpoint of the `api` project with anonymous access
* The `admin` endpoint of the `api` project that requires authentication

### Service discovery integration

[Section titled “Service discovery integration”](#service-discovery-integration)

When another resource references a dev tunnel, environment variables are injected using the Aspire service discovery configuration format:

```dotenv
WEB_HTTPS=https://myweb-1234.westeurope.devtunnels.ms/
services__web__https__0=https://myweb-1234.westeurope.devtunnels.ms/
```

This lets downstream resources use the tunneled address exactly like any other Aspire service discovery entry.

Note

Referencing a tunnel delays the consumer resource’s start until the tunnel has started and its endpoint is fully allocated.

Danger

Dev tunnels are a development time concern only and aren’t included when publishing or deploying an AppHost, including any service discovery information.

## Configuration

[Section titled “Configuration”](#configuration)

### Dev tunnel options

[Section titled “Dev tunnel options”](#dev-tunnel-options)

The `DevTunnelOptions` class provides several configuration options:

| Property         | Description                                                            |
| ---------------- | ---------------------------------------------------------------------- |
| `Description`    | A description for the tunnel that appears in the dev tunnels service   |
| `Labels`         | A list of labels to apply to the tunnel for organization and filtering |
| `AllowAnonymous` | Whether to allow anonymous access to the entire tunnel                 |

### Dev tunnel port options

[Section titled “Dev tunnel port options”](#dev-tunnel-port-options)

The `DevTunnelPortOptions` class provides configuration for individual tunnel ports:

| Property         | Description                                                                                    |
| ---------------- | ---------------------------------------------------------------------------------------------- |
| `Protocol`       | The protocol to use (`http`, `https`, or `auto`). If not specified, uses the endpoint’s scheme |
| `Description`    | A description for this specific port                                                           |
| `Labels`         | Labels to apply to this port                                                                   |
| `AllowAnonymous` | Whether to allow anonymous access to this specific port                                        |

### Security considerations

[Section titled “Security considerations”](#security-considerations)

* Prefer authenticated tunnels during normal development
* Only enable anonymous access for endpoints that are safe to expose publicly
* Treat public tunnel URLs as temporary & untrusted (rate limit / validate input server-side)

### Tunnel lifecycle

[Section titled “Tunnel lifecycle”](#tunnel-lifecycle)

Dev tunnels automatically:

* Install the devtunnel CLI if not already available
* Ensure the user is logged in to the dev tunnels service
* Create and manage tunnel lifecycle
* Clean up unmodeled ports from previous runs
* Provide detailed logging and diagnostics

Tunnels will expire after not being hosted for 30 days by default, so they won’t be forcibly deleted when the resource or AppHost is stopped.

### Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

#### Authentication required

[Section titled “Authentication required”](#authentication-required)

If you see authentication errors, ensure you’re logged in to the dev tunnels service:

```bash
devtunnel user login
```

#### Port conflicts

[Section titled “Port conflicts”](#port-conflicts)

If you encounter port binding issues, check that no other processes are using the same ports, or configure different ports for your endpoints.

#### Tunnel not accessible

[Section titled “Tunnel not accessible”](#tunnel-not-accessible)

Verify that:

* The tunnel is running and healthy in the Aspire dashboard
* You’re using the correct tunnel URL
* Anonymous access is configured correctly if accessing without authentication

# flagd integration

⭐ Community Toolkit ![flagd logo](/_astro/flagd-icon.BEqgEdwX.svg)

[flagd](https://flagd.dev) is a feature flag evaluation engine that provides an OpenFeature-compliant backend system for managing and evaluating feature flags in real-time. The Aspire flagd integration enables you to create new container instances from Aspire with the `ghcr.io/open-feature/flagd` container image.

flagd is designed to be a flexible, open-source feature flag evaluation engine. It enables real-time flag modifications, supports various flag types (boolean, string, number, JSON), uses context-sensitive rules for targeting, and performs pseudorandom assignments for experimentation. You can aggregate flag definitions from multiple sources and expose them through gRPC or OFREP services.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire flagd hosting integration, install the [CommunityToolkit.Aspire.Hosting.Flagd](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Flagd) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Flagd package

  ```bash
  aspire add communitytoolkit-flagd
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-flagd (CommunityToolkit.Aspire.Hosting.Flagd)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Flagd@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Flagd package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Flagd" Version="*" />
  ```

### Add flagd server resource

[Section titled “Add flagd server resource”](#add-flagd-server-resource)

In your app host project, call `AddFlagd` on the builder instance to add a flagd container resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var flagd = builder.AddFlagd("flagd")
                   .WithBindFileSync("./flags/");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(flagd);


// After adding all resources, run the app...
```

When Aspire adds a container image to the app host, as shown in the preceding example with the `ghcr.io/open-feature/flagd` image, it creates a new flagd server instance on your local machine. A reference to your flagd server (the `flagd` variable) is added to the `ExampleProject`.

Caution

The flagd container requires a sync source to be configured. Use the `WithBindFileSync` method to configure file-based flag synchronization.

### Add flagd server resource with bind mount

[Section titled “Add flagd server resource with bind mount”](#add-flagd-server-resource-with-bind-mount)

To add a bind mount to the flagd container resource, call the `WithBindFileSync` method on the flagd container resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var flagd = builder.AddFlagd("flagd")
                   .WithBindFileSync(
                       fileSource: "./flags/",
                       filename: "flagd.json");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(flagd);


// After adding all resources, run the app...
```

The bind mount is used to provide flagd with access to your flag configuration files. The `fileSource` parameter specifies the path on your host machine where the flag configuration file is located, and the `filename` parameter specifies the name of the flag configuration file. The default filename is `flagd.json`.

### Flag configuration format

[Section titled “Flag configuration format”](#flag-configuration-format)

flagd uses JSON files for flag definitions. Create a folder named `flags` in your project root and place your flag configuration file inside it. By default, the filename is `flagd.json`, but you can specify a different filename using the `filename` parameter in `WithBindFileSync`.

Here’s a simple example:

```json
{
    "$schema": "https://flagd.dev/schema/v0/flags.json",
    "flags": {
        "welcome-banner": {
            "state": "ENABLED",
            "variants": {
                "on": true,
                "off": false
            },
            "defaultVariant": "off"
        },
        "background-color": {
            "state": "ENABLED",
            "variants": {
                "red": "#FF0000",
                "blue": "#0000FF",
                "yellow": "#FFFF00"
            },
            "defaultVariant": "red"
        }
    }
}
```

For more information on flag configuration, see the [flagd flag definitions documentation](https://flagd.dev/reference/flag-definitions/).

### Configure logging

[Section titled “Configure logging”](#configure-logging)

To configure debug logging for the flagd container resource, call the `WithLogLevel` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var flagd = builder.AddFlagd("flagd")
                   .WithBindFileSync("./flags/")
                   .WithLogLevel(Microsoft.Extensions.Logging.LogLevel.Debug);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(flagd);


// After adding all resources, run the app...
```

The `WithLogLevel` method enables debug logging in the flagd container, which provides verbose output for troubleshooting flag evaluation issues. Currently, only `Debug` log level is supported.

### Customize ports

[Section titled “Customize ports”](#customize-ports)

To customize the ports used by the flagd container resource, provide the `port` and `ofrepPort` parameters to the `AddFlagd` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var flagd = builder.AddFlagd(
    name: "flagd",
    port: 8013,
    ofrepPort: 8016)
    .WithBindFileSync("./flags/");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(flagd);


// After adding all resources, run the app...
```

The `port` parameter specifies the host port for the flagd HTTP endpoint, and the `ofrepPort` parameter specifies the host port for the OFREP (OpenFeature Remote Evaluation Protocol) endpoint. If these parameters aren’t provided, random ports are assigned.

### Health checks

[Section titled “Health checks”](#health-checks)

The flagd hosting integration automatically adds a health check for the flagd server resource. The health check verifies that the flagd server is running and that a connection can be established to it.

The hosting integration uses the flagd `/healthz` endpoint to perform health checks.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire flagd client integration, install an OpenFeature provider for .NET. The most common provider for flagd is the [OpenFeature.Contrib.Providers.Flagd](https://www.nuget.org/packages/OpenFeature.Contrib.Providers.Flagd) NuGet package in the client-consuming project:

```powershell
dotnet add package OpenFeature.Contrib.Providers.Flagd
```

### Add flagd client

[Section titled “Add flagd client”](#add-flagd-client)

In the `Program.cs` file of your client-consuming project, configure the OpenFeature SDK to use the flagd provider:

```csharp
using OpenFeature;
using OpenFeature.Contrib.Providers.Flagd;


var connectionString = builder.Configuration.GetConnectionString("flagd");


await OpenFeature.Api.Instance.SetProviderAsync(
    new FlagdProvider(new Uri(connectionString)));


var flagClient = OpenFeature.Api.Instance.GetClient();
```

You can then use the `flagClient` to evaluate feature flags:

```csharp
var welcomeBanner = await flagClient.GetBooleanValueAsync(
    "welcome-banner",
    defaultValue: false);


var backgroundColor = await flagClient.GetStringValueAsync(
    "background-color",
    defaultValue: "#000000");
```

For more information on the OpenFeature SDK and flagd provider, see the [OpenFeature .NET documentation](https://openfeature.dev/docs/reference/technologies/client/dotnet/) and the [flagd provider documentation](https://flagd.dev/providers/dotnet/).

### Configuration

[Section titled “Configuration”](#configuration)

The flagd client integration uses the connection string from the `ConnectionStrings` configuration section. The connection string is automatically provided when you reference the flagd resource in your app host project using `WithReference`.

The connection string format is:

```plaintext
http://localhost:<port>
```

Where `<port>` is the port assigned to the flagd HTTP endpoint.

## See also

[Section titled “See also”](#see-also)

* [flagd documentation](https://flagd.dev)
* [OpenFeature documentation](https://openfeature.dev)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# GO Feature Flag integration

⭐ Community Toolkit ![goff logo](/_astro/go-feature-flag.UXez91CJ.png)

Feature flags lets you modify system behavior without changing code. Deploy every day, release when you are ready. Reduce risk by releasing your features progressively.

* [GO Feature Flag](https://gofeatureflag.org/) believes in simplicity and offers a simple and lightweight solution to use feature flags.
* Target individual segments, users, and development environments, use advanced rollout functionality.
* 100% Opensource, no vendor locking, supports your favorite languages and is pushing for standardisation with the support of OpenFeature.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire GO Feature Flag hosting integration, install the [CommunityToolkit.Aspire.Hosting.GoFeatureFlag](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.GoFeatureFlag) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.GoFeatureFlag package

  ```bash
  aspire add communitytoolkit-gofeatureflag
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-gofeatureflag (CommunityToolkit.Aspire.Hosting.GoFeatureFlag)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.GoFeatureFlag@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.GoFeatureFlag package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.GoFeatureFlag" Version="*" />
  ```

### Add goff server resource

[Section titled “Add goff server resource”](#add-goff-server-resource)

In your app host project, call `AddGoFeatureFlag` on the builder instance to add a goff container resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var goff = builder.AddGoFeatureFlag("goff")
                  .WithGoffBindMount("./goff");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(goff);


// After adding all resources, run the app...
```

When Aspire adds a container image to the app host, as shown in the preceding example with the `docker.io/gofeatureflag/go-feature-flag` image, it creates a new goff server instance on your local machine. A reference to your goff server (the `goff` variable) is added to the `ExampleProject`.

Caution

The goff container requires a folder source with configuration files. Use the `WithGoffBindMount` method to configure file-based flag synchronization.

### Flag configuration format

[Section titled “Flag configuration format”](#flag-configuration-format)

goff uses either the `YAML`, `JSON` or `TOML` format to configure feature flags. Here is a simple example for you to get started:

goff/flags.yaml

```yaml
display-banner:
  variations:
    enabled: true
    disabled: false
  defaultRule:
    variation: enabled
```

You can learn more on how to create flags here: [Create flags with goff](https://gofeatureflag.org/docs/configure_flag/create-flags).

### Flag configuration

[Section titled “Flag configuration”](#flag-configuration)

In the previous section, we created flags via a configuration file. We now need another file to configure the Relay Proxy that will load your flags from the file system. Here is what you need to ingest the previous created file:

goff/goff-proxy.yaml

```yaml
retrievers:
  - kind: file
    path: /goff/flags.yaml
```

### Configure logging

[Section titled “Configure logging”](#configure-logging)

To configure debug logging for the goff container resource, call the `WithLogLevel` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var goff = builder.AddGoFeatureFlag("goff")
                  .WithGoffBindMount("./goff");
                  .WithLogLevel(Microsoft.Extensions.Logging.LogLevel.Debug);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(goff);


// After adding all resources, run the app...
```

The `WithLogLevel` method enables debug logging in the goff container, which provides verbose output for troubleshooting flag evaluation issues. Currently, only `Debug`, `Information`, `Warning` and `Error` log levels are supported.

### Customize ports

[Section titled “Customize ports”](#customize-ports)

To customize the port used by the goff container resource, provide the `port` parameter to the `AddGoFeatureFlag` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var goff = builder.AddGoFeatureFlag(name: "goff", port: 1031)
                  .WithGoffBindMount("./goff");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(goff);


// After adding all resources, run the app...
```

The `port` parameter specifies the host port for the goff HTTP endpoint. If this parameter is not provided, a random port is assigned.

### Health checks

[Section titled “Health checks”](#health-checks)

The goff hosting integration automatically adds a health check for the goff server resource. The health check verifies that the goff server is running and that a connection can be established to it.

The hosting integration uses the goff `/health` endpoint to perform health checks.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire goff client integration, install the [📦 CommunityToolkit.Aspire.GoFeatureFlag](https://nuget.org/packages/CommunityToolkit.Aspire.GoFeatureFlag) NuGet package in the client-consuming project.

* .NET CLI

  .NET CLI — Add CommunityToolkit.Aspire.GoFeatureFlag package

  ```bash
  dotnet add package CommunityToolkit.Aspire.GoFeatureFlag
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package CommunityToolkit.Aspire.GoFeatureFlag@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.GoFeatureFlag package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.GoFeatureFlag" Version="*" />
  ```

### Add GO Feature Flag client

[Section titled “Add GO Feature Flag client”](#add-go-feature-flag-client)

In the `Program.cs` file of your client-consuming project, call the `AddGoFeatureFlagClient` extension method to register a `GoFeatureFlagProvider` for use via the dependency injection container. The method takes a connection name parameter.

```csharp
builder.AddGoFeatureFlagClient(connectionName: "goff");
```

Tip

The `connectionName` parameter must match the name used when adding the goff resource in the AppHost project.

You can then retrieve the `GoFeatureFlagProvider` instance using dependency injection:

```csharp
public class ExampleService(GoFeatureFlagProvider provider)
{
    // Use provider...
}
```

### Add keyed GO Feature Flag client

[Section titled “Add keyed GO Feature Flag client”](#add-keyed-go-feature-flag-client)

There might be situations where you want to register multiple `GoFeatureFlagProvider` instances with different connection names. To register keyed goff clients, call the `AddKeyedGoFeatureFlagClient` method:

```csharp
builder.AddKeyedGoFeatureFlagClient(name: "technical");
builder.AddKeyedGoFeatureFlagClient(name: "business");
```

Then you can retrieve the `GoFeatureFlagProvider` instances using dependency injection:

```csharp
public class ExampleService(
    [FromKeyedServices("technical")] GoFeatureFlagProvider technicalProvider,
    [FromKeyedServices("business")] GoFeatureFlagProvider businessProvider)
{
    // Use providers...
}
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

The Aspire goff integration uses the configured client to perform a health check.

## See also

[Section titled “See also”](#see-also)

* [GO Feature Flag documentation](https://gofeatureflag.org/)
* [.NET SDK for GO Feature Flag](https://github.com/open-feature/dotnet-sdk-contrib/tree/main/src/OpenFeature.Providers.GOFeatureFlag)
* [OpenFeature documentation](https://openfeature.dev)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)

# k6 integration

⭐ Community Toolkit ![k6 logo](/_astro/k6-icon.DPd0lzLv.svg)

[Grafana k6](https://k6.io/) is a performance & load testing tool. The Aspire k6 integration enables you to create new container instances from Aspire with the `docker.io/grafana/k6` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire k6 hosting integration, install the [CommunityToolkit.Aspire.Hosting.k6](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.k6) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.k6 package

  ```bash
  aspire add communitytoolkit-k6
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-k6 (CommunityToolkit.Aspire.Hosting.k6)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.k6@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.k6 package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.k6" Version="*" />
  ```

### Add k6 server resource

[Section titled “Add k6 server resource”](#add-k6-server-resource)

In your app host project, call `AddK6` on the builder instance to add a flagd container resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var myService = builder.AddProject<Projects.MyService>();


var k6 = builder.AddK6("k6")
                .WithBindMount("scripts", "/scripts", true)
                .WithScript("/scripts/main.js")
                .WithReference(myService)
                .WaitFor(apiservice);


// After adding all resources, run the app...
```

When Aspire adds a container image to the app host, as shown in the preceding example with the `docker.io/grafana/k6` image, it creates a new k6 instance on your local machine. You may need to add a reference to your k6 instance in order to test this resource.

Caution

The k6 container requires a JavaScript entrypoint to run successfully. Use the `WithBindMount` method to configure a source for your scripts and the `WithScript` to configure the JavaScript entrypoint.

## Scripts configuration

[Section titled “Scripts configuration”](#scripts-configuration)

You will need to add a JavaScript file that will be executed by k6. Here is a simple example:

scripts/main.js

```js
import http from "k6/http";
import { sleep } from "k6";


export default function () {
    http.get(`${__ENV.services__myService__http__0}/hello`);


    sleep(1);
}
```

The `services__myService__http__0` environment variable is used to get the `http` endpoint provided for the `myService` resource.

For more information on how to write a Grafana k6 script, see the [Write your first test with Grafana k6](https://grafana.com/docs/k6/latest/get-started/write-your-first-test/).

### Customize ports

[Section titled “Customize ports”](#customize-ports)

To customize the ports used by the k6 container resource, provide the `port` parameter to the `AddK6` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var myService = builder.AddProject<Projects.MyService>();


var k6 = builder.AddK6("k6", port: 6565)
                .WithBindMount("scripts", "/scripts", true)
                .WithScript("/scripts/main.js")
                .WithReference(myService)
                .WaitFor(apiservice);


// After adding all resources, run the app...
```

The `port` parameter specifies the host port for the k6 HTTP endpoint. If this parameter is not provided, a random port is assigned.

### Enable browser extensions

[Section titled “Enable browser extensions”](#enable-browser-extensions)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var myService = builder.AddProject<Projects.MyService>();


var k6 = builder.AddK6("k6", enableBrowserExtensions: true)
                .WithBindMount("scripts", "/scripts", true)
                .WithScript("/scripts/main.js")
                .WithReference(myService)
                .WaitFor(apiservice);


// After adding all resources, run the app...
```

The browser module brings browser automation and end-to-end web testing to k6 while supporting core k6 features. It adds browser-level APIs to interact with browsers and collect frontend performance metrics as part of your k6 tests.

For more information on how to use Grafana k6 browser, see the [Using k6 browser](https://grafana.com/docs/k6/latest/using-k6-browser/).

## See also

[Section titled “See also”](#see-also)

* [Grafana k6 website](https://k6.io/)
* [Grafana k6 documentation](https://grafana.com/docs/k6/latest/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)

# MailPit integration

⭐ Community Toolkit ![Mailpit logo](/_astro/mailpit-icon.DNy-ogcL.svg)

[MailPit](https://mailpit.axllent.org/) is an email testing tool for developers. It acts as an SMTP server, captures emails, and provides a web interface to view them. The Aspire MailPit hosting integration enables you to run MailPit alongside your Aspire projects for local email testing.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire MailPit hosting integration, install the [CommunityToolkit.Aspire.Hosting.MailPit](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.MailPit) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.MailPit package

  ```bash
  aspire add communitytoolkit-mailpit
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-mailpit (CommunityToolkit.Aspire.Hosting.MailPit)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.MailPit@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.MailPit package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.MailPit" Version="*" />
  ```

### Add MailPit resource

[Section titled “Add MailPit resource”](#add-mailpit-resource)

To add MailPit to your app host, use the `AddMailPit` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mailpit = builder.AddMailPit("mailpit");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mailpit);


// After adding all resources, run the app...
```

When Aspire adds MailPit to the app host, it creates a new MailPit instance with the `docker.io/axllent/mailpit` container image.

### Ports

[Section titled “Ports”](#ports)

MailPit exposes two ports:

* **SMTP port**: 1025 (for sending emails)
* **Web UI port**: 8025 (for viewing emails in the browser)

Both ports are automatically configured and accessible through the Aspire dashboard.

### Data persistence

[Section titled “Data persistence”](#data-persistence)

To persist emails across container restarts, use the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mailpit = builder.AddMailPit("mailpit")
                     .WithDataVolume();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mailpit);
```

The data volume is used to persist the MailPit data outside the lifecycle of the container.

For development scenarios, you may want to use bind mounts instead of data volumes. To add a data bind mount, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var mailpit = builder.AddMailPit("mailpit")
                     .WithDataBindMount(source: @"C:\MailPit\Data");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(mailpit);
```

### Web UI

[Section titled “Web UI”](#web-ui)

The MailPit web interface is automatically available when you add a MailPit resource. You can access it through the Aspire dashboard by clicking on the endpoint for the MailPit resource.

## Client integration

[Section titled “Client integration”](#client-integration)

MailPit doesn’t require a dedicated client integration package. You can use any SMTP library to send emails to MailPit. The connection information is automatically injected into your application when you reference the MailPit resource.

### Using MailKit

[Section titled “Using MailKit”](#using-mailkit)

Here’s an example using the popular [MailKit](https://www.nuget.org/packages/MailKit) library:

```powershell
dotnet add package MailKit
```

```csharp
using MailKit.Net.Smtp;
using MimeKit;


public class EmailService
{
    private readonly string _smtpHost;
    private readonly int _smtpPort;


    public EmailService(IConfiguration configuration)
    {
        _smtpHost = configuration.GetConnectionString("mailpit")?.Split(':')[0] ?? "localhost";
        _smtpPort = 1025;
    }


    public async Task SendEmailAsync(string to, string subject, string body)
    {
        using var message = new MimeMessage();
        message.From.Add(new MailboxAddress("Sender", "sender@example.com"));
        message.To.Add(new MailboxAddress("Recipient", to));
        message.Subject = subject;
        message.Body = new TextPart("plain") { Text = body };


        using var client = new SmtpClient();
        await client.ConnectAsync(_smtpHost, _smtpPort, false);
        await client.SendAsync(message);
        await client.DisconnectAsync(true);
    }
}
```

### Using System.Net.Mail

[Section titled “Using System.Net.Mail”](#using-systemnetmail)

You can also use the built-in `System.Net.Mail` APIs:

```csharp
using System.Net;
using System.Net.Mail;


public class EmailService
{
    private readonly string _smtpHost;
    private readonly int _smtpPort;


    public EmailService(IConfiguration configuration)
    {
        _smtpHost = configuration.GetConnectionString("mailpit")?.Split(':')[0] ?? "localhost";
        _smtpPort = 1025;
    }


    public async Task SendEmailAsync(string to, string subject, string body)
    {
        using var client = new SmtpClient(_smtpHost, _smtpPort);
        using var message = new MailMessage("sender@example.com", to, subject, body);
        await client.SendMailAsync(message);
    }
}
```

## See also

[Section titled “See also”](#see-also)

* [MailPit documentation](https://mailpit.axllent.org/)
* [MailPit GitHub repository](https://github.com/axllent/mailpit)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# SQL Database Projects integration

> Learn about the Aspire hosting integration for SQL Database Projects.

⭐ Community Toolkit ![SQL Database Projects icon](/_astro/sql-database-projects-icon.XFCfircj_vMDIQ.webp)

The Aspire SQL Database Projects hosting integration enables you to deploy SQL database schemas from SQL projects or DACPAC files during local development and testing. This integration supports both [MSBuild.Sdk.SqlProj](https://github.com/rr-wfm/MSBuild.Sdk.SqlProj) and [Microsoft.Build.Sql](https://www.nuget.org/packages/Microsoft.Build.Sql) project formats.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire SQL Database Projects hosting integration, install the [CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects package

  ```bash
  aspire add communitytoolkit-sqldatabaseprojects
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-sqldatabaseprojects (CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects" Version="*" />
  ```

### Add SQL project

[Section titled “Add SQL project”](#add-sql-project)

To deploy a SQL project to a SQL Server database, use the `AddSqlProject` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .AddDatabase("sqldb");


sql.AddSqlProject<Projects.DatabaseProject>("database-project");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(sql);


// After adding all resources, run the app...
```

This method takes a project reference to your SQL database project and deploys it to the specified database when the app host starts.

Note

Your SQL database project must use either [MSBuild.Sdk.SqlProj](https://github.com/rr-wfm/MSBuild.Sdk.SqlProj) or [Microsoft.Build.Sql](https://www.nuget.org/packages/Microsoft.Build.Sql) SDK. Add one of these to your SQL project file:

```xml
  <Project Sdk="MSBuild.Sdk.SqlProj/3.3.0">
  <!-- or -->
  <Project Sdk="Microsoft.Build.Sql/2.0.0">
```

### Add SQL package (NuGet)

[Section titled “Add SQL package (NuGet)”](#add-sql-package-nuget)

To deploy a SQL database schema from a NuGet package, use the `AddSqlPackage` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .AddDatabase("sqldb");


sql.AddSqlPackage("Contoso.DatabasePackage", "1.0.0");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(sql);


// After adding all resources, run the app...
```

This method downloads the specified NuGet package and deploys the DACPAC it contains to the database.

Tip

When using NuGet packages, mark them with the `IsAspirePackageResource` metadata to indicate they’re only used for Aspire deployment:

```xml
<PackageReference Include="Contoso.DatabasePackage" Version="1.0.0">
  <IsAspirePackageResource>true</IsAspirePackageResource>
</PackageReference>
```

### Add DACPAC file

[Section titled “Add DACPAC file”](#add-dacpac-file)

To deploy a DACPAC file directly, use the `WithDacpac` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .AddDatabase("sqldb");


sql.WithDacpac("path/to/database.dacpac");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(sql);


// After adding all resources, run the app...
```

### Configure DAC deployment options

[Section titled “Configure DAC deployment options”](#configure-dac-deployment-options)

You can customize the DACPAC deployment behavior using the `WithConfigureDacDeployOptions` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .AddDatabase("sqldb");


sql.AddSqlProject<Projects.DatabaseProject>("database-project")
   .WithConfigureDacDeployOptions(options =>
   {
       options.BlockOnPossibleDataLoss = false;
       options.DropObjectsNotInSource = true;
   });


// After adding all resources, run the app...
```

### Redeploy action

[Section titled “Redeploy action”](#redeploy-action)

The SQL Database Projects integration adds a custom “Redeploy” action to the Aspire dashboard. This action allows you to manually trigger a redeployment of the database schema without restarting the entire app host.

To use the Redeploy action:

1. Open the Aspire dashboard
2. Find your SQL database resource
3. Click the “Redeploy” action in the resource’s menu

This is useful during development when you make changes to your database schema and want to quickly apply them.

### Multiple SQL projects

[Section titled “Multiple SQL projects”](#multiple-sql-projects)

You can add multiple SQL projects to the same database or different databases:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql");


var db1 = sql.AddDatabase("db1");
db1.AddSqlProject<Projects.Database1Project>("db1-project");


var db2 = sql.AddDatabase("db2");
db2.AddSqlProject<Projects.Database2Project>("db2-project");


// After adding all resources, run the app...
```

### Ability to skip deployment

[Section titled “Ability to skip deployment”](#ability-to-skip-deployment)

You can use the `WithSkipWhenDeployed` method to avoid re-deploying your SQL Database Project if no changes have been made. This is useful in scenarios where the SQL container database is persisted to permanent storage and will significantly reduce the app host startup time.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
    .WithDataVolume("data")
    .WithLifetime(ContainerLifetime.Persistent);


var db1 = sql.AddDatabase("db1");


db1.AddSqlProject<Projects.Database1Project>("db1-project")
   .WithSkipWhenDeployed();


// After adding all resources, run the app...
```

## See also

[Section titled “See also”](#see-also)

* [MSBuild.Sdk.SqlProj](https://github.com/rr-wfm/MSBuild.Sdk.SqlProj)
* [Microsoft.Build.Sql](https://www.nuget.org/packages/Microsoft.Build.Sql)
* [SQL Server Data Tools (SSDT)](https://learn.microsoft.com/sql/ssdt/sql-server-data-tools)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Bun integration

> Learn about the Aspire hosting integration for Bun apps.

⭐ Community Toolkit ![Bun logo](/_astro/bun-icon.DvKtlocW_Z2mjA6o.webp)

The Aspire Bun hosting integration enables you to run [Bun](https://bun.sh/) applications alongside your Aspire projects in the Aspire app host. Bun is a fast JavaScript runtime and toolkit.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Bun hosting integration, install the [CommunityToolkit.Aspire.Hosting.Bun](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Bun) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Bun package

  ```bash
  aspire add communitytoolkit-bun
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-bun (CommunityToolkit.Aspire.Hosting.Bun)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Bun@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Bun package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Bun" Version="*" />
  ```

### Add Bun app

[Section titled “Add Bun app”](#add-bun-app)

To add a Bun application to your app host, use the `AddBunApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var bunApp = builder.AddBunApp(
    name: "bun-api",
    workingDirectory: "../bun-app")
    .WithHttpEndpoint(port: 3000, env: "PORT");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(bunApp);


// After adding all resources, run the app...
```

The `AddBunApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **workingDirectory**: The path to the directory containing your Bun application

By default, the integration looks for an `index.ts` file as the entrypoint.

### Package installation

[Section titled “Package installation”](#package-installation)

To ensure packages are installed before running your Bun application, use the `WithBunPackageInstaller` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var bunApp = builder.AddBunApp("bun-api", "../bun-app")
    .WithBunPackageInstaller()
    .WithHttpEndpoint(port: 3000, env: "PORT");


// After adding all resources, run the app...
```

This runs `bun install` before starting your application.

### Custom entrypoint

[Section titled “Custom entrypoint”](#custom-entrypoint)

To specify a custom entrypoint file, pass it as an additional parameter:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var bunApp = builder.AddBunApp("bun-api", "../bun-app", "server.ts")
    .WithHttpEndpoint(port: 3000, env: "PORT");


// After adding all resources, run the app...
```

### Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Bun applications typically use environment variables to configure the port they listen on. Use `WithHttpEndpoint` to configure the port and set the PORT environment variable:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var bunApp = builder.AddBunApp("bun-api", "../bun-app")
    .WithHttpEndpoint(port: 3000, env: "PORT");


// After adding all resources, run the app...
```

Your Bun application can read the PORT environment variable:

```typescript
const server = Bun.serve({
  port: process.env.PORT || 3000,
  fetch(request) {
    return new Response('Hello from Bun!');
  },
});


console.log(`Server listening on port ${server.port}`);
```

### Working directory

[Section titled “Working directory”](#working-directory)

The `workingDirectory` parameter specifies where the Bun application is located. The Aspire app host will run `bun run` in this directory to start your Bun application.

## See also

[Section titled “See also”](#see-also)

* [Bun documentation](https://bun.sh/docs)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Dapr integration

⭐ Community Toolkit ![Dapr logo](/_astro/dapr-icon.MGF9MsE6.png)

[Dapr](https://dapr.io/) (Distributed Application Runtime) is a portable, event-driven runtime that makes it easy for developers to build resilient, microservice stateless and stateful applications. The Aspire Dapr integration enables you to add [Dapr sidecars](https://docs.dapr.io/concepts/dapr-services/sidecar/) to your Aspire projects.

Note

This integration requires the Dapr CLI to be installed on your machine. For installation instructions, see [Install the Dapr CLI](https://docs.dapr.io/getting-started/install-dapr-cli/).

After installing the CLI, you must run `dapr init` to initialize Dapr on your local machine before using this integration.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Dapr hosting integration, install the [CommunityToolkit.Aspire.Hosting.Dapr](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Dapr) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Dapr package

  ```bash
  aspire add communitytoolkit-dapr
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-dapr (CommunityToolkit.Aspire.Hosting.Dapr)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Dapr@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Dapr package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Dapr" Version="*" />
  ```

### Add Dapr sidecar

[Section titled “Add Dapr sidecar”](#add-dapr-sidecar)

In your app host project, add a Dapr sidecar to a project using the `WithDaprSidecar` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.ExampleProject>("exampleproject")
       .WithDaprSidecar();


// After adding all resources, run the app...
```

By default, the Dapr sidecar uses the resource name as the Dapr app ID. You can customize the app ID and sidecar options:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddProject<Projects.ExampleProject>("exampleproject")
       .WithDaprSidecar(new DaprSidecarOptions
       {
           AppId = "my-app-id",
           DaprGrpcPort = 50001,
           DaprHttpPort = 3500,
           MetricsPort = 9090
       });


// After adding all resources, run the app...
```

### Dashboard integration

[Section titled “Dashboard integration”](#dashboard-integration)

When you add Dapr sidecars to your projects, they appear as separate resources in the Aspire dashboard. Each sidecar is displayed with a unique name based on the project name and includes the configured ports.

## Client integration

[Section titled “Client integration”](#client-integration)

To connect to services with Dapr sidecars from your client application, use the [Dapr.AspNetCore](https://www.nuget.org/packages/Dapr.AspNetCore) or [Dapr.Client](https://www.nuget.org/packages/Dapr.Client) NuGet packages:

* .NET CLI

  .NET CLI — Add Dapr.AspNetCore package

  ```bash
  dotnet add package Dapr.AspNetCore
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Dapr.AspNetCore@*
  ```

* PackageReference (\*.csproj)

  XML — Add Dapr.AspNetCore package reference

  ```xml
  <PackageReference Include="Dapr.AspNetCore" Version="*" />
  ```

For non-ASP.NET Core applications, use the Dapr.Client package instead:

```powershell
dotnet add package Dapr.Client
```

### Use Dapr client

[Section titled “Use Dapr client”](#use-dapr-client)

In the `Program.cs` file of your client-consuming project, call the `AddDaprClient` extension method to register the Dapr client:

```csharp
builder.Services.AddDaprClient();
```

You can then retrieve the `DaprClient` instance using dependency injection:

```csharp
public class ExampleService(DaprClient daprClient)
{
    public async Task CallServiceAsync()
    {
        var response = await daprClient.InvokeMethodAsync<Response>(
            HttpMethod.Get,
            "exampleproject",
            "api/data");
    }
}
```

### Service-to-service invocation

[Section titled “Service-to-service invocation”](#service-to-service-invocation)

Dapr enables service-to-service invocation using the app ID. When you add a Dapr sidecar to a project, you can invoke methods on that service using the app ID:

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDaprClient();


var app = builder.Build();


app.MapGet("/call-service", async (DaprClient daprClient) =>
{
    var result = await daprClient.InvokeMethodAsync<string>(
        HttpMethod.Get,
        "exampleproject",
        "api/data");


    return Results.Ok(result);
});


app.Run();
```

For more information on Dapr service invocation, see [Dapr service invocation](https://docs.dapr.io/developing-applications/building-blocks/service-invocation/).

## See also

[Section titled “See also”](#see-also)

* [Dapr documentation](https://docs.dapr.io/)
* [Dapr .NET SDK](https://docs.dapr.io/developing-applications/sdks/dotnet/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Deno integration

⭐ Community Toolkit ![Deno logo](/_astro/deno-icon.BlzooUTA.png)

The Aspire Deno hosting integration enables you to run [Deno](https://deno.com/) applications alongside your Aspire projects in the Aspire app host. Deno is a modern JavaScript and TypeScript runtime.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Deno hosting integration, install the [CommunityToolkit.Aspire.Hosting.Deno](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Deno) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Deno package

  ```bash
  aspire add communitytoolkit-deno
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-deno (CommunityToolkit.Aspire.Hosting.Deno)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Deno@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Deno package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Deno" Version="*" />
  ```

### Add Deno app

[Section titled “Add Deno app”](#add-deno-app)

To add a Deno application to your app host, use the `AddDenoApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var denoApp = builder.AddDenoApp(
    name: "deno-api",
    workingDirectory: "../deno-app",
    scriptPath: "main.ts",
    args: ["--allow-net", "--allow-env"])
    .WithHttpEndpoint(port: 8000, env: "PORT");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(denoApp);


// After adding all resources, run the app...
```

The `AddDenoApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **workingDirectory**: The path to the directory containing your Deno application
* **scriptPath**: The path to the Deno script to run (relative to working directory)
* **args**: Permission flags required by Deno (e.g., `--allow-net`, `--allow-env`)

Note

Deno requires explicit permissions for various operations. Common permission flags include:

* `--allow-net`: Network access
* `--allow-env`: Environment variables
* `--allow-read`: File system reading
* `--allow-write`: File system writing

### Add Deno task

[Section titled “Add Deno task”](#add-deno-task)

To run a task defined in `package.json` or `deno.json`, use the `AddDenoTask` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var denoApp = builder.AddDenoTask(
    name: "deno-api",
    workingDirectory: "../deno-app",
    taskName: "start")
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

This runs `deno task start` in the specified working directory.

### Package installation

[Section titled “Package installation”](#package-installation)

To ensure packages are installed before running your Deno application, use the `WithDenoPackageInstallation` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var denoApp = builder.AddDenoApp("deno-api", "../deno-app", "main.ts", ["--allow-net", "--allow-env"])
    .WithDenoPackageInstallation()
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

Note

Package installation requires a `deno.lock` file in your Deno project. If the file doesn’t exist, run `deno install` in your Deno project directory to generate it.

### Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Deno applications typically use environment variables to configure the port they listen on. Use `WithHttpEndpoint` to configure the port and set the PORT environment variable:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var denoApp = builder.AddDenoApp("deno-api", "../deno-app", "main.ts", ["--allow-net", "--allow-env"])
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

Your Deno application can read the PORT environment variable:

```typescript
const port = Number(Deno.env.get("PORT")) || 8000;


Deno.serve({ port }, () => {
  return new Response("Hello from Deno!");
});


console.log(`Server listening on port ${port}`);
```

### Working directory

[Section titled “Working directory”](#working-directory)

The `workingDirectory` parameter specifies where the Deno application is located. The Aspire app host will run Deno commands in this directory.

## See also

[Section titled “See also”](#see-also)

* [Deno documentation](https://docs.deno.com/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Go integration

⭐ Community Toolkit ![Go logo](/_astro/go-icon.BtjqguRP.png)

The Aspire Go hosting integration enables you to run Go applications alongside your Aspire projects in the Aspire app host.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Go hosting integration, install the [CommunityToolkit.Aspire.Hosting.Golang](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Golang) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Golang package

  ```bash
  aspire add communitytoolkit-golang
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-golang (CommunityToolkit.Aspire.Hosting.Golang)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Golang@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Golang package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Golang" Version="*" />
  ```

### Add Go app

[Section titled “Add Go app”](#add-go-app)

To add a Go application to your app host, use the `AddGolangApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var goApp = builder.AddGolangApp(
    name: "go-api",
    workingDirectory: "../go-app")
    .WithHttpEndpoint(port: 8080, env: "PORT");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(goApp);


// After adding all resources, run the app...
```

The `AddGolangApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **workingDirectory**: The path to the directory containing your Go application

### Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Go applications typically use environment variables to configure the port they listen on. Use `WithHttpEndpoint` to configure the port and set the PORT environment variable:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var goApp = builder.AddGolangApp("go-api", "../go-app")
    .WithHttpEndpoint(port: 8080, env: "PORT");


// After adding all resources, run the app...
```

Your Go application can read the PORT environment variable to determine which port to listen on:

```go
package main


import (
    "fmt"
    "net/http"
    "os"
)


func main() {
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }


    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello from Go!")
    })


    fmt.Printf("Server listening on port %s\n", port)
    http.ListenAndServe(":"+port, nil)
}
```

### Working directory

[Section titled “Working directory”](#working-directory)

The `workingDirectory` parameter specifies where the Go application is located. The Aspire app host will run `go run .` in this directory to start your Go application.

## See also

[Section titled “See also”](#see-also)

* [Go documentation](https://go.dev/doc/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Java integration

⭐ Community Toolkit ![Java logo](/_astro/java-icon.R5ekku_P_Z1PqVX5.webp)

The Aspire Java hosting integration enables you to run Java applications, including Spring Boot applications, alongside your Aspire projects in the Aspire app host.

Note

This integration requires the OpenTelemetry Java agent for observability support. The agent JAR file must be downloaded to the `./agents` directory relative to your app host project.

Download the agent from: [OpenTelemetry Java Agent releases](https://github.com/open-telemetry/opentelemetry-java-instrumentation/releases)

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Java hosting integration, install the [CommunityToolkit.Aspire.Hosting.Java](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Java) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Java package

  ```bash
  aspire add communitytoolkit-java
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-java (CommunityToolkit.Aspire.Hosting.Java)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Java@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Java package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Java" Version="*" />
  ```

### Add Spring Boot app

[Section titled “Add Spring Boot app”](#add-spring-boot-app)

To add a Spring Boot application to your app host, use the `AddSpringApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var javaApp = builder.AddSpringApp(
    name: "spring-api",
    workingDirectory: "../spring-app",
    otelAgentPath: "../agents/opentelemetry-javaagent.jar")
    .WithHttpEndpoint(port: 8080);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(javaApp);


// After adding all resources, run the app...
```

The `AddSpringApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **workingDirectory**: The path to the directory containing your Spring Boot application
* **otelAgentPath**: The path to the OpenTelemetry Java agent JAR file

### Container hosting

[Section titled “Container hosting”](#container-hosting)

For production scenarios, you can host Java applications in containers. Use `JavaAppContainerResourceOptions` to specify container-specific settings:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var javaApp = builder.AddSpringApp(
    name: "spring-api",
    new JavaAppContainerResourceOptions
    {
        OtelAgentPath = "../agents/opentelemetry-javaagent.jar",
        ContainerImageName = "my-spring-app:latest",
        ContainerRegistry = "myregistry.azurecr.io"
    })
    .WithHttpEndpoint(port: 8080);


// After adding all resources, run the app...
```

### Executable hosting

[Section titled “Executable hosting”](#executable-hosting)

For local development, you can run Java applications as executables using `JavaAppExecutableResourceOptions`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var javaApp = builder.AddSpringApp(
    name: "spring-api",
    new JavaAppExecutableResourceOptions
    {
        ApplicationName = "spring-app",
        OtelAgentPath = "../agents/opentelemetry-javaagent.jar",
        WorkingDirectory = "../spring-app"
    })
    .WithHttpEndpoint(port: 8080);


// After adding all resources, run the app...
```

### Certificate trust (Linux/macOS)

[Section titled “Certificate trust (Linux/macOS)”](#certificate-trust-linuxmacos)

On Linux and macOS, you may need to add additional configuration to trust the Aspire development certificates. Add the following to your Spring Boot application’s `application.properties`:

```properties
server.ssl.trust-store=/path/to/aspire/dev/certificate.p12
server.ssl.trust-store-password=your-password
```

For more information, see the [Spring Boot SSL documentation](https://docs.spring.io/spring-boot/reference/features/ssl.html).

### Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Spring Boot applications typically use the `server.port` property to configure the port. Use `WithHttpEndpoint` to expose the endpoint:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var javaApp = builder.AddSpringApp("spring-api", "../spring-app", "../agents/opentelemetry-javaagent.jar")
    .WithHttpEndpoint(port: 8080);


// After adding all resources, run the app...
```

## Observability

[Section titled “Observability”](#observability)

The Java integration uses the OpenTelemetry Java agent to provide observability features. The agent automatically instruments your Java application and exports telemetry to the Aspire dashboard.

Make sure to download the OpenTelemetry Java agent and specify its path when calling `AddSpringApp`.

## See also

[Section titled “See also”](#see-also)

* [Spring Boot documentation](https://spring.io/projects/spring-boot)
* [OpenTelemetry Java](https://opentelemetry.io/docs/languages/java/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# JavaScript integration

> Learn how to orchestrate JavaScript applications with Aspire using the Aspire.Hosting.JavaScript package.

![JavaScript logo](/_astro/javascript.BtpOR5m6_Z1k8iGn.svg)

The Aspire JavaScript/TypeScript hosting integration enables you to orchestrate JavaScript applications alongside your Aspire projects in the AppHost. This integration provides a unified approach to running JavaScript applications with support for multiple package managers (npm, yarn, pnpm), runtimes (Node.js), and build tools (Vite, and more).

Package rename

In Aspire 13.0, the `Aspire.Hosting.NodeJs` package was renamed to `Aspire.Hosting.JavaScript` to better reflect its broader support for JavaScript applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire JavaScript hosting integration, install the [📦 Aspire.Hosting.JavaScript](https://www.nuget.org/packages/Aspire.Hosting.JavaScript) NuGet package in the AppHost project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.JavaScript package

  ```bash
  aspire add javascript
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > javascript (Aspire.Hosting.JavaScript)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.JavaScript@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.JavaScript package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.JavaScript" Version="*" />
  ```

The integration exposes a number of app resource types:

* `JavaScriptAppResource`: Added with the `AddJavaScriptApp` method for general JavaScript applications
* `NodeAppResource`: Added with the `AddNodeApp` method for running specific JavaScript files with Node.js
* `ViteAppResource`: Added with the `AddViteApp` method for Vite applications with Vite-specific defaults

## Add JavaScript application

[Section titled “Add JavaScript application”](#add-javascript-application)

The `AddJavaScriptApp` method is the foundational method for adding JavaScript applications to your Aspire AppHost. It provides a consistent way to orchestrate JavaScript applications with automatic package manager detection and intelligent defaults.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.ExampleProject>();


var frontend = builder.AddJavaScriptApp("frontend", "./frontend")
    .WithHttpEndpoint(port: 3000, env: "PORT")
    .WithReference(api);


// After adding all resources, run the app...
```

By default, `AddJavaScriptApp`:

* Uses npm as the package manager when `package.json` is present
* Runs the “dev” script during local development
* Runs the “build” script when publishing to create production assets
* Automatically generates Dockerfiles to build production assets

The method accepts the following parameters:

* `name`: The name of the resource in the Aspire dashboard
* `appDirectory`: The path to the directory containing your JavaScript application (where `package.json` is located)
* `runScriptName` (optional): The name of the npm script to run when starting the application. Defaults to ‘dev’.

## Add Node.js application

[Section titled “Add Node.js application”](#add-nodejs-application)

For Node.js applications that don’t use a package.json script runner, you can directly run a JavaScript file using the `AddNodeApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.ExampleProject>();


var nodeApp = builder.AddNodeApp("node-app", "./node-app", "server.js")
    .WithHttpEndpoint(port: 3000, env: "PORT")
    .WithReference(api);


// After adding all resources, run the app...
```

The `AddNodeApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **appDirectory**: The path to the directory containing the node application.
* **scriptPath** The path to the script relative to the app directory to run.

## Add Vite application

[Section titled “Add Vite application”](#add-vite-application)

For Vite applications, you can use the `AddViteApp` extension method which provides Vite-specific defaults and optimizations:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.ExampleProject>();


var viteApp = builder.AddViteApp("vite-app", "./vite-app")
    .WithReference(api);


// After adding all resources, run the app...
```

`AddViteApp` automatically configures:

* **Development script**: Runs the “dev” script (typically `vite`) during local development
* **Build script**: Runs the “build” script (typically `vite build`) when publishing
* **Package manager**: Uses npm by default, but can be customized with `WithYarn()` or `WithPnpm()`

The method accepts the same parameters as `AddJavaScriptApp`:

* **name**: The name of the resource in the Aspire dashboard
* **appDirectory**: The path to the directory containing the Vite app.
* **runScriptName** (optional): The name of the script that runs the Vite app. Defaults to “dev”.

## Configure package managers

[Section titled “Configure package managers”](#configure-package-managers)

Aspire automatically detects and supports multiple JavaScript package managers with intelligent defaults for both development and production scenarios.

### Auto-install by default

[Section titled “Auto-install by default”](#auto-install-by-default)

Package managers automatically install dependencies by default. This ensures dependencies are always up-to-date during development and publishing.

### Use npm (default)

[Section titled “Use npm (default)”](#use-npm-default)

npm is the default package manager. If your project has a `package.json` file, Aspire will use npm unless you specify otherwise:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// npm is used by default
var app = builder.AddJavaScriptApp("app", "./app");


// Customize npm with additional flags
var customApp = builder.AddJavaScriptApp("custom-app", "./custom-app")
    .WithNpm(installCommand: "ci", installArgs: ["--legacy-peer-deps"]);


// After adding all resources, run the app...
```

When publishing (production mode), Aspire automatically uses `npm ci` if `package-lock.json` exists, otherwise it uses `npm install` for deterministic builds.

### Use yarn

[Section titled “Use yarn”](#use-yarn)

To use yarn as the package manager, call the `WithYarn` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddJavaScriptApp("app", "./app")
    .WithYarn();


// Customize yarn with additional flags
var customApp = builder.AddJavaScriptApp("custom-app", "./custom-app")
    .WithYarn(installArgs: ["--immutable"]);


// After adding all resources, run the app...
```

When publishing, Aspire uses:

* `yarn install --immutable` if `yarn.lock` exists and yarn v2+ is detected
* `yarn install --frozen-lockfile` if `yarn.lock` exists with yarn v1
* `yarn install` otherwise

### Use pnpm

[Section titled “Use pnpm”](#use-pnpm)

To use pnpm as the package manager, call the `WithPnpm` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddJavaScriptApp("app", "./app")
    .WithPnpm();


// Customize pnpm with additional flags
var customApp = builder.AddJavaScriptApp("custom-app", "./custom-app")
    .WithPnpm(installArgs: ["--frozen-lockfile"]);


// After adding all resources, run the app...
```

When publishing, Aspire uses `pnpm install --frozen-lockfile` if `pnpm-lock.yaml` exists, otherwise it uses `pnpm install`.

## Customize scripts

[Section titled “Customize scripts”](#customize-scripts)

You can customize which scripts run during development and build:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Use different script names
var app = builder.AddJavaScriptApp("app", "./app")
    .WithRunScript("start")      // Run "npm run start" during development instead of "dev"
    .WithBuildScript("prod");    // Run "npm run prod" during publish instead of "build"


// After adding all resources, run the app...
```

### Pass arguments to scripts

[Section titled “Pass arguments to scripts”](#pass-arguments-to-scripts)

To pass command-line arguments to your scripts, use the `WithArgs` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddJavaScriptApp("app", "./app")
    .WithRunScript("dev")
    .WithArgs("--port", "3000", "--host");


// After adding all resources, run the app...
```

Alternatively, you can define custom scripts in your `package.json` with arguments baked in:

package.json

```json
{
  "scripts": {
    "dev": "vite",
    "dev:custom": "vite --port 3000 --host"
  }
}
```

Then reference the custom script:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddJavaScriptApp("app", "./app")
    .WithRunScript("dev:custom");


// After adding all resources, run the app...
```

## Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

JavaScript applications typically use environment variables to configure the port they listen on. Use `WithHttpEndpoint` to configure the port and set the environment variable:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var app = builder.AddJavaScriptApp("app", "./app")
    .WithHttpEndpoint(port: 3000, env: "PORT");


// After adding all resources, run the app...
```

Common environment variables for JavaScript frameworks:

* **PORT**: Generic port configuration used by many frameworks (Express, Vite, Next.js)
* **VITE\_PORT**: For Vite applications
* **HOST**: Some frameworks also use this to bind to specific interfaces

## Customize Vite configuration

[Section titled “Customize Vite configuration”](#customize-vite-configuration)

For Vite applications, you can specify a custom configuration file if you need to override the default Vite configuration resolution behavior:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var viteApp = builder.AddViteApp("vite-app", "./vite-app")
    // Path is relative to the Vite service project root
    .WithViteConfig("./vite.production.config.js");


// After adding all resources, run the app...
```

The `WithViteConfig` method accepts:

* **configPath**: The path to the Vite configuration file, relative to the Vite service project root.

This is useful when you have multiple Vite configuration files for different scenarios (development, staging, production).

### HTTPS configuration

[Section titled “HTTPS configuration”](#https-configuration)

Aspire automatically augments existing Vite configurations to enable HTTPS endpoints at runtime, eliminating manual certificate configuration for development. When you configure HTTPS endpoints on a Vite resource, Aspire dynamically injects the necessary HTTPS configuration:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var viteApp = builder.AddViteApp("vite-app", "./vite-app")
    .WithHttpsEndpoint(env: "PORT")
    .WithHttpsDeveloperCertificate();


// After adding all resources, run the app...
```

The HTTPS configuration is automatically applied without modifying your `vite.config.js` file. For more information about certificate configuration, see [Certificate configuration](/app-host/certificate-configuration/).

## Production builds

[Section titled “Production builds”](#production-builds)

When you publish your application using `aspire deploy`, Aspire automatically:

1. Generates a Dockerfile for containerized deployment
2. Installs dependencies using deterministic install commands based on lockfiles
3. Runs the build script (typically “build”) to create production assets
4. Creates production-ready containers

This ensures your JavaScript applications are built consistently across environments and deployed alongside your other Aspire services.

## See also

[Section titled “See also”](#see-also)

* [Node.js hosting extensions](/integrations/frameworks/nodejs-extensions/) - Community Toolkit extensions for Vite, Yarn, and pnpm
* [What’s new in Aspire 13](/whats-new/aspire-13/) - Learn about first-class JavaScript support
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# .NET MAUI integration

> Learn how to integrate .NET MAUI mobile and desktop applications with Aspire for simplified service orchestration and discovery.

🧪 Preview ![.NET MAUI logo](/_astro/maui-icon.oIIgefok_ZNiupT.webp)

The .NET MAUI integration with Aspire simplifies the development experience when building mobile and desktop applications that connect to local web services during development. This integration enables you to orchestrate your .NET MAUI apps alongside your backend services using Aspire’s powerful orchestration capabilities.

Preview feature

This feature is currently in preview. Some features are still being implemented, and integration with Visual Studio 2026 is not completely available yet.

## What is .NET MAUI?

[Section titled “What is .NET MAUI?”](#what-is-net-maui)

.NET Multi-platform App UI (.NET MAUI) is a cross-platform framework for creating native mobile and desktop apps with C# and XAML. With .NET MAUI, you can develop apps that run on Android, iOS, macOS, and Windows from a single shared codebase.

## Benefits of using Aspire with .NET MAUI

[Section titled “Benefits of using Aspire with .NET MAUI”](#benefits-of-using-aspire-with-net-maui)

Integrating Aspire with your .NET MAUI applications provides several key benefits:

* **Simplified configuration**: Eliminate complex platform-specific networking configuration. No need to manually handle `10.0.2.2` for Android or deal with certificate validation issues.
* **Automatic service discovery**: Your MAUI app automatically discovers and connects to local services without hardcoded URLs.
* **Development tunnels integration**: Built-in support for Dev Tunnels on iOS and Android, making it easy to connect mobile emulators and simulators to local services.
* **Consistent experience**: Use the same patterns and tools across your entire application stack.
* **Observable services**: Monitor your services through the Aspire dashboard during development.

### Comparison with traditional approach

[Section titled “Comparison with traditional approach”](#comparison-with-traditional-approach)

Traditionally, connecting a .NET MAUI app to local web services requires significant manual configuration:

* Use different URLs for different platforms (localhost, 10.0.2.2, etc.).
* Configure network security settings for Android.
* Set up Apple Transport Security (ATS) for iOS.
* Handle certificate validation for HTTPS.
* Manually manage service URLs in your code.

With Aspire integration, these complexities are handled automatically, allowing you to focus on building your application instead of configuring network access.

## Prerequisites

[Section titled “Prerequisites”](#prerequisites)

To use Aspire with .NET MAUI, you need:

* [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) or later.
* [Aspire 13](/whats-new/aspire-13/) or later.
* A .NET MAUI app targeting .NET 10 or later.
* One or more web services to connect to.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The MAUI hosting integration is distributed via the [Aspire.Hosting.Maui](https://www.nuget.org/packages/Aspire.Hosting.Maui) NuGet package and enables you to orchestrate .NET MAUI applications in your AppHost project.

### Register MAUI project

[Section titled “Register MAUI project”](#register-maui-project)

To register a MAUI project in your AppHost, install the `Aspire.Hosting.Maui` package and use the `AddMauiProject` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Register your backend service
var weatherApi = builder.AddProject<Projects.WeatherApi>("webapi");


// Register your MAUI app
var mauiapp = builder.AddMauiProject("mauiapp", "../YourMauiApp/YourMauiApp.csproj");


// Add platform specific preferences here, chaining calls on your mauiapp.


builder.Build().Run();
```

### Platform-specific device configurations

[Section titled “Platform-specific device configurations”](#platform-specific-device-configurations)

The MAUI integration supports multiple platforms. Each platform requires a specific device configuration:

* Windows

  Windows apps run directly on the host machine using localhost:

  C# — AppHost.cs

  ```csharp
  mauiapp.AddWindowsDevice()
      .WithReference(weatherApi);
  ```

* Mac Catalyst

  Mac Catalyst apps also use localhost directly on macOS:

  C# — AppHost.cs

  ```csharp
  mauiapp.AddMacCatalystDevice()
      .WithReference(weatherApi);
  ```

* iOS Simulator

  iOS Simulator requires Dev Tunnels to connect to local services:

  C# — AppHost.cs

  ```csharp
  // Create a public dev tunnel for mobile platforms
  var publicDevTunnel = builder.AddDevTunnel("devtunnel-public")
      .WithAnonymousAccess()
      .WithReference(weatherApi.GetEndpoint("https"));


  // Add iOS simulator with Dev Tunnel
  mauiapp.AddiOSSimulator()
      .WithOtlpDevTunnel() // Required for OpenTelemetry data collection
      .WithReference(weatherApi, publicDevTunnel);
  ```

* Android Emulator

  Android Emulator also requires Dev Tunnels for connectivity:

  C# — AppHost.cs

  ```csharp
  mauiapp.AddAndroidEmulator()
      .WithOtlpDevTunnel() // Required for OpenTelemetry data collection
      .WithReference(weatherApi, publicDevTunnel);
  ```

### Complete AppHost example

[Section titled “Complete AppHost example”](#complete-apphost-example)

Here’s a complete example showing all platform configurations:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Register your web service
var weatherApi = builder.AddProject<Projects.WeatherApi>("webapi");


// Create a public dev tunnel for iOS and Android
var publicDevTunnel = builder.AddDevTunnel("devtunnel-public")
    .WithAnonymousAccess()
    .WithReference(weatherApi.GetEndpoint("https"));


// Register your MAUI app
var mauiapp = builder.AddMauiProject("mauiapp", @"../YourMauiApp/YourMauiApp.csproj");


// Add Windows device (uses localhost directly)
mauiapp.AddWindowsDevice()
    .WithReference(weatherApi);


// Add Mac Catalyst device (uses localhost directly)
mauiapp.AddMacCatalystDevice()
    .WithReference(weatherApi);


// Add iOS simulator with Dev Tunnel
mauiapp.AddiOSSimulator()
    .WithOtlpDevTunnel() // Required for OpenTelemetry data collection
    .WithReference(weatherApi, publicDevTunnel);


// Add Android emulator with Dev Tunnel
mauiapp.AddAndroidEmulator()
    .WithOtlpDevTunnel() // Required for OpenTelemetry data collection
    .WithReference(weatherApi, publicDevTunnel);


builder.Build().Run();
```

Tip

You can add multiple device configurations for the same MAUI project. Each device configuration can target different platforms, allowing you to deploy and test your app on multiple targets simultaneously from the same AppHost.

## Client configuration

[Section titled “Client configuration”](#client-configuration)

To configure your .NET MAUI app to work with Aspire, you need to:

1. Create a MAUI Service Defaults project.
2. Reference it from your MAUI app.
3. Configure service defaults in your MAUI app.

### Create a MAUI Service Defaults project

[Section titled “Create a MAUI Service Defaults project”](#create-a-maui-service-defaults-project)

The MAUI Service Defaults project contains shared configuration for your MAUI app:

.NET CLI — New service defaults

```bash
dotnet new maui-aspire-servicedefaults -n YourApp.MauiServiceDefaults
```

This project includes:

* Service discovery configuration.
* Default resilience patterns.
* Telemetry setup.
* Platform-specific networking configuration.

Add a reference to this project from your MAUI app:

.NET CLI — Add project reference

```bash
dotnet add YourMauiApp.csproj reference YourApp.MauiServiceDefaults/YourApp.MauiServiceDefaults.csproj
```

### Configure your MAUI app

[Section titled “Configure your MAUI app”](#configure-your-maui-app)

In your `MauiProgram.cs`, add service defaults and configure HTTP clients:

C# — MauiProgram.cs

```csharp
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;


public static class MauiProgram
{
    public static MauiApp CreateMauiApp()
    {
        var builder = MauiApp.CreateBuilder();


        builder
            .UseMauiApp<App>()
            .ConfigureFonts(fonts =>
            {
                fonts.AddFont("OpenSans-Regular.ttf", "OpenSansRegular");
                fonts.AddFont("OpenSans-Semibold.ttf", "OpenSansSemibold");
            });


        // Add service defaults
        builder.AddServiceDefaults();


        // Configure HTTP client with service discovery
        builder.Services.AddHttpClient<WeatherApiClient>(client =>
        {
            // Service name matches the name used in AppHost
            client.BaseAddress = new Uri("https+http://webapi");
        });


        return builder.Build();
    }
}
```

Note

The `https+http://` scheme is special syntax that enables both HTTPS and HTTP protocols, with preference for HTTPS. The service name must match the name you used when registering the service in your `AppHost.cs`.

### Create a typed client

[Section titled “Create a typed client”](#create-a-typed-client)

Create a strongly-typed HTTP client to consume your web service:

C# — WeatherApiClient.cs

```csharp
public class WeatherApiClient
{
    private readonly HttpClient _httpClient;


    public WeatherApiClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }


    public async Task<WeatherForecast[]?> GetWeatherForecastAsync(
        CancellationToken cancellationToken = default)
    {
        return await _httpClient.GetFromJsonAsync<WeatherForecast[]>(
            "/weatherforecast",
            cancellationToken);
    }
}


public record WeatherForecast(DateOnly Date, int TemperatureC, string? Summary)
{
    public int TemperatureF => 32 + (int)(TemperatureC * 1.8);
}
```

### Use the client in your app

[Section titled “Use the client in your app”](#use-the-client-in-your-app)

Inject and use the client in your pages or view models:

C# — MainPage.cs

```csharp
public partial class MainPage : ContentPage
{
    private readonly WeatherApiClient _weatherClient;


    public MainPage(WeatherApiClient weatherClient)
    {
        _weatherClient = weatherClient;
        InitializeComponent();
    }


    private async void OnGetWeatherClicked(object sender, EventArgs e)
    {
        try
        {
            var forecasts = await _weatherClient.GetWeatherForecastAsync();


            if (forecasts is not null)
            {
                ResultLabel.Text = $"Retrieved {forecasts.Length} forecasts";
            }
        }
        catch (Exception ex)
        {
            ResultLabel.Text = $"Error: {ex.Message}";
        }
    }
}
```

## Platform-specific considerations

[Section titled “Platform-specific considerations”](#platform-specific-considerations)

### Dev Tunnels for iOS and Android

[Section titled “Dev Tunnels for iOS and Android”](#dev-tunnels-for-ios-and-android)

Dev Tunnels provide a secure way to expose your local web services to mobile devices and emulators. The Aspire integration automatically:

* Creates and manages Dev Tunnels for your services.
* Configures your MAUI app to use the tunnel URLs.
* Handles authentication and connection management.

### OpenTelemetry data collection

[Section titled “OpenTelemetry data collection”](#opentelemetry-data-collection)

The `WithOtlpDevTunnel()` method creates a Dev Tunnel specifically for OpenTelemetry protocol (OTLP) traffic, allowing telemetry data from your iOS and Android apps to reach the Aspire dashboard. This is essential for monitoring and debugging your mobile apps through the Aspire dashboard.

### Windows and Mac Catalyst

[Section titled “Windows and Mac Catalyst”](#windows-and-mac-catalyst)

On Windows and Mac Catalyst, local service connectivity works directly through localhost without requiring Dev Tunnels. The Aspire integration provides a consistent API across all platforms while handling platform-specific requirements automatically.

## Running your application

[Section titled “Running your application”](#running-your-application)

To run your MAUI app with Aspire integration:

* Visual Studio

  1. Set the AppHost project as the startup project.
  2. Run the solution ( F5 `F5` F5 `F5` F5 `F5` or Debug > Start Debugging).

* Aspire CLI

  Navigate to the AppHost project directory and run:

  Aspire CLI — Run

  ```bash
  aspire run
  ```

* VS Code

  1. Open the AppHost project folder.
  2. Run the project using the .NET debugger or terminal.

When the AppHost starts:

* The Aspire dashboard will open, showing all registered services.
* Your MAUI app will **not** launch automatically.
* Start each .NET MAUI target manually through the dashboard.

The dashboard provides real-time monitoring, logs from all services, and distributed tracing across your entire application stack.

## Troubleshooting

[Section titled “Troubleshooting”](#troubleshooting)

### Service discovery not working

[Section titled “Service discovery not working”](#service-discovery-not-working)

If your MAUI app can’t connect to your web services:

1. Verify that you’ve called `AddServiceDefaults()` in your MAUI app’s `MauiProgram.cs`.
2. Ensure the service name in your HTTP client configuration matches the name used in the AppHost.
3. Check that you’re using the `https+http://` scheme in your service URL.
4. For iOS and Android, confirm that Dev Tunnels are configured correctly in the AppHost.

### Missing telemetry from iOS/Android apps

[Section titled “Missing telemetry from iOS/Android apps”](#missing-telemetry-from-iosandroid-apps)

If you’re not seeing telemetry data from your iOS or Android apps in the Aspire dashboard:

1. Verify that you’ve added the `WithOtlpDevTunnel()` method to your device configurations.
2. Ensure Dev Tunnels have anonymous access configured.
3. Check that your firewall isn’t blocking tunnel connections.

### Dev Tunnels connection issues

[Section titled “Dev Tunnels connection issues”](#dev-tunnels-connection-issues)

If Dev Tunnels aren’t working for iOS or Android:

1. Ensure the Dev Tunnel is configured with anonymous access: `.WithAnonymousAccess()`.
2. Verify that the device configuration includes the Dev Tunnel reference.
3. Try restarting the AppHost to recreate the tunnels.

## Best practices

[Section titled “Best practices”](#best-practices)

When building .NET MAUI apps with Aspire integration:

* **Use typed clients**: Create strongly-typed HTTP clients for each service to improve maintainability.
* **Handle errors gracefully**: Network operations can fail; implement proper error handling and retry logic.
* **Leverage the dashboard**: Use the Aspire dashboard for debugging and monitoring during development.
* **Test on all platforms**: While the integration handles platform differences, always test on your target platforms.
* **Follow service defaults**: The service defaults project provides recommended patterns for resilience and telemetry.

## Sample application

[Section titled “Sample application”](#sample-application)

For a complete working example of .NET MAUI integration with Aspire, see the [AspireWithMaui sample](https://github.com/dotnet/aspire/tree/main/playground/AspireWithMaui) in the Aspire repository.

## See also

[Section titled “See also”](#see-also)

* [.NET MAUI documentation](https://learn.microsoft.com/dotnet/maui/)
* [.NET MAUI integration with Aspire on Microsoft Learn](https://learn.microsoft.com/dotnet/maui/data-cloud/aspire-integration)
* [Dev Tunnels documentation](https://learn.microsoft.com/aspnet/core/test/dev-tunnels)

# Node.js hosting extensions

⭐ Community Toolkit ![Node.js logo](/_astro/nodejs-icon.KKaryUxz.png)

The Aspire Community Toolkit Node.js hosting extensions package provides extra functionality to the [Aspire.Hosting.NodeJS](https://www.nuget.org/packages/Aspire.Hosting.NodeJS) hosting package.

Package rename

In Aspire 13.0, the `Aspire.Hosting.NodeJs` package was renamed to [`Aspire.Hosting.JavaScript`](/integrations/frameworks/javascript/) to better reflect its broader support for JavaScript applications.

This package provides the following features:

* Running [Vite](https://vitejs.dev/) applications
* Running Node.js applications using [Yarn](https://yarnpkg.com/) and [pnpm](https://pnpm.io/)
* Ensuring that packages are installed before running the application (using the specified package manager)

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Community Toolkit Node.js hosting extensions, install the [CommunityToolkit.Aspire.Hosting.NodeJS.Extensions](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.NodeJS.Extensions) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.NodeJS.Extensions package

  ```bash
  aspire add communitytoolkit-nodejs-extensions
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-nodejs-extensions (CommunityToolkit.Aspire.Hosting.NodeJS.Extensions)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.NodeJS.Extensions@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.NodeJS.Extensions package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.NodeJS.Extensions" Version="*" />
  ```

## Run specific package managers

[Section titled “Run specific package managers”](#run-specific-package-managers)

This integration extension adds support for running Node.js applications using Yarn or pnpm as the package manager.

### Yarn

[Section titled “Yarn”](#yarn)

To add a Node.js application using Yarn, use the `AddYarnApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var yarnApp = builder.AddYarnApp("yarn-demo")
                     .WithExternalHttpEndpoints();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(yarnApp);


// After adding all resources, run the app...
```

### pnpm

[Section titled “pnpm”](#pnpm)

To add a Node.js application using pnpm, use the `AddPnpmApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var pnpmApp = builder.AddPnpmApp("pnpm-demo")
                     .WithExternalHttpEndpoints();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(pnpmApp);


// After adding all resources, run the app...
```

## Run Vite apps

[Section titled “Run Vite apps”](#run-vite-apps)

This integration extension adds support for running the development server for Vite applications. By default, it uses the `npm` package manager to launch, but this can be overridden with the `packageManager` argument.

### Using npm (default)

[Section titled “Using npm (default)”](#using-npm-default)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var viteApp = builder.AddViteApp("vite-demo")
                     .WithExternalHttpEndpoints();


// After adding all resources, run the app...
```

### Using Yarn

[Section titled “Using Yarn”](#using-yarn)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var viteApp = builder.AddViteApp("yarn-demo", packageManager: "yarn")
                     .WithExternalHttpEndpoints();


// After adding all resources, run the app...
```

### Using pnpm

[Section titled “Using pnpm”](#using-pnpm)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var viteApp = builder.AddViteApp("pnpm-demo", packageManager: "pnpm")
                     .WithExternalHttpEndpoints();


// After adding all resources, run the app...
```

## Install packages

[Section titled “Install packages”](#install-packages)

When using the `WithNpmPackageInstallation`, `WithYarnPackageInstallation`, or `WithPnpmPackageInstallation` methods, the package manager is used to install the packages before starting the application. These methods are useful to ensure that packages are installed before the application starts, similar to how a C# application would restore NuGet packages before running.

### npm

[Section titled “npm”](#npm)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var nodeApp = builder.AddNodeApp("node-demo", "server.js")
                     .WithNpmPackageInstallation();


// After adding all resources, run the app...
```

### Yarn

[Section titled “Yarn”](#yarn-1)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var yarnApp = builder.AddYarnApp("yarn-demo")
                     .WithYarnPackageInstallation();


// After adding all resources, run the app...
```

### pnpm

[Section titled “pnpm”](#pnpm-1)

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var pnpmApp = builder.AddPnpmApp("pnpm-demo")
                     .WithPnpmPackageInstallation();


// After adding all resources, run the app...
```

## See also

[Section titled “See also”](#see-also)

* [Orchestrate Node.js apps in Aspire](/get-started/prerequisites/)
* [Node.js integration](/integrations/frameworks/javascript/)
* [Vite documentation](https://vitejs.dev/)
* [Yarn documentation](https://yarnpkg.com/)
* [pnpm documentation](https://pnpm.io/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Orleans integration

> Learn how to use the Orleans integration, which includes the Orleans hosting integration.

![Orleans logo](/_astro/microsoft-orleans.CgrIAp1e_29tQif.webp)

[Orleans](https://github.com/dotnet/orleans) has built-in support for Aspire. Orleans provides a straightforward way to build distributed applications that are elastically scalable and fault-tolerant. You can use Aspire to configure and orchestrate Orleans and its dependencies.

Orleans is represented as a resource in Aspire. Unlike other integrations, the Orleans integration doesn’t create a container and doesn’t require a separate client integration package. Instead you complete the Orleans configuration in the Aspire AppHost project.

Note

This integration requires Orleans version 8.1.0 or later.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Orleans hosting integration models an Orleans service as the `OrleansService` type. To access this type and APIs, add the [📦 Aspire.Hosting.Orleans](https://www.nuget.org/packages/Aspire.Hosting.Orleans) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Orleans package

  ```bash
  aspire add orleans
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > orleans (Aspire.Hosting.Orleans)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Orleans@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Orleans package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Orleans" Version="*" />
  ```

### Add an Orleans resource

[Section titled “Add an Orleans resource”](#add-an-orleans-resource)

In your AppHost project, call `AddOrleans` to add and return an Orleans service resource builder. The name provided to the Orleans resource is for diagnostic purposes. For most applications, a value of `"default"` suffices:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var orleans = builder.AddOrleans("default");
```

### Use Azure storage for clustering and grain storage

[Section titled “Use Azure storage for clustering and grain storage”](#use-azure-storage-for-clustering-and-grain-storage)

In an Orleans app, the fundamental building block is a **grain**. Grains can have durable states. You must store the durable state for a grain somewhere. In an Aspire application, **Azure Blob Storage** is one possible location.

Orleans hosts register themselves in a database and use that database to find each other and form a cluster. They store which servers are members of which silos in a database table. In an Aspire application, a popular choice to store this table is **Azure Table Storage**.

To configure Orleans with clustering and grain storage in Azure, install the [📦 Aspire.Hosting.Azure.Storage](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage) NuGet package in the AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Azure.Storage package

  ```bash
  aspire add azure-storage
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > azure-storage (Aspire.Hosting.Azure.Storage)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Azure.Storage@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Azure.Storage package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Azure.Storage" Version="*" />
  ```

In your AppHost project, after you call `AddOrleans`, configure the Orleans resource with clustering and grain storage using the `WithClustering` and `WithGrainStorage` methods:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage");
var clusteringTable = storage.AddTables("clustering");
var grainStorage = storage.AddBlobs("grainstate");


var orleans = builder.AddOrleans("default")
                     .WithClustering(clusteringTable)
                     .WithGrainStorage("Default", grainStorage);
```

The preceding code tells Orleans that any service referencing it must also reference the `clusteringTable` resource.

### Add an Orleans server project

[Section titled “Add an Orleans server project”](#add-an-orleans-server-project)

Now you can add a new project, enrolled in Aspire orchestration, to your solution as an Orleans server. It will take part in the Orleans cluster as a silo with constituent grains. Reference the Orleans resource from your server project using `WithReference(orleans)`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var orleans = builder.AddOrleans("default")
                     .WithClustering(clusteringTable)
                     .WithGrainStorage("Default", grainStorage);


var server = builder.AddProject<Projects.OrleansServer>("orleans-server")
                    .WithReference(orleans);
```

When you reference the Orleans resource from your service, those resources are also referenced.

### Add an Orleans client project

[Section titled “Add an Orleans client project”](#add-an-orleans-client-project)

Orleans clients communicate with grains hosted on Orleans servers. In an Aspire app, for example, you might have a front-end web site that calls grains in an Orleans cluster. Reference the Orleans resource from your Orleans client using `WithReference(orleans.AsClient())`:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var orleans = builder.AddOrleans("default")
                     .WithClustering(clusteringTable)
                     .WithGrainStorage("Default", grainStorage);


var client = builder.AddProject<Projects.OrleansClient>("orleans-client")
                    .WithReference(orleans.AsClient());
```

## Create the Orleans server project

[Section titled “Create the Orleans server project”](#create-the-orleans-server-project)

Now that the AppHost project is completed, you can implement the Orleans server project. Let’s start by adding the necessary NuGet packages:

```bash
dotnet add package Aspire.Azure.Data.Tables
dotnet add package Aspire.Azure.Storage.Blobs
dotnet add package Microsoft.Orleans.Server
dotnet add package Microsoft.Orleans.Persistence.AzureStorage
dotnet add package Microsoft.Orleans.Clustering.AzureStorage
```

Next, in the `Program.cs` file of your Orleans server project, add the Azure Storage blob and tables clients and then call `UseOrleans`:

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.AddKeyedAzureTableServiceClient("clustering");
builder.AddKeyedAzureBlobServiceClient("grainstate");
builder.UseOrleans();


var app = builder.Build();


app.Run();
```

### Example: CounterGrain implementation

[Section titled “Example: CounterGrain implementation”](#example-countergrain-implementation)

The following code is a complete example of an Orleans server project, including a grain named `CounterGrain`:

```csharp
using Orleans;


var builder = WebApplication.CreateBuilder(args);


builder.AddKeyedAzureTableServiceClient("clustering");
builder.AddKeyedAzureBlobServiceClient("grainstate");
builder.UseOrleans();


var app = builder.Build();


app.Run();


public interface ICounterGrain : IGrainWithStringKey
{
    Task<int> GetCountAsync();
    Task<int> IncrementAsync();
}


[GenerateSerializer]
public class CounterState
{
    [Id(0)]
    public int Count { get; set; }
}


public class CounterGrain : Grain, ICounterGrain
{
    private readonly IPersistentState<CounterState> _state;


    public CounterGrain(
        [PersistentState("count", "Default")] IPersistentState<CounterState> state)
    {
        _state = state;
    }


    public Task<int> GetCountAsync() => Task.FromResult(_state.State.Count);


    public async Task<int> IncrementAsync()
    {
        _state.State.Count++;
        await _state.WriteStateAsync();
        return _state.State.Count;
    }
}
```

## Create an Orleans client project

[Section titled “Create an Orleans client project”](#create-an-orleans-client-project)

In the Orleans client project, add the same NuGet packages:

```bash
dotnet add package Aspire.Azure.Data.Tables
dotnet add package Aspire.Azure.Storage.Blobs
dotnet add package Microsoft.Orleans.Client
dotnet add package Microsoft.Orleans.Persistence.AzureStorage
dotnet add package Microsoft.Orleans.Clustering.AzureStorage
```

Next, in the `Program.cs` file of your Orleans client project, add the Azure table storage client and then call `UseOrleansClient`:

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.AddKeyedAzureTableServiceClient("clustering");
builder.UseOrleansClient();


var app = builder.Build();


app.MapGet("/", async (IGrainFactory grains) =>
{
    var grain = grains.GetGrain<ICounterGrain>("counter");
    var count = await grain.IncrementAsync();
    return Results.Ok(new { count });
});


app.Run();
```

The preceding code calls the `CounterGrain` grain defined in the Orleans server example above.

## Enabling OpenTelemetry

[Section titled “Enabling OpenTelemetry”](#enabling-opentelemetry)

By convention, Aspire solutions include a project for defining default configuration and behavior for your service. This project is called the *service defaults* project. To configure Orleans for OpenTelemetry in Aspire, apply configuration to your service defaults project.

Modify the `ConfigureOpenTelemetry` method to add the Orleans *meters* and *tracing* instruments:

```csharp
public static IHostApplicationBuilder ConfigureOpenTelemetry(this IHostApplicationBuilder builder)
{
    builder.Logging.AddOpenTelemetry(logging =>
    {
        logging.IncludeFormattedMessage = true;
        logging.IncludeScopes = true;
    });


    builder.Services.AddOpenTelemetry()
        .WithMetrics(metrics =>
        {
            metrics.AddAspNetCoreInstrumentation()
                   .AddHttpClientInstrumentation()
                   .AddRuntimeInstrumentation()
                   .AddMeter("Microsoft.Orleans"); // Add Orleans meter
        })
        .WithTracing(tracing =>
        {
            tracing.AddAspNetCoreInstrumentation()
                   .AddHttpClientInstrumentation()
                   .AddSource("Microsoft.Orleans.Runtime")
                   .AddSource("Microsoft.Orleans.Application"); // Add Orleans sources
        });


    builder.AddOpenTelemetryExporters();


    return builder;
}
```

## Supported providers

[Section titled “Supported providers”](#supported-providers)

The Orleans Aspire integration supports a limited subset of Orleans providers:

**Clustering:**

* Redis
* Azure Storage Tables

**Persistence:**

* Redis
* Azure Storage Tables
* Azure Storage Blobs

**Reminders:**

* Redis
* Azure Storage Tables

**Grain directory:**

* Redis
* Azure Storage Tables

Streaming providers aren’t supported as of Orleans version 8.1.0.

# PowerShell integration

> Learn about the Aspire hosting integration for PowerShell scripts.

⭐ Community Toolkit ![PowerShell logo](/_astro/powershell-icon.B0QrE_7N_ZvraE9.webp)

The Aspire PowerShell hosting integration enables you to run PowerShell Core (pwsh) scripts alongside your Aspire projects in the Aspire app host. This integration allows you to script your resources, reference connection strings, access live resources, and leverage the full power of PowerShell within your distributed application.

Note

This integration requires PowerShell Core (pwsh) 7.4 or later to be installed on your system and available in your PATH. For installation instructions, see [Install PowerShell](https://learn.microsoft.com/powershell/scripting/install/installing-powershell).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire PowerShell hosting integration, install the [CommunityToolkit.Aspire.Hosting.PowerShell](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.PowerShell) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.PowerShell package

  ```bash
  aspire add communitytoolkit-powershell
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-powershell (CommunityToolkit.Aspire.Hosting.PowerShell)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.PowerShell@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.PowerShell package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.PowerShell" Version="*" />
  ```

### Add PowerShell resource

[Section titled “Add PowerShell resource”](#add-powershell-resource)

To add a PowerShell resource to your app host, use the `AddPowerShell` extension method:

C# — AppHost.cs

```csharp
using CommunityToolkit.Aspire.Hosting.PowerShell;


var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage").RunAsEmulator();
var blob = storage.AddBlobs("myblob");


var ps = builder.AddPowerShell("ps")
    .WithReference(blob)
    .WaitFor(storage);


// After adding all resources, run the app...
```

The `AddPowerShell` method requires:

* **name**: The name of the PowerShell resource in the Aspire dashboard

### Add scripts

[Section titled “Add scripts”](#add-scripts)

To execute PowerShell scripts within your resource, use the `AddScript` method:

C# — AppHost.cs

```csharp
var ps = builder.AddPowerShell("ps")
    .WithReference(blob);


var script1 = ps.AddScript("script1", """
    param($name)


    Write-Information "Hello, $name"
    Write-Information "`$myblob is $myblob"


    az storage container create --connection-string $myblob -n demo
    az storage blob upload --connection-string $myblob -c demo --file ./scripts/script.ps1


    Write-Information "Blob uploaded"
""").WithArgs("world");


var script2 = ps.AddScript("script2", """
    & ./scripts/script.ps1 @args
""")
    .WithArgs(2, 3)
    .WaitForCompletion(script1);


// After adding all resources, run the app...
```

The `AddScript` method requires:

* **name**: The name of the script resource in the Aspire dashboard
* **script**: The PowerShell script content to execute

### References and dependencies

[Section titled “References and dependencies”](#references-and-dependencies)

Use `WithReference` to pass connection strings and resource references to your PowerShell scripts. Referenced resources are available as variables in your script scope:

C# — AppHost.cs

```csharp
var storage = builder.AddAzureStorage("storage").RunAsEmulator();
var blob = storage.AddBlobs("myblob");


var ps = builder.AddPowerShell("ps")
    .WithReference(blob);  // The $myblob variable is now available in scripts


var script = ps.AddScript("demo", """
    Write-Information "Connection string: $myblob"
""");


// After adding all resources, run the app...
```

Use `WaitFor` to specify that a PowerShell resource should wait for other resources to be ready before executing:

C# — AppHost.cs

```csharp
var storage = builder.AddAzureStorage("storage").RunAsEmulator();


var ps = builder.AddPowerShell("ps")
    .WaitFor(storage);  // Wait for storage to be ready before running scripts


// After adding all resources, run the app...
```

### Custom arguments

[Section titled “Custom arguments”](#custom-arguments)

Pass arguments to your PowerShell scripts using the `WithArgs` method:

C# — AppHost.cs

```csharp
var ps = builder.AddPowerShell("ps");


var script = ps.AddScript("process-data", """
    param($count, $name)


    Write-Information "Processing $count items for $name"
""").WithArgs(5, "demo");


// After adding all resources, run the app...
```

Scripts can define parameters using PowerShell’s `param()` block and receive arguments passed via `WithArgs`.

### Script execution order

[Section titled “Script execution order”](#script-execution-order)

Control the execution order of scripts using `WaitForCompletion`. A script that calls `WaitForCompletion` will not run until the referenced script completes:

C# — AppHost.cs

```csharp
var ps = builder.AddPowerShell("ps");


var script1 = ps.AddScript("setup", """
    Write-Information "Setting up resources"
    "setup-data.txt" | Set-Content "ready"
""");


var script2 = ps.AddScript("process", """
    Write-Information "Processing after setup"
""").WaitForCompletion(script1);  // Waits for script1 to complete


// After adding all resources, run the app...
```

### Working directory

[Section titled “Working directory”](#working-directory)

Scripts execute in the context of your app host’s working directory. You can access files relative to this directory within your scripts:

C# — AppHost.cs

```csharp
var ps = builder.AddPowerShell("ps");


var script = ps.AddScript("file-ops", """
    $pwd | Write-Information
    Get-ChildItem ./scripts
""");


// After adding all resources, run the app...
```

## Debugging

[Section titled “Debugging”](#debugging)

While your app host is running a script that contains a `Wait-Debugger` call, you can attach a PowerShell debugger to debug the script interactively.

Open a terminal with PowerShell Core (pwsh) 7.4 or later and use the following commands:

```powershell
Get-PSHostProcessInfo
Enter-PSHostProcess -Id <ProcessId>
Get-Runspace
Debug-Runspace -Id <RunspaceId>
```

For more information about PowerShell debugging, see [Enter-PSHostProcess documentation](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/enter-pshostprocess?view=powershell-7.5).

## See also

[Section titled “See also”](#see-also)

* [PowerShell documentation](https://learn.microsoft.com/powershell/)
* [Enter-PSHostProcess documentation](https://learn.microsoft.com/powershell/module/microsoft.powershell.core/enter-pshostprocess?view=powershell-7.5)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Python integration

> Learn how to use the Aspire Python Hosting integration to orchestrate Python applications in an Aspire solution.

![Python logo](/_astro/python.HT_z5JOp_Z1NYjKL.svg)

The Aspire Python hosting integration enables you to run Python applications alongside your Aspire projects in the Aspire app host. This integration provides first-class support for Python apps, scripts, modules, executables, and web frameworks like FastAPI.

First-class Python support

As of Aspire 13, Python is a first-class workload with the `Aspire.Hosting.Python` package. The previous `CommunityToolkit.Aspire.Hosting.Python.Extensions` package is deprecated, and its functionality has been integrated into the official package with full support for debugging, service discovery, and deployment alongside .NET and JavaScript applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To access these types and APIs for expressing Python resources in your [`AppHost`](/get-started/app-host/) project, install the [📦 Aspire.Hosting.Python](https://www.nuget.org/packages/Aspire.Hosting.Python) NuGet package:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Python package

  ```bash
  aspire add python
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > python (Aspire.Hosting.Python)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Python@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Python package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Python" Version="*" />
  ```

## Add Python app

[Section titled “Add Python app”](#add-python-app)

To add a Python application to your app host, use the `AddPythonApp` extension method to run a Python script:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonApp(
    name: "python-api",
    projectDirectory: "../python-app",
    scriptPath: "main.py")
    .WithHttpEndpoint(port: 8000, env: "PORT");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(python);


// After adding all resources, run the app...
```

The `AddPythonApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **projectDirectory**: The path to the directory containing your Python application
* **scriptPath**: The path to the Python script to run (relative to the project directory)

## Add Python module

[Section titled “Add Python module”](#add-python-module)

To run a Python module (using `python -m`), use the `AddPythonModule` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonModule(
    name: "python-module",
    projectDirectory: "../python-app",
    moduleName: "mymodule")
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

The `AddPythonModule` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **projectDirectory**: The path to the directory containing your Python application
* **moduleName**: The name of the Python module to run

## Add Python executable

[Section titled “Add Python executable”](#add-python-executable)

To run a Python executable or CLI tool from a virtual environment, use the `AddPythonExecutable` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonExecutable(
    name: "python-tool",
    projectDirectory: "../python-app",
    executable: "uvicorn",
    args: ["main:app", "--host", "0.0.0.0", "--port", "8000"]);


// After adding all resources, run the app...
```

## Add Uvicorn app

[Section titled “Add Uvicorn app”](#add-uvicorn-app)

For ASGI web frameworks like FastAPI, Starlette, and Quart, use the `AddUvicornApp` extension method which provides built-in support for Uvicorn:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddUvicornApp(
    name: "python-api",
    projectDirectory: "../python-app",
    appName: "main:app")
    .WithHttpEndpoint(port: 8000, env: "PORT");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(python);


// After adding all resources, run the app...
```

The `AddUvicornApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **projectDirectory**: The path to the directory containing your Python application
* **appName**: The Python module and ASGI application instance (e.g., `main:app` for an `app` instance in `main.py`)

### Uvicorn configuration

[Section titled “Uvicorn configuration”](#uvicorn-configuration)

The `AddUvicornApp` method supports additional configuration options:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddUvicornApp("python-api", "../python-app", "main:app")
    .WithHttpEndpoint(port: 8000, env: "PORT")
    .WithEnvironment("UVICORN_WORKERS", "4")
    .WithEnvironment("UVICORN_LOG_LEVEL", "info");


// After adding all resources, run the app...
```

Common Uvicorn environment variables:

* **UVICORN\_PORT**: The port to listen on
* **UVICORN\_HOST**: The host to bind to (default: `127.0.0.1`)
* **UVICORN\_WORKERS**: Number of worker processes
* **UVICORN\_LOG\_LEVEL**: Logging level (e.g., `debug`, `info`, `warning`, `error`)

## Virtual environment management

[Section titled “Virtual environment management”](#virtual-environment-management)

The Python hosting integration automatically detects and manages Python virtual environments:

### Automatic virtual environment

[Section titled “Automatic virtual environment”](#automatic-virtual-environment)

By default, the integration looks for a virtual environment in the project directory. If a `requirements.txt` or `pyproject.toml` file is found, it will automatically create and activate a virtual environment.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Automatically detects and uses virtual environment
var python = builder.AddPythonApp("python-api", "../python-app", "main.py");


// After adding all resources, run the app...
```

### Custom virtual environment

[Section titled “Custom virtual environment”](#custom-virtual-environment)

To specify a custom virtual environment location, use the `WithVirtualEnvironment` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonApp("python-api", "../python-app", "main.py")
    .WithVirtualEnvironment("../python-app/.venv");


// After adding all resources, run the app...
```

### Disable virtual environment

[Section titled “Disable virtual environment”](#disable-virtual-environment)

To disable automatic virtual environment creation, use the `WithoutVirtualEnvironment` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonApp("python-api", "../python-app", "main.py")
    .WithoutVirtualEnvironment();


// After adding all resources, run the app...
```

## Package management

[Section titled “Package management”](#package-management)

The Python hosting integration supports multiple package managers and allows you to choose which one to use:

### Using uv package manager

[Section titled “Using uv package manager”](#using-uv-package-manager)

Use the `WithUv()` method to explicitly use the [uv package manager](https://docs.astral.sh/uv/) for faster dependency installation:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddUvicornApp("python-api", "../python-app", "main:app")
    .WithUv()
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

The `WithUv()` method configures the Python app to use uv for package management, which is significantly faster than pip and recommended for new projects.

### Using pip package manager

[Section titled “Using pip package manager”](#using-pip-package-manager)

Use the `WithPip()` method to explicitly use pip for package management:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonApp("python-api", "../python-app", "main.py")
    .WithPip()
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

Tip

If neither `WithUv()` nor `WithPip()` is specified, Aspire will automatically detect the appropriate package manager based on your project configuration (`pyproject.toml` for uv, `requirements.txt` for pip).

## Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Python applications typically use environment variables to configure the port they listen on. Use `WithHttpEndpoint` to configure the port and set the environment variable:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddUvicornApp("python-api", "../python-app", "main:app")
    .WithHttpEndpoint(port: 8000, env: "PORT");


// After adding all resources, run the app...
```

### Multiple endpoints

[Section titled “Multiple endpoints”](#multiple-endpoints)

You can configure multiple endpoints for a Python application:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonApp("python-api", "../python-app", "main.py")
    .WithHttpEndpoint(port: 8000, env: "HTTP_PORT", name: "http")
    .WithHttpEndpoint(port: 8443, env: "HTTPS_PORT", name: "https");


// After adding all resources, run the app...
```

## Health checks

[Section titled “Health checks”](#health-checks)

The Python hosting integration supports health checks for monitoring service health:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddUvicornApp("python-api", "../python-app", "main:app")
    .WithHttpEndpoint(port: 8000, env: "PORT")
    .WithHttpHealthCheck("/health");


// After adding all resources, run the app...
```

## Environment variables

[Section titled “Environment variables”](#environment-variables)

Pass environment variables to your Python application using the `WithEnvironment` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var python = builder.AddPythonApp("python-api", "../python-app", "main.py")
    .WithEnvironment("DEBUG", "true")
    .WithEnvironment("LOG_LEVEL", "debug");


// After adding all resources, run the app...
```

## Service discovery

[Section titled “Service discovery”](#service-discovery)

Python applications can reference other services in the Aspire app host using service discovery:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres")
    .AddDatabase("mydb");


var python = builder.AddPythonApp("python-api", "../python-app", "main.py")
    .WithReference(postgres);


// After adding all resources, run the app...
```

The connection string will be available as an environment variable in the Python application.

## Debugging

[Section titled “Debugging”](#debugging)

The Python hosting integration provides full debugging support in Visual Studio Code:

1. Install the [Aspire VS Code extension](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.dotnet-aspire)
2. Set breakpoints in your Python code
3. Run the Aspire app host
4. The debugger will automatically attach to your Python application

Tip

The Aspire VS Code extension automatically generates launch configurations for Python applications in your Aspire solution, enabling zero-configuration debugging.

## Deployment

[Section titled “Deployment”](#deployment)

When deploying your Aspire application, the Python hosting integration automatically generates production-ready Dockerfiles for your Python services:

```dockerfile
# Auto-generated Dockerfile
FROM python:3.12-slim


WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt


COPY . .
CMD ["python", "main.py"]
```

Note

The generated Dockerfile is tailored to your detected Python version and dependency setup, ensuring optimal compatibility and performance.

## See also

[Section titled “See also”](#see-also)

* [Build your first Aspire app](/get-started/first-app/)
* [Deploy your first Aspire app](/get-started/deploy-first-app/)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire.Hosting.Python NuGet package](https://www.nuget.org/packages/Aspire.Hosting.Python)
* [Uvicorn documentation](https://www.uvicorn.org/)
* [uv package manager documentation](https://docs.astral.sh/uv/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Rust integration

> Learn about the Aspire hosting integration for Rust apps.

⭐ Community Toolkit ![Rust logo](/_astro/rust-icon.Dbc7QCHB_Z10Rz3g.webp)

The Aspire Rust hosting integration enables you to run Rust applications alongside your Aspire projects in the Aspire app host.

Note

This integration requires `cargo` to be installed on your system and available in your PATH. For installation instructions, see [Install Rust](https://www.rust-lang.org/tools/install).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire Rust hosting integration, install the [CommunityToolkit.Aspire.Hosting.Rust](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Rust) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.Rust package

  ```bash
  aspire add communitytoolkit-rust
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-rust (CommunityToolkit.Aspire.Hosting.Rust)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.Rust@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.Rust package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.Rust" Version="*" />
  ```

### Add Rust app

[Section titled “Add Rust app”](#add-rust-app)

To add a Rust application to your app host, use the `AddRustApp` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rustApp = builder.AddRustApp(
    name: "rust-api",
    workingDirectory: "../rust-app")
    .WithHttpEndpoint(port: 8080, env: "PORT");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(rustApp);


// After adding all resources, run the app...
```

The `AddRustApp` method requires:

* **name**: The name of the resource in the Aspire dashboard
* **workingDirectory**: The path to the directory containing your Rust application

### Configure endpoints

[Section titled “Configure endpoints”](#configure-endpoints)

Rust applications typically use environment variables to configure the port they listen on. Use `WithHttpEndpoint` to configure the port and set the PORT environment variable:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rustApp = builder.AddRustApp("rust-api", "../rust-app")
    .WithHttpEndpoint(port: 8080, env: "PORT");


// After adding all resources, run the app...
```

Your Rust application can read the PORT environment variable to determine which port to listen on:

```rust
use std::env;
use actix_web::{web, App, HttpServer, Responder};


async fn greet() -> impl Responder {
    "Hello from Rust!"
}


#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let port = env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let addr = format!("0.0.0.0:{}", port);


    println!("Server listening on {}", addr);


    HttpServer::new(|| {
        App::new()
            .route("/", web::get().to(greet))
    })
    .bind(addr)?
    .run()
    .await
}
```

### Custom arguments

[Section titled “Custom arguments”](#custom-arguments)

You can pass custom arguments to `cargo run` using the `WithArgs` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rustApp = builder.AddRustApp("rust-api", "../rust-app")
    .WithArgs("--release")
    .WithHttpEndpoint(port: 8080, env: "PORT");


// After adding all resources, run the app...
```

### Working directory

[Section titled “Working directory”](#working-directory)

The `workingDirectory` parameter specifies where the Rust application is located. The Aspire app host will run `cargo run` in this directory to start your Rust application.

## See also

[Section titled “See also”](#see-also)

* [Rust documentation](https://www.rust-lang.org/learn)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# Integrations gallery

> Explore the Aspire gallery of integrations and extensions to enhance your Aspire solution.

Search integrations...

Clear

0

Number of Integrations

0

Unique Tags

0

Total Downloads

![Icon for Aspire.StackExchange.Redis integration](https://api.nuget.org/v3-flatcontainer/aspire.stackexchange.redis/13.1.1/icon) Aspire.StackExchange.Redis

A generic Redis® client that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloud +3

3.7M

Version 13.1.1

[Package  Visit Aspire.StackExchange.Redis package](https://www.nuget.org/packages/Aspire.StackExchange.Redis)

[Docs  Visit Aspire.StackExchange.Redis documentation](/integrations/caching/redis/)

![Icon for Aspire.Npgsql.EntityFrameworkCore.PostgreSQL integration](https://api.nuget.org/v3-flatcontainer/aspire.npgsql.entityframeworkcore.postgresql/13.1.1/icon) Aspire.Npgsql.EntityFrameworkCore.PostgreSQL

A PostgreSQL® provider for Entity Framework Core that integrates with Aspire, including connection pooling, health checks, logging, and telemetry.

clientcomponentcloud +12

3.4M

Version 13.1.1

[Package  Visit Aspire.Npgsql.EntityFrameworkCore.PostgreSQL package](https://www.nuget.org/packages/Aspire.Npgsql.EntityFrameworkCore.PostgreSQL)

[Docs  Visit Aspire.Npgsql.EntityFrameworkCore.PostgreSQL documentation](/integrations/databases/efcore/postgres/postgresql-get-started/)

![Icon for Aspire.Azure.Storage.Blobs integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.storage.blobs/13.1.1/icon) Aspire.Azure.Storage.Blobs

A client for Azure Blob Storage that integrates with Aspire, including health checks, logging and telemetry.

clientcomponentcloud +4

3.2M

Version 13.1.1

[Package  Visit Aspire.Azure.Storage.Blobs package](https://www.nuget.org/packages/Aspire.Azure.Storage.Blobs)

[Docs  Visit Aspire.Azure.Storage.Blobs documentation](/integrations/cloud/azure/azure-storage-blobs/)

![Icon for Aspire.Microsoft.EntityFrameworkCore.SqlServer integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.entityframeworkcore.sqlserver/13.1.1/icon) Aspire.Microsoft.EntityFrameworkCore.SqlServer

A Microsoft SQL Server provider for Entity Framework Core that integrates with Aspire, including connection pooling, health check, logging, and telemetry.

clientcomponentcloud +10

3.1M

Version 13.1.1

[Package  Visit Aspire.Microsoft.EntityFrameworkCore.SqlServer package](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.SqlServer)

[Docs  Visit Aspire.Microsoft.EntityFrameworkCore.SqlServer documentation](/integrations/databases/efcore/sql-server/sql-server-get-started/)

![Icon for Aspire.Hosting.Testing integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.testing/13.1.1/icon) Aspire.Hosting.Testing

Testing support for the Aspire application model.

testing

3M

Version 13.1.1

[Package  Visit Aspire.Hosting.Testing package](https://www.nuget.org/packages/Aspire.Hosting.Testing)

[Docs  Visit Aspire.Hosting.Testing documentation](/testing/overview/)

![Icon for Aspire.Hosting.SqlServer integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.sqlserver/13.1.1/icon) Aspire.Hosting.SqlServer

Microsoft SQL Server support for Aspire.

hostingsqlserversql +2

2.9M

Version 13.1.1

[Package  Visit Aspire.Hosting.SqlServer package](https://www.nuget.org/packages/Aspire.Hosting.SqlServer)

[Docs  Visit Aspire.Hosting.SqlServer documentation](/integrations/databases/sql-server/sql-server-host/)

![Icon for Aspire.Azure.Data.Tables integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.data.tables/13.1.1/icon) Aspire.Azure.Data.Tables

A client for Azure Table Storage that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloud +4

2.7M

Version 13.1.1

[Package  Visit Aspire.Azure.Data.Tables package](https://www.nuget.org/packages/Aspire.Azure.Data.Tables)

[Docs  Visit Aspire.Azure.Data.Tables documentation](/integrations/cloud/azure/azure-storage-tables/)

![Icon for Aspire.Hosting.Redis integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.redis/13.1.1/icon) Aspire.Hosting.Redis

Redis® support for Aspire.

hostingrediscachecaching

2.7M

Version 13.1.1

[Package  Visit Aspire.Hosting.Redis package](https://www.nuget.org/packages/Aspire.Hosting.Redis)

[Docs  Visit Aspire.Hosting.Redis documentation](/integrations/caching/redis/)

![Icon for Aspire.Hosting.PostgreSQL integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.postgresql/13.1.1/icon) Aspire.Hosting.PostgreSQL

PostgreSQL® support for Aspire.

hostingpostgresqlpostgres +4

2.4M

Version 13.1.1

[Package  Visit Aspire.Hosting.PostgreSQL package](https://www.nuget.org/packages/Aspire.Hosting.PostgreSQL)

[Docs  Visit Aspire.Hosting.PostgreSQL documentation](/integrations/databases/postgres/postgres-get-started/)

![Icon for Aspire.MySqlConnector integration](https://api.nuget.org/v3-flatcontainer/aspire.mysqlconnector/13.1.1/icon) Aspire.MySqlConnector

A MySQL client that integrates with Aspire, including health checks, metrics, logging, and telemetry.

clientcomponentcloud +5

2.3M

Version 13.1.1

[Package  Visit Aspire.MySqlConnector package](https://www.nuget.org/packages/Aspire.MySqlConnector)

[Docs  Visit Aspire.MySqlConnector documentation](/integrations/databases/mysql/mysql-get-started/)

![Icon for Aspire.Hosting.Azure.Storage integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.storage/13.1.1/icon) Aspire.Hosting.Azure.Storage

Azure Storage resource types for Aspire.

hostingazurestorage +4

2.1M

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.Storage package](https://www.nuget.org/packages/Aspire.Hosting.Azure.Storage)

[Docs  Visit Aspire.Hosting.Azure.Storage documentation](/integrations/cloud/azure/azure-storage-blobs/)

![Icon for Aspire.Npgsql integration](https://api.nuget.org/v3-flatcontainer/aspire.npgsql/13.1.1/icon) Aspire.Npgsql

A PostgreSQL® client that integrates with Aspire, including health checks, metrics, logging, and telemetry.

clientcomponentcloud +6

1.8M

Version 13.1.1

[Package  Visit Aspire.Npgsql package](https://www.nuget.org/packages/Aspire.Npgsql)

[Docs  Visit Aspire.Npgsql documentation](/integrations/databases/postgres/postgres-get-started/)

![Icon for Aspire.Confluent.Kafka integration](https://api.nuget.org/v3-flatcontainer/aspire.confluent.kafka/13.1.1/icon) Aspire.Confluent.Kafka

Confluent.Kafka based Kafka generic consumer and producer that integrates with Aspire, including healthchecks and metrics.

clientcomponentcloud +3

1.8M

Version 13.1.1

[Package  Visit Aspire.Confluent.Kafka package](https://www.nuget.org/packages/Aspire.Confluent.Kafka)

[Docs  Visit Aspire.Confluent.Kafka documentation](/integrations/messaging/apache-kafka/)

![Icon for Aspire.StackExchange.Redis.DistributedCaching integration](https://api.nuget.org/v3-flatcontainer/aspire.stackexchange.redis.distributedcaching/13.1.1/icon) Aspire.StackExchange.Redis.DistributedCaching

A Redis® implementation for IDistributedCache that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloud +5

1.5M

Version 13.1.1

[Package  Visit Aspire.StackExchange.Redis.DistributedCaching package](https://www.nuget.org/packages/Aspire.StackExchange.Redis.DistributedCaching)

[Docs  Visit Aspire.StackExchange.Redis.DistributedCaching documentation](/integrations/caching/redis-distributed/)

![Icon for Aspire.Hosting.RabbitMQ integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.rabbitmq/13.1.1/icon) Aspire.Hosting.RabbitMQ

RabbitMQ support for Aspire.

hostingrabbitmqmessagingeventing

1.2M

Version 13.1.1

[Package  Visit Aspire.Hosting.RabbitMQ package](https://www.nuget.org/packages/Aspire.Hosting.RabbitMQ)

[Docs  Visit Aspire.Hosting.RabbitMQ documentation](/integrations/messaging/rabbitmq/)

![Icon for Aspire.Hosting.Azure.KeyVault integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.keyvault/13.1.1/icon) Aspire.Hosting.Azure.KeyVault

Azure resource types for Aspire.

hostingazurekeyvault +3

1M

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.KeyVault package](https://www.nuget.org/packages/Aspire.Hosting.Azure.KeyVault)

[Docs  Visit Aspire.Hosting.Azure.KeyVault documentation](/integrations/cloud/azure/azure-key-vault/)

![Icon for Aspire.Microsoft.Data.SqlClient integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.data.sqlclient/13.1.1/icon) Aspire.Microsoft.Data.SqlClient

A Microsoft SQL Server client that integrates with Aspire, including health checks, metrics and telemetry.

clientcomponentcloud +4

1M

Version 13.1.1

[Package  Visit Aspire.Microsoft.Data.SqlClient package](https://www.nuget.org/packages/Aspire.Microsoft.Data.SqlClient)

[Docs  Visit Aspire.Microsoft.Data.SqlClient documentation](/integrations/databases/sql-server/sql-server-client/)

![Icon for Aspire.Azure.Storage.Queues integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.storage.queues/13.1.1/icon) Aspire.Azure.Storage.Queues

A client for Azure Queue Storage that integrates with Aspire, including health checks, logging and telemetry.

clientcomponentcloud +5

1M

Version 13.1.1

[Package  Visit Aspire.Azure.Storage.Queues package](https://www.nuget.org/packages/Aspire.Azure.Storage.Queues)

[Docs  Visit Aspire.Azure.Storage.Queues documentation](/integrations/cloud/azure/azure-storage-queues/)

![Icon for Aspire.Azure.Messaging.ServiceBus integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.messaging.servicebus/13.1.1/icon) Aspire.Azure.Messaging.ServiceBus

A client for Azure Service Bus that integrates with Aspire, including health checks, logging and telemetry.

clientcomponentcloud +5

751k

Version 13.1.1

[Package  Visit Aspire.Azure.Messaging.ServiceBus package](https://www.nuget.org/packages/Aspire.Azure.Messaging.ServiceBus)

[Docs  Visit Aspire.Azure.Messaging.ServiceBus documentation](/integrations/cloud/azure/azure-service-bus/)

![Icon for Aspire.Azure.Security.KeyVault integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.security.keyvault/13.1.1/icon) Aspire.Azure.Security.KeyVault

A client for Azure Key Vault that integrates with Aspire, including health checks, logging and telemetry.

clientcomponentcloud +4

709k

Version 13.1.1

[Package  Visit Aspire.Azure.Security.KeyVault package](https://www.nuget.org/packages/Aspire.Azure.Security.KeyVault)

[Docs  Visit Aspire.Azure.Security.KeyVault documentation](/integrations/cloud/azure/azure-key-vault/)

![Icon for Aspire.Hosting.Azure.ServiceBus integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.servicebus/13.1.1/icon) Aspire.Hosting.Azure.ServiceBus

Azure Service Bus resource types for Aspire.

hostingazureservicebus +3

694k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.ServiceBus package](https://www.nuget.org/packages/Aspire.Hosting.Azure.ServiceBus)

[Docs  Visit Aspire.Hosting.Azure.ServiceBus documentation](/integrations/cloud/azure/azure-service-bus/)

![Icon for Aspire.Microsoft.Azure.Cosmos integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.azure.cosmos/13.1.1/icon) Aspire.Microsoft.Azure.Cosmos

A client for Azure Cosmos DB that integrates with Aspire, including logging and telemetry.

clientcomponentcloud +7

666k

Version 13.1.1

[Package  Visit Aspire.Microsoft.Azure.Cosmos package](https://www.nuget.org/packages/Aspire.Microsoft.Azure.Cosmos)

[Docs  Visit Aspire.Microsoft.Azure.Cosmos documentation](/integrations/cloud/azure/azure-cosmos-db/)

![Icon for Aspire.RabbitMQ.Client integration](https://api.nuget.org/v3-flatcontainer/aspire.rabbitmq.client/13.1.1/icon) Aspire.RabbitMQ.Client

A RabbitMQ client that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloud +6

586k

Version 13.1.1

[Package  Visit Aspire.RabbitMQ.Client package](https://www.nuget.org/packages/Aspire.RabbitMQ.Client)

[Docs  Visit Aspire.RabbitMQ.Client documentation](/integrations/messaging/rabbitmq/)

![Icon for Aspire.Hosting.Azure.Functions integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.functions/13.1.1/icon) Aspire.Hosting.Azure.Functions

Azure Functions resource types for Aspire.

hostingazurefunctions +2

582k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.Functions package](https://www.nuget.org/packages/Aspire.Hosting.Azure.Functions)

[Docs  Visit Aspire.Hosting.Azure.Functions documentation](/integrations/cloud/azure/azure-functions/)

![Icon for Aspire.Hosting.Azure.OperationalInsights integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.operationalinsights/13.1.1/icon) Aspire.Hosting.Azure.OperationalInsights

Azure Log Analytics resource types for Aspire.

hostingazuremonitoring +2

572k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.OperationalInsights package](https://www.nuget.org/packages/Aspire.Hosting.Azure.OperationalInsights)

[Docs  Visit Aspire.Hosting.Azure.OperationalInsights documentation](/integrations/cloud/azure/overview/)

![Icon for Aspire.Hosting.Azure.CosmosDB integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.cosmosdb/13.1.1/icon) Aspire.Hosting.Azure.CosmosDB

Azure Cosmos DB resource types for Aspire.

hostingazurecosmosdb +4

536k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.CosmosDB package](https://www.nuget.org/packages/Aspire.Hosting.Azure.CosmosDB)

[Docs  Visit Aspire.Hosting.Azure.CosmosDB documentation](/integrations/cloud/azure/azure-cosmos-db/)

![Icon for Aspire.StackExchange.Redis.OutputCaching integration](https://api.nuget.org/v3-flatcontainer/aspire.stackexchange.redis.outputcaching/13.1.1/icon) Aspire.StackExchange.Redis.OutputCaching

A Redis® implementation for ASP.NET Core Output Caching that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloud +6

534k

Version 13.1.1

[Package  Visit Aspire.StackExchange.Redis.OutputCaching package](https://www.nuget.org/packages/Aspire.StackExchange.Redis.OutputCaching)

[Docs  Visit Aspire.StackExchange.Redis.OutputCaching documentation](/integrations/caching/redis-output/)

![Icon for Aspire.Azure.AI.OpenAI integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.ai.openai/13.1.1-preview.1.26105.8/icon) Aspire.Azure.AI.OpenAI

A client for Azure OpenAI that integrates with Aspire, including logging and telemetry.

clientcomponentcloud +3

454k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Azure.AI.OpenAI package](https://www.nuget.org/packages/Aspire.Azure.AI.OpenAI)

[Docs  Visit Aspire.Azure.AI.OpenAI documentation](/integrations/cloud/azure/azure-openai/)

![Icon for Aspire.Hosting.Kafka integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.kafka/13.1.1/icon) Aspire.Hosting.Kafka

Kafka support for Aspire.

hostingkafkamessagingeventing

442k

Version 13.1.1

[Package  Visit Aspire.Hosting.Kafka package](https://www.nuget.org/packages/Aspire.Hosting.Kafka)

[Docs  Visit Aspire.Hosting.Kafka documentation](/integrations/messaging/apache-kafka/)

![Icon for Aspire.Hosting.Azure.CognitiveServices integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.cognitiveservices/13.1.1/icon) Aspire.Hosting.Azure.CognitiveServices

Azure OpenAI resource types for Aspire.

hostingazureopenai +5

441k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.CognitiveServices package](https://www.nuget.org/packages/Aspire.Hosting.Azure.CognitiveServices)

[Docs  Visit Aspire.Hosting.Azure.CognitiveServices documentation](/integrations/cloud/azure/azure-openai/)

![Icon for Aspire.Hosting.Azure.ApplicationInsights integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.applicationinsights/13.1.1/icon) Aspire.Hosting.Azure.ApplicationInsights

Azure Application Insights resource types for Aspire.

hostingazuremonitoring +3

423k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.ApplicationInsights package](https://www.nuget.org/packages/Aspire.Hosting.Azure.ApplicationInsights)

[Docs  Visit Aspire.Hosting.Azure.ApplicationInsights documentation](/integrations/cloud/azure/overview/)

![Icon for Aspire.Hosting.Azure.AppContainers integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.appcontainers/13.1.1/icon) Aspire.Hosting.Azure.AppContainers

Azure container apps resource types for Aspire.

hostingazurecontainer +2

378k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.AppContainers package](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppContainers)

[Docs  Visit Aspire.Hosting.Azure.AppContainers documentation](/integrations/cloud/azure/configure-container-apps/)

![Icon for Aspire.Hosting.Azure.Sql integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.sql/13.1.1/icon) Aspire.Hosting.Azure.Sql

Azure SQL Database resource types for Aspire.

hostingazuresql +3

358k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.Sql package](https://www.nuget.org/packages/Aspire.Hosting.Azure.Sql)

[Docs  Visit Aspire.Hosting.Azure.Sql documentation](/integrations/cloud/azure/azure-sql-database/)

![Icon for Aspire.OpenAI integration](https://api.nuget.org/v3-flatcontainer/aspire.openai/13.1.1-preview.1.26105.8/icon) Aspire.OpenAI

A client for OpenAI that integrates with Aspire, including metrics and telemetry.

clientcomponentcloud +2

358k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.OpenAI package](https://www.nuget.org/packages/Aspire.OpenAI)

[Docs  Visit Aspire.OpenAI documentation](/integrations/ai/openai/)

![Icon for Aspire.Hosting.MongoDB integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.mongodb/13.1.1/icon) Aspire.Hosting.MongoDB

MongoDB support for Aspire.

hostingmongodbdatabasedata

357k

Version 13.1.1

[Package  Visit Aspire.Hosting.MongoDB package](https://www.nuget.org/packages/Aspire.Hosting.MongoDB)

[Docs  Visit Aspire.Hosting.MongoDB documentation](/integrations/databases/mongodb/mongodb-get-started/)

![Icon for Aspire.Seq integration](https://api.nuget.org/v3-flatcontainer/aspire.seq/13.1.1/icon) Aspire.Seq

A Seq client that connects an Aspire project's telemetry to Seq.

clientcomponentcloud +3

306k

Version 13.1.1

[Package  Visit Aspire.Seq package](https://www.nuget.org/packages/Aspire.Seq)

[Docs  Visit Aspire.Seq documentation](/integrations/observability/seq/)

![Icon for Aspire.Azure.Messaging.EventHubs integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.messaging.eventhubs/13.1.1/icon) Aspire.Azure.Messaging.EventHubs

A client for Azure Event Hubs that integrates with Aspire, including logging and telemetry.

clientcomponentcloud +5

302k

Version 13.1.1

[Package  Visit Aspire.Azure.Messaging.EventHubs package](https://www.nuget.org/packages/Aspire.Azure.Messaging.EventHubs)

[Docs  Visit Aspire.Azure.Messaging.EventHubs documentation](/integrations/cloud/azure/azure-event-hubs/)

![Icon for CommunityToolkit.Aspire.Hosting.Dapr integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.dapr/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Dapr

Dapr support for Aspire.

communitytoolkithostingdapr

298k

Version 13.0.0

[Package  Visit CommunityToolkit.Aspire.Hosting.Dapr package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Dapr)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Dapr documentation](/integrations/frameworks/dapr/)

![Icon for Aspire.Pomelo.EntityFrameworkCore.MySql integration](https://api.nuget.org/v3-flatcontainer/aspire.pomelo.entityframeworkcore.mysql/13.1.1/icon) Aspire.Pomelo.EntityFrameworkCore.MySql

A MySQL provider for Entity Framework Core that integrates with Aspire, including connection pooling, health checks, logging, and telemetry.

clientcomponentcloud +11

296k

Version 13.1.1

[Package  Visit Aspire.Pomelo.EntityFrameworkCore.MySql package](https://www.nuget.org/packages/Aspire.Pomelo.EntityFrameworkCore.MySql)

[Docs  Visit Aspire.Pomelo.EntityFrameworkCore.MySql documentation](/integrations/databases/efcore/mysql/mysql-get-started/)

![Icon for Aspire.Hosting.Keycloak integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.keycloak/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Keycloak

Keycloak support for Aspire.

hostingkeycloakauthentication +2

296k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Keycloak package](https://www.nuget.org/packages/Aspire.Hosting.Keycloak)

[Docs  Visit Aspire.Hosting.Keycloak documentation](/integrations/security/keycloak/)

![Icon for Aspire.Hosting.Azure.PostgreSQL integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.postgresql/13.1.1/icon) Aspire.Hosting.Azure.PostgreSQL

Azure PostgreSql Flexible Server resource types for Aspire.

hostingazurepostgresql +3

259k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.PostgreSQL package](https://www.nuget.org/packages/Aspire.Hosting.Azure.PostgreSQL)

[Docs  Visit Aspire.Hosting.Azure.PostgreSQL documentation](/integrations/cloud/azure/azure-postgresql/azure-postgresql-get-started/)

![Icon for Aspire.Hosting.Azure.Redis integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.redis/13.1.1/icon) Aspire.Hosting.Azure.Redis

Azure Redis resource types for Aspire.

hostingazureredis +3

252k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.Redis package](https://www.nuget.org/packages/Aspire.Hosting.Azure.Redis)

[Docs  Visit Aspire.Hosting.Azure.Redis documentation](/integrations/cloud/azure/azure-cache-redis/)

![Icon for Aspire.Hosting.AWS integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.aws/9.3.2/icon) Aspire.Hosting.AWS

Add support for provisioning AWS application resources and configuring the AWS SDK for .NET.

hostingaws

241k

Version 9.3.2

[Package  Visit Aspire.Hosting.AWS package](https://www.nuget.org/packages/Aspire.Hosting.AWS)

[Docs  Visit Aspire.Hosting.AWS documentation](https://docs.aws.amazon.com/sdk-for-net/v3/developer-guide/aspire-integrations.html)

![Icon for Aspire.Hosting.JavaScript integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.javascript/13.1.1/icon) Aspire.Hosting.JavaScript

JavaScript support for Aspire.

hostingnodenodejs +3

238k

Version 13.1.1

[Package  Visit Aspire.Hosting.JavaScript package](https://www.nuget.org/packages/Aspire.Hosting.JavaScript)

[Docs  Visit Aspire.Hosting.JavaScript documentation](/integrations/frameworks/javascript/)

![Icon for CommunityToolkit.Aspire.OllamaSharp integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.ollamasharp/13.1.2-beta.516/icon) CommunityToolkit.Aspire.OllamaSharp

An Aspire client integration for the OllamaSharp library.

communitytoolkitollamaai +2

237k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.OllamaSharp package](https://www.nuget.org/packages/CommunityToolkit.Aspire.OllamaSharp)

[Docs  Visit CommunityToolkit.Aspire.OllamaSharp documentation](/integrations/ai/ollama/)

![Icon for Aspire.Keycloak.Authentication integration](https://api.nuget.org/v3-flatcontainer/aspire.keycloak.authentication/13.1.1-preview.1.26105.8/icon) Aspire.Keycloak.Authentication

Configures Keycloak as the authentication provider for ASP.NET Core applications.

clientcomponentcloud +4

227k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Keycloak.Authentication package](https://www.nuget.org/packages/Aspire.Keycloak.Authentication)

[Docs  Visit Aspire.Keycloak.Authentication documentation](/integrations/security/keycloak/)

![Icon for Aspire.Hosting.Seq integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.seq/13.1.1/icon) Aspire.Hosting.Seq

Seq support for Aspire.

hostingseqobservabilitylogging

222k

Version 13.1.1

[Package  Visit Aspire.Hosting.Seq package](https://www.nuget.org/packages/Aspire.Hosting.Seq)

[Docs  Visit Aspire.Hosting.Seq documentation](/integrations/observability/seq/)

![Icon for Aspire.Azure.Search.Documents integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.search.documents/13.1.1/icon) Aspire.Azure.Search.Documents

A client for Azure AI Search that integrates with Aspire, including logging and telemetry.

clientcomponentcloud +4

219k

Version 13.1.1

[Package  Visit Aspire.Azure.Search.Documents package](https://www.nuget.org/packages/Aspire.Azure.Search.Documents)

[Docs  Visit Aspire.Azure.Search.Documents documentation](/integrations/cloud/azure/azure-ai-search/)

![Icon for CommunityToolkit.Aspire.Hosting.Ollama integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.ollama/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Ollama

An Aspire integration leveraging the Ollama container with support for downloading a model on startup.

communitytoolkithostingollamaai

204k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Ollama package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Ollama)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Ollama documentation](/integrations/ai/ollama/)

![Icon for Aspire.MongoDB.Driver integration](https://api.nuget.org/v3-flatcontainer/aspire.mongodb.driver/13.1.1/icon) Aspire.MongoDB.Driver

A generic MongoDB client that integrates with Aspire.

clientcomponentcloud +3

203k

Version 13.1.1

[Package  Visit Aspire.MongoDB.Driver package](https://www.nuget.org/packages/Aspire.MongoDB.Driver)

[Docs  Visit Aspire.MongoDB.Driver documentation](/integrations/databases/mongodb/mongodb-get-started/)

![Icon for Aspire.Hosting.Docker integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.docker/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Docker

Docker Compose publishing for Aspire.

hostingdockerdocker-compose

198k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Docker package](https://www.nuget.org/packages/Aspire.Hosting.Docker)

[Docs  Visit Aspire.Hosting.Docker documentation](/integrations/compute/docker/)

![Icon for Aspire.Hosting.Orleans integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.orleans/13.1.1/icon) Aspire.Hosting.Orleans

Orleans support for Aspire.

hostingorleansmessagingeventing

186k

Version 13.1.1

[Package  Visit Aspire.Hosting.Orleans package](https://www.nuget.org/packages/Aspire.Hosting.Orleans)

[Docs  Visit Aspire.Hosting.Orleans documentation](/integrations/frameworks/orleans/)

![Icon for Aspire.Hosting.Azure.AppConfiguration integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.appconfiguration/13.1.1/icon) Aspire.Hosting.Azure.AppConfiguration

Azure AppConfiguration resource types for Aspire.

hostingazureconfigurationcloud

182k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.AppConfiguration package](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppConfiguration)

[Docs  Visit Aspire.Hosting.Azure.AppConfiguration documentation](/integrations/cloud/azure/azure-app-configuration/)

![Icon for Aspire.Oracle.EntityFrameworkCore integration](https://api.nuget.org/v3-flatcontainer/aspire.oracle.entityframeworkcore/13.1.1/icon) Aspire.Oracle.EntityFrameworkCore

An Oracle Database provider for Entity Framework Core that integrates with Aspire, including connection pooling, health check, logging, and telemetry.

clientcomponentcloud +10

176k

Version 13.1.1

[Package  Visit Aspire.Oracle.EntityFrameworkCore package](https://www.nuget.org/packages/Aspire.Oracle.EntityFrameworkCore)

[Docs  Visit Aspire.Oracle.EntityFrameworkCore documentation](/integrations/databases/efcore/oracle/oracle-get-started/)

![Icon for Aspire.Hosting.MySql integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.mysql/13.1.1/icon) Aspire.Hosting.MySql

MySQL support for Aspire.

hostingmysqldatabasedata

169k

Version 13.1.1

[Package  Visit Aspire.Hosting.MySql package](https://www.nuget.org/packages/Aspire.Hosting.MySql)

[Docs  Visit Aspire.Hosting.MySql documentation](/integrations/databases/mysql/mysql-get-started/)

![Icon for Aspire.Hosting.Azure.EventHubs integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.eventhubs/13.1.1/icon) Aspire.Hosting.Azure.EventHubs

Azure Event Hubs resource types for Aspire.

hostingazureeventhubs +3

164k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.EventHubs package](https://www.nuget.org/packages/Aspire.Hosting.Azure.EventHubs)

[Docs  Visit Aspire.Hosting.Azure.EventHubs documentation](/integrations/cloud/azure/azure-event-hubs/)

![Icon for Aspire.Hosting.Valkey integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.valkey/13.1.1/icon) Aspire.Hosting.Valkey

Valkey® support for Aspire.

hostingvalkeycachecaching

157k

Version 13.1.1

[Package  Visit Aspire.Hosting.Valkey package](https://www.nuget.org/packages/Aspire.Hosting.Valkey)

[Docs  Visit Aspire.Hosting.Valkey documentation](/integrations/caching/valkey/)

![Icon for Aspire.Hosting.Azure.Search integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.search/13.1.1/icon) Aspire.Hosting.Azure.Search

Azure AI Search resource types for Aspire.

hostingazuresearch +3

139k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.Search package](https://www.nuget.org/packages/Aspire.Hosting.Azure.Search)

[Docs  Visit Aspire.Hosting.Azure.Search documentation](/integrations/cloud/azure/azure-ai-search/)

![Icon for CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.sqldatabaseprojects/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects

An Aspire hosting integration capable of deploying SQL Server Database Projects as part of your AppHost.

communitytoolkithostingsqlsqlproj

133k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects)

[Docs  Visit CommunityToolkit.Aspire.Hosting.SqlDatabaseProjects documentation](/integrations/devtools/sql-projects/)

![Icon for Aspire.Hosting.Python integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.python/13.1.1/icon) Aspire.Hosting.Python

Python support for Aspire.

hostingpythonframeworkruntime

130k

Version 13.1.1

[Package  Visit Aspire.Hosting.Python package](https://www.nuget.org/packages/Aspire.Hosting.Python)

[Docs  Visit Aspire.Hosting.Python documentation](/integrations/frameworks/python/)

![Icon for Aspire.Hosting.Elasticsearch integration](https://www.nuget.org/Content/gallery/img/default-package-icon.svg) Aspire.Hosting.Elasticsearch

Elasticsearch support for .NET Aspire.

hostingelasticsearch

116k

Version 13.1.0

[Package  Visit Aspire.Hosting.Elasticsearch package](https://www.nuget.org/packages/Aspire.Hosting.Elasticsearch)

[Docs  Visit Aspire.Hosting.Elasticsearch documentation](/integrations/databases/elasticsearch/elasticsearch-get-started/)

![Icon for Aspire.Microsoft.EntityFrameworkCore.Cosmos integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.entityframeworkcore.cosmos/13.1.1/icon) Aspire.Microsoft.EntityFrameworkCore.Cosmos

A Microsoft Azure Cosmos DB provider for Entity Framework Core that integrates with Aspire, including connection pooling, logging, and telemetry.

clientcomponentcloud +12

110k

Version 13.1.1

[Package  Visit Aspire.Microsoft.EntityFrameworkCore.Cosmos package](https://www.nuget.org/packages/Aspire.Microsoft.EntityFrameworkCore.Cosmos)

[Docs  Visit Aspire.Microsoft.EntityFrameworkCore.Cosmos documentation](/integrations/databases/efcore/azure-cosmos-db/azure-cosmos-db-get-started/)

![Icon for CommunityToolkit.Aspire.Hosting.MailPit integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.mailpit/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.MailPit

An Aspire component leveraging the MailPit container.

communitytoolkitmailpitsmtphosting

108k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.MailPit package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.MailPit)

[Docs  Visit CommunityToolkit.Aspire.Hosting.MailPit documentation](/integrations/devtools/mailpit/)

![Icon for CommunityToolkit.Aspire.Hosting.DbGate integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.dbgate/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.DbGate

An Aspire integration for dbgate hosting.

communitytoolkithostingdbgate

107k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.DbGate package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.DbGate)

![Icon for Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.extensions.configuration.azureappconfiguration/13.1.1/icon) Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration

A client for Azure App Configuration that integrates with Aspire.

clientcomponentcloud +3

102k

Version 13.1.1

[Package  Visit Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration package](https://www.nuget.org/packages/Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration)

[Docs  Visit Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration documentation](/integrations/cloud/azure/azure-app-configuration/)

![Icon for Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.npgsql.entityframeworkcore.postgresql/13.1.1/icon) Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL

An Azure Database for PostgreSQL® provider for Entity Framework Core that integrates with Aspire, including connection pooling, health checks, logging, and telemetry.

clientcomponentcloud +12

102k

Version 13.1.1

[Package  Visit Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL package](https://www.nuget.org/packages/Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL)

[Docs  Visit Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL documentation](/integrations/databases/efcore/azure-postgresql/)

![Icon for Aspire.Hosting.Qdrant integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.qdrant/13.1.1/icon) Aspire.Hosting.Qdrant

Qdrant vector database support for Aspire.

hostingqdrantvector +3

96k

Version 13.1.1

[Package  Visit Aspire.Hosting.Qdrant package](https://www.nuget.org/packages/Aspire.Hosting.Qdrant)

[Docs  Visit Aspire.Hosting.Qdrant documentation](/integrations/databases/qdrant/qdrant-get-started/)

![Icon for Aspire.Hosting.Yarp integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.yarp/13.1.1/icon) Aspire.Hosting.Yarp

YARP support for Aspire.

hostingyarpreverse-proxyapi

94k

Version 13.1.1

[Package  Visit Aspire.Hosting.Yarp package](https://www.nuget.org/packages/Aspire.Hosting.Yarp)

[Docs  Visit Aspire.Hosting.Yarp documentation](/integrations/reverse-proxies/yarp/)

![Icon for Aspire.Hosting.Azure.SignalR integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.signalr/13.1.1/icon) Aspire.Hosting.Azure.SignalR

Azure SignalR resource types for Aspire.

hostingazuresignalr +2

92k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.SignalR package](https://www.nuget.org/packages/Aspire.Hosting.Azure.SignalR)

[Docs  Visit Aspire.Hosting.Azure.SignalR documentation](/integrations/cloud/azure/azure-signalr/)

![Icon for Aspire.Hosting.Azure.ContainerRegistry integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.containerregistry/13.1.1/icon) Aspire.Hosting.Azure.ContainerRegistry

Azure Container Registry resource types for Aspire.

hostingazurecontainer +2

86k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.ContainerRegistry package](https://www.nuget.org/packages/Aspire.Hosting.Azure.ContainerRegistry)

[Docs  Visit Aspire.Hosting.Azure.ContainerRegistry documentation](/integrations/cloud/azure/azure-container-registry/)

![Icon for CommunityToolkit.Aspire.Hosting.Adminer integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.adminer/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Adminer

An Aspire integration for adminer hosting.

communitytoolkithostingadminer

74k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Adminer package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Adminer)

![Icon for CommunityToolkit.Aspire.Hosting.SqlServer.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.sqlserver.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.SqlServer.Extensions

An Aspire integration for extending sqlserver hosting.

communitytoolkithostingsqlserverdbgate

74k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.SqlServer.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.SqlServer.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.SqlServer.Extensions documentation](/integrations/databases/sql-server/sql-server-extensions/)

![Icon for Aspire.Qdrant.Client integration](https://api.nuget.org/v3-flatcontainer/aspire.qdrant.client/13.1.1/icon) Aspire.Qdrant.Client

A Qdrant client that integrates with Aspire, including logging.

clientcomponentcloud +4

72k

Version 13.1.1

[Package  Visit Aspire.Qdrant.Client package](https://www.nuget.org/packages/Aspire.Qdrant.Client)

[Docs  Visit Aspire.Qdrant.Client documentation](/integrations/databases/qdrant/qdrant-get-started/)

![Icon for CommunityToolkit.Aspire.Hosting.Golang integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.golang/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Golang

An Aspire integration for hosting Golang apps.

communitytoolkithostinggolang

69k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Golang package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Golang)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Golang documentation](/integrations/frameworks/go-apps/)

![Icon for CommunityToolkit.Aspire.Hosting.Ngrok integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.ngrok/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Ngrok

An Aspire integration for exposing hosted applications via secure, public URLs using ngrok.

communitytoolkithostingngroktunnels

64k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Ngrok package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Ngrok)

![Icon for Aspire.Hosting.DevTunnels integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.devtunnels/13.1.1/icon) Aspire.Hosting.DevTunnels

DevTunnels support for Aspire.

hostingdevtunnels

63k

Version 13.1.1

[Package  Visit Aspire.Hosting.DevTunnels package](https://www.nuget.org/packages/Aspire.Hosting.DevTunnels)

[Docs  Visit Aspire.Hosting.DevTunnels documentation](/integrations/devtools/dev-tunnels/)

![Icon for Aspire.NATS.Net integration](https://api.nuget.org/v3-flatcontainer/aspire.nats.net/13.1.1/icon) Aspire.NATS.Net

A NATS client that integrates with Aspire, including health checks and logging.

clientcomponentcloud +3

63k

Version 13.1.1

[Package  Visit Aspire.NATS.Net package](https://www.nuget.org/packages/Aspire.NATS.Net)

[Docs  Visit Aspire.NATS.Net documentation](/integrations/messaging/nats/)

![Icon for CommunityToolkit.Aspire.MassTransit.RabbitMQ integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.masstransit.rabbitmq/13.1.2-beta.516/icon) CommunityToolkit.Aspire.MassTransit.RabbitMQ

An Aspire client integration for MassTransit RabbitMQ.

communitytoolkitclientmasstransitrabbitmq

59k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.MassTransit.RabbitMQ package](https://www.nuget.org/packages/CommunityToolkit.Aspire.MassTransit.RabbitMQ)

[Docs  Visit CommunityToolkit.Aspire.MassTransit.RabbitMQ documentation](/integrations/messaging/rabbitmq/)

![Icon for Aspire.Hosting.Nats integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.nats/13.1.1/icon) Aspire.Hosting.Nats

NATS support for Aspire.

hostingnatsmessagingeventing

59k

Version 13.1.1

[Package  Visit Aspire.Hosting.Nats package](https://www.nuget.org/packages/Aspire.Hosting.Nats)

[Docs  Visit Aspire.Hosting.Nats documentation](/integrations/messaging/nats/)

![Icon for CommunityToolkit.Aspire.Hosting.Python.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.python.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Python.Extensions

An Aspire integration for hosting Uvicorn apps.

communitytoolkithostinguvicornpython

59k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Python.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Python.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Python.Extensions documentation](/integrations/frameworks/python/)

![Icon for CommunityToolkit.Aspire.Meilisearch integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.meilisearch/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Meilisearch

A Meilisearch client that integrates with Aspire, including health checks, logging, and telemetry.

communitytoolkitmeilisearchclient

58k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Meilisearch package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Meilisearch)

[Docs  Visit CommunityToolkit.Aspire.Meilisearch documentation](/integrations/databases/meilisearch/)

![Icon for CommunityToolkit.Aspire.Hosting.Bun integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.bun/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Bun

An Aspire integration for hosting Bun apps.

communitytoolkithostingbunjavascript

58k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Bun package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Bun)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Bun documentation](/integrations/frameworks/bun-apps/)

![Icon for CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.postgresql.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions

An Aspire integration for extending postgres hosting.

communitytoolkithostingpostgresdbgate

57k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.PostgreSQL.Extensions documentation](/integrations/databases/postgres/postgresql-extensions/)

![Icon for CommunityToolkit.Aspire.Hosting.Java integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.java/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Java

An Aspire integration for hosting Java apps using either the Java executable or container image.

communitytoolkithostingjava

57k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Java package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Java)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Java documentation](/integrations/frameworks/java/)

![Icon for CommunityToolkit.Aspire.Hosting.Sqlite integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.sqlite/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Sqlite

An Aspire hosting integration for providing a Sqlite database connection.

communitytoolkithostingsqlsqlite

56k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Sqlite package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Sqlite)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Sqlite documentation](/integrations/databases/sqlite/sqlite-host/)

![Icon for CommunityToolkit.Aspire.RavenDB.Client integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.ravendb.client/13.1.2-beta.516/icon) CommunityToolkit.Aspire.RavenDB.Client

An Aspire client integration for the RavenDB.Client library.

communitytoolkitclientravendb

54k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.RavenDB.Client package](https://www.nuget.org/packages/CommunityToolkit.Aspire.RavenDB.Client)

[Docs  Visit CommunityToolkit.Aspire.RavenDB.Client documentation](/integrations/databases/ravendb/)

![Icon for CommunityToolkit.Aspire.Hosting.Minio integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.minio/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Minio

An Aspire hosting integration for MinIO

communitytoolkitminiohosting +2

54k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Minio package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Minio)

![Icon for CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.azure.dataapibuilder/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder

An Aspire component leveraging the Data API Builder container.

communitytoolkitapidataapibuilderhosting

54k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Azure.DataApiBuilder documentation](/integrations/devtools/dab/)

![Icon for CommunityToolkit.Aspire.Hosting.Meilisearch integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.meilisearch/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Meilisearch

Meilisearch support for Aspire.

communitytoolkithostingmeilisearch

52k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Meilisearch package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Meilisearch)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Meilisearch documentation](/integrations/databases/meilisearch/)

![Icon for CommunityToolkit.Aspire.Hosting.Deno integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.deno/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Deno

An Aspire integration for hosting Deno apps.

communitytoolkithostingdeno

52k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Deno package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Deno)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Deno documentation](/integrations/frameworks/deno-apps/)

![Icon for CommunityToolkit.Aspire.Microsoft.EntityFrameworkCore.Sqlite integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.microsoft.entityframeworkcore.sqlite/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Microsoft.EntityFrameworkCore.Sqlite

An Aspire client integration for the Microsoft.EntityFrameworkCore.Sqlite package.

communitytoolkitclientsqlite +5

51k

Version 9.7.2

[Package  Visit CommunityToolkit.Aspire.Microsoft.EntityFrameworkCore.Sqlite package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Microsoft.EntityFrameworkCore.Sqlite)

[Docs  Visit CommunityToolkit.Aspire.Microsoft.EntityFrameworkCore.Sqlite documentation](/integrations/databases/sqlite/sqlite-client/)

![Icon for CommunityToolkit.Aspire.Hosting.ActiveMQ integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.activemq/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.ActiveMQ

An Aspire hosting package for hosting ActiveMQ.

communitytoolkithostingactivemq

51k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.ActiveMQ package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.ActiveMQ)

![Icon for CommunityToolkit.Aspire.Hosting.Rust integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.rust/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Rust

An Aspire integration for hosting Rust apps.

communitytoolkithostingrust

50k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Rust package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Rust)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Rust documentation](/integrations/frameworks/rust/)

![Icon for CommunityToolkit.Aspire.Hosting.Redis.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.redis.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Redis.Extensions

An Aspire integration for extending redis hosting.

communitytoolkithostingredisdbgate

49k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Redis.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Redis.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Redis.Extensions documentation](/integrations/caching/redis-extensions/)

![Icon for CommunityToolkit.Aspire.Hosting.RavenDB integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.ravendb/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.RavenDB

An Aspire integration leveraging the RavenDB container.

communitytoolkithostingravendb

49k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.RavenDB package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.RavenDB)

[Docs  Visit CommunityToolkit.Aspire.Hosting.RavenDB documentation](/integrations/databases/ravendb/)

![Icon for Aspire.Azure.Npgsql integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.npgsql/13.1.1/icon) Aspire.Azure.Npgsql

A client for Azure Database for PostgreSQL® that integrates with Aspire, including health checks, logging and telemetry.

clientcomponentcloud +7

48k

Version 13.1.1

[Package  Visit Aspire.Azure.Npgsql package](https://www.nuget.org/packages/Aspire.Azure.Npgsql)

[Docs  Visit Aspire.Azure.Npgsql documentation](/integrations/cloud/azure/azure-postgresql/azure-postgresql-get-started/)

![Icon for Aspire.Hosting.Garnet integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.garnet/13.1.1/icon) Aspire.Hosting.Garnet

Garnet® support for Aspire.

hostinggarnetcachecaching

47k

Version 13.1.1

[Package  Visit Aspire.Hosting.Garnet package](https://www.nuget.org/packages/Aspire.Hosting.Garnet)

[Docs  Visit Aspire.Hosting.Garnet documentation](/integrations/caching/garnet/)

![Icon for CommunityToolkit.Aspire.Hosting.Azure.Dapr integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.azure.dapr/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Azure.Dapr

Azure Dapr support for Aspire.

communitytoolkithostingdaprazure

46k

Version 13.0.0

[Package  Visit CommunityToolkit.Aspire.Hosting.Azure.Dapr package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Azure.Dapr)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Azure.Dapr documentation](/integrations/frameworks/dapr/)

![Icon for CommunityToolkit.Aspire.Hosting.MongoDB.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.mongodb.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.MongoDB.Extensions

An Aspire integration for extending mongodb hosting.

communitytoolkithostingmongodbdbgate

46k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.MongoDB.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.MongoDB.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.MongoDB.Extensions documentation](/integrations/databases/mongodb/mongodb-extensions/)

![Icon for CommunityToolkit.Aspire.Hosting.PapercutSmtp integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.papercutsmtp/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.PapercutSmtp

An Aspire component leveraging Papercut SMTP container.

communitytoolkitpapercutsmtphosting

42k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.PapercutSmtp package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.PapercutSmtp)

![Icon for CommunityToolkit.Aspire.Microsoft.Data.Sqlite integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.microsoft.data.sqlite/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Microsoft.Data.Sqlite

An Aspire client integration for the Microsoft.Data.Sqlite.Core package.

communitytoolkitclientsqlite +2

42k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Microsoft.Data.Sqlite package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Microsoft.Data.Sqlite)

[Docs  Visit CommunityToolkit.Aspire.Microsoft.Data.Sqlite documentation](/integrations/databases/sqlite/sqlite-client/)

![Icon for Aspire.Elastic.Clients.Elasticsearch integration](https://www.nuget.org/Content/gallery/img/default-package-icon.svg) Aspire.Elastic.Clients.Elasticsearch

A Elasticsearch client that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloudelasticsearch

41k

Version 13.1.0

[Package  Visit Aspire.Elastic.Clients.Elasticsearch package](https://www.nuget.org/packages/Aspire.Elastic.Clients.Elasticsearch)

[Docs  Visit Aspire.Elastic.Clients.Elasticsearch documentation](/integrations/databases/elasticsearch/elasticsearch-get-started/)

![Icon for Aspire.Hosting.Kubernetes integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.kubernetes/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Kubernetes

Kubernetes publishing for Aspire.

hostingkubernetes

41k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Kubernetes package](https://www.nuget.org/packages/Aspire.Hosting.Kubernetes)

[Docs  Visit Aspire.Hosting.Kubernetes documentation](/integrations/compute/kubernetes/)

![Icon for CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.azure.staticwebapps/9.5.1-beta.315/icon) CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps

A hosting package that wraps endpoints with the Azure Static Web Apps emulator.

communitytoolkitazurestaticwebappshosting

39k

Version 9.4.0

[Package  Visit CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Azure.StaticWebApps documentation](/integrations/cloud/azure/overview/)

![Icon for CommunityToolkit.Aspire.GoFeatureFlag integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.gofeatureflag/13.1.2-beta.516/icon) CommunityToolkit.Aspire.GoFeatureFlag

A GO Feature Flag client that integrates with Aspire, including health checks, logging, and telemetry.

communitytoolkitgofeatureflagclient

39k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.GoFeatureFlag package](https://www.nuget.org/packages/CommunityToolkit.Aspire.GoFeatureFlag)

[Docs  Visit CommunityToolkit.Aspire.GoFeatureFlag documentation](/integrations/frameworks/go-apps/)

![Icon for CommunityToolkit.Aspire.Hosting.GoFeatureFlag integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.gofeatureflag/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.GoFeatureFlag

GO Feature Flag support for Aspire.

communitytoolkithostinggofeatureflag

38k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.GoFeatureFlag package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.GoFeatureFlag)

[Docs  Visit CommunityToolkit.Aspire.Hosting.GoFeatureFlag documentation](/integrations/frameworks/go-apps/)

![Icon for CommunityToolkit.Aspire.Hosting.Azure.Dapr.Redis integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.azure.dapr.redis/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Azure.Dapr.Redis

Package Description

communitytoolkit

37k

Version 13.0.0

[Package  Visit CommunityToolkit.Aspire.Hosting.Azure.Dapr.Redis package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Azure.Dapr.Redis)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Azure.Dapr.Redis documentation](/integrations/frameworks/dapr/)

![Icon for CommunityToolkit.Aspire.Hosting.LavinMQ integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.lavinmq/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.LavinMQ

An Aspire hosting package for hosting LavinMQ.

communitytoolkithostinglavinmq

36k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.LavinMQ package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.LavinMQ)

[Docs  Visit CommunityToolkit.Aspire.Hosting.LavinMQ documentation](/integrations/messaging/lavinmq/)

![Icon for CommunityToolkit.Aspire.Hosting.k6 integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.k6/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.k6

Grafana k6 support for Aspire.

communitytoolkithostingk6

34k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.k6 package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.k6)

![Icon for Aspire.Hosting.Oracle integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.oracle/13.1.1/icon) Aspire.Hosting.Oracle

Oracle Database support for Aspire.

hostingoraclesql +2

33k

Version 13.1.1

[Package  Visit Aspire.Hosting.Oracle package](https://www.nuget.org/packages/Aspire.Hosting.Oracle)

[Docs  Visit Aspire.Hosting.Oracle documentation](/integrations/databases/efcore/oracle/oracle-get-started/)

![Icon for Aspire.Azure.Messaging.WebPubSub integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.messaging.webpubsub/13.1.1/icon) Aspire.Azure.Messaging.WebPubSub

A service client for Azure Web PubSub that integrates with Aspire, including health checks, logging and telemetry.

clientcomponentcloud +5

33k

Version 13.1.1

[Package  Visit Aspire.Azure.Messaging.WebPubSub package](https://www.nuget.org/packages/Aspire.Azure.Messaging.WebPubSub)

[Docs  Visit Aspire.Azure.Messaging.WebPubSub documentation](/integrations/cloud/azure/azure-web-pubsub/)

![Icon for CommunityToolkit.Aspire.Minio.Client integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.minio.client/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Minio.Client

An Aspire client integration for MinIO

communitytoolkitminiohosting +2

29k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Minio.Client package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Minio.Client)

![Icon for CommunityToolkit.Aspire.Hosting.PowerShell integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.powershell/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.PowerShell

Run powershell scripts in-process with your Aspire AppHost, injecting aspire resources and/or object instances as variables, using the command lines tools of your choice like azure cli, azd, or any other terminal tools.

communitytoolkitpowershellpwsh +3

28k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.PowerShell package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.PowerShell)

[Docs  Visit CommunityToolkit.Aspire.Hosting.PowerShell documentation](/integrations/frameworks/powershell/)

![Icon for Aspire.Hosting.Azure.AIFoundry integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.aifoundry/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Azure.AIFoundry

Azure AI Foundry resource types for Aspire.

hostingazureopenai +5

28k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Azure.AIFoundry package](https://www.nuget.org/packages/Aspire.Hosting.Azure.AIFoundry)

[Docs  Visit Aspire.Hosting.Azure.AIFoundry documentation](/integrations/cloud/azure/azure-ai-foundry/)

![Icon for CommunityToolkit.Aspire.Hosting.McpInspector integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.mcpinspector/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.McpInspector

An Aspire to run the MCP Inspector against a MCP server.

communitytoolkitaimcp +2

27k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.McpInspector package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.McpInspector)

![Icon for CommunityToolkit.Aspire.Hosting.MySql.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.mysql.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.MySql.Extensions

An Aspire integration for extending mysql hosting.

communitytoolkithostingmysqldbgate

24k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.MySql.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.MySql.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.MySql.Extensions documentation](/integrations/databases/mysql/mysql-extensions/)

![Icon for Aspire.Hosting.Azure.WebPubSub integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.webpubsub/13.1.1/icon) Aspire.Hosting.Azure.WebPubSub

Azure WebPubSub resource types for Aspire.

hostingazurewebpubsub +4

22k

Version 13.1.1

[Package  Visit Aspire.Hosting.Azure.WebPubSub package](https://www.nuget.org/packages/Aspire.Hosting.Azure.WebPubSub)

[Docs  Visit Aspire.Hosting.Azure.WebPubSub documentation](/integrations/cloud/azure/azure-web-pubsub/)

![Icon for Aspire.Azure.AI.Inference integration](https://api.nuget.org/v3-flatcontainer/aspire.azure.ai.inference/13.1.1-preview.1.26105.8/icon) Aspire.Azure.AI.Inference

A client for Azure AI Inference SDK that integrates with Aspire, including logging and telemetry.

clientcomponentcloud +4

20k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Azure.AI.Inference package](https://www.nuget.org/packages/Aspire.Azure.AI.Inference)

[Docs  Visit Aspire.Azure.AI.Inference documentation](/integrations/cloud/azure/azure-ai-inference/)

![Icon for Aspire.Hosting.OpenAI integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.openai/13.1.1/icon) Aspire.Hosting.OpenAI

OpenAI resource types for Aspire.

hostingopenaiai

19k

Version 13.1.1

[Package  Visit Aspire.Hosting.OpenAI package](https://www.nuget.org/packages/Aspire.Hosting.OpenAI)

[Docs  Visit Aspire.Hosting.OpenAI documentation](/integrations/ai/openai/)

![Icon for Aspire.Microsoft.Azure.StackExchangeRedis integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.azure.stackexchangeredis/13.1.1-preview.1.26105.8/icon) Aspire.Microsoft.Azure.StackExchangeRedis

An Azure Cache for Redis® client that integrates with Aspire, including Azure AD authentication, health checks, logging and telemetry.

clientcomponentcloud +4

18k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Microsoft.Azure.StackExchangeRedis package](https://www.nuget.org/packages/Aspire.Microsoft.Azure.StackExchangeRedis)

[Docs  Visit Aspire.Microsoft.Azure.StackExchangeRedis documentation](/integrations/cloud/azure/azure-cache-redis/)

![Icon for Aspire.Hosting.Azure.AppService integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.appservice/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Azure.AppService

Azure app service resource types for Aspire.

hostingazurecloudappservice

18k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Azure.AppService package](https://www.nuget.org/packages/Aspire.Hosting.Azure.AppService)

[Docs  Visit Aspire.Hosting.Azure.AppService documentation](/integrations/cloud/azure/azure-app-service/)

![Icon for CommunityToolkit.Aspire.Hosting.JavaScript.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.javascript.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.JavaScript.Extensions

An Aspire integration for hosting NodeJS apps using Vite, Yarn, PNPM, or NPM.

communitytoolkithostingnodejs +4

17k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.JavaScript.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.JavaScript.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.JavaScript.Extensions documentation](/integrations/frameworks/nodejs-extensions/)

![Icon for CommunityToolkit.Aspire.Hosting.SurrealDb integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.surrealdb/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.SurrealDb

SurrealDB support for Aspire.

communitytoolkithostingsurrealdb

16k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.SurrealDb package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.SurrealDb)

![Icon for CommunityToolkit.Aspire.SurrealDb integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.surrealdb/13.1.2-beta.516/icon) CommunityToolkit.Aspire.SurrealDb

A SurrealDB client that integrates with Aspire, including health checks, logging, and telemetry.

communitytoolkitsurrealdbclient

16k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.SurrealDb package](https://www.nuget.org/packages/CommunityToolkit.Aspire.SurrealDb)

![Icon for CommunityToolkit.Aspire.Hosting.OpenTelemetryCollector integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.opentelemetrycollector/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.OpenTelemetryCollector

An Aspire component to add an OpenTelemetry Collector into the OTLP pipeline

communitytoolkitopentelemetryobservability

12k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.OpenTelemetryCollector package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.OpenTelemetryCollector)

![Icon for CommunityToolkit.Aspire.Hosting.Solr integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.solr/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Solr

An Aspire hosting integration for Apache Solr.

communitytoolkit

10k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Solr package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Solr)

![Icon for CommunityToolkit.Aspire.Hosting.Flagd integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.flagd/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Flagd

flagd is a feature flag evaluation engine. Think of it as a ready-made, open source, OpenFeature-compliant feature flag backend system.

communitytoolkithostingflagd +2

9k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Flagd package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Flagd)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Flagd documentation](/integrations/devtools/flagd/)

![Icon for Aspire.Hosting.Milvus integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.milvus/13.1.1/icon) Aspire.Hosting.Milvus

Milvus vector database support for Aspire.

hostingmilvusdatabase +4

9k

Version 13.1.1

[Package  Visit Aspire.Hosting.Milvus package](https://www.nuget.org/packages/Aspire.Hosting.Milvus)

[Docs  Visit Aspire.Hosting.Milvus documentation](/integrations/databases/milvus/milvus-get-started/)

![Icon for Aspire.Hosting.GitHub.Models integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.github.models/13.1.1/icon) Aspire.Hosting.GitHub.Models

GitHub Models resource types for Aspire.

hostinggithubmodelsai

8k

Version 13.1.1

[Package  Visit Aspire.Hosting.GitHub.Models package](https://www.nuget.org/packages/Aspire.Hosting.GitHub.Models)

[Docs  Visit Aspire.Hosting.GitHub.Models documentation](/integrations/ai/github-models/)

![Icon for Aspire.Hosting.Maui integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.maui/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Maui

MAUI integration for Aspire (local dev only)

mauihosting

7k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Maui package](https://www.nuget.org/packages/Aspire.Hosting.Maui)

[Docs  Visit Aspire.Hosting.Maui documentation](/integrations/frameworks/maui/)

![Icon for CommunityToolkit.Aspire.Hosting.KurrentDB integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.kurrentdb/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.KurrentDB

KurrentDB support for Aspire.

communitytoolkithostingkurrentdb

7k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.KurrentDB package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.KurrentDB)

[Docs  Visit CommunityToolkit.Aspire.Hosting.KurrentDB documentation](/integrations/databases/kurrentdb/)

![Icon for CommunityToolkit.Aspire.KurrentDB integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.kurrentdb/13.1.2-beta.516/icon) CommunityToolkit.Aspire.KurrentDB

A KurrentDB client that integrates with Aspire, including health checks, logging, and telemetry.

communitytoolkitkurrentdbclient

7k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.KurrentDB package](https://www.nuget.org/packages/CommunityToolkit.Aspire.KurrentDB)

[Docs  Visit CommunityToolkit.Aspire.KurrentDB documentation](/integrations/databases/kurrentdb/)

![Icon for Aspire.Milvus.Client integration](https://api.nuget.org/v3-flatcontainer/aspire.milvus.client/13.1.1-preview.1.26105.8/icon) Aspire.Milvus.Client

A Milvus client that integrates with Aspire, including logging.

clientcomponentcloud +5

7k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Milvus.Client package](https://www.nuget.org/packages/Aspire.Milvus.Client)

[Docs  Visit Aspire.Milvus.Client documentation](/integrations/databases/milvus/milvus-get-started/)

![Icon for CommunityToolkit.Aspire.Hosting.Keycloak.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.keycloak.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Keycloak.Extensions

Aspire hosting extensions for Keycloak (includes PostgreSQL integration).

communitytoolkitkeycloakpostgres +2

6k

Version 13.1.2-beta.516

[Package  Visit CommunityToolkit.Aspire.Hosting.Keycloak.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Keycloak.Extensions)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Keycloak.Extensions documentation](/integrations/security/keycloak/)

![Icon for CommunityToolkit.Aspire.Hosting.Dapr.AzureRedis integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.dapr.azureredis/9.1.1-beta.197/icon) CommunityToolkit.Aspire.Hosting.Dapr.AzureRedis

Package Description

communitytoolkit

3k

Version 9.1.1-beta.197

[Package  Visit CommunityToolkit.Aspire.Hosting.Dapr.AzureRedis package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Dapr.AzureRedis)

[Docs  Visit CommunityToolkit.Aspire.Hosting.Dapr.AzureRedis documentation](/integrations/frameworks/dapr/)

![Icon for CommunityToolkit.Aspire.Hosting.Flyway integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.flyway/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Flyway

An Aspire integration for Flyway database migration tool.

communitytoolkithostingflywaymigration

3k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Flyway package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Flyway)

![Icon for Aspire.Hosting.Azure.Kusto integration](https://api.nuget.org/v3-flatcontainer/aspire.hosting.azure.kusto/13.1.1-preview.1.26105.8/icon) Aspire.Hosting.Azure.Kusto

Azure Kusto support for Aspire.

hostingazurekusto +3

3k

Version 13.1.1-preview\.1.26105.8

[Package  Visit Aspire.Hosting.Azure.Kusto package](https://www.nuget.org/packages/Aspire.Hosting.Azure.Kusto)

[Docs  Visit Aspire.Hosting.Azure.Kusto documentation](/integrations/cloud/azure/overview/)

![Icon for Aspire.RabbitMQ.Client.v6 integration](https://api.nuget.org/v3-flatcontainer/aspire.rabbitmq.client.v6/13.1.1/icon) Aspire.RabbitMQ.Client.v6

A RabbitMQ client (versions 6.x) that integrates with Aspire, including health checks, logging, and telemetry.

clientcomponentcloud +6

2k

Version 13.1.1

[Package  Visit Aspire.RabbitMQ.Client.v6 package](https://www.nuget.org/packages/Aspire.RabbitMQ.Client.v6)

[Docs  Visit Aspire.RabbitMQ.Client.v6 documentation](/integrations/messaging/rabbitmq/)

![Icon for Aspire.MongoDB.Driver.v2 integration](https://api.nuget.org/v3-flatcontainer/aspire.mongodb.driver.v2/13.1.1/icon) Aspire.MongoDB.Driver.v2

A generic MongoDB client (versions 2.x) that integrates with Aspire.

clientcomponentcloud +3

2k

Version 13.1.1

[Package  Visit Aspire.MongoDB.Driver.v2 package](https://www.nuget.org/packages/Aspire.MongoDB.Driver.v2)

[Docs  Visit Aspire.MongoDB.Driver.v2 documentation](/integrations/databases/mongodb/mongodb-get-started/)

![Icon for Aspire.Microsoft.AspNetCore.SystemWebAdapters integration](https://api.nuget.org/v3-flatcontainer/aspire.microsoft.aspnetcore.systemwebadapters/2.3.0-preview.1.26110.2/icon) Aspire.Microsoft.AspNetCore.SystemWebAdapters

Aspire integration for Microsoft.AspNetCore.SystemWebAdapters to support incremental migration scenarios.

1k

Version 2.3.0-preview\.1.26110.2

[Package  Visit Aspire.Microsoft.AspNetCore.SystemWebAdapters package](https://www.nuget.org/packages/Aspire.Microsoft.AspNetCore.SystemWebAdapters)

![Icon for CommunityToolkit.Aspire.Hosting.Sftp integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.sftp/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Sftp

Aspire hosting integration for the atmoz SFTP container image.

communitytoolkitatmozsftphosting

1k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Sftp package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Sftp)

![Icon for CommunityToolkit.Aspire.Hosting.Stripe integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.stripe/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Stripe

An Aspire integration for the Stripe CLI for local webhook forwarding and testing.

communitytoolkithostingstripe +2

1k

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Stripe package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Stripe)

![Icon for CommunityToolkit.Aspire.Hosting.Elasticsearch.Extensions integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.hosting.elasticsearch.extensions/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Hosting.Elasticsearch.Extensions

An Aspire integration for extending Elasticsearch hosting.

communitytoolkithostingelasticsearchelasticvue

985

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Hosting.Elasticsearch.Extensions package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.Elasticsearch.Extensions)

![Icon for CommunityToolkit.Aspire.Sftp integration](https://api.nuget.org/v3-flatcontainer/communitytoolkit.aspire.sftp/13.1.2-beta.516/icon) CommunityToolkit.Aspire.Sftp

An SFTP client that integrates with Aspire, including health checks, logging, and telemetry.

communitytoolkitsftpclient

811

Version 13.1.1

[Package  Visit CommunityToolkit.Aspire.Sftp package](https://www.nuget.org/packages/CommunityToolkit.Aspire.Sftp)

No integrations found

Try searching for things like "SQL", "Cache", or "Testing" to discover integrations!

# Apache Kafka integration

> Learn how to use the Apache Kafka integration, which includes both hosting and client integrations.

![Apache Kafka logo](/_astro/apache-kafka-icon.SnHW5mZV_Z1NYjKL.svg)

[Apache Kafka](https://kafka.apache.org/) is a distributed streaming platform that enables you to build real-time data pipelines and streaming applications. The Aspire Apache Kafka integration enables you to connect to existing Kafka instances or create new instances from Aspire with the [`confluentinc/confluent-local` container image](https://hub.docker.com/r/confluentinc/confluent-local).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Apache Kafka hosting integration models a Kafka resource as the `KafkaServerResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Kafka](https://www.nuget.org/packages/Aspire.Hosting.Kafka) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Kafka package

  ```bash
  aspire add kafka
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > kafka (Aspire.Hosting.Kafka)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Kafka@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Kafka package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Kafka" Version="*" />
  ```

### Add Kafka server resource

[Section titled “Add Kafka server resource”](#add-kafka-server-resource)

In your AppHost project, call `AddKafka` on the builder instance to add a Kafka server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kafka = builder.AddKafka("kafka");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kafka);


// After adding all resources, run the app...
```

When Aspire adds a container image to the AppHost, it creates a new Kafka server instance on your local machine.

Tip

If you’d rather connect to an existing Kafka server, call `AddConnectionString` instead. For more information on how to use `WithReference`, see [Resource dependencies](/get-started/resources/) and [Configuration injection](/get-started/app-host/).

### Add Kafka UI

[Section titled “Add Kafka UI”](#add-kafka-ui)

To add the [Kafka UI](https://hub.docker.com/r/kafbat/kafka-ui) to the Kafka server resource, call the `WithKafkaUI` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kafka = builder.AddKafka("kafka")
                   .WithKafkaUI();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kafka);
```

The Kafka UI is a free, open-source web UI to monitor and manage Apache Kafka clusters.

### Change the Kafka UI host port

[Section titled “Change the Kafka UI host port”](#change-the-kafka-ui-host-port)

To change the Kafka UI host port, chain a call to the `WithHostPort` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kafka = builder.AddKafka("kafka")
                   .WithKafkaUI(kafkaUI => kafkaUI.WithHostPort(9100));


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kafka);
```

### Add Kafka server resource with data volume

[Section titled “Add Kafka server resource with data volume”](#add-kafka-server-resource-with-data-volume)

To add a data volume to the Kafka server resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var kafka = builder.AddKafka("kafka")
                   .WithDataVolume(isReadOnly: false);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(kafka);
```

The data volume is used to persist the Kafka server data outside the lifecycle of its container.

### Work with larger Kafka clusters

[Section titled “Work with larger Kafka clusters”](#work-with-larger-kafka-clusters)

The Aspire Kafka integration deploys a container from the confluentinc/confluent-local image to your local container host. This image provides a simple Apache Kafka cluster that runs in KRaft mode and requires no further configuration. It’s ideal for developing and testing producers and consumers. However, this image is for local experimentation only and isn’t supported by Confluent.

In the following AppHost code, a local container is used in run mode. At other times, a connection string provides URLs and port numbers for the Kafka brokers:

```csharp
var kafka = builder.ExecutionContext.IsRunMode
    ? builder.AddKafka("kafka").WithKafkaUI()
    : builder.AddConnectionString("kafka");
```

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a Kafka resource using `WithReference`, the following connection properties are made available to the consuming project:

#### Kafka server

[Section titled “Kafka server”](#kafka-server)

The Kafka server resource exposes the following connection properties:

| Property Name | Description                                           |
| ------------- | ----------------------------------------------------- |
| `Host`        | The host-facing Kafka listener hostname or IP address |
| `Port`        | The host-facing Kafka listener port                   |

**Example properties:**

```plaintext
Host: localhost
Port: 9092
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Host` property of a resource called `kafka` becomes `KAFKA_HOST`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Kafka hosting integration automatically adds a health check for the Kafka server resource. The health check verifies that a Kafka producer with the specified connection name is able to connect and persist a topic to the Kafka server.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire Apache Kafka client integration, install the [📦 Aspire.Confluent.Kafka](https://www.nuget.org/packages/Aspire.Confluent.Kafka) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.Confluent.Kafka package

  ```bash
  dotnet add package Aspire.Confluent.Kafka
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Confluent.Kafka@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Confluent.Kafka package reference

  ```xml
  <PackageReference Include="Aspire.Confluent.Kafka" Version="*" />
  ```

### Add Kafka producer

[Section titled “Add Kafka producer”](#add-kafka-producer)

In the `Program.cs` file of your client-consuming project, call the `AddKafkaProducer` extension method to register an `IProducer<TKey, TValue>` for use via the dependency injection container:

```csharp
builder.AddKafkaProducer<string, string>("kafka");
```

Tip

The `connectionName` parameter must match the name used when adding the Kafka resource in the AppHost project.

You can then retrieve the `IProducer<TKey, TValue>` instance using dependency injection:

```csharp
internal sealed class Worker(IProducer<string, string> producer) : BackgroundService
{
    // Use producer...
}
```

### Add Kafka consumer

[Section titled “Add Kafka consumer”](#add-kafka-consumer)

To register an `IConsumer<TKey, TValue>` for use via the dependency injection container, call the `AddKafkaConsumer` extension method:

```csharp
builder.AddKafkaConsumer<string, string>("kafka");
```

You can then retrieve the `IConsumer<TKey, TValue>` instance using dependency injection:

```csharp
internal sealed class Worker(IConsumer<string, string> consumer) : BackgroundService
{
    // Use consumer...
}
```

### Add keyed Kafka producers or consumers

[Section titled “Add keyed Kafka producers or consumers”](#add-keyed-kafka-producers-or-consumers)

There might be situations where you want to register multiple producer or consumer instances with different connection names:

* `AddKeyedKafkaProducer`: Registers a keyed Kafka producer.
* `AddKeyedKafkaConsumer`: Registers a keyed Kafka consumer.

### Configuration

[Section titled “Configuration”](#configuration)

The Apache Kafka integration provides multiple options to configure the connection.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, provide the name when calling `builder.AddKafkaProducer()` or `builder.AddKafkaConsumer()`:

```csharp
builder.AddKafkaProducer<string, string>("kafka");
```

Example configuration:

```json
{
  "ConnectionStrings": {
    "kafka": "broker:9092"
  }
}
```

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Apache Kafka integration supports `Microsoft.Extensions.Configuration`. It loads the `KafkaProducerSettings` or `KafkaConsumerSettings` from configuration using the `Aspire:Confluent:Kafka:Producer` and `Aspire:Confluent:Kafka:Consumer` keys. Example `appsettings.json`:

```json
{
  "Aspire": {
    "Confluent": {
      "Kafka": {
        "Producer": {
          "DisableHealthChecks": false,
          "Config": {
            "Acks": "All"
          }
        }
      }
    }
  }
}
```

The `Config` properties bind to instances of `ProducerConfig` and `ConsumerConfig`.

Note

`Confluent.Kafka.Consumer<TKey, TValue>` requires the `ClientId` property to be set to let the broker track consumed message offsets.

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Apache Kafka integration supports named configuration for multiple instances:

```json
{
  "Aspire": {
    "Confluent": {
      "Kafka": {
        "Producer": {
          "kafka1": {
            "DisableHealthChecks": false,
            "Config": {
              "Acks": "All"
            }
          },
          "kafka2": {
            "DisableHealthChecks": true,
            "Config": {
              "Acks": "Leader"
            }
          }
        }
      }
    }
  }
}
```

Use the connection names when calling the registration methods:

```csharp
builder.AddKafkaProducer<string, string>("kafka1");
builder.AddKafkaConsumer<string, string>("kafka2");
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the `Action<KafkaProducerSettings>` delegate to set up options inline:

```csharp
builder.AddKafkaProducer<string, string>(
    "kafka",
    static settings => settings.DisableHealthChecks = true);
```

To configure `Confluent.Kafka` builders, pass an `Action<ProducerBuilder<TKey, TValue>>`:

```csharp
builder.AddKafkaProducer<string, MyMessage>(
    "kafka",
    static producerBuilder =>
    {
        var messageSerializer = new MyMessageSerializer();
        producerBuilder.SetValueSerializer(messageSerializer);
    });
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Apache Kafka integration handles the following health check scenarios:

* Adds the `Aspire.Confluent.Kafka.Producer` health check when `DisableHealthChecks` is `false`.
* Adds the `Aspire.Confluent.Kafka.Consumer` health check when `DisableHealthChecks` is `false`.
* Integrates with the `/health` HTTP endpoint.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Apache Kafka integration uses the following log categories:

* `Aspire.Confluent.Kafka`

#### Tracing

[Section titled “Tracing”](#tracing)

The Apache Kafka integration doesn’t emit distributed traces.

#### Metrics

[Section titled “Metrics”](#metrics)

The Apache Kafka integration emits the following metrics using OpenTelemetry:

* `Aspire.Confluent.Kafka`

  * `messaging.kafka.network.tx`
  * `messaging.kafka.network.transmitted`
  * `messaging.kafka.network.rx`
  * `messaging.kafka.network.received`
  * `messaging.publish.messages`
  * `messaging.kafka.message.transmitted`
  * `messaging.receive.messages`
  * `messaging.kafka.message.received`

# LavinMQ integration

⭐ Community Toolkit ![LavinMQ logo](/_astro/lavinmq-icon.D9qf9hFl_1SWMV3.webp)

[LavinMQ](https://lavinmq.com/) is a high-performance message broker that implements the AMQP 0.9.1 protocol and is wire-compatible with RabbitMQ. The Aspire LavinMQ integration provides a way to connect to existing LavinMQ instances or create new instances from Aspire with the `docker.io/cloudamqp/lavinmq` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire LavinMQ hosting integration, install the [CommunityToolkit.Aspire.Hosting.LavinMQ](https://www.nuget.org/packages/CommunityToolkit.Aspire.Hosting.LavinMQ) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add CommunityToolkit.Aspire.Hosting.LavinMQ package

  ```bash
  aspire add communitytoolkit-lavinmq
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > communitytoolkit-lavinmq (CommunityToolkit.Aspire.Hosting.LavinMQ)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package CommunityToolkit.Aspire.Hosting.LavinMQ@*
  ```

* PackageReference (\*.csproj)

  XML — Add CommunityToolkit.Aspire.Hosting.LavinMQ package reference

  ```xml
  <PackageReference Include="CommunityToolkit.Aspire.Hosting.LavinMQ" Version="*" />
  ```

### Add LavinMQ resource

[Section titled “Add LavinMQ resource”](#add-lavinmq-resource)

In your app host project, register and consume a LavinMQ server integration using the `AddLavinMQ` extension method to add the LavinMQ server resource to the builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var lavinmq = builder.AddLavinMQ("lavinmq");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(lavinmq);


// After adding all resources, run the app...
```

When Aspire adds a container image to the app host, as shown in the preceding example with the `docker.io/cloudamqp/lavinmq` image, it creates a new LavinMQ instance. The default username is `guest`, and the password is a randomly generated string.

### Data persistence

[Section titled “Data persistence”](#data-persistence)

To add data volumes for persisting LavinMQ data, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var lavinmq = builder.AddLavinMQ("lavinmq")
                     .WithDataVolume();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(lavinmq);
```

The data volume is used to persist the LavinMQ data outside the lifecycle of the container.

For development scenarios, you may want to use bind mounts instead of data volumes. To add a data bind mount, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var lavinmq = builder.AddLavinMQ("lavinmq")
                     .WithDataBindMount(source: @"C:\LavinMQ\Data");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(lavinmq);
```

### Management UI

[Section titled “Management UI”](#management-ui)

LavinMQ provides a management UI that you can use to monitor and manage your LavinMQ instance. The management UI is automatically exposed when you add a LavinMQ resource and is accessible through the Aspire dashboard.

## Client integration

[Section titled “Client integration”](#client-integration)

LavinMQ is wire-compatible with RabbitMQ and uses the AMQP 0.9.1 protocol. To connect to LavinMQ from your client application, use the [Aspire.RabbitMQ.Client](https://www.nuget.org/packages/Aspire.RabbitMQ.Client) NuGet package:

* .NET CLI

  .NET CLI — Add Aspire.RabbitMQ.Client package

  ```bash
  dotnet add package Aspire.RabbitMQ.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.RabbitMQ.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.RabbitMQ.Client package reference

  ```xml
  <PackageReference Include="Aspire.RabbitMQ.Client" Version="*" />
  ```

### Add RabbitMQ client API

[Section titled “Add RabbitMQ client API”](#add-rabbitmq-client-api)

In the `Program.cs` file of your client-consuming project, call the `AddRabbitMQClient` extension method to register an `IConnection` for use through dependency injection. The method takes a connection name parameter:

```csharp
builder.AddRabbitMQClient(connectionName: "lavinmq");
```

You can then retrieve the `IConnection` instance using dependency injection. For example, to retrieve the connection object from an example service:

```csharp
public class ExampleService(IConnection connection)
{
    // Use connection...
}
```

For more information on using the RabbitMQ client with LavinMQ, see the [RabbitMQ integration documentation](/integrations/messaging/rabbitmq/).

### Configuration

[Section titled “Configuration”](#configuration)

Because LavinMQ is wire-compatible with RabbitMQ, you can use the same configuration options as the RabbitMQ client integration. The Aspire RabbitMQ client integration supports `Microsoft.Extensions.Configuration`. It loads the `RabbitMQClientSettings` from configuration using the `Aspire:RabbitMQ:Client` key.

For more information about configuration options, see the [RabbitMQ integration documentation](/integrations/messaging/rabbitmq/#configuration).

## Health checks

[Section titled “Health checks”](#health-checks)

By default, the Aspire RabbitMQ client integration handles health checks using the [AspNetCore.HealthChecks.RabbitMQ](https://www.nuget.org/packages/AspNetCore.HealthChecks.RabbitMQ) package. Since LavinMQ is wire-compatible with RabbitMQ, the same health checks work for LavinMQ connections.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

The LavinMQ integration uses the RabbitMQ client, which provides observability features. For more information about tracing, metrics, and logging with the RabbitMQ client, see the [RabbitMQ integration documentation](/integrations/messaging/rabbitmq/#observability-and-telemetry).

## See also

[Section titled “See also”](#see-also)

* [LavinMQ documentation](https://lavinmq.com/documentation)
* [RabbitMQ integration](/integrations/messaging/rabbitmq/)
* [Aspire Community Toolkit](https://github.com/CommunityToolkit/Aspire)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# NATS integration

![NATS logo](/_astro/nats-icon.D9qyPulo_Z1HLR10.webp)

[NATS](https://nats.io) is a simple, secure and high-performance open-source messaging system for cloud-native applications, IoT messaging, and microservices architectures. The Aspire NATS integration provides a way to connect to existing NATS instances or create new instances from Aspire with the `docker.io/library/nats` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

To get started with the Aspire NATS hosting integration, install the [Aspire.Hosting.Nats](https://www.nuget.org/packages/Aspire.Hosting.Nats) NuGet package in the app host project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Nats package

  ```bash
  aspire add nats
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > nats (Aspire.Hosting.Nats)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Nats@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Nats package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Nats" Version="*" />
  ```

### Add NATS resource

[Section titled “Add NATS resource”](#add-nats-resource)

In your app host project, register and consume a NATS server integration using the `AddNats` extension method to add the NATS server resource to the builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var nats = builder.AddNats("nats");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(nats);


// After adding all resources, run the app...
```

### Add NATS with JetStream

[Section titled “Add NATS with JetStream”](#add-nats-with-jetstream)

To add NATS with [JetStream](https://docs.nats.io/nats-concepts/jetstream) enabled, which provides streaming capabilities, use the `WithJetStream` extension method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var nats = builder.AddNats("nats")
                  .WithJetStream();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(nats);
```

### Data persistence

[Section titled “Data persistence”](#data-persistence)

To add data volumes for persisting NATS data, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var nats = builder.AddNats("nats")
                  .WithJetStream()
                  .WithDataVolume();


builder.AddProject<Projects.ExampleProject>()
       .WithReference(nats);
```

The data volume is used to persist the NATS data outside the lifecycle of the container.

For development scenarios, you may want to use bind mounts instead of data volumes. To add a data bind mount, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var nats = builder.AddNats("nats")
                  .WithJetStream()
                  .WithDataBindMount(source: @"C:\Nats\Data");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(nats);
```

### Add NATS with authentication

[Section titled “Add NATS with authentication”](#add-nats-with-authentication)

To add NATS with username and password authentication, use the `WithNatsUser` and `WithNatsPassword` parameters:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var nats = builder.AddNats("nats", userName: "nats", password: "pass");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(nats);
```

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a NATS resource using `WithReference`, the following connection properties are made available to the consuming project:

#### NATS server

[Section titled “NATS server”](#nats-server)

The NATS server resource exposes the following connection properties:

| Property Name | Description                                                                     |
| ------------- | ------------------------------------------------------------------------------- |
| `Host`        | The hostname or IP address of the NATS server                                   |
| `Port`        | The port number the NATS server is listening on                                 |
| `Username`    | The username for authentication                                                 |
| `Password`    | The password for authentication                                                 |
| `Uri`         | The connection URI with the format `nats://{Username}:{Password}@{Host}:{Port}` |

**Example connection string:**

```plaintext
Uri: nats://admin:p%40ssw0rd1@localhost:4222
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `messaging` becomes `MESSAGING_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire NATS client integration, install the [Aspire.NATS.Net](https://www.nuget.org/packages/Aspire.NATS.Net) NuGet package in the consuming client project:

* .NET CLI

  .NET CLI — Add Aspire.NATS.Net package

  ```bash
  dotnet add package Aspire.NATS.Net
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.NATS.Net@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.NATS.Net package reference

  ```xml
  <PackageReference Include="Aspire.NATS.Net" Version="*" />
  ```

### Add NATS client API

[Section titled “Add NATS client API”](#add-nats-client-api)

In the `Program.cs` file of your client-consuming project, call the `AddNatsClient` extension method to register an `INatsConnection` for use through dependency injection. The method takes a connection name parameter:

```csharp
builder.AddNatsClient(connectionName: "nats");
```

You can then retrieve the `INatsConnection` instance using dependency injection. For example, to retrieve the connection object from an example service:

```csharp
public class ExampleService(INatsConnection connection)
{
    // Use connection...
}
```

### Add keyed NATS client API

[Section titled “Add keyed NATS client API”](#add-keyed-nats-client-api)

There might be situations where you want to register multiple `INatsConnection` instances with different connection names. To register keyed NATS clients, call the `AddKeyedNatsClient` method:

```csharp
builder.AddKeyedNatsClient(name: "products");
builder.AddKeyedNatsClient(name: "orders");
```

Then you can retrieve the `INatsConnection` instances using dependency injection. For example, to retrieve the connection from an example service:

```csharp
public class ExampleService(
    [FromKeyedServices("products")] INatsConnection productsConnection,
    [FromKeyedServices("orders")] INatsConnection ordersConnection)
{
    // Use connections...
}
```

For more information on keyed services, see [.NET dependency injection: Keyed services](https://learn.microsoft.com/dotnet/core/extensions/dependency-injection#keyed-services).

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire NATS client integration provides multiple configuration approaches. You can provide configuration using `appsettings.json`, configuration keys, or inline code.

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire NATS client integration supports `Microsoft.Extensions.Configuration`. It loads the `NatsClientSettings` from configuration using the `Aspire:Nats:Client` key:

```json
{
  "Aspire": {
    "Nats": {
      "Client": {
        "ConnectionString": "nats://localhost:4222",
        "DisableHealthChecks": false,
        "DisableTracing": false
      }
    }
  }
}
```

For the complete NATS client integration JSON schema, see [Aspire.NATS.Net/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/v9.0.0/src/Components/Aspire.NATS.Net/ConfigurationSchema.json).

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can also pass the `Action<NatsClientSettings>` delegate to set up some or all the options inline:

```csharp
builder.AddNatsClient(
    "nats",
    static settings => settings.DisableHealthChecks = true);
```

## Health checks

[Section titled “Health checks”](#health-checks)

By default, the Aspire NATS integration handles health checks using the [AspNetCore.HealthChecks.Nats](https://www.nuget.org/packages/AspNetCore.HealthChecks.Nats) package. This integration registers a health check that verifies the connection to the NATS server.

The NATS client integration registers a health check using the connection name. The health check verifies that the connection is active and can be used to send and receive messages.

## Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

### Tracing

[Section titled “Tracing”](#tracing)

The Aspire NATS integration emits tracing activities using OpenTelemetry. The integration automatically enables tracing for NATS operations.

The following are the tracing activities emitted by NATS components:

* **“NATS”**: Emitted by `NatsConnection`.
* **“NATS.Net”**: Emitted by the NATS .NET client library.

For more information about tracing activities, see [NATS .NET client library: OpenTelemetry support](https://nats-io.github.io/nats.net.v2/documentation/observability/opentelemetry.html).

## See also

[Section titled “See also”](#see-also)

* [NATS documentation](https://docs.nats.io)
* [NATS .NET client](https://github.com/nats-io/nats.net.v2)
* [Aspire integrations overview](/integrations/overview/)
* [Aspire GitHub repo](https://github.com/dotnet/aspire)

# RabbitMQ Integration

![RabbitMQ logo](/_astro/rabbitmq-icon.D4S9ajGZ_Z15CWs.svg)

[RabbitMQ](https://www.rabbitmq.com/) is a reliable messaging and streaming broker, which is easy to deploy on cloud environments, on-premises, and on your local machine. The Aspire RabbitMQ integration enables you to connect to existing RabbitMQ instances, or create new instances from the [`docker.io/library/rabbitmq` container image](https://hub.docker.com/_/rabbitmq).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The RabbitMQ hosting integration models a RabbitMQ server as the `RabbitMQServerResource` type. To access this type and its APIs add the [📦 Aspire.Hosting.RabbitMQ](https://www.nuget.org/packages/Aspire.Hosting.RabbitMQ) NuGet package in the [`AppHost`](/get-started/app-host/) project.

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.RabbitMQ package

  ```bash
  aspire add rabbitmq
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > rabbitmq (Aspire.Hosting.RabbitMQ)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.RabbitMQ@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.RabbitMQ package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.RabbitMQ" Version="*" />
  ```

### Add RabbitMQ server resource

[Section titled “Add RabbitMQ server resource”](#add-rabbitmq-server-resource)

In your AppHost project, call `AddRabbitMQ` on the `builder` instance to add a RabbitMQ server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rabbitmq = builder.AddRabbitMQ("messaging");


builder.AddProject<Projects.ExampleProject>()
       .WithReference(rabbitmq);


// After adding all resources, run the app...
```

1. When Aspire adds a container image to the app host, as shown in the preceding example with the `docker.io/library/rabbitmq` image, it creates a new RabbitMQ server instance on your local machine. A reference to your RabbitMQ server (the `rabbitmq` variable) is added to the `ExampleProject`.

2. The RabbitMQ server resource includes default credentials with a `username` of `"guest"` and randomly generated `password` using the `CreateDefaultPasswordParameter` method.

3. The `WithReference` method configures a connection in the `ExampleProject` named `"messaging"`.

Tip

If you’d rather connect to an existing RabbitMQ server, chain a call to `AsExisting` instead—passing the appropriate parameters.

### Add RabbitMQ server resource with data volume

[Section titled “Add RabbitMQ server resource with data volume”](#add-rabbitmq-server-resource-with-data-volume)

To add a data volume to the RabbitMQ server resource, call the `WithDataVolume` method on the RabbitMQ server resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rabbitmq = builder.AddRabbitMQ("messaging")
                      .WithDataVolume(isReadOnly: false);


builder.AddProject<Projects.ExampleProject>()
        .WithReference(rabbitmq);


// After adding all resources, run the app...
```

The data volume is used to persist the RabbitMQ server data outside the lifecycle of its container. The data volume is mounted at the `/var/lib/rabbitmq` path in the RabbitMQ server container and when a `name` parameter isn’t provided, the name is generated at random. For more information on data volumes and details on why they’re preferred over [bind mounts](#add-rabbitmq-server-resource-with-data-bind-mount), see [Docker docs: Volumes](https://docs.docker.com/engine/storage/volumes).

### Add RabbitMQ server resource with data bind mount

[Section titled “Add RabbitMQ server resource with data bind mount”](#add-rabbitmq-server-resource-with-data-bind-mount)

To add a data bind mount to the RabbitMQ server resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rabbitmq = builder.AddRabbitMQ("messaging")
                      .WithDataBindMount(
                          source: @"/RabbitMQ/Data",
                          isReadOnly: false);


builder.AddProject<Projects.ExampleProject>()
        .WithReference(rabbitmq);


// After adding all resources, run the app...
```

Note

Data [bind mounts](https://docs.docker.com/engine/storage/bind-mounts/) have limited functionality compared to [volumes](https://docs.docker.com/engine/storage/volumes/), which offer better performance, portability, and security, making them more suitable for production environments. However, bind mounts allow direct access and modification of files on the host system, ideal for development and testing where real-time changes are needed.

Data bind mounts rely on the host machine’s filesystem to persist the RabbitMQ server data across container restarts. The data bind mount is mounted at the `C:\RabbitMQ\Data` on Windows (or `/RabbitMQ/Data` on Unix) path on the host machine in the RabbitMQ server container. For more information on data bind mounts, see [Docker docs: Bind mounts](https://docs.docker.com/engine/storage/bind-mounts).

### Add RabbitMQ server resource with parameters

[Section titled “Add RabbitMQ server resource with parameters”](#add-rabbitmq-server-resource-with-parameters)

When you want to explicitly provide the username and password used by the container image, you can provide these credentials as parameters. Consider the following alternative example:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("username", secret: true);
var password = builder.AddParameter("password", secret: true);


var rabbitmq = builder.AddRabbitMQ("messaging", username, password);


builder.AddProject<Projects.ExampleProject>()
       .WithReference(rabbitmq);


// After adding all resources, run the app...
```

### Add RabbitMQ server resource with management plugin

[Section titled “Add RabbitMQ server resource with management plugin”](#add-rabbitmq-server-resource-with-management-plugin)

To add the [RabbitMQ management plugin](https://www.rabbitmq.com/docs/management) to the RabbitMQ server resource, call the `WithManagementPlugin` method. Remember to use parameters to set the credentials for the container. You’ll need these credentials to log into the management plugin:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("username", secret: true);
var password = builder.AddParameter("password", secret: true);


var rabbitmq = builder.AddRabbitMQ("messaging", username, password)
                      .WithManagementPlugin();


builder.AddProject<Projects.ExampleProject>()
        .WithReference(rabbitmq);


// After adding all resources, run the app...
```

The RabbitMQ management plugin provides an HTTP-based API for management and monitoring of your RabbitMQ server. Aspire adds another container image [`docker.io/library/rabbitmq-management`](https://hub.docker.com/_/rabbitmq) to the AppHost that runs the management plugin. You can access the management plugin from the Aspire dashboard by selecting an endpoint for your RabbitMQ resource:

![The Aspire dashboard interface displays a list of resources with RabbitMQ selected. The right panel shows endpoints including a link labeled Management Plugin. The environment is a web-based dashboard with a clean, organized layout. Visible text includes Management Plugin and other resource names. The tone is neutral and informative, focusing on guiding users to access the RabbitMQ management plugin.](/_astro/dashboard-access-rabbitmq-management.0yjt5nBa_Z1V5mTv.webp)

Log into the management plugin using the credentials you configured with parameters:

![RabbitMQ management plugin dashboard showing an overview of queues, exchanges, and connections. The interface displays navigation tabs for Overview, Connections, Channels, Exchanges, Queues, Admin, and a search bar. Visible text includes RabbitMQ Management, Overview, Queues, Exchanges, and Connections. The environment is a web-based dashboard with a clean and organized layout. The tone is neutral and informative, focusing on providing management and monitoring information for RabbitMQ.](/_astro/rabbitmq-management-plugin.C-zCemxe_Z1Ec122.webp)

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a RabbitMQ resource using `WithReference`, the following connection properties are made available to the consuming project:

#### RabbitMQ server

[Section titled “RabbitMQ server”](#rabbitmq-server)

The RabbitMQ server resource exposes the following connection properties:

| Property Name | Description                                                                      |
| ------------- | -------------------------------------------------------------------------------- |
| `Host`        | The hostname or IP address of the RabbitMQ server                                |
| `Port`        | The port number the RabbitMQ server is listening on                              |
| `Username`    | The username for authentication                                                  |
| `Password`    | The password for authentication                                                  |
| `Uri`         | The connection URI, with the format `amqp://{Username}:{Password}@{Host}:{Port}` |

**Example connection string:**

```plaintext
Uri: amqp://guest:p%40ssw0rd1@localhost:5672
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `messaging` becomes `MESSAGING_URI`.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The RabbitMQ hosting integration automatically adds a health check for the RabbitMQ server resource. The health check verifies that the RabbitMQ server is running and that a connection can be established to it.

The hosting integration relies on the [📦 AspNetCore.HealthChecks.Rabbitmq](https://www.nuget.org/packages/AspNetCore.HealthChecks.Rabbitmq) NuGet package.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Aspire RabbitMQ client integration, install the [📦 Aspire.RabbitMQ.Client](https://www.nuget.org/packages/Aspire.RabbitMQ.Client) NuGet package in the client-consuming project, that is, the project for the application that uses the RabbitMQ client. The RabbitMQ client integration registers an [IConnection](https://rabbitmq.github.io/rabbitmq-dotnet-client/api/RabbitMQ.Client.IConnection.html) instance that you can use to interact with RabbitMQ.

* .NET CLI

  .NET CLI — Add Aspire.RabbitMQ.Client package

  ```bash
  dotnet add package Aspire.RabbitMQ.Client
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.RabbitMQ.Client@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.RabbitMQ.Client package reference

  ```xml
  <PackageReference Include="Aspire.RabbitMQ.Client" Version="*" />
  ```

Note

The `Aspire.RabbitMQ.Client` NuGet package depends on the `RabbitMQ.Client` NuGet package. With the release of version 7.0.0 of `RabbitMQ.Client`, a binary breaking change was introduced. To address this, a new client integration package, `Aspire.RabbitMQ.Client.v7`, was created. The original `Aspire.RabbitMQ.Client` package continues to reference `RabbitMQ.Client` version 6.8.1, ensuring compatibility with previous versions of the RabbitMQ client integration. The new `Aspire.RabbitMQ.Client.v7` package references `RabbitMQ.Client` version 7.0.0. In a future version of Aspire, the `Aspire.RabbitMQ.Client` will be updated to version `7.x` and the `Aspire.RabbitMQ.Client.v7` package will be deprecated. For more information, see [Migrating to RabbitMQ .NET Client 7.x](https://github.com/rabbitmq/rabbitmq-dotnet-client/blob/main/v7-MIGRATION.md).

### Add RabbitMQ client

[Section titled “Add RabbitMQ client”](#add-rabbitmq-client)

In the `Program.cs` file of your client-consuming project, call the `AddRabbitMQClient` extension method on any `IHostApplicationBuilder` to register an `IConnection` for use via the dependency injection container. The method takes a connection name parameter.

C# — Program.cs

```csharp
builder.AddRabbitMQClient(connectionName: "messaging");
```

Tip

The `connectionName` parameter must match the name used when adding the RabbitMQ server resource in the AppHost project. For more information, see [Add RabbitMQ server resource](#add-rabbitmq-server-resource).

You can then retrieve the `IConnection` instance using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(IConnection connection)
{
    // Use connection...
}
```

### Add keyed RabbitMQ client

[Section titled “Add keyed RabbitMQ client”](#add-keyed-rabbitmq-client)

There might be situations where you want to register multiple `IConnection` instances with different connection names. To register keyed RabbitMQ clients, call the `AddKeyedRabbitMQClient` method:

C# — Program.cs

```csharp
builder.AddKeyedRabbitMQClient(name: "chat");
builder.AddKeyedRabbitMQClient(name: "queue");
```

Then you can retrieve the `IConnection` instances using dependency injection. For example, to retrieve the connection from an example service:

C# — ExampleService.cs

```csharp
public class ExampleService(
    [FromKeyedServices("chat")] IConnection chatConnection,
    [FromKeyedServices("queue")] IConnection queueConnection)
{
    // Use connections...
}
```

### Configuration

[Section titled “Configuration”](#configuration)

The Aspire RabbitMQ integration provides multiple options to configure the connection based on the requirements and conventions of your project.

#### Use a connection string

[Section titled “Use a connection string”](#use-a-connection-string)

When using a connection string from the `ConnectionStrings` configuration section, you can provide the name of the connection string when calling the `AddRabbitMQClient` method:

C# — Program.cs

```csharp
builder.AddRabbitMQClient(connectionName: "messaging");
```

Then the connection string is retrieved from the `ConnectionStrings` configuration section:

JSON — appsettings.json

```json
{
  "ConnectionStrings": {
    "messaging": "amqp://username:password@localhost:5672"
  }
}
```

For more information on how to format this connection string, see the [RabbitMQ URI specification docs](https://www.rabbitmq.com/uri-spec.html).

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Aspire RabbitMQ integration supports `Configuration`. It loads the `RabbitMQClientSettings` from configuration by using the `Aspire:RabbitMQ:Client` key. The following snippet is an example of a *appsettings.json* file that configures some of the options:

JSON — appsettings.json

```json
{
  "Aspire": {
    "RabbitMQ": {
      "Client": {
        "ConnectionString": "amqp://username:password@localhost:5672",
        "DisableHealthChecks": true,
        "DisableTracing": true,
        "MaxConnectRetryCount": 2
      }
    }
  }
}
```

For the complete RabbitMQ client integration JSON schema, see [Aspire.RabbitMQ.Client/ConfigurationSchema.json](https://github.com/dotnet/aspire/blob/v9.1.0/src/Components/Aspire.RabbitMQ.Client/ConfigurationSchema.json).

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

Also you can pass the `Action<RabbitMQClientSettings> configureSettings` delegate to set up some or all the options inline, for example to disable health checks from code:

C# — Program.cs

```csharp
builder.AddRabbitMQClient(
    "messaging",
    static settings => settings.DisableHealthChecks = true);
```

You can also set up the [IConnectionFactory](https://rabbitmq.github.io/rabbitmq-dotnet-client/api/RabbitMQ.Client.IConnectionFactory.html) using the `Action<IConnectionFactory> configureConnectionFactory` delegate parameter of the `AddRabbitMQClient` method. For example to set the client provided name for connections:

C# — Program.cs

```csharp
builder.AddRabbitMQClient(
    "messaging",
    configureConnectionFactory:
        static factory => factory.ClientProvidedName = "MyApp");
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Aspire RabbitMQ integration:

* Adds the health check when `DisableHealthChecks?displayProperty=nameWithType` is `false`, which attempts to connect to and create a channel on the RabbitMQ server.
* Integrates with the `/health` HTTP endpoint, which specifies all registered health checks must pass for app to be considered ready to accept traffic.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

Aspire integrations automatically set up Logging, Tracing, and Metrics configurations, which are sometimes known as *the pillars of observability*. Depending on the backing service, some integrations might only support some of these features. For example, some integrations support logging and tracing, but not metrics. Telemetry features can also be disabled using the techniques presented in the [Configuration](#configuration) section.

#### Logging

[Section titled “Logging”](#logging)

The Aspire RabbitMQ integration uses the following log categories:

* `RabbitMQ.Client`

#### Tracing

[Section titled “Tracing”](#tracing)

The Aspire RabbitMQ integration emits the following tracing activities using OpenTelemetry:

* `Aspire.RabbitMQ.Client`

#### Metrics

[Section titled “Metrics”](#metrics)

The Aspire RabbitMQ integration currently doesn’t support metrics by default.

# Seq integration

> Learn how to use the Seq integration for centralized structured logging and diagnostics.

![Seq logo](/_astro/seq-icon.DTfU7WN9_ZYUopk.webp)

[Seq](https://datalust.co/seq) is the intelligent search, analysis, and alerting server built for structured log data. The Aspire Seq integration enables you to connect to existing Seq instances or create new instances from Aspire with the [`datalust/seq` container image](https://hub.docker.com/r/datalust/seq).

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Seq hosting integration models a Seq resource as the `SeqResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Seq](https://www.nuget.org/packages/Aspire.Hosting.Seq) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Seq package

  ```bash
  aspire add seq
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > seq (Aspire.Hosting.Seq)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Seq@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Seq package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Seq" Version="*" />
  ```

### Add a Seq resource

[Section titled “Add a Seq resource”](#add-a-seq-resource)

In your AppHost project, call `AddSeq` to add and return a Seq resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var seq = builder.AddSeq("seq")
                 .ExcludeFromManifest()
                 .WithLifetime(ContainerLifetime.Persistent)
                 .WithEnvironment("ACCEPT_EULA", "Y");


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(seq)
                       .WaitFor(seq);
```

Note

The Seq container may be slow to start, so it’s best to use a *persistent* lifetime to avoid unnecessary restarts. For more information, see [Container resource lifetime](/architecture/resource-model/#built-in-resources-and-lifecycle).

#### Accept the Seq End User License Agreement (EULA)

[Section titled “Accept the Seq End User License Agreement (EULA)”](#accept-the-seq-end-user-license-agreement-eula)

You must accept the [Seq EULA](https://datalust.co/doc/eula-current.pdf) for Seq to start. To accept the agreement in code, pass the environment variable `ACCEPT_EULA` to the Seq container, and set its value to `Y`.

#### Seq in the Aspire manifest

[Section titled “Seq in the Aspire manifest”](#seq-in-the-aspire-manifest)

Seq shouldn’t be part of the Aspire deployment manifest, hence the chained call to `ExcludeFromManifest`. It’s recommended you set up a secure production Seq server outside of Aspire for your production environment.

### Persistent logs and traces

[Section titled “Persistent logs and traces”](#persistent-logs-and-traces)

Register Seq with a data directory in your AppHost project to retain Seq’s data and configuration across application restarts:

```csharp
var seq = builder.AddSeq("seq", seqDataDirectory: "./seqdata")
                 .ExcludeFromManifest()
                 .WithLifetime(ContainerLifetime.Persistent);
```

The directory specified must already exist.

### Add a Seq resource with a data volume

[Section titled “Add a Seq resource with a data volume”](#add-a-seq-resource-with-a-data-volume)

To add a data volume to the Seq resource, call the `WithDataVolume` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var seq = builder.AddSeq("seq")
                 .WithDataVolume()
                 .ExcludeFromManifest()
                 .WithLifetime(ContainerLifetime.Persistent);


var myService = builder.AddProject<Projects.ExampleProject>()
                       .WithReference(seq)
                       .WaitFor(seq);
```

The data volume is used to persist the Seq data outside the lifecycle of its container.

### Connection properties

[Section titled “Connection properties”](#connection-properties)

When you reference a Seq resource using `WithReference`, the following connection properties are made available to the consuming project:

#### Seq

[Section titled “Seq”](#seq)

The Seq resource exposes the following connection properties:

| Property Name | Description                                                |
| ------------- | ---------------------------------------------------------- |
| `Host`        | The hostname or IP address of the Seq server               |
| `Port`        | The port number the Seq server is listening on             |
| `Uri`         | The connection URI, with the format `http://{Host}:{Port}` |

**Example connection string:**

```plaintext
Uri: http://localhost:5341
```

Note

Aspire exposes each property as an environment variable named `[RESOURCE]_[PROPERTY]`. For instance, the `Uri` property of a resource called `seq` becomes `SEQ_URI`.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Seq client integration, install the [📦 Aspire.Seq](https://www.nuget.org/packages/Aspire.Seq) NuGet package in the client-consuming project:

* .NET CLI

  .NET CLI — Add Aspire.Seq package

  ```bash
  dotnet add package Aspire.Seq
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Seq@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Seq package reference

  ```xml
  <PackageReference Include="Aspire.Seq" Version="*" />
  ```

### Add a Seq client

[Section titled “Add a Seq client”](#add-a-seq-client)

In the `Program.cs` file of your client-consuming project, call the `AddSeqEndpoint` extension method to register OpenTelemetry Protocol exporters to send logs and traces to Seq:

```csharp
builder.AddSeqEndpoint(connectionName: "seq");
```

Tip

The `connectionName` parameter must match the name used when adding the Seq resource in the AppHost project.

### Configuration

[Section titled “Configuration”](#configuration)

The Seq integration provides multiple options to configure the connection to Seq.

#### Use configuration providers

[Section titled “Use configuration providers”](#use-configuration-providers)

The Seq integration supports `Microsoft.Extensions.Configuration`. It loads the `SeqSettings` from configuration using the `Aspire:Seq` key. Example `appsettings.json`:

```json
{
  "Aspire": {
    "Seq": {
      "DisableHealthChecks": true,
      "ServerUrl": "http://localhost:5341"
    }
  }
}
```

#### Use named configuration

[Section titled “Use named configuration”](#use-named-configuration)

The Seq integration supports named configuration for multiple instances:

```json
{
  "Aspire": {
    "Seq": {
      "seq1": {
        "ServerUrl": "http://seq1:5341",
        "DisableHealthChecks": true
      },
      "seq2": {
        "ServerUrl": "http://seq2:5341",
        "DisableHealthChecks": false
      }
    }
  }
}
```

Use the connection names when calling `AddSeqEndpoint`:

```csharp
builder.AddSeqEndpoint("seq1");
builder.AddSeqEndpoint("seq2");
```

#### Use inline delegates

[Section titled “Use inline delegates”](#use-inline-delegates)

You can pass the `Action<SeqSettings>` delegate to set up options inline:

```csharp
builder.AddSeqEndpoint("seq", static settings =>
{
    settings.DisableHealthChecks  = true;
    settings.ServerUrl = "http://localhost:5341";
});
```

### Client integration health checks

[Section titled “Client integration health checks”](#client-integration-health-checks)

By default, Aspire integrations enable health checks for all services. The Seq integration:

* Adds the health check when `DisableHealthChecks` is `false`, which attempts to connect to the Seq server’s `/health` endpoint.
* Integrates with the `/health` HTTP endpoint.

### Observability and telemetry

[Section titled “Observability and telemetry”](#observability-and-telemetry)

#### Logging

[Section titled “Logging”](#logging)

The Seq integration uses the following log categories:

* `Seq`

#### Tracing and Metrics

[Section titled “Tracing and Metrics”](#tracing-and-metrics)

The Seq integration doesn’t emit tracing activities or metrics because it’s a telemetry sink, not a telemetry source.

# Integrations Overview

> Aspire integrations overview page, showcasing how Aspire works with various tools and platforms.

Aspire integrations are a curated suite of packages that make it easy to connect your cloud-native applications with popular services like Redis and PostgreSQL. Each integration provides essential cloud-native capabilities through automatic setup or standardized configuration.

Tip

Always strive to use the latest version of Aspire integrations to take advantage of the latest features, improvements, and security updates.

## Integration responsibilities

[Section titled “Integration responsibilities”](#integration-responsibilities)

Most Aspire integrations are made up of two separate libraries, each with a different responsibility. One type represents resources within the *app host* project—known as [hosting integrations](#hosting-integrations). The other type of integration represents client libraries that connect to the resources modeled by hosting integrations, and they’re known as [client integrations](#client-integrations).

### Hosting integrations

[Section titled “Hosting integrations”](#hosting-integrations)

Hosting integrations configure applications by provisioning resources (like containers or cloud resources) or pointing to existing instances (such as a local SQL server). These packages model various services, platforms, or capabilities, including caches, databases, logging, storage, and messaging systems.

Hosting integrations extend the `IDistributedApplicationBuilder` interface to enable the *app host* project to express resources within its [*app model*](/architecture/overview/#app-model-architecture). Key characteristics include:

* Tagged with `aspire`, `integration`, and `hosting` in [official packages](/integrations/gallery/?search=hosting)
* Available from both official Aspire releases and community contributions through the Community Toolkit
* Enable resource modeling for various services and platforms

### Client integrations

[Section titled “Client integrations”](#client-integrations)

Client integrations wire up client libraries to dependency injection (DI), define configuration schema, and add *health checks*, *resiliency*, and *telemetry* where applicable. Aspire client integration libraries are prefixed with `Aspire.` and then include the full package name that they integrate with, such as `Aspire.StackExchange.Redis`.

These packages configure existing client libraries to connect to hosting integrations. Key characteristics include:

* Extend the `IHostApplicationBuilder` interface for client-consuming projects (web apps, APIs)
* Tagged with `aspire`, `integration`, and `client` in [official packages](/integrations/gallery/?search=client)
* Available from both official Aspire releases and community contributions through the Community Toolkit

### Relationship between hosting and client integrations

[Section titled “Relationship between hosting and client integrations”](#relationship-between-hosting-and-client-integrations)

Hosting and client integrations work together but are **not** coupled and can be used independently. Configuration via environment variables connects client integrations to their corresponding hosting integrations, with the AppHost project managing this connection.

## Integration features

[Section titled “Integration features”](#integration-features)

When you add a client integration to a project within your Aspire solution, *service defaults* are automatically applied to that project; meaning the Service Defaults project is referenced and the `AddServiceDefaults` extension method is called. These defaults are designed to work well in most scenarios and can be customized as needed. The following service defaults are applied:

* **Observability and telemetry**: Automatically sets up logging, tracing, and metrics configurations:

  * **Logging**: A technique where code is instrumented to produce logs of interesting events that occurred while the program was running.
  * **Tracing**: A specialized form of logging that helps you localize failures and performance issues within applications distributed across multiple machines or processes.
  * **Metrics**: Numerical measurements recorded over time to monitor application performance and health. Metrics are often used to generate alerts when potential problems are detected.

* **Health checks**: Exposes HTTP endpoints to provide basic availability and state information about an app. Health checks are used to influence decisions made by container orchestrators, load balancers, API gateways, and other management services.

* **Resiliency**: The ability of your system to react to failure and still remain functional. Resiliency extends beyond preventing failures to include recovering and reconstructing your cloud-native environment back to a healthy state.

## Versioning considerations

[Section titled “Versioning considerations”](#versioning-considerations)

Hosting and client integrations are updated each release to target the latest stable versions of dependent resources. When container images are updated with new image versions, the hosting integrations update to these new versions. Similarly, when a new package version is available for a dependent client library, the corresponding client integration updates to the new version. This ensures the latest features and security updates are available to applications. The Aspire update type (major, minor, patch) doesn’t necessarily indicate the type of update in dependent resources. For example, a new major version of a dependent resource may be updated in a Aspire patch release, if necessary.

When major breaking changes happen in dependent resources, integrations may temporarily split into version-dependent packages to ease updating across the breaking change.

# YARP integration

> Learn how to use the YARP (Yet Another Reverse Proxy) integration for reverse proxy functionality.

![YARP logo](/_astro/yarp-icon.C9M5RSPI_Z1NYjKL.svg)

[YARP (Yet Another Reverse Proxy)](https://microsoft.github.io/reverse-proxy/) is a toolkit for building fast and customizable reverse proxies using .NET. The Aspire YARP integration enables you to add reverse proxy capabilities to your distributed applications.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The YARP hosting integration models a YARP resource as the `YarpResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Yarp](https://www.nuget.org/packages/Aspire.Hosting.Yarp) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Yarp package

  ```bash
  aspire add yarp
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > yarp (Aspire.Hosting.Yarp)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Yarp@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Yarp package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Yarp" Version="*" />
  ```

### Add YARP resource

[Section titled “Add YARP resource”](#add-yarp-resource)

In your AppHost project, call `AddYarp` on the builder instance to add a YARP resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogService = builder.AddProject<Projects.CatalogService>("catalogservice");
var basketService = builder.AddProject<Projects.BasketService>("basketservice");


var gateway = builder.AddYarp("gateway")
                     .WithConfiguration(yarp =>
                     {
                         // Configure routes programmatically
                         yarp.AddRoute(catalogService);
                         yarp.AddRoute("/api/{**catch-all}", basketService);
                     });
```

When Aspire adds a YARP resource to the AppHost, it creates a new containerized YARP instance using the [mcr.microsoft.com/dotnet/nightly/yarp](https://mcr.microsoft.com/product/dotnet/nightly/yarp/about) container image.

Caution

Starting with Aspire 9.4, the `WithConfigFile` method has been removed. YARP configuration is now done exclusively through code-based configuration using the `WithConfiguration` method. This provides better IntelliSense support, type safety, and works seamlessly with deployment scenarios.

### Programmatic configuration

[Section titled “Programmatic configuration”](#programmatic-configuration)

The YARP integration provides a fluent API for configuring routes, clusters, and transforms programmatically:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogService = builder.AddProject<Projects.CatalogService>("catalogservice");
var basketService = builder.AddProject<Projects.BasketService>("basketservice");


var gateway = builder.AddYarp("gateway")
                     .WithConfiguration(yarp =>
                     {
                         // Add catch-all route for frontend service
                         yarp.AddRoute(catalogService);


                         // Add specific path route with transforms
                         yarp.AddRoute("/api/{**catch-all}", basketService)
                             .WithTransformPathRemovePrefix("/api");


                         // Configure route matching
                         yarp.AddRoute("/catalog/api/{**catch-all}", catalogService)
                             .WithMatchMethods("GET", "POST")
                             .WithTransformPathRemovePrefix("/catalog");
                     });
```

#### Route configuration

[Section titled “Route configuration”](#route-configuration)

Routes define how incoming requests are matched and forwarded to backend services:

* `AddRoute(resource)` - Creates a catch-all route for the specified resource
* `AddRoute(path, resource)` - Creates a route with a specific path pattern
* `AddRoute(path, externalService)` - Creates a route targeting an external service

#### Transforms

[Section titled “Transforms”](#transforms)

Transforms modify requests and responses as they pass through the proxy:

```csharp
yarp.AddRoute("/api/{**catch-all}", basketService)
    .WithTransformPathRemovePrefix("/api")
    .WithTransformPathPrefix("/v1")
    .WithTransformRequestHeader("X-Forwarded-Host", "gateway.example.com")
    .WithTransformResponseHeader("X-Powered-By", "YARP");
```

Common transform methods include:

* **Path transforms**: `WithTransformPathRemovePrefix`, `WithTransformPathPrefix`, `WithTransformPathSet`
* **Header transforms**: `WithTransformRequestHeader`, `WithTransformResponseHeader`
* **Query transforms**: `WithTransformQueryParameter`, `WithTransformQueryRemoveParameter`
* **Custom transforms**: `WithTransform` for custom transformation logic

### Customize host port

[Section titled “Customize host port”](#customize-host-port)

To configure the host port that the YARP resource is exposed on, use the `WithHostPort` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var gateway = builder.AddYarp("gateway")
                     .WithHostPort(8080)
                     .WithConfiguration(yarp =>
                     {
                         // Configure routes...
                     });
```

### Service discovery integration

[Section titled “Service discovery integration”](#service-discovery-integration)

The YARP integration automatically works with .NET service discovery when targeting resources:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogService = builder.AddProject<Projects.CatalogService>("catalogservice");


var gateway = builder.AddYarp("gateway")
                     .WithConfiguration(yarp =>
                     {
                         // Service discovery automatically resolves catalogservice endpoints
                         yarp.AddRoute("/catalog/{**catch-all}", catalogService);
                     });
```

For external services, use `AddExternalService`:

```csharp
var externalApi = builder.AddExternalService("external-api")
                         .WithHttpsEndpoint("https://api.example.com");


var gateway = builder.AddYarp("gateway")
                     .WithConfiguration(yarp =>
                     {
                         yarp.AddRoute("/external/{**catch-all}", externalApi);
                     });
```

### Static file serving

[Section titled “Static file serving”](#static-file-serving)

YARP can serve static files alongside proxied routes. Use the `WithStaticFiles` method to copy files from a local directory:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var staticServer = builder.AddYarp("static")
                          .WithStaticFiles("../static");
```

For building frontend applications, you can use a Docker multi-stage build:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var frontend = builder.AddYarp("frontend")
                      .WithStaticFiles()
                      .WithDockerfile("../npmapp");
```

#### Combining static files with routing

[Section titled “Combining static files with routing”](#combining-static-files-with-routing)

You can combine static file serving with dynamic routing:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiService = builder.AddProject<Projects.ApiService>("api");


var gateway = builder.AddYarp("gateway")
                     .WithStaticFiles("../webapp/dist")
                     .WithConfiguration(yarp =>
                     {
                         // API routes take precedence over static files
                         yarp.AddRoute("/api/{**catch-all}", apiService);
                         // Static files are served for all other routes
                     });
```

# Keycloak integration

> Learn how to use the Keycloak integration, which includes both hosting and client integrations.

🧪 Preview ![Keycloak logo](/_astro/keycloak-icon.DX4K8To8_Z1NYjKL.svg)

[Keycloak](https://www.keycloak.org/) is an open-source Identity and Access Management solution aimed at modern applications and services. The Keycloak integration enables you to connect to existing Keycloak instances or create new instances from Aspire with the `quay.io/keycloak/keycloak` container image.

## Hosting integration

[Section titled “Hosting integration”](#hosting-integration)

The Keycloak hosting integration models the server as the `KeycloakResource` type. To access this type and APIs, add the [📦 Aspire.Hosting.Keycloak](https://www.nuget.org/packages/Aspire.Hosting.Keycloak) NuGet package in your AppHost project:

* Aspire CLI

  Aspire CLI — Add Aspire.Hosting.Keycloak package

  ```bash
  aspire add keycloak
  ```

  The Aspire CLI is interactive, be sure to select the appropriate search result when prompted:

  Aspire CLI — Example output prompt

  ```bash
  Select an integration to add:


  > keycloak (Aspire.Hosting.Keycloak)
  > Other results listed as selectable options...
  ```

  Note

  If there's only one result, the CLI selects it automatically. You'll still need to confirm the version.

* apphost.cs (C# file-based app)

  C# — AppHost.cs

  ```csharp
  #:package Aspire.Hosting.Keycloak@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Hosting.Keycloak package reference

  ```xml
  <PackageReference Include="Aspire.Hosting.Keycloak" Version="*" />
  ```

### Add Keycloak resource

[Section titled “Add Keycloak resource”](#add-keycloak-resource)

In your AppHost project, call `AddKeycloak` to add and return a Keycloak resource builder:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keycloak = builder.AddKeycloak("keycloak", 8080);


var apiService = builder.AddProject<Projects.ApiService>("apiservice")
                        .WithReference(keycloak)
                        .WaitFor(keycloak);


var webfrontend = builder.AddProject<Projects.Web>("webfrontend")
                         .WithExternalHttpEndpoints()
                         .WithReference(keycloak)
                         .WithReference(apiService)
                         .WaitFor(apiService);
```

Tip

For local development use a stable port for the Keycloak resource (`8080` in the preceding example). It can be any port, but it should be stable to avoid issues with browser cookies that will persist OIDC tokens beyond the lifetime of the AppHost.

When Aspire adds a container image to the AppHost, it creates a new Keycloak instance on your local machine. The Keycloak resource includes default credentials:

* `KEYCLOAK_ADMIN`: A value of `admin`
* `KEYCLOAK_ADMIN_PASSWORD`: Random password generated using the default password parameter

When the AppHost runs, the password is stored in the AppHost’s secret store in the `Parameters` section:

```json
{
  "Parameters:keycloak-password": "<THE_GENERATED_PASSWORD>"
}
```

Tip

If you’d rather connect to an existing Keycloak instance, call `AddConnectionString` instead. For more information, see [Reference existing resources](/get-started/resources/).

### Add Keycloak resource with data volume

[Section titled “Add Keycloak resource with data volume”](#add-keycloak-resource-with-data-volume)

To add a data volume to the Keycloak resource, call the `WithDataVolume` method on the Keycloak resource:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keycloak = builder.AddKeycloak("keycloak", 8080)
                      .WithDataVolume();


var apiService = builder.AddProject<Projects.ApiService>("apiservice")
                        .WithReference(keycloak)
                        .WaitFor(keycloak);
```

The data volume is used to persist the Keycloak data outside the lifecycle of its container. The data volume is mounted at the `/opt/keycloak/data` path in the Keycloak container.

Caution

The admin credentials are stored in the data volume. When using a data volume and if the credentials change, it will not work until you delete the volume.

### Add Keycloak resource with data bind mount

[Section titled “Add Keycloak resource with data bind mount”](#add-keycloak-resource-with-data-bind-mount)

To add a data bind mount to the Keycloak resource, call the `WithDataBindMount` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keycloak = builder.AddKeycloak("keycloak", 8080)
                      .WithDataBindMount(@"C:\Keycloak\Data");


var apiService = builder.AddProject<Projects.ApiService>("apiservice")
                        .WithReference(keycloak)
                        .WaitFor(keycloak);
```

Note

Data bind mounts have limited functionality compared to volumes, and when you use a bind mount, a file or directory on the host machine is mounted into a container.

### Add Keycloak resource with parameters

[Section titled “Add Keycloak resource with parameters”](#add-keycloak-resource-with-parameters)

When you want to explicitly provide the admin username and password used by the container image, you can provide these credentials as parameters:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("username");
var password = builder.AddParameter("password", secret: true);


var keycloak = builder.AddKeycloak("keycloak", 8080, username, password);


var apiService = builder.AddProject<Projects.ApiService>("apiservice")
                        .WithReference(keycloak)
                        .WaitFor(keycloak);
```

For more information on providing parameters, see [External parameters](/get-started/resources/).

### Add Keycloak resource with realm import

[Section titled “Add Keycloak resource with realm import”](#add-keycloak-resource-with-realm-import)

To import a realm into Keycloak, call the `WithRealmImport` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keycloak = builder.AddKeycloak("keycloak", 8080)
                      .WithRealmImport("./Realms");


var apiService = builder.AddProject<Projects.ApiService>("apiservice")
                        .WithReference(keycloak)
                        .WaitFor(keycloak);
```

The realm import files are mounted at `/opt/keycloak/data/import` in the Keycloak container. Realm import files are JSON files that represent the realm configuration.

### Export telemetry to OTLP collector

[Section titled “Export telemetry to OTLP collector”](#export-telemetry-to-otlp-collector)

Keycloak containers can export telemetry to your OTLP collector using the `WithOtlpExporter` method:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var keycloak = builder.AddKeycloak("keycloak", 8080)
    .WithOtlpExporter();


var apiService = builder.AddProject<Projects.ApiService>("apiservice")
    .WithReference(keycloak)
    .WaitFor(keycloak);
```

This enables Keycloak to send traces, metrics, and logs to the Aspire dashboard, providing better observability for your authentication flows.

### Hosting integration health checks

[Section titled “Hosting integration health checks”](#hosting-integration-health-checks)

The Keycloak hosting integration doesn’t currently support health checks, nor does it automatically add them.

## Client integration

[Section titled “Client integration”](#client-integration)

To get started with the Keycloak client integration, install the [📦 Aspire.Keycloak.Authentication](https://www.nuget.org/packages/Aspire.Keycloak.Authentication) NuGet package in your ASP.NET Core project:

* .NET CLI

  .NET CLI — Add Aspire.Keycloak.Authentication package

  ```bash
  dotnet add package Aspire.Keycloak.Authentication
  ```

* Program.cs (C# file-based app)

  Program.cs

  ```csharp
  #:package Aspire.Keycloak.Authentication@*
  ```

* PackageReference (\*.csproj)

  XML — Add Aspire.Keycloak.Authentication package reference

  ```xml
  <PackageReference Include="Aspire.Keycloak.Authentication" Version="*" />
  ```

The Keycloak client integration registers JwtBearer and OpenId Connect authentication handlers in the DI container for connecting to a Keycloak server.

### Add JWT bearer authentication

[Section titled “Add JWT bearer authentication”](#add-jwt-bearer-authentication)

In the `Program.cs` file of your ASP.NET Core API project, call the `AddKeycloakJwtBearer` extension method to add JwtBearer authentication:

```csharp
builder.Services.AddAuthentication()
                .AddKeycloakJwtBearer(
                    serviceName: "keycloak",
                    realm: "api",
                    options =>
                    {
                        options.Audience = "store.api";


                        // For development only - disable HTTPS metadata validation
                        // In production, use explicit Authority configuration instead
                        if (builder.Environment.IsDevelopment())
                        {
                            options.RequireHttpsMetadata = false;
                        }
                    });
```

Caution

When using `RequireHttpsMetadata = true` (the default), the JWT Bearer authentication requires the Authority URL to use HTTPS. However, Aspire service discovery uses the `https+http://` scheme, which doesn’t satisfy this requirement. For production scenarios where HTTPS metadata validation is required, you need to explicitly configure the Authority URL.

### Add OpenId Connect authentication

[Section titled “Add OpenId Connect authentication”](#add-openid-connect-authentication)

In the `Program.cs` file of your API-consuming project (for example, Blazor), call the `AddKeycloakOpenIdConnect` extension method to add OpenId Connect authentication:

```csharp
builder.Services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)
                .AddKeycloakOpenIdConnect(
                    serviceName: "keycloak",
                    realm: "api",
                    options =>
                    {
                        options.ClientId = "StoreWeb";
                        options.ResponseType = OpenIdConnectResponseType.Code;
                        options.Scope.Add("store:all");
                    });
```

## Production considerations

[Section titled “Production considerations”](#production-considerations)

When deploying Keycloak authentication to production environments, there are several important security considerations:

### HTTPS metadata requirements

[Section titled “HTTPS metadata requirements”](#https-metadata-requirements)

By default, JWT Bearer authentication in ASP.NET Core has `RequireHttpsMetadata = true`, which requires that the Authority URL uses HTTPS.

For production scenarios, configure the Authority URL explicitly:

```csharp
builder.Services.AddAuthentication()
    .AddKeycloakJwtBearer(
        serviceName: "keycloak",
        realm: "MyRealm",
        configureOptions: options =>
        {
            // Explicitly set the Authority for production
            if (!builder.Environment.IsDevelopment())
            {
                options.Authority = "https://your-keycloak-server.com/realms/MyRealm";
            }


            options.Audience = "my.api";
        });
```

### Connection string configuration

[Section titled “Connection string configuration”](#connection-string-configuration)

For production deployments, consider using connection strings:

```csharp
// In AppHost.cs
builder.AddConnectionString("keycloak", "https://your-keycloak-server.com");
```

### Security best practices

[Section titled “Security best practices”](#security-best-practices)

* Always use `RequireHttpsMetadata = true` in production environments
* Use secure, validated SSL certificates for your Keycloak server
* Configure appropriate realm settings and client configurations in Keycloak
* Implement proper token validation and audience checks
* Consider using Keycloak’s built-in security features like rate limiting and brute force protection

# API browser

> Search and explore Aspire's APIs from Microsoft using the Aspire API browser.

Welcome to the Aspire API browser — your one-stop shop for all `public` APIs from Aspire. To get started, simply enter your search terms in the search box below. You can search by API names, types, members, or keywords to quickly find the information you need.

Note

We’re actively exploring ways to improve the API browsing experience. Today, we still host APIs on [learn.microsoft.com](https://learn.microsoft.com/dotnet/api/?view=dotnet-aspire-13.0), but we’re working towards integrating more features directly into this browser. Stay tuned for updates!

Search Aspire APIs Search Aspire APIs...

Clear

Version:

Aspire 13 (dotnet-aspire-13.0)

# aspire command

> Learn about the aspire command (the generic driver for the Aspire CLI) and its usage.

## Name

[Section titled “Name”](#name)

`aspire` - The generic driver for the Aspire CLI.

## Synopsis

[Section titled “Synopsis”](#synopsis)

To get information about the available commands and the environment:

Aspire CLI

```bash
aspire [command] [options]
```

## Description

[Section titled “Description”](#description)

The `aspire` command provides commands for working with Aspire projects. For example, `aspire run` runs your Aspire AppHost.

## Options

[Section titled “Options”](#options)

The following options are available when `aspire` is used by itself, without specifying a command. For example, `aspire --version`.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`--version`**

  Prints the version of the Aspire CLI tool.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--non-interactive`**

  Run the command in non-interactive mode, disabling all interactive prompts and spinners.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Commands

[Section titled “Commands”](#commands)

The following commands are available:

| Command                                | Status  | Function                                                                           |
| -------------------------------------- | ------- | ---------------------------------------------------------------------------------- |
| [`aspire add`](../aspire-add/)         | Stable  | Add an integration to the Aspire project.                                          |
| [`aspire cache`](../aspire-cache/)     | Stable  | Manage disk cache for CLI operations.                                              |
| [`aspire config`](../aspire-config/)   | Stable  | Configures the Aspire environment.                                                 |
| [`aspire deploy`](../aspire-deploy/)   | Preview | Deploys the artifacts created by `aspire publish`.                                 |
| [`aspire do`](../aspire-do/)           | Preview | Execute a specific pipeline step and its dependencies.                             |
| [`aspire doctor`](../aspire-doctor/)   | Stable  | Check the development environment for common issues.                               |
| [`aspire exec`](../aspire-exec/)       | Preview | Similar to the `aspire run` command, but passes commands to the apphost.           |
| [`aspire init`](../aspire-init/)       | Stable  | Initialize Aspire support in an existing solution or create a single-file AppHost. |
| [`aspire mcp`](../aspire-mcp/)         | Stable  | Manage MCP (Model Context Protocol) server.                                        |
| [`aspire new`](../aspire-new/)         | Stable  | Create an Aspire sample project from a template.                                   |
| [`aspire publish`](../aspire-publish/) | Preview | Generates deployment artifacts for an Aspire apphost project.                      |
| [`aspire run`](../aspire-run/)         | Stable  | Run an Aspire apphost for local development.                                       |
| [`aspire update`](../aspire-update/)   | Preview | Update Aspire packages and templates in your project.                              |

## Examples

[Section titled “Examples”](#examples)

* Create an Aspire solution from the template:

  Aspire CLI

  ```bash
  aspire new aspire-starter
  ```

* Run an Aspire AppHost:

  Aspire CLI

  ```bash
  aspire run
  ```

# aspire add command

> Learn about the aspire add command and its usage. This command adds an integration package to an Aspire AppHost project.

## Name

[Section titled “Name”](#name)

`aspire add` - Add an integration to the Aspire project.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire add [<integration>] [options]
```

## Description

[Section titled “Description”](#description)

The `aspire add` command searches for an integration package and adds it to the Aspire AppHost.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

## Arguments

[Section titled “Arguments”](#arguments)

The following arguments are available:

* **`integration`**

  The name of the integration to add (for example: redis, postgres).

  If a partial name or invalid name is provided, the CLI searches NuGet for approximate matches and prints them in the terminal for the user to select. If no results are found, all packages are listed.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--project`**

  The path to the Aspire AppHost project file.

* **`-v, --version`**

  The version of the integration to add.

* **`-s, --source`**

  The NuGet source to use for the integration.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Finds an AppHost project and lists all Aspire integration packages from NuGet:

  Aspire CLI

  ```bash
  aspire add
  ```

* Finds an AppHost project and adds the **kafka** (Aspire.Hosting.Kafka) integration package:

  Aspire CLI

  ```bash
  aspire add kafka --version 13.1.0
  ```

# aspire cache command

> Learn about the aspire cache command and its usage. This command driver is used to manage disk cache for Aspire CLI operations.

## Name

[Section titled “Name”](#name)

`aspire cache` - Manage disk cache for CLI operations.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire cache [command] [options]
```

## Description

[Section titled “Description”](#description)

The `aspire cache` command manages the disk cache used by the Aspire CLI for various operations. The CLI caches data such as downloaded templates, NuGet package information, and other temporary files to improve performance and reduce network requests.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Commands

[Section titled “Commands”](#commands)

The following commands are available:

| Command                                        | Status | Function                 |
| ---------------------------------------------- | ------ | ------------------------ |
| [`aspire cache clear`](../aspire-cache-clear/) | Stable | Clear all cache entries. |

## Cache location

[Section titled “Cache location”](#cache-location)

The Aspire CLI stores cache data in a platform-specific location:

* **Windows**: `%LOCALAPPDATA%\.aspire\cli\cache\`
* **macOS/Linux**: `~/.aspire/cli/cache/`

## When to clear cache

[Section titled “When to clear cache”](#when-to-clear-cache)

You may want to clear the cache in the following scenarios:

* After updating the Aspire CLI to ensure fresh data
* When experiencing issues with template installation
* To free up disk space
* When NuGet package information appears outdated
* When troubleshooting CLI behavior

## See also

[Section titled “See also”](#see-also)

* [aspire cache clear command](../aspire-cache-clear/)
* [aspire config command](../aspire-config/)

# aspire cache clear command

> Learn about the aspire cache clear command and its usage. This command clears all cache entries used by the Aspire CLI.

## Name

[Section titled “Name”](#name)

`aspire cache clear` - Clear all cache entries.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire cache clear [options]
```

## Description

[Section titled “Description”](#description)

The `aspire cache clear` command removes all cached data stored by the Aspire CLI. This includes downloaded templates, NuGet package metadata, and other temporary files used to improve CLI performance.

Clearing the cache forces the CLI to re-download templates and refresh package information on the next operation, which can help resolve issues related to stale or corrupted cache data.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Clear all cached data:

  Aspire CLI

  ```bash
  aspire cache clear
  ```

## What gets cleared

[Section titled “What gets cleared”](#what-gets-cleared)

The `aspire cache clear` command removes:

* Downloaded project templates
* NuGet package metadata and search results
* Integration package information
* Temporary build artifacts
* Other CLI operation caches

Note

This command does not remove: - The Aspire CLI installation itself - Configuration settings (those are managed by `aspire config`) - Your Aspire projects or their dependencies

## Performance impact

[Section titled “Performance impact”](#performance-impact)

After clearing the cache:

* The first `aspire new` command may take longer as templates are re-downloaded
* The first `aspire add` command may be slower as package information is refreshed
* Subsequent operations will benefit from the rebuilt cache

## See also

[Section titled “See also”](#see-also)

* [aspire cache command](../aspire-cache/)
* [aspire config command](../aspire-config/)

# aspire config command

> Learn about the aspire config command and its usage. This command driver is used to manage the Aspire CLI config settings.

## Name

[Section titled “Name”](#name)

`aspire config` - Manage configuration settings.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire config [command] [options]
```

## Description

[Section titled “Description”](#description)

The `aspire config` command manages the Aspire CLI config settings.

Aspire supports a local and global settings file. Settings defined in a local settings file override those set in the global settings file.

* **Local settings**

  A local settings file is stored at `.aspire/settings.json` under the current directory.

* **Global settings**

  The global settings file is stored at `$HOME/.aspire/settings.json`.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Commands

[Section titled “Commands”](#commands)

The following commands are available:

| Command                                                    | Status | Function                       |
| ---------------------------------------------------------- | ------ | ------------------------------ |
| [`aspire config list`](../aspire-config-list/)             | Stable | List all configuration values. |
| [`aspire config get <key>`](../aspire-config-get/)         | Stable | Get a configuration value.     |
| [`aspire config set <key> <value>`](../aspire-config-set/) | Stable | Set a configuration value.     |
| [`aspire config delete <key>`](../aspire-config-delete/)   | Stable | Delete a configuration value.  |

## Settings

[Section titled “Settings”](#settings)

The following config settings are available:

| Setting                                        | Description                                     |
| ---------------------------------------------- | ----------------------------------------------- |
| `appHostPath`                                  | Path to default AppHost project.                |
| `features.defaultWatchEnabled`                 | Enable watch mode by default for run command.   |
| `features.dotnetSdkInstallationEnabled`        | Enable automatic .NET SDK installation.         |
| `features.execCommandEnabled`                  | Enable exec command.                            |
| `features.minimumSdkCheckEnabled`              | Enforce minimum SDK version.                    |
| `features.orphanDetectionWithTimestampEnabled` | Use timestamp-based orphan detection.           |
| `features.packageSearchDiskCachingEnabled`     | Cache package search results on disk.           |
| `features.runningInstanceDetectionEnabled`     | Enable detection of already running instances.  |
| `features.showAllTemplates`                    | Show all templates including experimental ones. |
| `features.showDeprecatedPackages`              | Show deprecated packages.                       |
| `features.stagingChannelEnabled`               | Use staging channel packages.                   |
| `features.updateNotificationsEnabled`          | Show update notifications.                      |

# aspire config delete command

> Learn about the aspire config delete command and its usage. This command deletes an Aspire CLI config value by key name.

## Name

[Section titled “Name”](#name)

`aspire config delete` - Delete a configuration value.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire config delete <key> [options]
```

## Description

[Section titled “Description”](#description)

The `aspire config delete` command deletes a config value by key name.

Aspire supports a local and global settings file. Settings defined in a local settings file override those set in the global settings file.

* **Local settings**

  A local settings file is stored at `.aspire/settings.json` under the current directory.

* **Global settings**

  The global settings file is stored at `$HOME/.aspire/settings.json`.

The command returns the following exit codes:

* `0`—The command succeeded.
* `1`—The supplied key doesn’t exist in the config file, or the config file is missing.

## Arguments

[Section titled “Arguments”](#arguments)

The following arguments are available:

* **`key`**

  The configuration key to delete.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-g, --global`**

  Delete the configuration value from the global `$HOME/.aspire/settings.json` instead of the local settings file.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

# aspire config get command

> Learn about the aspire config get command and its usage. This command gets an Aspire CLI config value by key name.

## Name

[Section titled “Name”](#name)

`aspire config get` - Get a configuration value.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire config get <key> [options]
```

## Description

[Section titled “Description”](#description)

The `aspire config get` command retrieves a config value by key name.

Aspire supports a local and global settings file. Settings defined in a local settings file override those set in the global settings file.

* **Local settings**

  A local settings file is stored at `.aspire/settings.json` under the current directory.

* **Global settings**

  The global settings file is stored at `$HOME/.aspire/settings.json`.

If the config value doesn’t exist in a local settings file, the config file is retrieved from the global settings file.

The command returns the following exit codes:

* `0`—The command succeeded.
* `10`—The supplied key doesn’t exist in the config file, or the config file is missing.

## Arguments

[Section titled “Arguments”](#arguments)

The following arguments are available:

* **`key`**

  The configuration key to retrieve.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

# aspire config list command

> Learn about the aspire config list command and its usage. This command lists all Aspire CLI config values.

## Name

[Section titled “Name”](#name)

`aspire config list` - List all configuration values.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire config list [options]
```

## Description

[Section titled “Description”](#description)

The `aspire config list` command lists all config value by key name.

Aspire supports a local and global settings file. Settings defined in a local settings file override those set in the global settings file.

* **Local settings**

  A local settings file is stored at `.aspire/settings.json` under the current directory.

* **Global settings**

  The global settings file is stored at `$HOME/.aspire/settings.json`.

This command lists both the global and local settings. If a local setting overrides a global setting, only the local setting is displayed.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

# aspire config set command

> Learn about the aspire config set command and its usage. This command sets an Aspire CLI config value by key name.

## Name

[Section titled “Name”](#name)

`aspire config set` - Set a configuration value.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire config set <key> <value> [options]
```

## Description

[Section titled “Description”](#description)

The `aspire config set` command sets a config value by key name.

Aspire supports a local and global settings file. Settings defined in a local settings file override those set in the global settings file.

* **Local settings**

  A local settings file is stored at `.aspire/settings.json` under the current directory.

* **Global settings**

  The global settings file is stored at `$HOME/.aspire/settings.json`.

## Arguments

[Section titled “Arguments”](#arguments)

The following arguments are available:

* **`key`**

  The configuration key to set.

* **`value`**

  The configuration value to set.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-g, --global`**

  Set the configuration value globally in `$HOME/.aspire/settings.json` instead of the local settings file.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Settings

[Section titled “Settings”](#settings)

The following config settings are available:

| Setting                                        | Description                                     |
| ---------------------------------------------- | ----------------------------------------------- |
| `appHostPath`                                  | Path to default AppHost project.                |
| `features.defaultWatchEnabled`                 | Enable watch mode by default for run command.   |
| `features.dotnetSdkInstallationEnabled`        | Enable automatic .NET SDK installation.         |
| `features.execCommandEnabled`                  | Enable exec command.                            |
| `features.minimumSdkCheckEnabled`              | Enforce minimum SDK version.                    |
| `features.orphanDetectionWithTimestampEnabled` | Use timestamp-based orphan detection.           |
| `features.packageSearchDiskCachingEnabled`     | Cache package search results on disk.           |
| `features.runningInstanceDetectionEnabled`     | Enable detection of already running instances.  |
| `features.showAllTemplates`                    | Show all templates including experimental ones. |
| `features.showDeprecatedPackages`              | Show deprecated packages.                       |
| `features.stagingChannelEnabled`               | Use staging channel packages.                   |
| `features.updateNotificationsEnabled`          | Show update notifications.                      |

# aspire deploy command

> Learn about the aspire deploy command and its usage. This command first runs publishing mode, then invokes resource deployments declared by the AppHost.

## Name

[Section titled “Name”](#name)

`aspire deploy` - Deploy a codebase orchestrated with Aspire to specified targets.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire deploy [options] [[--] <additional arguments>...]
```

## Description

[Section titled “Description”](#description)

The `aspire deploy` command first invokes the [`aspire publish`](../aspire-publish/) command. After which, Aspire invokes all `DeployingCallbackAnnotation` resource annotations, in the order they’re declared.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

The command performs the following steps to deploy an app orchestrated with Aspire:

* Creates or modifies the `.aspire/settings.json` config file in the current directory, and sets the `appHostPath` config value to the path of the AppHost project file.
* Installs or verifies that Aspire’s local hosting certificates are installed and trusted.
* Builds the AppHost project and its resources.
* Starts the AppHost and its resources.
* Invokes all `PublishingCallbackAnnotation` resource annotations.
* Invokes all `DeployingCallbackAnnotation` resource annotations.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--`**

  Delimits arguments to `aspire publish` from arguments for the AppHost. All arguments after this delimiter are passed to the apphost.

* **`--project`**

  The path to the Aspire AppHost project file.

* **`-o, --output-path`**

  The optional output path for deployment artifacts. Defaults to the `aspire-output` folder relative to the apphost.

* **`--log-level`**

  Set the minimum log level for pipeline logging. Valid values are: `trace`, `debug`, `information`, `warning`, `error`, `critical`. The default is `information`.

* **`-e, --environment`**

  The environment to use for the operation. The default is `Production`.

* **`--include-exception-details`**

  Include exception details (stack traces) in pipeline logs.

* **`--clear-cache`**

  Clear the deployment cache associated with the current environment and do not save deployment state.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Search the current directory structure for AppHost projects to build, publish, and deploy:

  Aspire CLI

  ```bash
  aspire deploy
  ```

* Publish and deploy an Aspire apphost and its dependencies:

  Aspire CLI

  ```bash
  aspire deploy --project './projects/apphost/orchestration.AppHost.csproj'
  ```

* Publish and deploy an Aspire AppHost with arguments:

  Aspire CLI

  ```bash
  aspire deploy --project './projects/apphost/orchestration.AppHost.csproj' -- -fast
  ```

# aspire do command

> Learn about the aspire do command and its usage. This command executes a specific pipeline step and its dependencies.

## Name

[Section titled “Name”](#name)

`aspire do` - Execute a specific pipeline step and its dependencies.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire do <step> [options] [[--] <additional arguments>...]
```

## Description

[Section titled “Description”](#description)

The `aspire do` command executes a specific pipeline step and its dependencies in your Aspire AppHost. This command provides fine-grained control over the orchestration pipeline, allowing you to run individual steps of the deployment or build process.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

The command allows you to:

* Execute specific pipeline steps without running the entire pipeline
* Run only the dependencies needed for a particular step
* Test individual pipeline stages during development
* Customize pipeline execution with environment-specific settings
* Discover available steps and their dependencies using the diagnostics step

For more information, see [Pipelines and app topology](/get-started/pipelines/).

## Arguments

[Section titled “Arguments”](#arguments)

The following arguments are available:

* **`step`**

  The name of the step to execute.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--`**

  Delimits arguments to `aspire do` from arguments for the AppHost. All arguments after this delimiter are passed to the application being run.

* **`--project`**

  The path to the Aspire AppHost project file.

* **`-o, --output-path`**

  The optional output path for artifacts.

* **`--log-level`**

  Set the minimum log level for pipeline logging. Valid values are: `trace`, `debug`, `information`, `warning`, `error`, `critical`. The default is `information`.

* **`-e, --environment`**

  The environment to use for the operation. The default is `Production`.

* **`--include-exception-details`**

  Include exception details (stack traces) in pipeline logs.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Discovering available steps

[Section titled “Discovering available steps”](#discovering-available-steps)

Before executing a pipeline step, you can discover what steps are available in your application’s pipeline and understand their dependencies using the `diagnostics` step.

### Understanding pipeline structure

[Section titled “Understanding pipeline structure”](#understanding-pipeline-structure)

The `aspire do diagnostics` command provides comprehensive information about your pipeline, including:

* All available steps and their dependencies
* Execution order with parallelization indicators
* Step dependencies and target resources
* Configuration issues like orphaned steps or circular dependencies

This is particularly useful after installing a deployment package or when you want to understand which steps will execute for a given command.

### Well-known steps

[Section titled “Well-known steps”](#well-known-steps)

Aspire provides several well-known steps that serve as entry points for common operations:

* **`build`**: Builds container images for compute resources defined in the application
* **`push`**: Pushes container images to registries after they have been built
* **`publish`**: Generates deployment artifacts by serializing resources to disk
* **`deploy`**: Orchestrates the complete deployment process including infrastructure provisioning, image building, and application deployment

Resources in your application can contribute their own custom steps, and you can add application-specific steps through the pipeline API.

## Examples

[Section titled “Examples”](#examples)

The following examples demonstrate common pipeline operations:

* Examine the pipeline structure and available steps:

  Aspire CLI

  ```bash
  aspire do diagnostics
  ```

  This displays all steps in your pipeline, their dependencies, and execution order. Use this to understand what steps are available and how they relate to each other.

* Build container images for your application:

  Aspire CLI

  ```bash
  aspire do build
  ```

  This builds all container images for compute resources defined in your AppHost.

* Push container images to a registry:

  Aspire CLI

  ```bash
  aspire do push
  ```

  This pushes built container images to their configured registries. The push step automatically includes its dependencies (building images and ensuring registry availability) before pushing.

* Execute a pipeline step with debug logging:

  Aspire CLI

  ```bash
  aspire do deploy --log-level debug
  ```

  Use debug logging to get detailed troubleshooting output during step execution.

* Execute a pipeline step for a specific environment:

  Aspire CLI

  ```bash
  aspire do publish --environment Staging
  ```

  Target different environments to use environment-specific configurations.

* Execute a pipeline step with custom output path:

  Aspire CLI

  ```bash
  aspire do publish --output-path ./artifacts
  ```

  Specify where publishing artifacts should be written.

* Execute a pipeline step with additional arguments:

  Aspire CLI

  ```bash
  aspire do test -- --configuration Release
  ```

  Pass additional arguments to the AppHost after the `--` delimiter.

# aspire doctor command

> Learn about the aspire doctor command and its usage. This command checks the Aspire development environment for common issues.

## Name

[Section titled “Name”](#name)

`aspire doctor` - Check the Aspire development environment for common issues.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire doctor [options]
```

## Description

[Section titled “Description”](#description)

The `aspire doctor` command runs a series of diagnostic checks to verify that your development environment is properly configured for Aspire development. It checks prerequisites such as the .NET SDK, container runtime, and environment settings.

This command is useful for troubleshooting when you encounter issues with Aspire or when setting up a new development environment. The checks are grouped by category:

* **SDK checks**: Verifies .NET SDK installation and version requirements
* **Container checks**: Validates container runtime (Docker/Podman) availability and configuration
* **Environment checks**: Validates environment variables and other settings

The command displays results with clear status indicators:

* ✓ (green) - Check passed
* ⚠ (yellow) - Warning (non-blocking issue)
* ✗ (red) - Check failed (blocking issue)

If any checks fail, the command provides suggestions for how to fix the issues and links to relevant documentation.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--json`**

  Outputs the check results in JSON format. This is useful for automation scenarios or when you need to parse the results programmatically.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Run diagnostic checks on your development environment:

  Aspire CLI

  ```bash
  aspire doctor
  ```

* Run diagnostic checks with JSON output:

  Aspire CLI

  ```bash
  aspire doctor --json
  ```

## Sample output

[Section titled “Sample output”](#sample-output)

When you run `aspire doctor`, you see output similar to the following:

Aspire CLI

```bash
Environment Check
=================


SDK
✓  .NET SDK 10.0.100 or later is installed
✓  Aspire templates are available


Container Runtime
✓  Docker is installed and running
✓  Docker Compose is available


Environment
✓  ASPNETCORE_ENVIRONMENT is set correctly


Summary: 5 passed, 0 warnings, 0 failed
```

## Exit codes

[Section titled “Exit codes”](#exit-codes)

The command returns the following exit codes:

| Exit code | Description                              |
| --------- | ---------------------------------------- |
| `0`       | All checks passed (warnings are allowed) |
| `1`       | One or more checks failed                |

## JSON output format

[Section titled “JSON output format”](#json-output-format)

When using the `--json` option, the output includes a structured response with all check results and a summary:

```json
{
  "checks": [
    {
      "category": "sdk",
      "message": ".NET SDK 10.0.100 or later is installed",
      "status": "Pass"
    }
  ],
  "summary": {
    "passed": 5,
    "warnings": 0,
    "failed": 0
  }
}
```

## See also

[Section titled “See also”](#see-also)

* [aspire command](../aspire/)
* [aspire run command](../aspire-run/)
* [Aspire CLI overview](../../overview/)

# aspire exec command

> Learn about the aspire exec command and its usage. This command builds and runs an Aspire AppHost project, then sends commands to a resource.

Note

This command is disabled by default. To use it, turn on the feature toggle by running:

Aspire CLI

```bash
aspire config set features.execCommandEnabled true
```

For more information, see [aspire config command](../aspire-config/).

## Name

[Section titled “Name”](#name)

`aspire exec` - Run an Aspire AppHost to execute a command against the resource.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire exec [options] [[--] <additional arguments>...]
```

## Description

[Section titled “Description”](#description)

The `aspire exec` command runs a command in the context of one of the resources defined in the AppHost.

You must specify either the `--resource` or the `--start-resource` option, and you must provide parameters with the `--` option.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--`**

  Delimits arguments to `aspire exec` from arguments for the resource. All arguments after this delimiter are passed to the resource.

* **`--project`**

  The path to the Aspire AppHost project file.

* **`-r, --resource`**

  The name of the target resource to execute the command against.

* **`-s, --start-resource`**

  The name of the target resource to start and execute the command against.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Builds and runs the AppHost project, then sends the command `migrate` to the `database1` resource:

  Aspire CLI

  ```bash
  aspire exec --resource database1 -- migrate
  ```

# aspire init command

> Learn about the aspire init command and its usage. This command initializes Aspire support in an existing solution or creates a single-file AppHost.

## Name

[Section titled “Name”](#name)

`aspire init` - Initialize Aspire support in an existing solution or create a single-file AppHost.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire init [options]
```

## Description

[Section titled “Description”](#description)

The `aspire init` command initializes Aspire support in your existing .NET solution or creates a single-file AppHost project. This is useful when you want to add Aspire orchestration capabilities to an existing application without creating an entirely new solution structure.

This command defaults to **interactive** mode. When executed without any options, the command prompts you for the necessary information. When the `--version` and `--source` options are provided, the command runs **non-interactive** mode.

The command performs the following actions:

* Analyzes your existing solution structure
* Adds the necessary Aspire AppHost project or creates a single-file AppHost
* Installs required Aspire packages
* Sets up the initial configuration for orchestration

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-s, --source`**

  The NuGet source to use for the project templates.

* **`-v, --version`**

  The version of the project templates to use.

* **`--channel`**

  Channel to use for templates (`stable`, `staging`, `daily`).

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Initialize Aspire support in the current solution interactively:

  Aspire CLI

  ```bash
  aspire init
  ```

* Initialize Aspire support using a specific template version:

  Aspire CLI

  ```bash
  aspire init --version 13.1.0
  ```

* Initialize Aspire support from a custom NuGet source:

  Aspire CLI

  ```bash
  aspire init --source https://api.nuget.org/v3/index.json --version 13.1.0
  ```

# aspire mcp command

> Learn about the aspire mcp command and its usage. This command driver is used to manage MCP (Model Context Protocol) server operations.

## Name

[Section titled “Name”](#name)

`aspire mcp` - Manage MCP (Model Context Protocol) server.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire mcp [command] [options]
```

## Description

[Section titled “Description”](#description)

The `aspire mcp` command manages MCP (Model Context Protocol) server operations for Aspire. The MCP server enables AI assistants and development tools to interact with your Aspire AppHost, providing capabilities such as resource management, diagnostics, and observability.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Commands

[Section titled “Commands”](#commands)

The following commands are available:

| Command                                    | Status | Function                                                             |
| ------------------------------------------ | ------ | -------------------------------------------------------------------- |
| [`aspire mcp start`](../aspire-mcp-start/) | Stable | Start the MCP (Model Context Protocol) server.                       |
| [`aspire mcp init`](../aspire-mcp-init/)   | Stable | Initialize MCP server configuration for detected agent environments. |

## See also

[Section titled “See also”](#see-also)

* [aspire mcp start command](../aspire-mcp-start/)
* [aspire mcp init command](../aspire-mcp-init/)

# aspire mcp init command

> Learn about the aspire mcp init command and its usage. This command initializes MCP server configuration for detected agent environments.

## Name

[Section titled “Name”](#name)

`aspire mcp init` - Initialize MCP server configuration for detected agent environments.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire mcp init [options]
```

## Description

[Section titled “Description”](#description)

The `aspire mcp init` command initializes the MCP (Model Context Protocol) server configuration for your development environment. It detects agent environments (such as VS Code with GitHub Copilot, or other MCP-compatible tools) and creates the necessary configuration files to enable MCP integration.

The command performs the following:

* Detects supported agent environments in the current workspace
* Creates or updates MCP configuration files for each detected environment
* Sets up the connection between the agent and the Aspire MCP server

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Initialize MCP configuration for detected agent environments:

  Aspire CLI

  ```bash
  aspire mcp init
  ```

## See also

[Section titled “See also”](#see-also)

* [aspire mcp command](../aspire-mcp/)
* [aspire mcp start command](../aspire-mcp-start/)

# aspire mcp start command

> Learn about the aspire mcp start command and its usage. This command starts the MCP (Model Context Protocol) server.

## Name

[Section titled “Name”](#name)

`aspire mcp start` - Start the MCP (Model Context Protocol) server.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire mcp start [options]
```

## Description

[Section titled “Description”](#description)

The `aspire mcp start` command starts the MCP (Model Context Protocol) server, which enables AI assistants and development tools to interact with your Aspire AppHost. The MCP server provides a standardized interface for resource management, diagnostics, and observability operations.

When the server is running, MCP-compatible clients can connect to it to:

* List and manage Aspire resources
* View structured logs and traces
* Execute resource commands (start, stop, restart)
* Query integration information

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Start the MCP server:

  Aspire CLI

  ```bash
  aspire mcp start
  ```

## See also

[Section titled “See also”](#see-also)

* [aspire mcp command](../aspire-mcp/)
* [aspire mcp init command](../aspire-mcp-init/)

# aspire new command

> Learn about the aspire new command and its usage. This command creates new Aspire projects or solutions.

## Name

[Section titled “Name”](#name)

`aspire new` - Create a new Aspire project or solution.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire new [command] [options]
```

## Description

[Section titled “Description”](#description)

The `aspire new` command is the driver for creating Aspire projects, apps, or solutions, based on the Aspire templates. Each command specifies the template to use, and the options for the driver specify the options for the template.

This command defaults to **interactive** mode. When executed without any options, the command prompts you for the project template and version, name, and output folder. When the `--name`, `--output`, and `--version` options are provided, the command runs **non-interactive** and generates files based on the command template.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`-n, --name`**

  The name of the project to create.

* **`-o, --output`**

  The output path for the project.

* **`-s, --source`**

  The NuGet source to use for the project templates.

* **`-v, --version`**

  The version of the project templates to use.

* **`--channel`**

  Channel to use for templates (`stable`, `staging`, `daily`).

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Commands

[Section titled “Commands”](#commands)

Each command represents a template. Pass the `--help` parameter to the template command to print the options available to the template.

| Command                     | Template                          |
| --------------------------- | --------------------------------- |
| `aspire-starter`            | Starter App (ASP.NET Core/Blazor) |
| `aspire-ts-cs-starter`      | Starter App (ASP.NET Core/React)  |
| `aspire-py-starter`         | Starter App (FastAPI/React)       |
| `aspire-apphost-singlefile` | Empty AppHost                     |

## Examples

[Section titled “Examples”](#examples)

* Create an Aspire solution from the template. Because the template was selected (`aspire-starter`), you’re prompted for the name, output folder, and template version.

  Aspire CLI

  ```bash
  aspire new aspire-starter
  ```

* Create an AppHost project named `aspireapp` from the **13.1.0** templates and place the output in a folder named `dev`.

  Aspire CLI

  ```bash
  aspire new aspire-apphost-singlefile --version 13.1.0 --name aspireapp --output ./dev
  ```

* Create an Aspire starter app using templates from the `daily` channel to get the latest pre-release templates.

  Aspire CLI

  ```bash
  aspire new aspire-starter --channel daily
  ```

# aspire publish command

> Learn about the aspire publish command and its usage. This command invokes resource publishers declared by the apphost to serialize resources to disk.

## Name

[Section titled “Name”](#name)

`aspire publish` - Generates deployment artifacts for an Aspire AppHost project.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire publish [options] [[--] <additional arguments>...]
```

## Description

[Section titled “Description”](#description)

The `aspire publish` command publishes resources by serializing them to disk. When this command is run, Aspire invokes registered `PublishingCallbackAnnotation` annotations for resources, in the order they’re declared. These annotations serialize a resource so that it can be consumed by deployment tools.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

The command performs the following steps to run an Aspire AppHost:

* Creates or modifies the `.aspire/settings.json` config file in the current directory, and sets the `appHostPath` config value to the path of the AppHost project file.
* Installs or verifies that Aspire’s local hosting certificates are installed and trusted.
* Builds the AppHost project and its resources.
* Starts the AppHost and its resources.
* Invokes all `PublishingCallbackAnnotation` annotations for resources.

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--`**

  Delimits arguments to `aspire publish` from arguments for the AppHost. All arguments after this delimiter are passed to the AppHost.

* **`--project`**

  The path to the Aspire AppHost project file.

* **`-o, --output-path`**

  The output path for the generated artifacts. Defaults to `./aspire-output` if not specified.

* **`--log-level`**

  Set the minimum log level for pipeline logging. Valid values are: `trace`, `debug`, `information`, `warning`, `error`, `critical`. The default is `information`.

* **`-e, --environment`**

  The environment to use for the operation. The default is `Production`.

* **`--include-exception-details`**

  Include exception details (stack traces) in pipeline logs.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Search the current directory structure for AppHost projects to build and publish:

  Aspire CLI

  ```bash
  aspire publish
  ```

* Publish a specific AppHost project:

  Aspire CLI

  ```bash
  aspire publish --project './projects/apphost/orchestration.AppHost.csproj'
  ```

* Publish a specific AppHost project with arguments:

  Aspire CLI

  ```bash
  aspire publish --project './projects/apphost/orchestration.AppHost.csproj' -- -fast
  ```

# aspire run command

> Learn about the aspire run command and its usage. This command runs an Aspire AppHost.

## Name

[Section titled “Name”](#name)

`aspire run` - Run an Aspire AppHost in development mode.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire run [options] [[--] <additional arguments>...]
```

## Description

[Section titled “Description”](#description)

The `aspire run` command runs the AppHost project in development mode, which configures the Aspire environment, builds and starts resources defined by the AppHost, launches the web dashboard, and prints a list of endpoints.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

The command performs the following steps to run an Aspire AppHost:

* Creates or modifies the `.aspire/settings.json` config file in the current directory, and sets the `appHostPath` config value to the path of the AppHost project file.
* Installs or verifies that Aspire’s local hosting certificates are installed and trusted.
* Builds the AppHost project and its resources.
* Starts the AppHost and its resources.
* Starts the dashboard.

The following snippet is an example of the output displayed by the `aspire run` command:

Aspire CLI

```bash
Dashboard:  https://localhost:17244/login?t=9db79f2885dae24ee06c6ef10290b8b2


    Logs:  /home/vscode/.aspire/cli/logs/apphost-5932-2025-08-25-18-37-31.log


        Press CTRL+C to stop the apphost and exit.
```

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--`**

  Delimits arguments to `aspire run` from arguments for the AppHost being run. All arguments after this delimiter are passed to the AppHost run.

* **`--project`**

  The path to the Aspire AppHost project file.

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Search the current directory structure for AppHost projects to build and run:

  Aspire CLI

  ```bash
  aspire run
  ```

* Run a specific AppHost project:

  Aspire CLI

  ```bash
  aspire run --project './projects/apphost/orchestration.AppHost.csproj'
  ```

* Run a specific AppHost project with arguments:

  Aspire CLI

  ```bash
  aspire run --project './projects/apphost/orchestration.AppHost.csproj' -- -fast
  ```

# aspire update command

> Learn about the aspire update command and its usage. This command helps you keep your Aspire projects current by automatically detecting and updating outdated packages and templates.

## Name

[Section titled “Name”](#name)

`aspire update` - Update Aspire packages and templates in your project.

## Synopsis

[Section titled “Synopsis”](#synopsis)

Aspire CLI

```bash
aspire update [options]
```

## Description

[Section titled “Description”](#description)

The `aspire update` command helps you keep your Aspire projects current by automatically detecting and updating outdated packages and templates. It finds outdated Aspire NuGet packages while respecting channel configurations and intelligently handles complex dependency graphs.

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

The command performs the following:

* Detects outdated Aspire NuGet packages in your project
* Respects your configured Aspire channel (preview, stable, etc.)
* Resolves diamond dependencies to avoid duplicate updates
* Validates package compatibility before applying changes
* Provides colorized output with detailed summary of changes

## Options

[Section titled “Options”](#options)

The following options are available:

* **`--project`**

  The path to the Aspire AppHost project file.

* **`--self`**

  Update the Aspire CLI itself to the latest version.

* **`--channel`**

  Channel to update to (`stable`, `staging`, `daily`).

* **`-?, -h, --help`**

  Prints help and usage documentation for the available commands and options.

* **`-d, --debug`**

  Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

* **`--wait-for-debugger`**

  Wait for a debugger to attach before running a command.

## Examples

[Section titled “Examples”](#examples)

* Analyze and update out-of-date Aspire packages and templates:

  Aspire CLI

  ```bash
  aspire update
  ```

* Update a specific AppHost project:

  Aspire CLI

  ```bash
  aspire update --project './projects/apphost/orchestration.AppHost.csproj'
  ```

# Configuration settings

> Learn about the Aspire CLI configuration settings, including feature flags and AppHost project settings.

The Aspire CLI uses a configuration file to control its behavior. You can configure feature flags to enable or disable CLI features, and specify which AppHost project the CLI should use by default for an Aspire solution.

The settings file is stored in a `.aspire` folder and is named `settings.json`. Settings files can be stored locally or globally.

The following snippet is an example `.aspire/settings.json` file:

.aspire/settings.json

```json
{
  "appHostPath": "../AspireShop/AspireShop.AppHost/AspireShop.AppHost.csproj",
  "features": {
    "deployCommandEnabled": "true"
  }
}
```

Note

For all available configuration settings in JSON format, see [Example settings file](#example-settings-file).

## Config file locations

[Section titled “Config file locations”](#config-file-locations)

A global Aspire CLI settings file is stored at `$HOME/.aspire/globalsettings.json`, and is used as the default settings for the CLI. A local settings file overwrites the settings from the global file. Local settings files are stored at `./.aspire/settings.json`.

* Bash

  You can inspect (and test existence of) the local and global settings files:

  Check local and global settings files

  ```bash
  # Check local and global settings files
  for f in ./.aspire/settings.json "$HOME/.aspire/globalsettings.json"; do
    [ -f "$f" ] && echo "$f (found)" || echo "$f (not found)"
  done


  # Optional: open global file
  nano "$HOME/.aspire/globalsettings.json"
  ```

* PowerShell

  Simple PowerShell to show file paths and whether they exist:

  Check local and global settings files

  ```powershell
  $local  = "$PWD\.aspire\settings.json"
  $global = "$HOME\.aspire\globalsettings.json"
  "Local :  $local  Exists: $(Test-Path $local)"
  "Global:  $global Exists: $(Test-Path $global)"


  # Optional: open global file in VS Code
  if (Test-Path $global) { code $global }
  ```

## Generating a config file

[Section titled “Generating a config file”](#generating-a-config-file)

The CLI automatically generates a local settings file when you run a command that requires interaction with the AppHost, or if you set a config option. For example, `aspire run` searches for an AppHost project, and when found, generates the `./.aspire/settings.json` file with the `appHostPath` setting set to the project it found.

Caution

`appHostPath` can be set globally, but the CLI ignores it and only reads it in the local settings file.

## Settings

[Section titled “Settings”](#settings)

The Aspire CLI supports two categories of configuration settings:

* **Feature flags**\
  These settings enable or disable specific CLI features. All feature flag setting names start with `feature.`

* **CLI behavior**\
  These settings control how the CLI operates. Currently, the only CLI behavior setting is `appHostPath`, which specifies the location of the AppHost project.

The following table lists the settings that can be set in the config file:

| Setting                                        | Description                                     |
| ---------------------------------------------- | ----------------------------------------------- |
| `appHostPath`                                  | Path to default AppHost project.                |
| `features.defaultWatchEnabled`                 | Enable watch mode by default for run command.   |
| `features.dotnetSdkInstallationEnabled`        | Enable automatic .NET SDK installation.         |
| `features.execCommandEnabled`                  | Enable exec command.                            |
| `features.minimumSdkCheckEnabled`              | Enforce minimum SDK version.                    |
| `features.orphanDetectionWithTimestampEnabled` | Use timestamp-based orphan detection.           |
| `features.packageSearchDiskCachingEnabled`     | Cache package search results on disk.           |
| `features.runningInstanceDetectionEnabled`     | Enable detection of already running instances.  |
| `features.showAllTemplates`                    | Show all templates including experimental ones. |
| `features.showDeprecatedPackages`              | Show deprecated packages.                       |
| `features.stagingChannelEnabled`               | Use staging channel packages.                   |
| `features.updateNotificationsEnabled`          | Show update notifications.                      |

### Example settings file

[Section titled “Example settings file”](#example-settings-file)

The following is an example with all supported settings:

.aspire/settings.json

```json
{
  "appHostPath": "../AspireShop/AspireShop.AppHost/AspireShop.AppHost.csproj",
  "features": {
    "deployCommandEnabled": "true",
    "doCommandEnabled": "true",
    "execCommandEnabled": "true",
    "minimumSdkCheckEnabled": "true",
    "orphanDetectionWithTimestampEnabled": "true",
    "packageSearchDiskCachingEnabled": "true",
    "publishCommandEnabled": "true",
    "showDeprecatedPackages": "true",
    "singleFileAppHostEnabled": "true",
    "stagingChannelEnabled": "true",
    "updateCommandEnabled": "true",
    "updateNotificationsEnabled": "true"
  }
}
```

## CLI commands

[Section titled “CLI commands”](#cli-commands)

| Command                                                                         | Status | Function                                          |
| ------------------------------------------------------------------------------- | ------ | ------------------------------------------------- |
| [`aspire config`](/reference/cli/commands/aspire-config-list/)                  | Stable | Command driver for managing Aspire configuration. |
| [`aspire config list`](/reference/cli/commands/aspire-config-list/)             | Stable | List all configuration values.                    |
| [`aspire config get <key>`](/reference/cli/commands/aspire-config-get/)         | Stable | Get a configuration value.                        |
| [`aspire config set <key> <value>`](/reference/cli/commands/aspire-config-set/) | Stable | Set a configuration value.                        |
| [`aspire config delete <key>`](/reference/cli/commands/aspire-config-delete/)   | Stable | Delete a configuration value.                     |

# Config File Description

Aspire supports a local and global settings file. Settings defined in a local settings file override those set in the global settings file.

* **Local settings**

  A local settings file is stored at `.aspire/settings.json` under the current directory.

* **Global settings**

  The global settings file is stored at `$HOME/.aspire/settings.json`.

# Config Settings Table

| Setting                                        | Description                                     |
| ---------------------------------------------- | ----------------------------------------------- |
| `appHostPath`                                  | Path to default AppHost project.                |
| `features.defaultWatchEnabled`                 | Enable watch mode by default for run command.   |
| `features.dotnetSdkInstallationEnabled`        | Enable automatic .NET SDK installation.         |
| `features.execCommandEnabled`                  | Enable exec command.                            |
| `features.minimumSdkCheckEnabled`              | Enforce minimum SDK version.                    |
| `features.orphanDetectionWithTimestampEnabled` | Use timestamp-based orphan detection.           |
| `features.packageSearchDiskCachingEnabled`     | Cache package search results on disk.           |
| `features.runningInstanceDetectionEnabled`     | Enable detection of already running instances.  |
| `features.showAllTemplates`                    | Show all templates including experimental ones. |
| `features.showDeprecatedPackages`              | Show deprecated packages.                       |
| `features.stagingChannelEnabled`               | Use staging channel packages.                   |
| `features.updateNotificationsEnabled`          | Show update notifications.                      |

# Debug Option

**`-d, --debug`**

Enable debug logging to the console, which prints detailed information about what Aspire CLI is doing when a command is run.

# Help Option

**`-?, -h, --help`**

Prints help and usage documentation for the available commands and options.

# Non-Interactive Option

**`--non-interactive`**

Run the command in non-interactive mode, disabling all interactive prompts and spinners.

# Option Project

**`--project`**

The path to the Aspire AppHost project file.

# Option Version

**`--version`**

Prints the version of the Aspire CLI tool.

# Option Wait

**`--wait-for-debugger`**

Wait for a debugger to attach before running a command.

# Project Search Logic

The Aspire CLI uses the following logic, in order, to determine which AppHost project to process:

* The `--project` option.

  This option specifies the path to a project to process.

* The `.aspire/settings.json` config file.

  If the config file path exists in the current directory, it’s used. If not, the CLI walks up the directory structure looking for the config file. If it finds a config file, it reads the `appHostPath` setting value as the project to process.

* Searches the current directory and subdirectories.

  Starting in the current directory, the CLI gathers all AppHost projects from that directory and below. If a single project is discovered, it’s automatically selected. If multiple projects are discovered, they’re printed to the terminal for the user to manually select one of the projects.

  Once a project is selected, either automatically or manually, the path to the project is stored in the `.aspire/settings.json` config file.

# Install script

> Learn about the aspire-install scripts to install the Aspire CLI. Use the Aspire CLI to create, run, and manage Aspire solutions.

This article describes the syntax for the Aspire installation scripts, available in both Bash and PowerShell versions. To download and use these scripts, see [Install the Aspire CLI](/get-started/install-cli/).

## Name

[Section titled “Name”](#name)

`aspire-install.ps1` | `aspire-install.sh` - Scripts used to install the Aspire CLI.

## Synopsis

[Section titled “Synopsis”](#synopsis)

* Bash

  Bash

  ```bash
  aspire-install.sh
    [--install-path <DIRECTORY>]
    [--version <VERSION>]
    [--quality <QUALITY>]
    [--os <OPERATING_SYSTEM>]
    [--arch <ARCHITECTURE>]
    [--skip-path]
    [--keep-archive]
    [--verbose]
    [--help]
  ```

* PowerShell

  PowerShell

  ```powershell
  aspire-install.ps1
    [-InstallPath <DIRECTORY>]
    [-Version <VERSION>]
    [-Quality <QUALITY>]
    [-OS <OPERATING_SYSTEM>]
    [-Architecture <ARCHITECTURE>]
    [-SkipPath]
    [-KeepArchive]
    [-Help]"
  ```

## Description

[Section titled “Description”](#description)

The `aspire-install` scripts perform a nonadmin installation of the Aspire CLI.

### Script behavior

[Section titled “Script behavior”](#script-behavior)

Both scripts behave the same way. They download the Aspire CLI for the target platform, install it to the specified location, and add it to your PATH environment variable.

By default, the installation scripts download and install the latest stable release of the Aspire CLI. Specify a different version with the `-Version|--version` argument or a different quality level with the `-Quality|--quality` argument.

Unless changed with the `-InstallPath|--install-path` argument, the script installs to a user-specific location: `%USERPROFILE%\.aspire\bin` on Windows or `$HOME/.aspire/bin` on Linux/macOS.

## Options

[Section titled “Options”](#options)

* **`-InstallPath|--install-path <DIRECTORY>`**

  Specifies the installation path. The directory is created if it doesn’t exist. The default value is *%USERPROFILE%.aspire\bin* on Windows and *$HOME/.aspire/bin* on Linux/macOS. The Aspire CLI executable is placed directly in this directory.

* **`-Version|--version <VERSION>`**

  Represents a specific version to install. For example: `9.4`. If not specified, the latest stable version is installed.

* **`-Quality|--quality <QUALITY>`**

  Downloads the specified quality build. The possible values are:

  * `release`: The latest stable release (default).
  * `staging`: Builds from the current release branch (prerelease builds).
  * `dev`: Latest builds from the `main` branch (development builds).

  The different quality values signal different stages of the release process:

  * `release`: The final stable releases of the Aspire CLI. Intended for production use.
  * `staging`: Prerelease builds intended for testing upcoming releases. Not recommended for production use.
  * `dev`: The latest builds from the main development branch. They’re built frequently and aren’t fully tested. Not recommended for production use but can be used to test specific features or fixes immediately after they’re merged.

* **`-OS|--os <OPERATING_SYSTEM>`**

  Specifies the operating system for which the CLI is being installed. Possible values are: `win`, `linux`, `linux-musl`, `osx`.

  The parameter is optional and should only be used when it’s required to override the operating system that is detected by the script.

* **`-Architecture|--arch <ARCHITECTURE>`**

  Architecture of the Aspire CLI binaries to install. Possible values are `x64`, `x86`, `arm64`. The default behavior is to autodetect the current system architecture.

* **`-SkipPath|--skip-path`**

  If you set this option, the script installs the CLI without modifying your `PATH` environment variable. Use this when you want to manually manage your PATH or when installing in environments where automatic `PATH` modification isn’t desired.

* **`-KeepArchive|--keep-archive`**

  If you set this option, the script keeps the downloaded archive files and temporary directory after installation. By default, the script deletes the archive after extraction and cleans up the temporary directory.

* **`--verbose`**

  Displays diagnostics information. (Linux/macOS only)

* **`-Help|--help`**

  Prints help information for the script.

## Examples

[Section titled “Examples”](#examples)

* Install the latest stable version to the default location:

  * Bash

    ```bash
    ./aspire-install.sh
    ```

  * PowerShell

    ```powershell
    .\aspire-install.ps1
    ```

* Install to a custom directory:

  * Bash

    ```bash
    ./aspire-install.sh --install-path "/usr/local/bin"
    ```

  * PowerShell

    ```powershell
    .\aspire-install.ps1 -InstallPath 'C:\Tools\Aspire'
    ```

* Install a specific version:

  * Bash

    ```bash
    ./aspire-install.sh --version "13.0"
    ```

  * PowerShell

    ```powershell
    .\aspire-install.ps1 -Version '13.0'
    ```

* Install development builds:

  * Bash

    ```bash
    ./aspire-install.sh --quality "dev"
    ```

  * PowerShell

    ```powershell
    .\aspire-install.ps1 -Quality 'dev'
    ```

* Download and install development builds in one command:

  * Bash

    ```bash
    curl -sSL https://aspire.dev/install.sh | bash -s -- --quality "dev"
    ```

  * PowerShell

    ```powershell
    Invoke-Expression "& { $(Invoke-RestMethod 'https://aspire.dev/install.ps1') } -Quality 'dev'"
    ```

* Install with verbose output (Linux/macOS only):

  * Bash

    ```bash
    ./aspire-install.sh --verbose
    ```

  * PowerShell

    ```powershell
    # The --verbose option is not available in the PowerShell script.
    ```

* Install without modifying `PATH`:

  * Bash

    ```bash
    ./aspire-install.sh --skip-path
    ```

  * PowerShell

    ```powershell
    .\aspire-install.ps1 -SkipPath
    ```

  Or download and install in one command:

  * Bash

    ```bash
    curl -fsSL https://aspire.dev/install.sh | bash -s -- --skip-path
    ```

  * PowerShell

    ```powershell
    irm https://aspire.dev/install.ps1 | iex -SkipPath
    ```

## Uninstall

[Section titled “Uninstall”](#uninstall)

There’s no uninstall script. Delete the installation directory, such as `%USERPROFILE%\.aspire\bin` on Windows or `$HOME/.aspire/bin` on Linux/macOS.

To delete the installation directory, run the following command from your terminal:

* Bash

  ```bash
  rm -rf $HOME/.aspire/bin
  ```

* PowerShell

  ```powershell
  Remove-Item -Recurse -Force "$HOME\.aspire\bin"
  ```

Reminder

After deleting the installation directory, don’t forget to remove it from your `PATH` environment variable.

## See also

[Section titled “See also”](#see-also)

* [Install Aspire CLI](/get-started/install-cli/)
* [`aspire` command reference](/reference/cli/commands/aspire/)

# Aspire CLI overview

The Aspire CLI (`aspire` command) is a cross-platform tool that provides command-line functionality to create, manage, run, and publish polyglot Aspire projects. Use the Aspire CLI to streamline development workflows and coordinate services for distributed applications.

Note

Starting with Aspire 13.0, the Aspire CLI requires .NET SDK version 10.0.100 or later. Ensure that you have the appropriate .NET SDK installed to use the Aspire CLI.

The Aspire CLI is an interactive-first experience.

[Install the Aspire CLI ](/get-started/install-cli/)Get started by installing the Aspire CLI on your machine.

[Review install script reference ](../install-script/)Explore the details of the install script with reference.

## Use templates

[Section titled “Use templates”](#use-templates)

The `aspire new` command is an interactive-first CLI experience, and is used to create one or more Aspire projects. As part of creating a project, Aspire CLI ensures that the latest Aspire project templates are installed into the `dotnet` system.

Use the `aspire new` command to create an Aspire project from a list of templates. Once a template is selected, the name of the project is set, and the output folder is chosen, `aspire` downloads the latest templates and generates one or more projects.

[Command reference: `aspire new`](../commands/aspire-new/)

### Example usage

[Section titled “Example usage”](#example-usage)

The following example shows running the `aspire new` command to create a new Aspire project — select the play button to view terminal playback:

While command-line parameters can be used to automate the creation of an Aspire project, the Aspire CLI is an interactive-first experience.

## Initialize existing solutions

[Section titled “Initialize existing solutions”](#initialize-existing-solutions)

The `aspire init` command adds Aspire support to an existing .NET solution or creates a single-file AppHost. This is useful when you want to add Aspire orchestration capabilities to an existing application without creating an entirely new solution structure.

The command analyzes your existing solution and adds the necessary Aspire AppHost project or creates a minimal single-file AppHost, making it easy to adopt Aspire incrementally.

[Command reference: `aspire init`](../commands/aspire-init/)

## Start the Aspire AppHost

[Section titled “Start the Aspire AppHost”](#start-the-aspire-apphost)

The `aspire run` command runs the AppHost project in development mode, which configures the Aspire environment, builds and starts resources defined by the AppHost, launches the web dashboard, and prints a list of endpoints.

When `aspire run` starts, it searches the current directory for an AppHost project. If a project isn’t found, the subdirectories are searched until one is found. If no AppHost project is found, Aspire stops. Once a project is found, Aspire CLI takes the following steps:

1. Installs or verifies that Aspire’s local hosting certificates are installed and trusted.
2. Builds the AppHost project and its resources.
3. Starts the AppHost and its resources.
4. Starts the dashboard.

The following snippet is an example of the output displayed by the `aspire run` command:

Aspire CLI

```bash
Dashboard:  https://localhost:17244/login?t=9db79f2885dae24ee06c6ef10290b8b2


    Logs:  /home/vscode/.aspire/cli/logs/apphost-5932-2025-08-25-18-37-31.log


        Press CTRL+C to stop the apphost and exit.
```

[Command reference: `aspire run`](../commands/aspire-run/)

## Add integrations

[Section titled “Add integrations”](#add-integrations)

The `aspire add` command is an easy way to add official integration packages to your AppHost project. Use this as an alternative to a NuGet search through your IDE. You can run `aspire add <name|id>` if you know the name or NuGet ID of the integration package. If you omit a name or ID, the tool provides a list of packages to choose from. If you provide a partial name or ID, the tool filters the list of packages with items that match the provided value.

[Command reference: `aspire add`](../commands/aspire-add/)

## Update Aspire packages

[Section titled “Update Aspire packages”](#update-aspire-packages)

The `aspire update` command helps you keep your Aspire projects current by automatically detecting and updating outdated packages and templates. It finds outdated Aspire NuGet packages while respecting channel configurations and intelligently handles complex dependency graphs.

The command validates package compatibility before applying changes and provides detailed output showing which packages were updated.

[Command reference: `aspire update`](../commands/aspire-update/)

## Publish Aspire applications

[Section titled “Publish Aspire applications”](#publish-aspire-applications)

The `aspire publish` command publishes resources by serializing them to disk. When this command is run, Aspire invokes registered `PublishingCallbackAnnotation` resource annotations, in the order they’re declared. These annotations serialize a resource so that it can be consumed by deployment tools.

Some integrations automatically register a `PublishingCallbackAnnotation` for you, for example:

* `AzureEnvironmentResource` generates Bicep assets
* `DockerComposeEnvironmentResource` generates docker-compose YAML
* `KubernetesEnvironmentResource` generates Kubernetes Helm charts

[Command reference: `aspire publish`](../commands/aspire-publish/)

## Deploy Aspire solutions

[Section titled “Deploy Aspire solutions”](#deploy-aspire-solutions)

The `aspire deploy` command is similar to `aspire publish`. After Aspire has invoked the publishing annotations to serialize resources to disk, it invokes `DeployingCallbackAnnotation` resource annotations, in the order they’re declared.

As of Aspire 9.4, Aspire doesn’t include any default deployment annotations for its resources, you must use the `DeployingCallbackAnnotation` to build your own.

Tip

Consider this a good way to deploy your Aspire solution to a staging or testing environment.

[Command reference: `aspire deploy`](../commands/aspire-deploy/)

## Execute pipeline steps

[Section titled “Execute pipeline steps”](#execute-pipeline-steps)

The `aspire do` command executes a specific pipeline step and its dependencies in your Aspire AppHost. This provides fine-grained control over the orchestration pipeline, allowing you to run individual steps of the deployment or build process without executing the entire pipeline.

Use this command to test individual pipeline stages during development or to execute only the dependencies needed for a particular step.

[Command reference: `aspire do`](../commands/aspire-do/)

## Run commands in resource context

[Section titled “Run commands in resource context”](#run-commands-in-resource-context)

The `aspire exec` command runs a command in the context of a specific Aspire resource, inheriting that resource’s configuration, including environment variables, connection strings, and working directory. This is particularly useful for scenarios like running Entity Framework migrations where you need to run commands with the same configuration as your application. For example, you can run `aspire exec --resource api -- dotnet ef migrations add Init` to run Entity Framework commands with the proper database connection strings automatically configured.

[Command reference: `aspire exec`](../commands/aspire-exec/)

## Manage CLI configuration

[Section titled “Manage CLI configuration”](#manage-cli-configuration)

The `aspire config` command lets you manage Aspire CLI configuration settings. Use it to `list`, `get`, `set`, or `delete` configuration values that control CLI behavior. This command is also used to toggle features on or off.

[Command reference: `aspire config`](../commands/aspire-config/)

## Manage CLI cache

[Section titled “Manage CLI cache”](#manage-cli-cache)

The `aspire cache` command manages the disk cache used by the Aspire CLI. The CLI caches data such as downloaded templates, NuGet package information, and other temporary files to improve performance and reduce network requests.

Use `aspire cache clear` to remove all cached data. This is useful when troubleshooting CLI issues, freeing up disk space, or ensuring fresh data after updating the CLI.

[Command reference: `aspire cache`](../commands/aspire-cache/)

# Reference overview

> Comprehensive overview of Aspire's reference documentation, including API reference search, and CLI reference content.

Reference materials are essential for developers to understand and effectively utilize Aspire’s features and functionalities. This section provides comprehensive reference documentation for Aspire, including API documentation and command-line interface (CLI) reference materials.

API browser

A searchable interface to explore all Aspire APIs, types, and members across the various Aspire packages.

[Browse APIs](/reference/api/browser/)

CLI reference

Documentation for the `aspire` command-line tool, including all available commands and options.

[View CLI Reference](/reference/cli/overview/)

# Aspire support policy

> Official support policy for Aspire - lifecycle, release cadence, and support guidelines.

📆 Last updated: December 17, 2025

## Microsoft support for Aspire

[Section titled “Microsoft support for Aspire”](#microsoft-support-for-aspire)

Every Microsoft product has a lifecycle, including Aspire. The lifecycle begins when a product is released and ends when it is no longer supported. Knowing key dates in this lifecycle helps you make informed decisions about when to upgrade or make other changes to your software. This product is governed by the [Microsoft Modern Lifecycle](https://support.microsoft.com/lifecycle) policy.

The Aspire support policy follows the Microsoft Modern Lifecycle with unique versioning and support policies specific to Aspire releases.

## Release cadence

[Section titled “Release cadence”](#release-cadence)

Aspire ships roughly a new major release every year with various minor releases throughout the year.

### Supported versions

[Section titled “Supported versions”](#supported-versions)

The following table lists Aspire versions that are actively supported:

| Version     | Original release date | Latest patch version | Patch release date | End of support                               |
| ----------- | --------------------- | -------------------- | ------------------ | -------------------------------------------- |
| Aspire 13.1 | December 17, 2025     | 13.1.0               | December 17, 2025  | When next major or minor version is released |

### Out of support versions

[Section titled “Out of support versions”](#out-of-support-versions)

The following table lists Aspire versions no longer supported:

| Version     | Original release date | Latest patch version | Patch release date | End of support     |
| ----------- | --------------------- | -------------------- | ------------------ | ------------------ |
| Aspire 13.0 | November 11, 2025     | 13.0.2               | December 3, 2025   | December 17, 2025  |
| Aspire 9.5  | September 25, 2025    | 9.5.2                | October 23, 2025   | November 11, 2025  |
| Aspire 9.4  | July 29, 2025         | 9.4.2                | September 2, 2025  | September 25, 2025 |
| Aspire 9.3  | May 19, 2025          | 9.3.2                | June 20, 2025      | July 29, 2025      |
| Aspire 9.2  | April 10, 2025        | 9.2.1                | April 24, 2025     | May 19, 2025       |
| Aspire 9.1  | February 25, 2025     | 9.1.0                | February 25, 2025  | April 10, 2025     |
| Aspire 9.0  | November 12, 2024     | 9.0.0                | November 12, 2024  | February 25, 2025  |
| Aspire 8.2  | August 29, 2024       | 8.2.2                | October 24, 2024   | November 12, 2024  |
| Aspire 8.1  | July 23, 2024         | 8.1.0                | July 23, 2024      | August 29, 2024    |
| Aspire 8.0  | May 21, 2024          | 8.0.2                | June 28, 2024      | July 23, 2024      |

## Versioning and support

[Section titled “Versioning and support”](#versioning-and-support)

At any time, only the latest release of Aspire is supported by Microsoft. For example: support for Aspire 8.0 ended when Aspire 8.1 was released.

To receive technical support from Microsoft, you need to be on the latest servicing level (update) for the latest Aspire release.

## Servicing updates

[Section titled “Servicing updates”](#servicing-updates)

Servicing updates may be made available for supported versions of Aspire. Aspire updates may include a mix of security and non-security fixes in a single patch update. In months without a patch update, a release might not occur.

## Support of containers used by Aspire

[Section titled “Support of containers used by Aspire”](#support-of-containers-used-by-aspire)

Aspire enables the use of third-party containers through resources and integrations. The Aspire team cannot evaluate the underlying third-party containers for which we have API support for suitability for specific customer requirements.

You should evaluate whichever containers you choose to compose and automate with Aspire to ensure they meet your, your employer’s, or your government’s requirements on security and safety as well as cryptographic regulations and any other regulatory or corporate standards that may apply to your use of the container.

Updates to Aspire will from time to time bring updates to third-party containers.

# Access resources in tests

> Learn how to access the resources from the Aspire AppHost in your tests.

In this article, you learn how to access the resources from the Aspire AppHost in your tests. The AppHost represents the full application environment and contains all the resources that are available to the application. When writing functional or integration tests with Aspire, you might need to access these resources to verify the behavior of your application.

## Access HTTP resources

[Section titled “Access HTTP resources”](#access-http-resources)

To access an HTTP resource, use the `HttpClient` to request and receive responses. The `DistributedApplication` and the `DistributedApplicationFactory` both provide a `CreateHttpClient` method that’s used to create an `HttpClient` instance for a specific resource, based on the resource name from the AppHost. This method also takes an optional `endpointName` parameter, so if the resource has multiple endpoints, you can specify which one to use.

## Access other resources

[Section titled “Access other resources”](#access-other-resources)

In a test, you might want to access other resources by the connection information they provide, for example, querying a database to verify the state of the data. For this, you use the `GetConnectionString` method to retrieve the connection string for a resource, and then provide that to a client library within the test to interact with the resource.

## Ensure resources are available

[Section titled “Ensure resources are available”](#ensure-resources-are-available)

Starting with Aspire 9, there’s support for waiting on dependent resources to be available (via the [health check](/fundamentals/health-checks/) mechanism). This is useful in tests that ensure a resource is available before attempting to access it. The `ResourceNotificationService` class provides a `WaitForResourceAsync` method that’s used to wait for a named resource to be available. This method takes the resource name and the desired state of the resource as parameters and returns a `Task` that yields back when the resource is available. You can access the `ResourceNotificationService` via `app.ResourceNotifications`, as in the following example.

Note

It’s recommended to provide a time-out when waiting for resources, to prevent the test from hanging indefinitely in situations where a resource never becomes available.

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
await app.ResourceNotifications.WaitForResourceAsync(
    "webfrontend",
    KnownResourceStates.Running,
    cts.Token);
```

A resource enters the `KnownResourceStates.Running` state as soon as it starts executing, but this doesn’t mean that it’s ready to serve requests. If you want to wait for the resource to be ready to serve requests, and your resource has health checks, you can wait for the resource to become healthy by using the `WaitForResourceHealthyAsync` method.

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));


await app.ResourceNotifications.WaitForResourceHealthyAsync(
    "webfrontend",
    cts.Token);
```

This resource-notification pattern ensures that the resources are available before running the tests, avoiding potential issues with the tests failing due to the resources not being ready.

## Start & Stop

[Section titled “Start & Stop”](#start--stop)

In some cases, you may want to manually start a resource when it is not initially started, for when the resource was created `WithExplicitStart` for example.

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
await app.ResourceCommands.ExecuteCommandAsync(
    "webfrontend",
    KnownResourceCommands.StartCommand,
    cts.Token);
```

You could also want to stop a resource manually to see if your application is resilient when a particular resource shuts down.

```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
await app.ResourceCommands.ExecuteCommandAsync(
    "webfrontend",
    KnownResourceCommands.StopCommand,
    cts.Token);
```

# Manage the AppHost in tests

> Learn how to manage the AppHost in Aspire tests.

Select your testing framework

xUnit.net  MSTest  NUnit

When writing functional or integration tests with Aspire, managing the [AppHost](/get-started/app-host/) instance efficiently is crucial. The AppHost represents the full application environment and can be costly to create and tear down. This article explains how to manage the AppHost instance in your Aspire tests.

For writing tests with Aspire, you use the [Aspire.Hosting.Testing](https://www.nuget.org/packages/Aspire.Hosting.Testing) NuGet package which contains some helper classes to manage the AppHost instance in your tests.

## Use the `DistributedApplicationTestingBuilder` class

[Section titled “Use the DistributedApplicationTestingBuilder class”](#use-the-distributedapplicationtestingbuilder-class)

In the [tutorial on writing your first test](/testing/write-your-first-test/), you were introduced to the `DistributedApplicationTestingBuilder` class which can be used to create the AppHost instance:

```csharp
var appHost = await DistributedApplicationTestingBuilder
    .CreateAsync<Projects.AspireApp_AppHost>();
```

The `DistributedApplicationTestingBuilder.CreateAsync<T>` method takes the AppHost project type as a generic parameter to create the AppHost instance. While this method is executed at the start of each test, it’s more efficient to create the AppHost instance once and share it across tests as the test suite grows.

With xUnit, you implement the [IAsyncLifetime](https://github.com/xunit/xunit/blob/master/src/xunit.core/IAsyncLifetime.cs) interface on the test class to support asynchronous initialization and disposal of the AppHost instance. The `InitializeAsync` method is used to create the AppHost instance before the tests are run and the `DisposeAsync` method disposes the AppHost once the tests are completed.

```csharp
public class WebTests : IAsyncLifetime
{
    private DistributedApplication _app;


    public async Task InitializeAsync()
    {
        var appHost = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        _app = await appHost.BuildAsync();
    }


    public async Task DisposeAsync() => await _app.DisposeAsync();


    [Fact]
    public async Task GetWebResourceRootReturnsOkStatusCode()
    {
        // test code here
    }
}
```

With MSTest, you use the `ClassInitializeAttribute` and `ClassCleanupAttribute` on static methods of the test class to provide the initialization and cleanup of the AppHost instance. The `ClassInitialize` method is used to create the AppHost instance before the tests are run and the `ClassCleanup` method disposes the AppHost instance once the tests are completed.

```csharp
[TestClass]
public class WebTests
{
    private static DistributedApplication _app;


    [ClassInitialize]
    public static async Task ClassInitialize(TestContext context)
    {
       var appHost = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        _app = await appHost.BuildAsync();
    }


    [ClassCleanup]
    public static async Task ClassCleanup() => await _app.DisposeAsync();


    [TestMethod]
    public async Task GetWebResourceRootReturnsOkStatusCode()
    {
        // test code here
    }
}
```

With NUnit, you use the [OneTimeSetUp](https://docs.nunit.org/articles/nunit/writing-tests/attributes/onetimesetup.html) and [OneTimeTearDown](https://docs.nunit.org/articles/nunit/writing-tests/attributes/onetimeteardown.html) attributes on methods of the test class to provide the setup and teardown of the AppHost instance. The `OneTimeSetUp` method is used to create the AppHost instance before the tests are run and the `OneTimeTearDown` method disposes the AppHost instance once the tests are completed.

```csharp
public class WebTests
{
    private DistributedApplication _app;


    [OneTimeSetUp]
    public async Task OneTimeSetup()
    {
       var appHost = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        _app = await appHost.BuildAsync();
    }


    [OneTimeTearDown]
    public async Task OneTimeTearDown() => await _app.DisposeAsync();


    [Test]
    public async Task GetWebResourceRootReturnsOkStatusCode()
    {
        // test code here
    }
}
```

By capturing the AppHost in a field when the test run is started, you can access it in each test without the need to recreate it, decreasing the time it takes to run the tests. Then, when the test run completes, the AppHost is disposed, which cleans up any resources that were created during the test run, such as containers.

## Pass arguments to your AppHost

[Section titled “Pass arguments to your AppHost”](#pass-arguments-to-your-apphost)

You can access the arguments from your AppHost with the `args` parameter. Arguments are also passed to [.NET’s configuration system](https://learn.microsoft.com/dotnet/core/extensions/configuration), so you can override many configuration settings this way. In the following example, you override the [environment](https://learn.microsoft.com/aspnet/core/fundamentals/environments) by specifying it as a command line option:

```csharp
var builder = await DistributedApplicationTestingBuilder
    .CreateAsync<Projects.MyAppHost>(
    [
        "--environment=Testing"
    ]);
```

Other arguments can be passed to your AppHost `Program` and made available in your AppHost. In the next example, you pass an argument to the AppHost and use it to control whether you add data volumes to a Postgres instance.

In the AppHost `Program`, you use configuration to support enabling or disabling volumes:

```csharp
var postgres = builder.AddPostgres("postgres1");
if (builder.Configuration.GetValue("UseVolumes", true))
{
    postgres.WithDataVolume();
}
```

In test code, you pass `"UseVolumes=false"` in the `args` to the AppHost:

```csharp
public async Task DisableVolumesFromTest()
{
    // Disable volumes in the test builder via arguments:
    using var builder = await DistributedApplicationTestingBuilder
        .CreateAsync<Projects.TestingAppHost1_AppHost>(
        [
            "UseVolumes=false"
        ]);


    // The container will have no volume annotation since we disabled volumes by passing UseVolumes=false
    var postgres = builder.Resources.Single(r => r.Name == "postgres1");


    Assert.Empty(postgres.Annotations.OfType<ContainerMountAnnotation>());
}
```

## Use the `DistributedApplicationFactory` class

[Section titled “Use the DistributedApplicationFactory class”](#use-the-distributedapplicationfactory-class)

While the `DistributedApplicationTestingBuilder` class is useful for many scenarios, there might be situations where you want more control over starting the AppHost, such as executing code before the builder is created or after the AppHost is built. In these cases, you implement your own version of the `DistributedApplicationFactory` class. This is what the `DistributedApplicationTestingBuilder` uses internally.

```csharp
public class TestingAspireAppHost()
    : DistributedApplicationFactory(typeof(Projects.AspireApp_AppHost))
{
    // override methods here
}
```

The constructor requires the type of the AppHost project reference as a parameter. Optionally, you can provide arguments to the underlying host application builder. These arguments control how the AppHost starts and provide values to the args variable used by the *AppHost.cs* file to start the AppHost instance.

### Lifecycle methods

[Section titled “Lifecycle methods”](#lifecycle-methods)

The `DistributionApplicationFactory` class provides several lifecycle methods that can be overridden to provide custom behavior throughout the preparation and creation of the AppHost. The available methods are `OnBuilderCreating`, `OnBuilderCreated`, `OnBuilding`, and `OnBuilt`.

For example, we can use the `OnBuilderCreating` method to set configuration, such as the subscription and resource group information for Azure, before the AppHost is created and any dependent Azure resources are provisioned, resulting in our tests using the correct Azure environment.

```csharp
public class TestingAspireAppHost()
    : DistributedApplicationFactory(typeof(Projects.AspireApp_AppHost))
{
    protected override void OnBuilderCreating(
        DistributedApplicationOptions applicationOptions,
        HostApplicationBuilderSettings hostOptions)
    {
        hostOptions.Configuration ??= new();
        hostOptions.Configuration["environment"] = "Development";
        hostOptions.Configuration["AZURE_SUBSCRIPTION_ID"] = "00000000-0000-0000-0000-000000000000";
        hostOptions.Configuration["AZURE_RESOURCE_GROUP"] = "my-resource-group";
    }
}
```

Because of the order of precedence in the .NET configuration system, the environment variables will be used over anything in the *appsettings.json* or *secrets.json* file.

Another scenario you might want to use in the lifecycle is to configure the services used by the AppHost. In the following example, consider a scenario where you override the `OnBuilderCreated` API to add resilience to the `HttpClient`:

```csharp
protected override void OnBuilderCreated(
    DistributedApplicationBuilder applicationBuilder)
{
    applicationBuilder.Services.ConfigureHttpClientDefaults(clientBuilder =>
    {
        clientBuilder.AddStandardResilienceHandler();
    });
}
```

# Testing overview

> Learn how to write integration tests for your Aspire applications using the Aspire.Hosting.Testing package.

Aspire supports automated testing of your distributed applications through the [📦 Aspire.Hosting.Testing](https://www.nuget.org/packages/Aspire.Hosting.Testing) NuGet package. This package provides the `DistributedApplicationTestingBuilder` class, which creates a test host for your application. The testing builder launches your AppHost project in a background thread and manages its lifecycle, allowing you to control and manipulate the application and its resources.

By default, the testing builder disables the dashboard and randomizes the ports of proxied resources to enable multiple instances of your application to run concurrently. Once your test completes, disposing of the application or testing builder cleans up your app resources.

## Understanding Aspire testing

[Section titled “Understanding Aspire testing”](#understanding-aspire-testing)

Aspire’s testing capabilities are designed specifically for closed-box integration testing of your entire distributed application. Unlike unit tests or open-box integration tests, which typically run individual components in isolation, Aspire tests launch your complete solution—the AppHost and all its resources—as separate processes, closely simulating real-world scenarios.

The following diagram shows how the Aspire testing project starts the AppHost, which then starts the application and its resources:

![Aspire testing diagram showing how a test project starts the AppHost, which orchestrates the Database, API, and Front end applications. The test project sends an HTTP request to the Front end application.](/_astro/testing-diagram.CUK_51bY.svg)

1. The **test project** starts the AppHost.
2. The **AppHost** process starts.
3. The **AppHost** runs the `Database`, `API`, and `Front end` applications.
4. The **test project** sends an HTTP request to the `Front end` application.

The test project starts the AppHost, which then orchestrates all dependent app resources—regardless of their type. The test project can send an HTTP request to the `Front end` app, which depends on an `API` app, and the `API` app depends on a `Database`. A successful request confirms that the `Front end` app can communicate with the `API` app, and that the `API` app can successfully get data from the `Database`.

Caution

Aspire testing doesn’t enable scenarios for mocking, substituting, or replacing services in dependency injection—as the tests run in a separate process.

### When to use Aspire testing

[Section titled “When to use Aspire testing”](#when-to-use-aspire-testing)

Use Aspire testing when you want to:

* Verify end-to-end functionality of your distributed application.
* Ensure interactions between multiple services and resources (such as databases) behave correctly in realistic conditions.
* Confirm data persistence and integration with real external dependencies, like a PostgreSQL database.

If your goal is to test a single project in isolation, run components in-memory, or mock external dependencies, consider using `WebApplicationFactory<T>` instead.

Note

Aspire tests run your application as separate processes, meaning you don’t have direct access to internal services or components from your test code. You can influence application behavior through environment variables or configuration settings, but internal state and services remain encapsulated within their respective processes.

## Configuration options

[Section titled “Configuration options”](#configuration-options)

The `DistributedApplicationTestingBuilder` provides several configuration options to customize how your tests run. You can control port assignment, enable the dashboard, and adjust other settings through the builder’s options.

### Disable port randomization

[Section titled “Disable port randomization”](#disable-port-randomization)

By default, Aspire uses random ports to allow multiple instances of your application to run concurrently without interference. It uses Aspire’s service discovery to ensure applications can locate each other’s endpoints. To disable port randomization, pass `"DcpPublisher:RandomizePorts=false"` when constructing your testing builder:

```csharp
var builder = await DistributedApplicationTestingBuilder
    .CreateAsync<Projects.MyAppHost>(
        [
            "DcpPublisher:RandomizePorts=false"
        ]);
```

### Enable the dashboard

[Section titled “Enable the dashboard”](#enable-the-dashboard)

The testing builder disables the Aspire dashboard by default. To enable it, set the `DisableDashboard` property to `false` when creating your testing builder:

```csharp
var builder = await DistributedApplicationTestingBuilder
    .CreateAsync<Projects.MyAppHost>(
        args: [],
        configureBuilder: (appOptions, hostSettings) =>
        {
            appOptions.DisableDashboard = false;
        });
```

# Write your first test

> Learn how to test your Aspire solutions using xUnit.net, NUnit, and MSTest testing frameworks.

Select your testing framework

xUnit.net  MSTest  NUnit

In this article, you’ll learn how to create a test project, write C# tests, and run them for your Aspire solutions. These aren’t unit tests—they’re functional and integration tests that validate how your distributed application components work together. Aspire provides testing project templates for xUnit.net, MSTest, and NUnit frameworks, each including a sample test to help you get started quickly.

## Conceptualizing distributed app testing

[Section titled “Conceptualizing distributed app testing”](#conceptualizing-distributed-app-testing)

Before you start testing your Aspire solutions, you’ll need the [📦 Aspire.Hosting.Testing](https://www.nuget.org/packages/Aspire.Hosting.Testing) NuGet package. This powerful package provides the `DistributedApplicationTestingBuilder` class—your gateway to creating a test host for distributed applications.

Think of the `DistributedApplicationTestingBuilder` as a test harness that launches your AppHost project with built-in instrumentation. This gives you precise control to access and manipulate the host throughout its lifecycle. You’ll work with familiar Aspire types like `IDistributedApplicationBuilder` and `DistributedApplication` to build and start your [AppHost](/get-started/app-host/), making your tests feel natural and intuitive.

## Create a test project

[Section titled “Create a test project”](#create-a-test-project)

To create an Aspire test project, use the testing project template. When starting a new Aspire project, both IDE and CLI tooling prompts you to create a test project for some templates. To add a test project to an existing Aspire solution, use the [`dotnet new`](https://learn.microsoft.com/dotnet/core/tools/dotnet-new) command:

```bash
dotnet new aspire-xunit -o xUnit.Tests
```

```bash
dotnet new aspire-mstest -o MSTest.Tests
```

```bash
dotnet new aspire-nunit -o NUnit.Tests
```

Change directory to the newly created test project:

```bash
cd xUnit.Tests
```

```bash
cd MSTest.Tests
```

```bash
cd NUnit.Tests
```

After adding the test project to your Aspire solution, add a project reference to the target AppHost. For example, if your Aspire solution contains an AppHost project named `AspireApp.AppHost`, add a project reference to it from the test project:

```bash
dotnet reference add ../AspireApp.AppHost/AspireApp.AppHost.csproj --project xUnit.Tests.csproj
```

```bash
dotnet reference add ../AspireApp.AppHost/AspireApp.AppHost.csproj --project MSTest.Tests.csproj
```

```bash
dotnet reference add ../AspireApp.AppHost/AspireApp.AppHost.csproj --project NUnit.Tests.csproj
```

Finally, you can uncomment out the `IntegrationTest1.cs` file in the test project to explore the sample test.

## Explore the test project

[Section titled “Explore the test project”](#explore-the-test-project)

The following example test project was created as part of the **Blazor & Minimal API starter** template. If you’re unfamiliar with it, see [Build your first app—C#](/get-started/first-app/?lang=csharp). The Aspire test project takes a project reference dependency on the target AppHost. Consider the template project:

xUnit.Tests.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.Testing" Version="13.1.0" />
    <PackageReference Include="coverlet.collector" Version="6.0.4" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.14.1" />
    <PackageReference Include="xunit" Version="2.9.3" />
    <PackageReference Include="xunit.runner.visualstudio" Version="3.1.4" />
  </ItemGroup>


  <ItemGroup>
    <ProjectReference Include="..\AspireApp.AppHost\AspireApp.AppHost.csproj" />
  </ItemGroup>


  <ItemGroup>
    <Using Include="System.Net" />
    <Using Include="Microsoft.Extensions.DependencyInjection" />
    <Using Include="Aspire.Hosting.ApplicationModel" />
    <Using Include="Aspire.Hosting.Testing" />
    <Using Include="Xunit" />
  </ItemGroup>


</Project>
```

MSTest.Tests.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
    <EnableMSTestRunner>true</EnableMSTestRunner>
    <OutputType>Exe</OutputType>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.Testing" Version="13.1.0" />
    <PackageReference Include="MSTest" Version="3.10.2" />
  </ItemGroup>


  <ItemGroup>
    <ProjectReference Include="..\AspireApp.AppHost\AspireApp.AppHost.csproj" />
  </ItemGroup>


  <ItemGroup>
    <Using Include="System.Net" />
    <Using Include="Microsoft.Extensions.DependencyInjection" />
    <Using Include="Aspire.Hosting.ApplicationModel" />
    <Using Include="Aspire.Hosting.Testing" />
    <Using Include="Microsoft.VisualStudio.TestTools.UnitTesting" />
  </ItemGroup>


</Project>
```

NUnit.Tests.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.Testing" Version="13.1.0" />
    <PackageReference Include="coverlet.collector" Version="6.0.4" />
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.14.1" />
    <PackageReference Include="NUnit" Version="4.4.0" />
    <PackageReference Include="NUnit.Analyzers" Version="4.10.0" />
    <PackageReference Include="NUnit3TestAdapter" Version="4.6.0" />
  </ItemGroup>


  <ItemGroup>
    <ProjectReference Include="..\AspireApp.AppHost\AspireApp.AppHost.csproj" />
  </ItemGroup>


  <ItemGroup>
    <Using Include="System.Net" />
    <Using Include="Microsoft.Extensions.DependencyInjection" />
    <Using Include="Aspire.Hosting.ApplicationModel" />
    <Using Include="Aspire.Hosting.Testing" />
    <Using Include="NUnit.Framework" />
  </ItemGroup>


</Project>
```

The preceding project file is fairly standard. There’s a `PackageReference` to the [📦 Aspire.Hosting.Testing](https://www.nuget.org/packages/Aspire.Hosting.Testing) NuGet package, which includes the required types to write tests for Aspire projects.

The template test project includes an `IntegrationTest1` class with a single test. The test verifies the following scenario:

* The AppHost is successfully created and started.
* The `webfrontend` resource is available and running.
* An HTTP request can be made to the `webfrontend` resource and returns a successful response (HTTP 200 OK).

Consider the following test class:

IntegrationTest1.cs

```csharp
using Microsoft.Extensions.Logging;


namespace xUnit.Tests.Tests;


public class IntegrationTest1
{
    private static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(30);


    [Fact]
    public async Task GetWebResourceRootReturnsOkStatusCode()
    {
        // Arrange
        var cancellationToken = CancellationToken.None;
        var appHost = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>(cancellationToken);
        appHost.Services.AddLogging(logging =>
        {
            logging.SetMinimumLevel(LogLevel.Debug);
            // Override the logging filters from the app's configuration
            logging.AddFilter(appHost.Environment.ApplicationName, LogLevel.Debug);
            logging.AddFilter("Aspire.", LogLevel.Debug);
        });
        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =>
        {
            clientBuilder.AddStandardResilienceHandler();
        });


        await using var app = await appHost.BuildAsync(cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);
        await app.StartAsync(cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);


        // Act
        using var httpClient = app.CreateHttpClient("webfrontend");
        await app.ResourceNotifications.WaitForResourceHealthyAsync(
            "webfrontend", cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);
        using var response = await httpClient.GetAsync("/", cancellationToken);


        // Assert
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }
}
```

IntegrationTest1.cs

```csharp
using Microsoft.Extensions.Logging;


namespace MSTest.Tests;


[TestClass]
public class IntegrationTest1
{
    public TestContext TestContext { get; set; }


    private static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(30);


    [TestMethod]
    public async Task GetWebResourceRootReturnsOkStatusCode()
    {
        // Arrange
        var cancellationToken = TestContext.CancellationTokenSource.Token;
        var appHost = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();
        appHost.Services.AddLogging(logging =>
        {
            logging.SetMinimumLevel(LogLevel.Debug);
            // Override the logging filters from the app's configuration
            logging.AddFilter(appHost.Environment.ApplicationName, LogLevel.Debug);
            logging.AddFilter("Aspire.", LogLevel.Debug);
        });
        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =>
        {
            clientBuilder.AddStandardResilienceHandler();
        });


        await using var app = await appHost.BuildAsync(cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);
        await app.StartAsync(cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);


        // Act
        using var httpClient = app.CreateHttpClient("webfrontend");
        await app.ResourceNotifications.WaitForResourceHealthyAsync(
            "webfrontend", cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);
        using var response = await httpClient.GetAsync("/", cancellationToken);


        // Assert
        Assert.AreEqual(HttpStatusCode.OK, response.StatusCode);
    }
}
```

IntegrationTest1.cs

```csharp
using Microsoft.Extensions.Logging;


namespace NUnit.Tests;


public class IntegrationTest1
{
    private static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(30);


    [Test]
    public async Task GetWebResourceRootReturnsOkStatusCode()
    {
        // Arrange
        using var cts = new CancellationTokenSource(DefaultTimeout);
        var cancellationToken = cts.Token;
        var appHost = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();
        appHost.Services.AddLogging(logging =>
        {
            logging.SetMinimumLevel(LogLevel.Debug);
            // Override the logging filters from the app's configuration
            logging.AddFilter(appHost.Environment.ApplicationName, LogLevel.Debug);
            logging.AddFilter("Aspire.", LogLevel.Debug);
        });
        appHost.Services.ConfigureHttpClientDefaults(clientBuilder =>
        {
            clientBuilder.AddStandardResilienceHandler();
        });


        await using var app = await appHost.BuildAsync(cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);
        await app.StartAsync(cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);


        // Act
        using var httpClient = app.CreateHttpClient("webfrontend");
        await app.ResourceNotifications.WaitForResourceHealthyAsync(
            "webfrontend", cancellationToken)
            .WaitAsync(DefaultTimeout, cancellationToken);
        using var response = await httpClient.GetAsync("/", cancellationToken);


        // Assert
        Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.OK));
    }
}
```

The preceding code:

* Relies on the `DistributedApplicationTestingBuilder.CreateAsync` API to asynchronously create the AppHost.
* The `appHost` is an instance of `IDistributedApplicationTestingBuilder` that represents the AppHost.
* The `appHost` instance has its service collection configured with logging and the standard HTTP resilience handler. For more information, see [Build resilient HTTP apps: Key development patterns](https://learn.microsoft.com/dotnet/core/resilience/http-resilience).
* The `appHost` has its `BuildAsync` method invoked, which returns the `DistributedApplication` instance as the `app`.
* The `app` is started asynchronously.
* An `HttpClient` is created for the `webfrontend` resource by calling `app.CreateHttpClient`.
* The `app.ResourceNotifications` is used to wait for the `webfrontend` resource to be healthy.
* A simple HTTP GET request is made to the root of the `webfrontend` resource.
* The test asserts that the response status code is `OK`.

## Test resource environment variables

[Section titled “Test resource environment variables”](#test-resource-environment-variables)

To further test resources and their expressed dependencies in your Aspire solution, you can assert that environment variables are injected correctly. The following example demonstrates how to test that the `webfrontend` resource has an HTTPS environment variable that resolves to the `apiservice` resource:

EnvVarTests.cs

```csharp
using Aspire.Hosting;


namespace Tests;


public class EnvVarTests
{
    [Fact]
    public async Task WebResourceEnvVarsResolveToApiService()
    {
        // Arrange
        var builder = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        var frontend = builder.CreateResourceBuilder<ProjectResource>("webfrontend");


        // Act
        var envVars = await frontend.Resource.GetEnvironmentVariableValuesAsync(
            DistributedApplicationOperation.Publish);


        // Assert
        Assert.Contains(envVars, static (kvp) =>
        {
            var (key, value) = kvp;


            return key is "APISERVICE_HTTPS"
                && value is "{apiservice.bindings.https.url}";
        });
    }
}
```

EnvVarTests.cs

```csharp
using Aspire.Hosting;


namespace Tests;


[TestClass]
public class EnvVarTests
{
    [TestMethod]
    public async Task WebResourceEnvVarsResolveToApiService()
    {
        // Arrange
        var builder = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        var frontend = builder.CreateResourceBuilder<ProjectResource>("webfrontend");


        // Act
        var envVars = await frontend.Resource.GetEnvironmentVariableValuesAsync(
            DistributedApplicationOperation.Publish);


        // Assert
        CollectionAssert.Contains(envVars,
            new KeyValuePair<string, string>(
                key: "APISERVICE_HTTPS",
                value: "{apiservice.bindings.https.url}"));
    }
}
```

EnvVarTests.cs

```csharp
using Aspire.Hosting;


namespace Tests;


public class EnvVarTests
{
    [Test]
    public async Task WebResourceEnvVarsResolveToApiService()
    {
        // Arrange
        var builder = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        var frontend = builder.CreateResourceBuilder<ProjectResource>("webfrontend");


        // Act
        var envVars = await frontend.Resource.GetEnvironmentVariableValuesAsync(
            DistributedApplicationOperation.Publish);


        // Assert
        Assert.That(envVars, Does.Contain(
            new KeyValuePair<string, string>(
                key: "APISERVICE_HTTPS",
                value: "{apiservice.bindings.https.url}")));
    }
}
```

The preceding code:

* Relies on the `DistributedApplicationTestingBuilder.CreateAsync` API to asynchronously create the AppHost.
* The `builder` instance is used to retrieve an `IResourceWithEnvironment` instance named “webfrontend” from the `Resources` property.
* The `webfrontend` resource is used to call `GetEnvironmentVariableValuesAsync` to retrieve its configured environment variables.
* The `DistributedApplicationOperation.Publish` argument is passed when calling `GetEnvironmentVariableValuesAsync` to specify environment variables that are published to the resource as binding expressions.
* With the returned environment variables, the test asserts that the `webfrontend` resource has an HTTPS environment variable that resolves to the `apiservice` resource.

## Capture logs from tests

[Section titled “Capture logs from tests”](#capture-logs-from-tests)

When writing tests for your Aspire solutions, you might want to capture and view logs to help with debugging and monitoring test execution. The `DistributedApplicationTestingBuilder` provides access to the service collection, allowing you to configure logging for your test scenarios.

### Configure logging providers

[Section titled “Configure logging providers”](#configure-logging-providers)

To capture logs from your tests, use the `AddLogging` method on the `builder.Services` to configure logging providers specific to your testing framework:

LoggingTest.cs

```csharp
using Microsoft.Extensions.Logging;


namespace Tests;


public class LoggingTest
{
    [Fact]
    public async Task GetWebResourceRootReturnsOkStatusCodeWithLogging()
    {
        // Arrange
        var builder = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        builder.Services.ConfigureHttpClientDefaults(clientBuilder =>
        {
            clientBuilder.AddStandardResilienceHandler();
        });


        // Configure logging to capture test execution logs
        builder.Services.AddLogging(logging => logging
            .AddConsole() // Outputs logs to console
            .AddFilter("Default", LogLevel.Information)
            .AddFilter("Microsoft.AspNetCore", LogLevel.Warning)
            .AddFilter("Aspire.Hosting.Dcp", LogLevel.Warning));


        await using var app = await builder.BuildAsync();


        await app.StartAsync();


        // Act
        var httpClient = app.CreateHttpClient("webfrontend");


        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        await app.ResourceNotifications.WaitForResourceHealthyAsync(
            "webfrontend",
            cts.Token);


        var response = await httpClient.GetAsync("/");


        // Assert
        Assert.Equal(HttpStatusCode.OK, response.StatusCode);
    }
}
```

LoggingTest.cs

```csharp
using Microsoft.Extensions.Logging;


namespace Tests;


[TestClass]
public class LoggingTest
{
    [TestMethod]
    public async Task GetWebResourceRootReturnsOkStatusCodeWithLogging()
    {
        // Arrange
        var builder = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        builder.Services.ConfigureHttpClientDefaults(clientBuilder =>
        {
            clientBuilder.AddStandardResilienceHandler();
        });


        // Configure logging to capture test execution logs
        builder.Services.AddLogging(logging => logging
            .AddConsole() // Outputs logs to console
            .AddFilter("Default", LogLevel.Information)
            .AddFilter("Microsoft.AspNetCore", LogLevel.Warning)
            .AddFilter("Aspire.Hosting.Dcp", LogLevel.Warning));


        await using var app = await builder.BuildAsync();


        await app.StartAsync();


        // Act
        var httpClient = app.CreateHttpClient("webfrontend");


        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        await app.ResourceNotifications.WaitForResourceHealthyAsync(
            "webfrontend",
            cts.Token);


        var response = await httpClient.GetAsync("/");


        // Assert
        Assert.AreEqual(HttpStatusCode.OK, response.StatusCode);
    }
}
```

LoggingTest.cs

```csharp
using Microsoft.Extensions.Logging;


namespace Tests;


public class LoggingTest
{
    [Test]
    public async Task GetWebResourceRootReturnsOkStatusCodeWithLogging()
    {
        // Arrange
        var builder = await DistributedApplicationTestingBuilder
            .CreateAsync<Projects.AspireApp_AppHost>();


        builder.Services.ConfigureHttpClientDefaults(clientBuilder =>
        {
            clientBuilder.AddStandardResilienceHandler();
        });


        // Configure logging to capture test execution logs
        builder.Services.AddLogging(logging => logging
            .AddConsole() // Outputs logs to console
            .AddFilter("Default", LogLevel.Information)
            .AddFilter("Microsoft.AspNetCore", LogLevel.Warning)
            .AddFilter("Aspire.Hosting.Dcp", LogLevel.Warning));


        await using var app = await builder.BuildAsync();


        await app.StartAsync();


        // Act
        var httpClient = app.CreateHttpClient("webfrontend");


        using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        await app.ResourceNotifications.WaitForResourceHealthyAsync(
                "webfrontend",
                cts.Token);


        var response = await httpClient.GetAsync("/");


        // Assert
        Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.OK));
    }
}
```

### Configure log filters

[Section titled “Configure log filters”](#configure-log-filters)

Since the *appsettings.json* configuration from your application isn’t automatically replicated in test projects, you need to explicitly configure log filters. This is important to avoid excessive logging from infrastructure components that might overwhelm your test output. The following snippet explicitly configures log filters:

```csharp
builder.Services.AddLogging(logging => logging
    .AddFilter("Default", LogLevel.Information)
    .AddFilter("Microsoft.AspNetCore", LogLevel.Warning)
    .AddFilter("Aspire.Hosting.Dcp", LogLevel.Warning));
```

The preceding configuration:

* Sets the default log level to `Information` for most application logs.
* Reduces noise from ASP.NET Core infrastructure by setting it to `Warning` level.
* Limits Aspire hosting infrastructure logs to `Warning` level to focus on application-specific logs.

### Popular logging packages

[Section titled “Popular logging packages”](#popular-logging-packages)

Different testing frameworks have different logging provider packages available to assist with managing logging during test execution:

xUnit.net doesn’t capture log output from tests as test output. Tests must [use the `ITestOutputHelper` interface](https://xunit.net/docs/capturing-output) to achieve this.

For xUnit.net, consider using one of these logging packages:

* [📦 MartinCostello.Logging.XUnit](https://www.nuget.org/packages/MartinCostello.Logging.XUnit) - Outputs `ILogger` logs to `ITestOutputHelper` output.
* [📦 Xunit.DependencyInjection.Logging](https://www.nuget.org/packages/Xunit.DependencyInjection.Logging) - Integrates with xUnit.net’s dependency injection.
* [📦 Serilog.Extensions.Logging.File](https://www.nuget.org/packages/Serilog.Extensions.Logging.File) - Writes logs to files.
* [📦 Microsoft.Extensions.Logging.Console](https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console) - Outputs logs to console.

For MSTest, consider using one of these logging packages:

* [📦 Serilog.Extensions.Logging.File](https://www.nuget.org/packages/Serilog.Extensions.Logging.File) - Writes logs to files.
* [📦 Microsoft.Extensions.Logging.Console](https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console) - Outputs logs to console.

For NUnit, consider using one of these logging packages:

* [📦 Extensions.Logging.NUnit](https://www.nuget.org/packages/Extensions.Logging.NUnit) - Integrates with NUnit framework.
* [📦 Serilog.Extensions.Logging.File](https://www.nuget.org/packages/Serilog.Extensions.Logging.File) - Writes logs to files.
* [📦 Microsoft.Extensions.Logging.Console](https://www.nuget.org/packages/Microsoft.Extensions.Logging.Console) - Outputs logs to console.

## Summary

[Section titled “Summary”](#summary)

The Aspire testing project template makes it easier to create test projects for Aspire solutions. The template project includes a sample test that you can use as a starting point for your tests. The `DistributedApplicationTestingBuilder` follows a familiar pattern to the `WebApplicationFactory<T>` in ASP.NET Core. It allows you to create a test host for your distributed application and run tests against it.

Finally, when using the `DistributedApplicationTestingBuilder` all resource logs are redirected to the `DistributedApplication` by default. The redirection of resource logs enables scenarios where you want to assert that a resource is logging correctly.

# What's new in Aspire 13

> Aspire 13.0 introduces polyglot application development with first-class Python and JavaScript support, container-based builds, aspire do pipelines, VS Code extension, and modern CLI tooling updates and improvements.

📢 Aspire 13 represents a major milestone in the Aspire product line.

Aspire is no longer ”.NET Aspire” - it’s now simply **Aspire**, a full **polyglot application platform**. While Aspire continues to provide best-in-class support for .NET applications, version 13.0 elevates **Python and JavaScript to first-class citizens**, with comprehensive support for running, debugging, and deploying applications written in these languages.

This release introduces:

* **First-class Python support**: Support for Python modules, deploy with uvicorn, flexible package management (uv, pip, or venv), and generate production Dockerfiles automatically.
* **First-class JavaScript support**: Vite and npm-based apps with package manager auto-detection, debugging support, and container-based build pipelines.
* **Polyglot infrastructure**: Connection properties work in any language (URI, JDBC, individual properties), certificate trust across languages and containers.
* **Container files as build artifacts**: A new paradigm where build outputs are containers, not folders - enabling reproducible, isolated, and portable builds.
* **aspire do: a new platform for build, publish and deployment pipelines**: enabling parallel execution, dependency tracking, and extensible workflows for building, publishing, and deploying applications.
* **Modern CLI**: `aspire init` to Aspirify existing apps, and improved deployment state management that remembers your configuration across runs.
* **VS Code extension**: Streamlined Aspire development with commands for project creation, integration management, multi-language debugging, and deployment.

Along with the rebranding, Aspire now has a new home at **[aspire.dev](https://aspire.dev)** — your central hub for documentation, getting started guides, and community resources.

**Requirements:**

* .NET 10 SDK or later.

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [ GitHub](https://github.com/dotnet/aspire) or join us on our new [ Discord](https://aka.ms/aspire-discord) to chat with the team and other community members.

## 🆙 Upgrade to Aspire 13.0

[Section titled “🆙 Upgrade to Aspire 13.0”](#-upgrade-to-aspire-130)

Caution

Aspire 13.0 is a major version release with breaking changes. Please review the [Breaking changes](#-breaking-changes) section before upgrading.

The easiest way to upgrade to Aspire 13.0 is using the `aspire update` command:

1. Update the Aspire CLI to the latest version:

   * Bash

     ```bash
     curl -sSL https://aspire.dev/install.sh | bash
     ```

   * PowerShell

     ```powershell
     irm https://aspire.dev/install.ps1 | iex
     ```

2. Update your Aspire project using the [`aspire update` command](/reference/cli/commands/aspire-update/):

   Aspire CLI — Update all Aspire packages

   ```bash
   aspire update
   ```

   This command will:

   * Update the `Aspire.AppHost.Sdk` version in your AppHost project.
   * Update all Aspire NuGet packages to version 13.0.
   * Handle dependency resolution automatically.
   * Support both regular projects and Central Package Management (CPM).

3. Update your Aspire templates:

   ```bash
   dotnet new install Aspire.ProjectTemplates
   ```

Note

If you’re upgrading from Aspire 8.x, follow [the upgrade guide](https://learn.microsoft.com/dotnet/aspire/get-started/upgrade-to-aspire-9) first to upgrade to 9.x, then upgrade to 13.0.

## 🧩 AppHost template updates

[Section titled “🧩 AppHost template updates”](#-apphost-template-updates)

Aspire 13.0 introduces a simplified AppHost project template structure. The SDK now encapsulates the `Aspire.Hosting.AppHost` package, resulting in cleaner project files.

**Before (9.x):**

```xml
<Project Sdk="Microsoft.NET.Sdk">


  <Sdk Name="Aspire.AppHost.Sdk" Version="9.5.2" />


  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <UserSecretsId>1bf2ca25-7be4-4963-8782-c53a74e10ad9</UserSecretsId>
  </PropertyGroup>


  <ItemGroup>
    <ProjectReference Include="..\MyApp.ApiService\MyApp.ApiService.csproj" />
    <ProjectReference Include="..\MyApp.Web\MyApp.Web.csproj" />
  </ItemGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.AppHost" Version="9.5.2" />
    <PackageReference Include="Aspire.Hosting.Redis" Version="9.5.2" />
  </ItemGroup>


</Project>
```

**After (13.0):**

```xml
<Project Sdk="Aspire.AppHost.Sdk/13.0.0">


  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net10.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <UserSecretsId>1bf2ca25-7be4-4963-8782-c53a74e10ad9</UserSecretsId>
  </PropertyGroup>


  <ItemGroup>
    <ProjectReference Include="..\MyApp.ApiService\MyApp.ApiService.csproj" />
    <ProjectReference Include="..\MyApp.Web\MyApp.Web.csproj" />
  </ItemGroup>


  <ItemGroup>
    <PackageReference Include="Aspire.Hosting.Redis" Version="13.0.0" />
  </ItemGroup>


</Project>
```

**Key changes:**

* **Simplified SDK declaration**: The SDK is now specified directly in the `<Project>` tag with its version: `Sdk="Aspire.AppHost.Sdk/13.0.0"`.
* **No explicit `Aspire.Hosting.AppHost` reference**: The SDK now automatically includes this package, reducing boilerplate.
* **Cleaner structure**: Removed the separate `<Sdk Name="..." />` element and the `Microsoft.NET.Sdk` base SDK.
* **Target framework**: Updated from `net9.0` to `net10.0`.

The `aspire update` command automatically handles this migration when upgrading from 9.x to 13.0.

Tip

For an even simpler setup, Aspire 13.0 also supports [single-file AppHosts](#single-file-apphost-support) that don’t require a project file at all. Single-file AppHosts are perfect for quick prototypes and learning scenarios.

The same project as a file-based AppHost:

apphost.cs

```csharp
#:sdk Aspire.AppHost.Sdk@13.0.0
#:package Aspire.Hosting.Redis@13.0.0


var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");
var api = builder.AddProject("apiservice", "../MyApi")
                 .WithReference(cache);


builder.Build().Run();
```

No project file needed - just a single `.cs` file with package references declared using `#:package` directives.

## 🌐 Aspire as a polyglot platform

[Section titled “🌐 Aspire as a polyglot platform”](#-aspire-as-a-polyglot-platform)

Aspire 13.0 marks a transformative shift from a .NET-centric orchestration tool to a truly **polyglot application platform**. Python and JavaScript are now first-class citizens alongside .NET, with comprehensive support for development, debugging, and deployment workflows.

### Python as a first-class citizen

[Section titled “Python as a first-class citizen”](#python-as-a-first-class-citizen)

Aspire 13.0 introduces comprehensive Python support, making it effortless to build, debug, and deploy Python applications alongside your other services.

#### Flexible Python application models

[Section titled “Flexible Python application models”](#flexible-python-application-models)

Aspire provides three ways to run Python code, each suited to different use cases:

C# — Flexible Python application models

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Run a Python script directly
var etl = builder.AddPythonApp("etl-job", "../etl", "process_data.py");


// Run a Python module (python -m celery)
var worker = builder.AddPythonModule("celery-worker", "../worker", "celery")
    .WithArgs("worker", "-A", "tasks", "--loglevel=info");


// Run an executable from the virtual environment (e.g., gunicorn)
var api = builder.AddPythonExecutable("api", "../api", "gunicorn")
    .WithArgs("app:app", "--bind", "0.0.0.0:8000");
```

#### Uvicorn integration for ASGI applications

[Section titled “Uvicorn integration for ASGI applications”](#uvicorn-integration-for-asgi-applications)

For Python web applications using ASGI frameworks like FastAPI, Starlette, or Quart, Aspire provides dedicated `AddUvicornApp` support:

C# — Uvicorn integration

```csharp
var api = builder.AddUvicornApp("api", "./api", "main:app")
    .WithExternalHttpEndpoints()
    .WithHttpHealthCheck("/health");
```

The `AddUvicornApp` method automatically:

* Configures HTTP endpoints.
* Sets up appropriate Uvicorn command-line arguments.
* Supports hot-reload during development.
* Integrates with Aspire’s health check system.

#### Python package management

[Section titled “Python package management”](#python-package-management)

Aspire 13.0 provides flexible Python package management with automatic detection.

**Automatic package manager detection:**

When you add a Python app, Aspire automatically detects and configures package management:

C# — Automatic package detection

```csharp
// If pyproject.toml or requirements.txt exists → automatically uses pip
// If neither exists → creates a virtual environment (.venv)
var api = builder.AddUvicornApp("api", "./api", "main:app");
```

**In most cases, you don’t need to explicitly configure package management**—Aspire detects it automatically.

**Using uv (recommended for new projects):**

For modern Python projects using [uv](https://github.com/astral-sh/uv), explicitly opt-in with `WithUv()`:

C# — Using uv for package management

```csharp
builder.AddUvicornApp("api", "./api", "main:app")
    .WithUv();  // Use uv for package management
```

When using `WithUv()`, Aspire:

* Automatically runs `uv sync` to install dependencies from `pyproject.toml`.
* Creates isolated virtual environments per project.
* Leverages uv’s performance benefits (10-100x faster than pip).
* Auto-detects Python version from project configuration.

**Explicit pip configuration:**

To explicitly configure pip behavior, use `WithPip()`:

C# — Using pip for package management

```csharp
builder.AddUvicornApp("api", "./api", "main:app")
    .WithPip();  // Explicitly use pip for package management
```

When using `WithPip()`, Aspire:

* Automatically installs dependencies from `requirements.txt` or `pyproject.toml` (pip supports both).
* Detects virtual environments (`.venv`) by walking up parent directories.
* Creates a virtual environment if one doesn’t exist.

**Configuring virtual environment path:**

By default, Aspire uses `.venv` in the app directory as the virtual environment path. Use `WithVirtualEnvironment()` to specify a custom path or control automatic creation:

C# — Configuring virtual environment path

```csharp
// Use a custom venv path
builder.AddPythonApp("api", "./api", "main.py")
    .WithVirtualEnvironment("myenv");


// Use existing venv without auto-creation
builder.AddPythonApp("worker", "./worker", "worker.py")
    .WithVirtualEnvironment(".venv", createIfNotExists: false);
```

By default, `createIfNotExists` is `true`, so Aspire will create the virtual environment if it doesn’t exist. Set it to `false` to require the virtual environment to already exist.

#### VS Code debugging support

[Section titled “VS Code debugging support”](#vs-code-debugging-support)

Python applications can be debugged directly in VS Code with full breakpoint support. Aspire 13.0 automatically enables debugging infrastructure for all Python resources - no additional configuration required. See [Visual Studio Code extension](#visual-studio-code-extension) for more.

**Supported debugging scenarios:**

* **Python scripts**: Debug `AddPythonApp` with breakpoints and variable inspection.
* **Python modules**: Debug `AddPythonModule` with module resolution.
* **Flask applications**: Debug Flask apps with auto-reload.
* **Uvicorn/FastAPI**: Debug ASGI applications with async/await support.

Note

Debugging is automatically enabled for Python resources. The Aspire VS Code extension generates VS Code launch configurations automatically.

#### Automatic Dockerfile generation

[Section titled “Automatic Dockerfile generation”](#automatic-dockerfile-generation)

Aspire automatically generates production-ready Dockerfiles for Python applications when publishing:

C# — Automatic Dockerfile generation

```csharp
// With uv (recommended)
builder.AddUvicornApp("api", "./api", "main:app")
    .WithUv();


// Or with pip
builder.AddUvicornApp("api", "./api", "main:app")
    .WithPip();
```

The generated Dockerfile automatically adapts based on your package manager choice:

* **With uv**: Uses uv for fast dependency installation from `pyproject.toml`.
* **With pip**: Uses pip to install dependencies from `requirements.txt`.

Both approaches use appropriate Python base images and follow container best practices.

#### Python version detection

[Section titled “Python version detection”](#python-version-detection)

Aspire automatically detects the Python version for Dockerfile generation from multiple sources (in priority order):

1. **`.python-version` file** (highest priority).
2. **`pyproject.toml`** - `requires-python` field.
3. **Virtual environment** - `python --version` as fallback.

The detected version selects the appropriate Python base image for Docker publishing.

#### Starter template: Vite + FastAPI

[Section titled “Starter template: Vite + FastAPI”](#starter-template-vite--fastapi)

Aspire 13.0 includes a new `aspire-py-starter` template that demonstrates a full-stack Python application:

Bash — Create Python starter template

```bash
aspire new aspire-py-starter
```

This template includes:

* **FastAPI backend**: Python ASGI application using Uvicorn.
* **Vite + React frontend**: Modern JavaScript frontend with TypeScript.
* **OpenTelemetry integration**: Distributed tracing, logs, and metrics.
* **Redis caching** (optional): A distributed cache across requests.
* **Container files**: Frontend static files served by the Python backend.

Build a full-stack polyglot app—Python back end + JavaScript front end—fast. Explore it, customize it, ship it. [Create one now](/get-started/first-app/?lang=python) and [deploy it today](/get-started/deploy-first-app/?lang=python)!

The React front end communicates with the FastAPI back end via HTTP endpoints, demonstrating seamless integration between the two languages within a single Aspire application. The new template has a modern UX:

![Deployed Python/React application running in Docker Compose](/_astro/python-starter-dark.C71FfuaJ.png)

### JavaScript as a first-class citizen

[Section titled “JavaScript as a first-class citizen”](#javascript-as-a-first-class-citizen)

Aspire 13.0 refactors and expands JavaScript support. In earlier versions, the `Aspire.Hosting.NodeJs` integration enabled JavaScript applications. In Aspire 13.0, the integration was renamed to `Aspire.Hosting.JavaScript` and it introduces `AddJavaScriptApp` as the foundational method for all JavaScript applications.

#### Unified JavaScript application model

[Section titled “Unified JavaScript application model”](#unified-javascript-application-model)

The new `AddJavaScriptApp` method replaces the older `AddNpmApp` (removed) and provides a consistent way to add JavaScript applications:

C# — Unified JavaScript application model

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a JavaScript application - runs "npm run dev" by default
var frontend = builder.AddJavaScriptApp("frontend", "./frontend");


// Use a different package manager
var admin = builder.AddJavaScriptApp("admin", "./admin")
    .WithYarn();
```

By default, `AddJavaScriptApp`:

* Automatically detects npm from `package.json`.
* Runs the “dev” script during local development.
* Runs the “build” script when publishing to create production assets.
* Automatically generates Dockerfiles to build production assets.

#### Package manager flexibility

[Section titled “Package manager flexibility”](#package-manager-flexibility)

Aspire automatically detects and supports multiple JavaScript package managers with intelligent defaults for both development and production scenarios.

**Auto-install by default:**

Starting in Aspire 13.0, package managers automatically install dependencies by default (`install = true`). This ensures dependencies are always up-to-date during development and publishing.

**Smart defaults for deterministic builds:**

When publishing (production mode), Aspire automatically uses deterministic install commands based on the presence of lockfiles:

* **npm**: Uses `npm ci` if `package-lock.json` exists, otherwise `npm install`.

* **yarn**:

  * Uses `yarn install --immutable` if `yarn.lock` exists and yarn v2+ is detected, otherwise.
  * Uses `yarn install --frozen-lockfile` if `yarn.lock` exists, otherwise `yarn install`.

* **pnpm**: Uses `pnpm install --frozen-lockfile` if `pnpm-lock.yaml` exists, otherwise `pnpm install`.

This ensures reproducible builds in CI/CD and production environments while remaining flexible during development.

**Customizing package managers:**

C# — Customizing package managers

```csharp
// Customize npm with additional flags
var app = builder.AddJavaScriptApp("app", "./app")
    .WithNpm(installCommand: "ci", installArgs: ["--legacy-peer-deps"]);


// Or use different package managers
var yarnApp = builder.AddJavaScriptApp("yarn-app", "./yarn-app")
    .WithYarn(installArgs: ["--immutable"]);
```

#### Customizing scripts

[Section titled “Customizing scripts”](#customizing-scripts)

You can customize which scripts run during development and build:

C# — Customizing scripts

```csharp
// Use different script names
var app = builder.AddJavaScriptApp("app", "./app")
    .WithRunScript("start")      // Run "npm run start" during development instead of "dev"
    .WithBuildScript("prod");     // Run "npm run prod" during publish instead of "build"
```

#### Passing arguments to scripts

[Section titled “Passing arguments to scripts”](#passing-arguments-to-scripts)

Unlike the deprecated `AddNpmApp` API, `AddJavaScriptApp` does not support an `args` constructor parameter for passing command-line arguments directly to scripts. You have two options to pass arguments:

**Option 1: Use `WithArgs` to pass arguments directly**

C# — Pass arguments using WithArgs

```csharp
// Before (Aspire 9.x with AddNpmApp)
// builder.AddNpmApp("hasura-console", "../Web/ClientApp",
//     scriptName: "hasura:console",
//     args: ["--no-browser"])


// After (Aspire 13.0 with AddJavaScriptApp)
builder.AddJavaScriptApp("hasura-console", "../Web/ClientApp")
    .WithRunScript("hasura:console")
    .WithArgs("--no-browser");
```

**Option 2: Define custom scripts in `package.json` with arguments**

package.json — Define custom scripts with arguments

```json
{
  "scripts": {
    "dev": "vite",
    "hasura:console": "hasura console --no-browser"
  }
}
```

C# — Reference custom script

```csharp
// Before (Aspire 9.x with AddNpmApp)
// builder.AddNpmApp("hasura-console", "../Web/ClientApp",
//     scriptName: "hasura:console",
//     args: ["--no-browser"])


// After (Aspire 13.0 with AddJavaScriptApp)
builder.AddJavaScriptApp("hasura-console", "../Web/ClientApp")
    .WithRunScript("hasura:console");
```

Option 2 keeps all script configuration in `package.json`, making your scripts more discoverable and easier to run outside of Aspire (e.g., `npm run hasura:console`).

#### Vite support

[Section titled “Vite support”](#vite-support)

`AddViteApp` is now a specialization of `AddJavaScriptApp` with Vite-specific optimizations:

C# — Vite support

```csharp
var frontend = builder.AddViteApp("frontend", "./frontend")
    .WithReference(api);
```

Vite applications get:

* Automatic port binding configuration.
* Hot module replacement (HMR) support.
* Optimized build scripts for production.
* Automatic Dockerfile generation.

#### Dynamic Dockerfile generation

[Section titled “Dynamic Dockerfile generation”](#dynamic-dockerfile-generation)

JavaScript applications automatically generate Dockerfiles when published, with intelligent defaults based on your package manager:

C# — Dynamic Dockerfile generation

```csharp
var app = builder.AddJavaScriptApp("app", "./app");
```

The generated Dockerfile:

* Detects Node.js version from `.nvmrc`, `.node-version`, `package.json`, or `.tool-versions`.
* Uses multi-stage builds for smaller images.
* Installs dependencies in a separate layer for better caching.
* Runs your build script to create production assets.
* Defaults to `node:22-slim` if no version is specified.

For information about using JavaScript build artifacts in other containers, see [Container files as build artifacts](#container-files-as-build-artifacts).

#### Node support

[Section titled “Node support”](#node-support)

`AddNodeApp` has now been refactored to align with other language integrations.

C# — Node support

```csharp
var app = builder.AddNodeApp("frontend", "./frontend", "app.js")
    .WithReference(api);
```

Node.js applications get:

* Defaults to npm when `package.json` exists.
* Allows for customizing package manager and build/run scripts.
* Automatic Dockerfile generation with multi-stage builds for smaller images (defaults to `node:22-alpine` if no version is specified).

### Polyglot infrastructure

[Section titled “Polyglot infrastructure”](#polyglot-infrastructure)

Beyond language-specific support, Aspire 13.0 introduces infrastructure features that work across all languages.

#### Polyglot connection properties

[Section titled “Polyglot connection properties”](#polyglot-connection-properties)

Database resources now expose multiple connection string formats automatically, making it easy to connect from any language:

C# — Polyglot connection properties

```csharp
var postgres = builder.AddPostgres("db").AddDatabase("mydb");


// .NET app uses the "ConnectionStrings" configuration section
var dotnetApi = builder.AddProject<Projects.Api>()
    .WithReference(postgres);


// Python app can use URI format
var pythonWorker = builder.AddPythonModule("worker", "./worker", "worker.main")
    .WithEnvironment("DATABASE_URL", postgres.Resource.UriExpression);


// Java app can use JDBC format
var javaApp = builder.AddExecutable("java-app", "java", "./app", ["-jar", "app.jar"])
    .WithEnvironment("DB_JDBC", postgres.Resource.JdbcConnectionStringExpression);
```

When you reference a database resource with `WithReference`, Aspire automatically exposes multiple connection properties as environment variables. For example, a PostgreSQL resource named `db` exposes:

* `DB_URI` - PostgreSQL URI format: `postgresql://user:pass@host:port/dbname`.
* `DB_JDBCCONNECTIONSTRING` - JDBC format: `jdbc:postgresql://host:port/dbname`.
* `DB_HOST`, `DB_PORT`, `DB_USERNAME`, `DB_PASSWORD`, `DB_DATABASENAME` - Individual properties.

The JDBC connection string does not include credentials for security best practices. Use the separate `DB_USERNAME` and `DB_PASSWORD` environment variables to authenticate, or configure your JDBC driver to use these properties.

This pattern works for all supported databases (PostgreSQL, SQL Server, Oracle, MySQL, MongoDB, etc.) with appropriate URI and JDBC formats for each.

Note

These new connection property conventions are available in the built-in Aspire database integrations (PostgreSQL, SQL Server, Oracle, MySQL, MongoDB, etc.). If you have custom or community integrations, they may need to be updated to expose these properties. See the [connection properties agent documentation](https://github.com/dotnet/aspire/blob/main/.github/agents/connectionproperties.agent.md) for guidance on implementing these conventions in your own integrations.

#### Certificate trust across languages

[Section titled “Certificate trust across languages”](#certificate-trust-across-languages)

Aspire 13.0 automatically configures ASP.NET Development Certificate trust for Python, Node.js, and containerized applications without any additional configuration:

C# — Certificate trust across languages

```csharp
// Python applications automatically trust development certificates
var pythonApi = builder.AddUvicornApp("api", "./api", "main:app");


// Node.js applications automatically trust development certificates
var nodeApi = builder.AddJavaScriptApp("frontend", "./frontend");


// Containerized applications automatically trust development certificates
var container = builder.AddContainer("service", "myimage");
```

Aspire automatically:

* **Python**: Configures `SSL_CERT_FILE` and `REQUESTS_CA_BUNDLE` environment variables.
* **Node.js**: Configures `NODE_EXTRA_CA_CERTS` environment variable.
* **Containers**: Mounts certificate bundles and configures appropriate environment variables.
* **All platforms**: Generates and manages development certificates without manual intervention.

This enables secure HTTPS communication during local development across all languages and containerized services.

#### Simplified service URL environment variables

[Section titled “Simplified service URL environment variables”](#simplified-service-url-environment-variables)

Aspire 13.0 introduces polyglot-friendly environment variables that make service discovery easier for non-.NET applications.

C# — Simplified service URL environment variables

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api");


// Python app gets simple environment variables
var pythonApp = builder.AddPythonModule("worker", "./worker", "worker.main")
    .WithReference(api); // Sets API and API_HTTPS env vars


await builder.Build().RunAsync();
```

Instead of complex service discovery formats, non-.NET apps receive simple environment variables:

* `API_HTTP=http://localhost:5000`—HTTP endpoint.
* `API_HTTPS=https://localhost:5001`—HTTPS endpoint.

This feature makes Aspire’s service discovery mechanism accessible to any programming language, not just .NET applications with service discovery libraries.

## 🛠️ CLI and tooling

[Section titled “🛠️ CLI and tooling”](#️-cli-and-tooling)

### aspire init command

[Section titled “aspire init command”](#aspire-init-command)

The new `aspire init` command provides a streamlined, interactive experience for initializing Aspire solutions with comprehensive project setup and configuration.

Find out more about the `aspire init` command in the [aspire init documentation](/reference/cli/commands/aspire-init/).

Bash — Initialize new Aspire solution

```bash
# Initialize a new Aspire solution - interactive prompts guide you through setup
aspire init
```

When you run `aspire init`, the CLI will:

* **Discover existing solutions**: Automatically finds and updates solution files in the current directory.
* **Create single-file AppHost**: If no solution exists, creates a single-file AppHost for quick starts.
* **Add projects intelligently**: Prompts to add projects to your app host.
* **Configure service defaults**: Sets up service defaults referencing automatically.
* **Setup NuGet.config**: Creates package source mappings for Aspire packages.
* **Manage template versions**: Interactively selects the appropriate template version.

The init command simplifies the initial project setup through an interactive workflow that ensures consistent configuration across team members.

Note

The `aspire init` command sets up the Aspire project structure and configuration, but does not automatically add resources (databases, caches, message queues, etc.) to your AppHost. You’ll need to manually add resource definitions to your AppHost code using methods like `AddPostgres`, `AddRedis`, `AddRabbitMQ`, etc.

### aspire new: Curated starter templates

[Section titled “aspire new: Curated starter templates”](#aspire-new-curated-starter-templates)

Aspire 13.0 refocuses `aspire new` around curated starter templates that demonstrate different application patterns. The command now provides an interactive experience designed to help you get started quickly with ready-to-run examples.

```bash
aspire new
```

When you run the command, you’ll see an interactive menu to select a starter template:

```plaintext
Select a template:


> Blazor & Minimal API starter
  React (Vite) & FastAPI starter
  Empty AppHost


(Type to search)
```

**Available starter templates:**

* [**Blazor & Minimal API starter**](/get-started/first-app/?lang=csharp): Full-stack .NET application with Blazor frontend and ASP.NET Core API.
* [**React (Vite) & FastAPI starter**](/get-started/first-app/?lang=python): Polyglot application demonstrating Python and JavaScript integration.
* **Empty AppHost**: Minimal single-file AppHost for custom applications.

The starter template collection is designed to be extensible and will grow over time to showcase different architectural patterns and technology combinations. This approach makes it easier to explore Aspire’s capabilities and learn from working examples.

For command reference material, see the [aspire new documentation](/reference/cli/commands/aspire-new/).

### Aspire update improvements

[Section titled “Aspire update improvements”](#aspire-update-improvements)

The `aspire update` command has received significant improvements in Aspire 13.0, including the new `--self` flag to update the CLI itself:

Bash — Aspire update commands

```bash
# Update all Aspire packages in the current project
aspire update


# Update the Aspire CLI itself (new in 13.0)
aspire update --self


# Update a specific project
aspire update --project ./src/MyApp.AppHost
```

**New in Aspire 13.0:**

* **CLI self-update**: The `--self` flag allows you to update the Aspire CLI without reinstalling.
* **Improved reliability**: Numerous bug fixes for edge cases in dependency resolution.
* **Better error handling**: Clearer error messages when updates fail.
* **Performance improvements**: Faster package detection and update operations.

The `aspire update` command continues to support:

* Central package management (CPM) solutions.
* Diamond dependency resolution.
* Single-file app hosts.
* XML fallback parsing for unresolvable AppHost SDKs.
* Enhanced visual presentation with colorized output.
* Channel awareness (stable, preview, staging).

For detailed command reference, see [aspire update](/reference/cli/commands/aspire-update/).

### Visual Studio Code extension

[Section titled “Visual Studio Code extension”](#visual-studio-code-extension)

Aspire 13.0 includes a new Aspire VS Code extension which brings Aspire CLI features to VS Code. It provides commands to create and debug projects, add integrations, configure launch settings, and manage deployments directly from the Command Palette.

Note

To use most extension features, the Aspire 13.0 CLI must be installed and available on the user `PATH`. You can verify this by running `aspire --version` in a VS Code terminal. For installation steps, see [Upgrade to Aspire 13.0](#-upgrade-to-aspire-130).

**Key features:**

* **Debug Python and C# projects inside VS Code**: Launch your apphost using the Aspire debugger to launch and debug any C# and Python resources in your app.
* **Project creation**: Use `Aspire: New Aspire project` to create new Aspire projects from templates.
* **Integration management**: Use `Aspire: Add an integration` to add Aspire integrations to your AppHost.
* **Launch configuration**: Use `Aspire: Configure launch.json` to automatically set up a VS Code launch configuration.
* **Configuration management**: Use `Aspire: Manage configuration settings` to configure Aspire CLI settings.
* **Publish and deployment**: Use `Aspire: Publish deployment artifacts` and `Aspire: Deploy app` commands (preview).

**Getting started:**

1. Install the extension from the [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=microsoft-aspire.aspire-vscode).
2. Open the Command Palette (`Ctrl`+`Shift`+`P`).
3. Type “Aspire” to see all available commands.
4. Use `Aspire: Configure launch.json` to set up debugging for your AppHost.

The extension requires the Aspire CLI to be installed and available on your PATH. All commands are grouped under the **Aspire** category in the Command Palette for easy discovery.

### Single-file AppHost support

[Section titled “Single-file AppHost support”](#single-file-apphost-support)

Aspire 13.0 introduces comprehensive support for single-file app hosts, allowing you to define your entire distributed application in a single `.cs` file without a project file.

C# — Single-file AppHost

```csharp
// apphost.cs
#:sdk Aspire.AppHost.Sdk@13.0.0
#:package Aspire.Hosting.PostgreSQL@13.0.0


var builder = DistributedApplication.CreateBuilder(args);


var database = builder.AddPostgres("postgres");


builder.AddProject<Projects.Api>("api")
    .WithReference(database);


await builder.Build().RunAsync();
```

Single-file app host support includes:

* **Template support**: Use the `aspire-apphost-singlefile` template via `aspire new`.
* **Full CLI integration**: Works seamlessly with `aspire run`, `aspire deploy`, `aspire publish`, `aspire add`, `aspire update`.
* **Launch profile support**: Full debugging and launch configuration support.

Note

Single-file app hosts require .NET 10.0 SDK or later.

### Automatic .NET SDK installation (Preview)

[Section titled “Automatic .NET SDK installation (Preview)”](#automatic-net-sdk-installation-preview)

The Aspire CLI includes a preview feature for automatically installing required .NET SDK versions when they’re missing.

Caution

This is a preview feature that is **not enabled by default**. To use automatic SDK installation, enable it with:

```bash
aspire config set features.dotnetSdkInstallationEnabled true
```

Once enabled, the CLI will automatically install missing SDKs:

```bash
# With the feature enabled, the CLI will automatically install the required SDK
aspire run


# Installing .NET SDK 10.0.100...
# ✅ SDK installation complete
# Running app host...
```

The automatic SDK installation feature provides:

* **Cross-platform support**: Works on Windows, macOS, and Linux.
* **Version detection**: Automatically detects required SDK versions.
* **Fallback support**: Provides alternative installation options if automatic installation fails.

When enabled, this preview feature can improve the onboarding experience for new team members and CI/CD environments.

### Non-interactive mode for CI/CD

[Section titled “Non-interactive mode for CI/CD”](#non-interactive-mode-for-cicd)

The `--non-interactive` flag disables prompts and interactive progress indicators for CI/CD scenarios. The CLI automatically detects common CI environments and enables this mode. You can also set `ASPIRE_NON_INTERACTIVE=true` or use `--non-interactive` explicitly.

Note

Not all commands support non-interactive mode. Commands that require user input will fail if the `--non-interactive` flag is set and required values are not provided through other means.

***

**For advanced deployment workflows**, see [aspire do](#aspire-do), which introduces a comprehensive pipeline system for coordinating build, deployment, and publishing operations.

## ⭐ Major new features

[Section titled “⭐ Major new features”](#-major-new-features)

### aspire do

[Section titled “aspire do”](#aspire-do)

Aspire 13.0 introduces `aspire do` - a comprehensive system for coordinating build, deployment, and publishing operations. This new architecture provides a foundation for orchestrating complex deployment workflows with built-in support for step dependencies, parallel execution, and detailed progress reporting.

The `aspire do` system replaces the previous publishing infrastructure with a more flexible, extensible model that allows resource-specific deployment logic to be decentralized and composed into larger workflows.

Caution

🧪 **Early Preview**: The pipeline APIs are in early preview and marked as experimental. See [aspire do command reference](/reference/cli/commands/aspire-do/) for more information.

For basic CLI commands and tooling, see [CLI and tooling](#cli-and-tooling), which covers [aspire init](#aspire-init-command), [aspire update](#aspire-update-improvements), and [non-interactive mode](#non-interactive-mode-for-cicd).

**Example: Custom pipeline step**

The Aspire AppHost defines a global `DistributedApplicationPipeline` instance on the `DistributedApplicationBuilder` that can be used to register steps in the pipeline at the top-level.

C# — Custom pipeline step

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.Pipeline.AddStep("validate", (context) =>
{
    context.Logger.LogInformation("Running validation checks...");
    // Your custom validation logic
    return Task.CompletedTask;
}, requiredBy: WellKnownPipelineSteps.Build);
```

Steps registered in the pipeline can be run via the CLI:

Bash — Run custom pipeline step

```bash
aspire do validate
```

The pipeline system supports global steps, resource-specific steps, dependency configuration, parallel execution, and built-in logging. Resources can contribute their own steps via `WithPipelineStepFactory` and control ordering with `WithPipelineConfiguration`.

#### Running pipeline steps

[Section titled “Running pipeline steps”](#running-pipeline-steps)

Use `aspire do` to execute pipeline steps. The command automatically resolves dependencies and executes steps in the correct order:

Bash — Running pipeline steps

```bash
aspire do deploy                              # Runs all steps necessary to deploy the app
aspire do publish --output-path ./artifacts   # Custom output path
aspire do deploy --environment Production     # Target specific environment
aspire do deploy --log-level debug            # Verbose logging for troubleshooting
```

### Container files as build artifacts

[Section titled “Container files as build artifacts”](#container-files-as-build-artifacts)

Aspire 13.0 introduces the ability to **extract files from one resource’s container and copy them into another resource’s container** during the build process. This enables powerful patterns like building a frontend in one container and serving it from a backend in another container.

C# — Container files as build artifacts

```csharp
var frontend = builder.AddViteApp("frontend", "./frontend");
var api = builder.AddUvicornApp("api", "./api", "main:app");


// Extract files FROM the frontend container and copy TO the 'static' folder
// in the api container
api.PublishWithContainerFiles(frontend, "./static");
```

**How it works:**

1. The `frontend` resource builds inside its container, producing output files.
2. Aspire extracts those files from the frontend container.
3. The files are copied into the `api` container at `./static`.
4. The final `api` container contains both the API code and the frontend static files.

**Example: Serving frontend from backend**

The FastAPI app can serve the static files:

Python — Serving front end from back end

```python
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles


app = FastAPI()


# API endpoints
@app.get("/api/data")
def get_data():
    return {"message": "Hello from API"}


# Serve the frontend static files
app.mount("/", StaticFiles(directory="static", html=True), name="static")
```

This pattern works with any resource types (C#, Python, JavaScript) and integrates seamlessly with `aspire do` for dependency tracking, parallel execution, and incremental builds.

### Dockerfile builder API (experimental)

[Section titled “Dockerfile builder API (experimental)”](#dockerfile-builder-api-experimental)

Aspire 13.0 introduces an experimental programmatic Dockerfile generation API that allows you to define Dockerfiles using C# code with a composable, type-safe API.

Caution

🧪 **Experimental Feature**: The Dockerfile Builder API is experimental and may change before general availability.

```csharp
var app = builder.AddContainer("app", "app")
    .PublishAsDockerFile(publish =>
    {
        publish.WithDockerfileBuilder("/path/to/app", context =>
        {
            var buildStage = context.Builder
                .From("golang:1.23", "builder")
                .WorkDir("/build")
                .Copy(".", "./")
                .Run("go build -o /app/server .");


            context.Builder
                .From("alpine:latest")
                .CopyFrom(buildStage.StageName!, "/app/server", "/app/server")
                .Entrypoint(["/app/server"]);
        });
    });
```

The API provides multi-stage builds, fluent method chaining (`WorkDir`, `Copy`, `Run`, `Env`, `User`, `Entrypoint`), comments/formatting, and BuildKit features.

### Certificate management

[Section titled “Certificate management”](#certificate-management)

Aspire 13.0 introduces certificate management for custom certificate authorities and developer certificate trust:

```csharp
// Add custom certificate collections
var certs = builder.AddCertificateAuthorityCollection("custom-certs")
    .WithCertificatesFromFile("./certs/my-ca.pem")
    .WithCertificatesFromStore(StoreName.CertificateAuthority, StoreLocation.LocalMachine);


var gateway = builder.AddYarp("gateway")
    .WithCertificateAuthorityCollection(certs)
    .WithDeveloperCertificateTrust(trust: true);
```

Features include loading from PEM files or certificate stores, flexible trust scoping, customizable container paths, and automatic dev certificate trust configuration.

## 📦 Integrations

[Section titled “📦 Integrations”](#-integrations)

Aspire 13.0 introduces new integration packages that expand platform support.

### .NET MAUI integration

[Section titled “.NET MAUI integration”](#net-maui-integration)

Aspire 13.0 introduces a new `Aspire.Hosting.Maui` package that enables orchestrating .NET MAUI mobile applications alongside your cloud services.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api");


// To easily reach your local API project from the
// emulator/Simulator/physical device, you can use the Dev Tunnels integration
var publicDevTunnel = builder.AddDevTunnel("devtunnel-public")
    .WithAnonymousAccess()
    .WithReference(api.GetEndpoint("https"));


// Add the .NET MAUI project resource
var mauiapp = builder.AddMauiProject("myapp", @"../MyApp/MyApp.csproj");


// Add MAUI app for Windows
mauiapp.AddWindowsDevice()
    .WithReference(api);


// Add MAUI app for Mac Catalyst
mauiapp.AddMacCatalystDevice()
    .WithReference(api);


// Add MAUI app for iOS running on the iOS Simulator (starts
// a random one, or uses the currently started one)
mauiapp.AddiOSSimulator()
    .WithOtlpDevTunnel() // Needed to get the OpenTelemetry data to "localhost"
    .WithReference(api, publicDevTunnel); // Needs a dev tunnel to reach "localhost"


// Add MAUI app for Android running on the emulator with
// default emulator (uses running or default emulator, needs to be started)
mauiapp.AddAndroidEmulator()
    .WithOtlpDevTunnel() // Needed to get the OpenTelemetry data to "localhost"
    .WithReference(api, publicDevTunnel); // Needs a dev tunnel to reach "localhost"


builder.Build().Run();
```

MAUI integration features:

* **Platform support**: Windows, Mac Catalyst, Android, and iOS
* **Device registration**: Register multiple device instances for testing
* **Platform validation**: Automatically detects host OS compatibility and marks resources as unsupported when needed
* **Full orchestration**: MAUI apps participate in service discovery and can reference backend services

This enables a complete mobile + cloud development experience where you can run and debug your mobile app alongside your backend services in a single Aspire project.

## 📊 Dashboard enhancements

[Section titled “📊 Dashboard enhancements”](#-dashboard-enhancements)

### Aspire MCP server

[Section titled “Aspire MCP server”](#aspire-mcp-server)

[The Dashboard now includes an MCP server](/dashboard/mcp-server/) that integrates Aspire into your AI development ecosystem. The MCP server enables AI assistants to query resources, access telemetry data, and execute commands directly from your development environment.

**Getting started:**

1. Run your Aspire app and open the dashboard.
2. Click the MCP button in the top right corner.
3. Follow the instructions to configure your AI assistant (Claude Code, GitHub Copilot CLI, Cursor, VS Code, etc.).

The MCP server uses streamable HTTP with API key authentication for secure access. Configuration requires:

* `url`: The Aspire MCP endpoint address.
* `type`: Set to “http” for the streamable-HTTP MCP server.
* `x-mcp-api-key`: HTTP header for authentication.

**Available tools:**

* `list_resources`—Retrieve all resources with state, endpoints, environment variables, and metadata.
* `list_console_logs`—Access resource console output.
* `list_structured_logs`—Retrieve telemetry data, optionally filtered by resource.
* `list_traces`—Access distributed trace information.
* `list_trace_structured_logs`—View logs associated with specific traces.
* `execute_resource_command`—Execute commands on resources.

This enables AI assistants to directly interact with your Aspire applications, analyze telemetry in real-time, and provide intelligent insights during development.

![MCP dialog](/_astro/mcp-dialog.DJhOAzMI_Z2kOzKG.webp "MCP dialog")

### Interaction services dynamic inputs and comboboxes

[Section titled “Interaction services dynamic inputs and comboboxes”](#interaction-services-dynamic-inputs-and-comboboxes)

The interaction service just got a major upgrade:

* 💫 Dropdowns can now accept text—in other words, ComboBox inputs. For more information, see [interaction service custom choice](#interaction-service-custom-choices).
* 🔄 Supports dynamic data loading for cascading dropdowns. For more information, see [interaction service dynamic inputs](#interaction-service-dynamic-inputs).

You can see an example of the new interaction service features in the dashboard with the Azure provisioning dialog. 🚀

![New interaction service feature in the Azure provisioning dialog](/_astro/interaction-service.DyDhNPwb_1US32c.webp "New interaction service feature in the Azure provisioning dialog")

### Polyglot language icons

[Section titled “Polyglot language icons”](#polyglot-language-icons)

Aspire is going polyglot with strong support for JavaScript ☕ and Python 🐍 apps. The dashboard features new programming language icons for app resources. This includes .NET projects (C#, F#, VB.NET) and JavaScript and Python apps.

![Polyglot language icons](/_astro/language-icons.BEudrxhN_Z1wFsF0.webp "Polyglot language icons")

### Improved accent colors

[Section titled “Improved accent colors”](#improved-accent-colors)

Resources in the dashboard have accent colors, which is used to color their icon and telemetry. Accent colors are now more FluentUI-ish (saturation++) with custom tweaks for light and dark themes.

The dark blue accent color is no longer almost invisible on a dark background!

![Accent color tweaks](/_astro/color-tweaks.vuk9FmkC_W3naf.webp "Accent color tweaks")

### Health checks last run time

[Section titled “Health checks last run time”](#health-checks-last-run-time)

The dashboard makes it easy to see resource health statuses. New in Aspire 13, the last run time is now displayed next to each resource’s current state. This helps you tell whether an unhealthy resource is still being checked and progressing toward a healthy state.

![Health checks last run time](/_astro/health-checks-last-run.BNWR06oy_ZRIpnJ.webp "Health checks last run time")

## 🖥️ App model enhancements

[Section titled “🖥️ App model enhancements”](#️-app-model-enhancements)

### C# file-based app support

[Section titled “C# file-based app support”](#c-file-based-app-support)

Aspire 13.0 adds first-class support for C# file-based applications, enabling you to add C# apps without full project files to your distributed application.

apphost.cs

```csharp
#:sdk Aspire.AppHost.Sdk@13.0.0
#:package Aspire.Hosting.Redis@13.0.0


// Type is for evaluation purposes only and is subject to change or
// removal in future updates. Suppress this diagnostic to proceed.
#pragma warning disable ASPIRECSHARPAPPS001


var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache");


builder.AddCSharpApp("worker", "../worker/Program.cs")
    .WithReference(cache);


builder.Build().Run();
```

This works seamlessly with .NET 10 SDK’s file-based application support. The C# file-based app can use service discovery, access referenced resources, and be debugged in VS Code just like regular projects.

### Network identifiers

[Section titled “Network identifiers”](#network-identifiers)

Aspire 13.0 introduces `NetworkIdentifier` for better network context awareness in endpoint resolution.

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api");


// Get endpoint with specific network context
var localhostEndpoint = api.GetEndpoint("http", KnownNetworkIdentifiers.LocalhostNetwork);
var containerEndpoint = api.GetEndpoint("http", KnownNetworkIdentifiers.DefaultAspireContainerNetwork);


await builder.Build().RunAsync();
```

Network identifier features:

* **Context-aware endpoint resolution**: Resolve endpoints based on the network context (host, container network, etc.)
* **Known network identifiers**: Predefined identifiers for common scenarios (`LocalhostNetwork`, `DefaultAspireContainerNetwork`, `PublicInternet`)
* **AllocatedEndpoint changes**: Endpoints now include their `NetworkID` instead of a container host address
* **Better container networking**: Improved support for container-to-container communication scenarios

### Interaction service dynamic inputs

[Section titled “Interaction service dynamic inputs”](#interaction-service-dynamic-inputs)

The interaction service has been improved with support for dynamic inputs. This feature allows inputs to load options based on other input values, enabling cascading dropdowns and dependent parameter prompting.

Note

This is an experimental feature marked with `[Experimental("ASPIREINTERACTION001")]`.

```csharp
var inputs = new List<InteractionInput>
{
    // First input - static options
    new InteractionInput
    {
        Name = "DatabaseType",
        InputType = InputType.Choice,
        Label = "Database Type",
        Required = true,
        Options =
        [
            KeyValuePair.Create("postgres", "PostgreSQL"),
            KeyValuePair.Create("mysql", "MySQL"),
            KeyValuePair.Create("sqlserver", "SQL Server")
        ]
    },


    // Second input - loads dynamically based on DatabaseType
    new InteractionInput
    {
        Name = "DatabaseVersion",
        InputType = InputType.Choice,
        Label = "Database Version",
        Required = true,
        DynamicLoading = new InputLoadOptions
        {
            LoadCallback = async (context) =>
            {
                var dbType = context.AllInputs["DatabaseType"].Value;
                context.Input.Options = await GetAvailableVersionsAsync(dbType);
            },
            DependsOnInputs = ["DatabaseType"]
        }
    }
};
```

Features include callback-based loading (`LoadCallback`), dependency tracking (`DependsOnInputs`), access to other input values (`context.AllInputs`), and async support for loading from APIs or databases.

### Interaction service custom choices

[Section titled “Interaction service custom choices”](#interaction-service-custom-choices)

Choice inputs can be configured to accept custom choices by setting `AllowCustomChoice` to `true`. In the dashboard, these inputs are [displayed as a combobox](https://wikipedia.org/wiki/Combo_box).

```csharp
var input = new InteractionInput
{
    Name = "AllowCustomInput",
    Label = "Favorite food?",
    InputType = InputType.Choice,
    Options = [KeyValuePair.Create("pizza", "Pizza"), KeyValuePair.Create("burger", "Burger")],
    AllowCustomChoice = true
};


var result = await interactionService.PromptInputAsync("What is your favorite food?", "Select your favorite food.", input);
```

### Reference and connection improvements

[Section titled “Reference and connection improvements”](#reference-and-connection-improvements)

#### Named references

[Section titled “Named references”](#named-references)

Reference resources with explicit names to control the environment variable prefix:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var primaryDb = builder.AddPostgres("postgres-primary")
    .AddDatabase("customers");


var replicaDb = builder.AddPostgres("postgres-replica")
    .AddDatabase("customers");


var api = builder.AddProject<Projects.Api>("api")
    .WithReference(primaryDb, "primary")
    .WithReference(replicaDb, "replica");
```

**Environment variables injected into `api`:**

```bash
# From primaryDb with "primary" name
ConnectionStrings__primary=Host=postgres-primary;...


# From replicaDb with "replica" name
ConnectionStrings__replica=Host=postgres-replica;...
```

This allows the application to distinguish between multiple database connections using the custom names.

#### Connection properties

[Section titled “Connection properties”](#connection-properties)

Access individual connection string components to build custom connection strings or configuration:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("postgres").AddDatabase("mydb");
var redis = builder.AddRedis("cache");


var worker = builder.AddProject<Projects.Worker>("worker")
    .WithEnvironment("DB_HOST", postgres.Resource.GetConnectionProperty("Host"))
    .WithEnvironment("DB_PORT", postgres.Resource.GetConnectionProperty("Port"))
    .WithEnvironment("DB_NAME", postgres.Resource.DatabaseName)
    .WithEnvironment("CACHE_HOST", redis.Resource.GetConnectionProperty("Host"))
    .WithEnvironment("CACHE_PORT", redis.Resource.GetConnectionProperty("Port"));
```

**Environment variables injected into `worker`:**

```bash
DB_HOST=postgres
DB_PORT=5432
DB_NAME=mydb
CACHE_HOST=cache
CACHE_PORT=6379
```

This is useful when your application needs individual connection components rather than a full connection string, or when building connection strings in formats Aspire doesn’t provide natively.

#### Endpoint reference enhancements

[Section titled “Endpoint reference enhancements”](#endpoint-reference-enhancements)

Control how service URLs are resolved and injected with network-aware endpoint references:

C# — AppHost.cs

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var api = builder.AddProject<Projects.Api>("api")
    .WithExternalHttpEndpoints();


var frontend = builder.AddJavaScriptApp("frontend", "./frontend")
    .WithEnvironment("API_URL", api.GetEndpoint("https"));
```

**Environment variables injected into `frontend`:**

```bash
# Default behavior - uses the external endpoint URL
API_URL=https://localhost:7123
```

For advanced scenarios, you can specify the network context:

```csharp
var worker = builder.AddProject<Projects.Worker>("worker")
    .WithEnvironment("API_URL",
        api.GetEndpoint("http",
            KnownNetworkIdentifiers.DefaultAspireContainerNetwork));
```

**Environment variables injected into `worker`:**

```bash
# Container network context - uses internal container address
API_URL=http://api:8080
```

This enables proper service-to-service communication whether the consumer is running on the host or in a container.

### Other app model improvements

[Section titled “Other app model improvements”](#other-app-model-improvements)

**Compute environment support (graduated from experimental)**:

* `WithComputeEnvironment` API is now stable (no longer marked as experimental)
* Deploy resources to specific compute environments without experimental warnings

**Resource exclusion from MCP**:

* `ExcludeFromMcp` extension to exclude specific resources from Model Context Protocol exposure
* Control which resources are visible to AI assistants and MCP clients

**Reference environment injection control**:

* `WithReferenceEnvironment` to control how environment variables are injected from references
* `ReferenceEnvironmentInjectionFlags` for fine-grained control over environment variable behavior

**Helper methods**:

* `TryCreateResourceBuilder` for safely attempting resource builder creation with failure handling
* Returns false instead of throwing when resource builder creation fails

## 🚀 Deployment improvements

[Section titled “🚀 Deployment improvements”](#-deployment-improvements)

### Deployment pipeline reimplementation

[Section titled “Deployment pipeline reimplementation”](#deployment-pipeline-reimplementation)

Aspire 13.0 completely reimplements the deployment workflow on top of [aspire do](#aspire-do). This architectural change transforms deployment from a monolithic operation into a composable set of discrete, parallelizable steps.

The new deployment pipeline automatically parallelizes independent operations, dramatically reducing deployment time. Steps like prerequisites, builds, and provisioning run concurrently when dependencies allow.

**Granular step control:**

Execute individual deployment phases using `aspire do`:

```bash
aspire do build                           # Build all containers
aspire deploy                             # Complete deployment
aspire do deploy --log-level debug        # Deploy with verbose logging
```

This enables incremental deployments, debugging specific steps, and CI/CD pipeline splitting. Use `--log-level debug` for detailed troubleshooting output.

**Pipeline diagnostics:**

Use `aspire do diagnostics` to understand your pipeline graph, view execution order with parallelization indicators, see step dependencies and resources, simulate “what if” scenarios, and detect configuration issues like orphaned steps or circular dependencies.

**Benefits:**

The pipeline-based deployment provides dependency tracking, real-time progress reporting, failure isolation, selective execution, extensibility, and built-in diagnostics.

For more details, see [aspire do](#aspire-do).

### Deployment state management

[Section titled “Deployment state management”](#deployment-state-management)

Aspire 13.0 introduces deployment state management that automatically persists deployment information locally across runs. When you deploy to Azure, Aspire now remembers your choices and deployment state between sessions.

**What persists locally:**

* **Azure configuration**: Subscription, resource group, location, and tenant selections
* **Parameter values**: Input values from previous deployments
* **Deployed resources**: Track what’s been deployed and where

**User experience:**

```bash
# First deployment - you're prompted for configuration, assumes "Production" environment
aspire deploy
# Select Azure subscription, resource group, location, tenant...


# Subsequent deployments - no prompts, uses saved state
aspire deploy
# Uses previous selections automatically


# First deployment to a different environment -- prompted again
aspire deploy --environment staging
```

This eliminates repetitive prompts and makes iterative deployments faster. Your deployment configuration is stored locally (not in source control), so each developer can have their own Azure configuration without conflicts.

**Example workflow:**

1. First time: Select subscription “My Subscription”, resource group “my-rg”, location “eastus”
2. Deploy completes, state saved locally
3. Make code changes
4. Run `aspire deploy` again - automatically uses “My Subscription”, “my-rg”, “eastus”
5. No need to re-enter configuration

**Storage location:**

The state is stored in your local user profile at:

* **Windows**: `%USERPROFILE%\.aspire\deployments\<project-hash>\<environment>.json`
* **macOS/Linux**: `$HOME/.aspire/deployments/<project-hash>/<environment>.json`

The `<project-hash>` is a SHA256 hash of your AppHost project path, allowing different projects to maintain separate state. The `<environment>` corresponds to the deployment environment (e.g., `production`, `development`).

This location is excluded from source control by design, so each developer can have their own Azure configuration without conflicts.

**Resetting deployment state:**

If you need to reset your deployment state (for example, to change subscriptions or start fresh), use the `--clear-cache` flag:

```bash
aspire deploy --clear-cache
# Clears saved state and prompts for configuration again
```

This removes all saved deployment state, including Azure configuration, parameter values, and deployment context. The next deployment will prompt you for all configuration values as if it were the first deployment.

## ☁️ Azure

[Section titled “☁️ Azure”](#️-azure)

### Azure tenant selection

[Section titled “Azure tenant selection”](#azure-tenant-selection)

Aspire 13.0 introduces interactive tenant selection during Azure provisioning, fixing issues with multi-tenant scenarios (work and personal accounts).

When provisioning Azure resources, if multiple tenants are available, the CLI will prompt you to select the appropriate tenant. The tenant selection is stored alongside your subscription, location, and resource group choices for consistent deployments.

```bash
aspire deploy


# If you have multiple tenants, you'll be prompted:
# Select Azure tenant:
#   > work@company.com (Default Directory)
#     personal@outlook.com (Personal Account)
```

### Azure App Service enhancements

[Section titled “Azure App Service enhancements”](#azure-app-service-enhancements)

Aspire 13.0 brings significant improvements to Azure App Service deployment, making it easier to deploy and monitor your applications in production.

#### Aspire dashboard in App Service

[Section titled “Aspire dashboard in App Service”](#aspire-dashboard-in-app-service)

The Aspire Dashboard is now included by default when deploying to Azure App Service, giving you visibility into your deployed applications:

```csharp
builder.AddAzureAppServiceEnvironment("env");
// Dashboard is included by default at https://[prefix]-aspiredashboard-[unique string].azurewebsites.net
```

The deployed dashboard provides the same experience as local development: view logs, traces, metrics, and application topology for your production environment.

To disable the dashboard:

```csharp
builder.AddAzureAppServiceEnvironment("env")
    .WithDashboard(enable: false);
```

#### Application Insights integration

[Section titled “Application Insights integration”](#application-insights-integration)

Enable Azure Application Insights for comprehensive monitoring and telemetry:

```csharp
builder.AddAzureAppServiceEnvironment("env")
    .WithAzureApplicationInsights();
```

When enabled, Aspire automatically:

* Creates a Log Analytics workspace.
* Creates an Application Insights resource.
* Configures all App Service Web Apps with the connection string.
* Injects `APPLICATIONINSIGHTS_CONNECTION_STRING` into your applications.

You can also reference an existing Application Insights resource:

```csharp
var insights = builder.AddAzureApplicationInsights("insights");


builder.AddAzureAppServiceEnvironment("env")
    .WithAzureApplicationInsights(insights);
```

## ⚠️ Breaking changes

[Section titled “⚠️ Breaking changes”](#️-breaking-changes)

### Package renames

[Section titled “Package renames”](#package-renames)

**Aspire.Hosting.NodeJs → Aspire.Hosting.JavaScript**

The `Aspire.Hosting.NodeJs` package has been renamed to `Aspire.Hosting.JavaScript` to better reflect its broader support for JavaScript applications (Node.js, Vite, etc.).

Update your package references:

```xml
<!-- Before (9.x) -->
<PackageReference Include="Aspire.Hosting.NodeJs" Version="9.x.x" />


<!-- After (13.0) -->
<PackageReference Include="Aspire.Hosting.JavaScript" Version="13.0.0" />
```

Or use the CLI:

```bash
# Before (9.x)
aspire add nodejs


# After (13.0)
aspire add javaScript
```

### Removed APIs

[Section titled “Removed APIs”](#removed-apis)

The following APIs have been removed in Aspire 13.0:

**Publishing infrastructure** (replaced by `aspire do`):

* `PublishingContext` and `PublishingCallbackAnnotation`
* `DeployingContext` and `DeployingCallbackAnnotation`
* `WithPublishingCallback` extension method
* `IDistributedApplicationPublisher` interface
* `IPublishingActivityReporter`, `IPublishingStep`, `IPublishingTask` interfaces
* `NullPublishingActivityReporter` class
* `PublishingExtensions` class (all extension methods)
* `PublishingOptions` class
* `CompletionState` enum

**Debugging APIs** (replaced with new flexible API):

* Old `WithDebugSupport` overload with `debugAdapterId` and `requiredExtensionId` parameters
* `SupportsDebuggingAnnotation` (replaced with new debug support annotation)

**Diagnostic codes**:

* `ASPIRECOMPUTE001` diagnostics (removed - API graduated from experimental)
* `ASPIREPUBLISHERS001` (renamed to `ASPIREPIPELINES001-003`)

**CLI commands**:

* `--watch` flag removed from `aspire run` (replaced by `features.defaultWatchEnabled` feature flag)

### Obsolete APIs

[Section titled “Obsolete APIs”](#obsolete-apis)

The following APIs are marked as obsolete in Aspire 13.0 and will be removed in a future release:

**Lifecycle hooks**:

* `IDistributedApplicationLifecycleHook` interface - Use `IDistributedApplicationEventingSubscriber` instead

**Lifecycle hook extension methods** (use eventing subscriber extensions instead):

* `AddLifecycleHook<T>()` - Use `AddEventingSubscriber<T>()` instead
* `AddLifecycleHook<T>(Func<IServiceProvider, T>)` - Use `AddEventingSubscriber<T>(Func<IServiceProvider, T>)` instead
* `TryAddLifecycleHook<T>()` - Use `TryAddEventingSubscriber<T>()` instead
* `TryAddLifecycleHook<T>(Func<IServiceProvider, T>)` - Use `TryAddEventingSubscriber<T>(Func<IServiceProvider, T>)` instead

**Publishing interfaces** (use `aspire do` instead):

* `IDistributedApplicationPublisher` - Use `PipelineStep` instead
* `PublishingOptions` - Use `PipelineOptions` instead

**Node.js/JavaScript APIs** (use new JavaScript hosting instead):

* `AddNpmApp()` - Use `AddJavaScriptApp()` instead for general npm-based apps, or `AddViteApp()` for Vite projects

Migrating from AddNpmApp

The `AddNpmApp` API supported an `args` parameter for passing command-line arguments to scripts. `AddJavaScriptApp` does not have this parameter. Instead, define custom scripts in your `package.json` with the required arguments. See [Passing arguments to scripts](#passing-arguments-to-scripts) for details and examples.

While the obsoleted APIs still work in 13.0, they will be removed in the next major version. Update your code to use the recommended replacements.

### Changed signatures

[Section titled “Changed signatures”](#changed-signatures)

**AllocatedEndpoint constructor**:

```csharp
// Before (9.x)
var endpoint = new AllocatedEndpoint(
    "http",
    8080,
    containerHostAddress: "localhost");


// After (13.0)
var endpoint = new AllocatedEndpoint(
    endpointAnnotation,
    "http",
    8080,
    networkIdentifier: KnownNetworkIdentifiers.LocalhostNetwork);
```

**ParameterProcessor constructor**:

```csharp
// Before (9.x)
var processor = new ParameterProcessor(
    notificationService,
    loggerService,
    interactionService,
    logger,
    executionContext,
    distributedApplicationOptions);


// After (13.0)
var processor = new ParameterProcessor(
    notificationService,
    loggerService,
    interactionService,
    logger,
    executionContext,
    deploymentStateManager);
```

**InteractionInput property changes**:

* `MaxLength`: Changed from settable to init-only.
* `Options`: Changed from init-only to settable.
* `Placeholder`: Changed from settable to init-only.

**WithReference for IResourceWithServiceDiscovery**:

* Added new overload with `name` parameter for named references.
* Existing overload still available for compatibility.

**ProcessArgumentValuesAsync and ProcessEnvironmentVariableValuesAsync**:

```csharp
// Before (9.x)
await resource.ProcessArgumentValuesAsync(
    executionContext, processValue, logger,
    containerHostName: "localhost", cancellationToken);


// After (13.0)
await resource.ProcessArgumentValuesAsync(
    executionContext, processValue, logger, cancellationToken);
```

The `containerHostName` parameter has been removed. Network context is now handled through `NetworkIdentifier`.

**EndpointReference.GetValueAsync behavior change**:

```csharp
// Before (9.x) - would throw immediately if not allocated
var value = await endpointRef.GetValueAsync(cancellationToken);


// After (13.0) - waits for allocation, check IsAllocated if you need immediate failure
if (!endpointRef.IsAllocated)
{
    throw new InvalidOperationException("Endpoint not allocated");
}
var value = await endpointRef.GetValueAsync(cancellationToken);
```

### Major architectural changes

[Section titled “Major architectural changes”](#major-architectural-changes)

#### Universal container-to-host communication

[Section titled “Universal container-to-host communication”](#universal-container-to-host-communication)

Aspire 13.0 introduces a major architectural change to enable universal container-to-host communication, independent of container orchestrator support.

**What changed:**

* Leverages DCP’s container tunnel capability for container-to-host connectivity.
* `EndpointReference` resolution is now context-aware (uses `NetworkIdentifier`).
* Endpoint references are tracked by their `EndpointAnnotation`.
* `AllocatedEndpoint` constructor signature changed.

**Impact:**

* Enables containers to communicate with host-based services reliably across all deployment scenarios.
* Code that directly constructs `AllocatedEndpoint` objects will need updates.
* Extension methods that process endpoint references may need Network Identifier context.

**Migration:**

The universal container-to-host communication is currently an experimental feature and needs to be enabled via environment variable. Set `ASPIRE_ENABLE_CONTAINER_TUNNEL` to `true` to opt in.

This change fixes long-standing issues with container-to-host communication (issue #6547).

#### Refactored AddNodeApp API

[Section titled “Refactored AddNodeApp API”](#refactored-addnodeapp-api)

The `AddNodeApp` API has been refactored with breaking changes to how Node.js applications are configured.

**Signature changes:**

```csharp
// Before (9.x) - absolute scriptPath with optional workingDirectory
builder.AddNodeApp(
    name: "frontend",
    scriptPath: "/absolute/path/to/app.js",
    workingDirectory: "/absolute/path/to",
    args: ["--port", "3000"]);


// After (13.0) - appDirectory with relative scriptPath
builder.AddNodeApp(
    name: "frontend",
    appDirectory: "../frontend",
    scriptPath: "app.js");
```

**Behavioral changes:**

1. **Automatic npm integration**: If `package.json` exists in `appDirectory`, npm is automatically configured with auto-install enabled
2. **Automatic Dockerfile generation**: Includes Docker publishing support with multi-stage builds by default
3. **Package manager flexibility**: Use `WithNpm()`, `WithYarn()`, or `WithPnpm()` with `WithRunScript()` to execute package.json scripts

**Migration:**

```csharp
// Before (9.x)
var app = builder.AddNodeApp("frontend", "../frontend/server.js", "../frontend");


// After (13.0)
var app = builder.AddNodeApp("frontend", "../frontend", "server.js");


// Or use package.json script
var app = builder.AddNodeApp("frontend", "../frontend", "server.js")
    .WithNpm()
    .WithRunScript("dev");
```

### Migration guide

[Section titled “Migration guide”](#migration-guide)

#### Migrating from publishing callbacks to pipeline steps

[Section titled “Migrating from publishing callbacks to pipeline steps”](#migrating-from-publishing-callbacks-to-pipeline-steps)

**Before (9.x)**:

```csharp
var api = builder.AddProject<Projects.Api>("api")
    .WithPublishingCallback(async (context, cancellationToken) =>
    {
        await CustomDeployAsync(context, cancellationToken);
    });
```

**After (13.0)**:

```csharp
var api = builder.AddProject<Projects.Api>("api")
    .WithPipelineStepFactory(context =>
    {
        return new PipelineStep()
        {
            Name = "CustomDeployStep",
            Action = CustomDeployAsync,
            RequiredBySteps = [WellKnownPipelineSteps.Publish]
        };
    });
```

For more details, see [Deployment pipeline documentation](/get-started/pipelines/).

#### Migrating from lifecycle hooks to events

[Section titled “Migrating from lifecycle hooks to events”](#migrating-from-lifecycle-hooks-to-events)

**Before (9.x)**:

```csharp
public class MyLifecycleHook : IDistributedApplicationLifecycleHook
{
    public async Task BeforeStartAsync(
        DistributedApplicationModel model,
        CancellationToken cancellationToken)
    {
        // Logic before start
    }
}


builder.Services.TryAddLifecycleHook<MyLifecycleHook>();
```

**After (13.0)**:

```csharp
public class MyEventSubscriber : IDistributedApplicationEventingSubscriber
{
    public Task SubscribeAsync(
        IDistributedApplicationEventing eventing,
        DistributedApplicationExecutionContext executionContext,
        CancellationToken cancellationToken)
    {
        eventing.Subscribe<BeforeStartEvent>((@event, ct) =>
        {
            // Access model and services via event
            var model = @event.Model;
            var services = @event.Services;


            // Logic before start


            return Task.CompletedTask;
        });


        return Task.CompletedTask;
    }
}


builder.Services.TryAddEventingSubscriber<MyEventSubscriber>();
```

### Experimental features

[Section titled “Experimental features”](#experimental-features)

The following features are marked as `[Experimental]` and may change in future releases:

* **Dockerfile builder API**: `WithDockerfileBuilder`, `AddDockerfileBuilder`, `WithDockerfileBaseImage`.
* **C# file-based app support**: `AddCSharpApp`.
* **Dynamic inputs**: `InputLoadOptions`, dynamic input loading.
* **Pipeline features**: `IDistributedApplicationPipeline` and related APIs.

To use experimental features, you must enable them explicitly and acknowledge they may change:

```csharp
#pragma warning disable ASPIREXXX // Experimental feature
var app = builder.AddCSharpApp("myapp", "./app.cs");
#pragma warning restore ASPIREXXX
```

***

**Feedback and contributions**: We’d love to hear about your experience with Aspire 13.0! Share feedback on [GitHub](https://github.com/dotnet/aspire/issues) or join the conversation on [Discord](https://aka.ms/aspire-discord).

# What's new in Aspire 13.1

> Aspire 13.1 delivers comprehensive MCP support for AI coding agents, CLI enhancements with channel persistence, dashboard improvements, Azure Managed Redis, container registry support, and numerous bug fixes.

Aspire 13.1 builds on the polyglot foundation established in Aspire 13, delivering significant improvements to the CLI experience, enhanced MCP (Model Context Protocol) support for AI coding agents, dashboard refinements, and streamlined Azure deployments. This release focuses on developer productivity and seamless integration with modern AI-assisted development workflows.

This release introduces:

* **MCP for AI Coding Agents**: New `aspire mcp init` command and MCP tools for AI assistants to discover integrations and interact with your Aspire applications.
* **CLI enhancements**: Channel persistence, automatic instance detection, and installation path options.
* **Dashboard improvements**: Dedicated Parameters tab and GenAI visualizer enhancements.
* **Azure Managed Redis**: Renamed from `AddAzureRedisEnterprise` to `AddAzureManagedRedis` with improved validation.
* **Container registry support**: New `ContainerRegistryResource` for general-purpose container registries.
* **JavaScript improvements**: New frontend starter template, Vite HTTPS configuration, and pnpm fixes.
* **DevTunnels stabilization**: [📦 Aspire.Hosting.DevTunnels](https://www.nuget.org/packages/Aspire.Hosting.DevTunnels) is now a stable package.
* **TLS termination support**: New APIs for configuring HTTPS certificates on containers and resources.
* **Connection properties for Azure resources**: Polyglot support for Azure resource connection strings.

**Requirements:**

* [.NET 10 SDK or later](https://dotnet.microsoft.com/download/dotnet/10.0)

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [ GitHub](https://github.com/dotnet/aspire) or join us on our [ Discord](https://aka.ms/aspire-discord) to chat with the team and other community members.

## 🆙 Upgrade to Aspire 13.1

[Section titled “🆙 Upgrade to Aspire 13.1”](#-upgrade-to-aspire-131)

Caution

Aspire 13.1 includes breaking changes to Azure Redis APIs. Please review the [Breaking changes](#%EF%B8%8F-breaking-changes) section before upgrading.

Note

If you are on a version of the Aspire CLI less than 13, please use the [installation instructions](/get-started/install-cli/) to install the latest stable version.

The easiest way to upgrade to Aspire 13.1 is using the `aspire update` command:

1. Update your Aspire project using the [`aspire update` command](/reference/cli/commands/aspire-update/):

   Aspire CLI — Update all Aspire packages

   ```bash
   aspire update
   ```

2. Update the Aspire CLI itself:

   Aspire CLI — Update the CLI

   ```bash
   aspire update --self
   ```

Note

When you run `aspire update --self` and select a channel, your selection is now saved globally. Future `aspire new` and `aspire init` commands will use this channel by default.

## 🤖 MCP for AI Coding Agents

[Section titled “🤖 MCP for AI Coding Agents”](#-mcp-for-ai-coding-agents)

Aspire 13.1 introduces comprehensive support for AI coding agents through MCP (Model Context Protocol) integration. Configure your favorite AI coding tools to understand and interact with your Aspire applications.

### Initialize MCP for your project

[Section titled “Initialize MCP for your project”](#initialize-mcp-for-your-project)

The new `aspire mcp init` command detects your development environment and configures MCP servers for supported AI coding agents:

Bash — Initialize MCP configuration

```bash
aspire mcp init
```

Command reference: [`aspire mcp init`](/reference/cli/commands/aspire-mcp-init/).

The command presents a streamlined two-step selection process:

```plaintext
Which agent environments do you want to configure?
[ ] Configure VS Code to use the Aspire MCP server
[ ] Configure GitHub Copilot CLI to use Aspire MCP server
[ ] Configure Claude Code to use Aspire MCP server
[ ] Configure Open Code to use Aspire MCP server


Which additional options do you want to enable?
[ ] Create an agent instructions file (AGENTS.md)
[ ] Configure Playwright MCP server
```

### MCP tools for AI agents

[Section titled “MCP tools for AI agents”](#mcp-tools-for-ai-agents)

AI coding agents connected via MCP can now discover and use Aspire integrations directly:

* **`list_integrations`** — Returns available Aspire hosting integrations (Redis, PostgreSQL, Azure services, etc.).
* **`get_integration_docs`** — Retrieves detailed documentation for a specific integration package.
* **`list_apphosts`** — Lists all detected AppHost projects in the workspace.
* **`select_apphost`** — Switches context to a specific AppHost when multiple exist.

### Dashboard MCP integration

[Section titled “Dashboard MCP integration”](#dashboard-mcp-integration)

When connected to an AppHost, the dashboard exposes MCP endpoints, enabling AI agents to query resource state, view logs, and inspect traces directly from your running application.

Learn more about the [MCP server integration](/dashboard/mcp-server/).

## 🛠️ CLI enhancements

[Section titled “🛠️ CLI enhancements”](#️-cli-enhancements)

### Channel selection and persistence

[Section titled “Channel selection and persistence”](#channel-selection-and-persistence)

The `--channel` option is now available on `aspire new` and `aspire init` commands, letting you explicitly choose which Aspire version channel to use:

Bash — Channel selection

```bash
aspire new aspire-starter --channel preview
aspire init --channel stable
```

Command reference: [`aspire init`](/reference/cli/commands/aspire-init/#options).

When you update the CLI with `aspire update --self`, your channel selection is persisted to `~/.aspire/globalsettings.json` and becomes the default for future project creation.

### Automatic instance detection

[Section titled “Automatic instance detection”](#automatic-instance-detection)

Running `aspire run` when an instance is already running? Aspire 13.1 automatically detects running instances and terminates them.

### Installation path option

[Section titled “Installation path option”](#installation-path-option)

The installation scripts now support `--skip-path` to install the CLI without modifying your PATH:

* Bash

  ```bash
  curl -fsSL https://aspire.dev/install.sh | bash -s -- --skip-path
  ```

* PowerShell

  ```powershell
  iex "& { $(irm https://aspire.dev/install.ps1) } -SkipPath"
  ```

Learn more about [the Aspire CLI installation options](/reference/cli/install-script/#options).

## 📊 Dashboard improvements

[Section titled “📊 Dashboard improvements”](#-dashboard-improvements)

### Dedicated Parameters tab

[Section titled “Dedicated Parameters tab”](#dedicated-parameters-tab)

The Resources page now includes a dedicated **Parameters** tab, making it easier to view and manage configuration parameters for your resources without navigating away from the resource details.

![Resources parameters view](/_astro/resources-parameters-view.Dzwjb7Yx_Zn4qx7.webp "Resources parameters view")

### GenAI visualizer enhancements

[Section titled “GenAI visualizer enhancements”](#genai-visualizer-enhancements)

The GenAI visualizer received several improvements:

* **Tool definitions & evaluations** — Tool definitions and evaluations associated with GenAI spans are displayed in the visualizer.
* **Video and audio preview** — Video and audio content can be previewed in the GenAI visualizer.
* **Linked log entries** — Log entries associated with GenAI spans now include a direct link to the GenAI visualizer.
* **Improved content parsing** — Better handling of various AI model response formats.

![GenAI visualizer tool definitions](/_astro/genai-visualizer-tooldefinitions.S98dZUC3_Z1dMkKL.webp "GenAI visualizer tool definitions")

### Bug fixes

[Section titled “Bug fixes”](#bug-fixes)

* Fixed `OverflowException` in the Traces page when trace duration exceeds `int.MaxValue`.
* Fixed combobox filter behavior when no items match the search criteria.
* Fixed view options menu visibility when hidden resources exist.

## ☁️ Azure improvements

[Section titled “☁️ Azure improvements”](#️-azure-improvements)

### Azure Managed Redis

[Section titled “Azure Managed Redis”](#azure-managed-redis)

Caution

**Breaking Change**: The `AddAzureRedisEnterprise` method has been renamed to `AddAzureManagedRedis` to better reflect the Azure service naming.

C# — Azure Managed Redis (before)

```csharp
// Before (Aspire 13.0)
var redis = builder.AddAzureRedisEnterprise("cache");
```

C# — Azure Managed Redis (after)

```csharp
// After (Aspire 13.1)
var redis = builder.AddAzureManagedRedis("cache");
```

Note

`AddAzureRedis` is now obsolete. Migrate to `AddAzureManagedRedis` for new projects.

### Connection properties for Azure resources

[Section titled “Connection properties for Azure resources”](#connection-properties-for-azure-resources)

Azure resources now expose connection properties in a standardized format that works across all supported languages. This enables polyglot applications using Java, JavaScript, and Python SDKs to connect to Azure resources using consistent configuration patterns.

Resources now expose additional properties such as `HostName`, `Port`, and `JdbcConnectionString` where applicable, making it easier to configure clients in languages that don’t use .NET connection string formats.

### Azure App Service deployment slots

[Section titled “Azure App Service deployment slots”](#azure-app-service-deployment-slots)

New `WithDeploymentSlot` extension method to configure deployment slots for Azure App Service:

C# — Configure deployment slot

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureAppServiceEnvironment("appservice")
    .WithDeploymentSlot("staging");
```

### Clear default role assignments

[Section titled “Clear default role assignments”](#clear-default-role-assignments)

New `ClearDefaultRoleAssignments` extension method to disable automatic role assignments on Azure resources when you need fine-grained control over permissions.

### Bug fixes

[Section titled “Bug fixes”](#bug-fixes-1)

* Azure deployments now validate that required compute environments exist before attempting deployment, providing earlier and clearer error messages when infrastructure is missing.
* Fixed an issue with Azure authentication when working across multiple tenants.

## 🐳 Container and Docker Compose

[Section titled “🐳 Container and Docker Compose”](#-container-and-docker-compose)

### Container registry resource

[Section titled “Container registry resource”](#container-registry-resource)

Caution

This API is experimental and may change in future releases. Use diagnostic code `ASPIRECOMPUTE003` to suppress the experimental warning. For more information, see [ASPIRECOMPUTE003](/diagnostics/aspirecompute003/).

A new `ContainerRegistryResource` enables integration with general-purpose container registries beyond Azure Container Registry:

C# — Container registry resource

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var registry = builder.AddContainerRegistry("myregistry", "registry.example.com");


var api = builder.AddProject<Projects.Api>("api")
    .WithContainerRegistry(registry);
```

The deployment pipeline now includes a `push` step for container registry operations.

```plaintext
$ aspire do push
16:03:38 (pipeline-execution) → Starting pipeline-execution...
16:03:38 (push-prereq) → Starting push-prereq...
16:03:38 (process-parameters) → Starting process-parameters...
16:03:38 (push-prereq) ✓ push-prereq completed successfully
16:03:38 (process-parameters) i [INF] 3 parameter values saved to deployment state.
16:03:38 (process-parameters) ✓ process-parameters completed successfully
16:03:38 (build-prereq) → Starting build-prereq...
16:03:38 (build-prereq) ✓ build-prereq completed successfully
16:03:38 (build-go-app) → Starting build-go-app...
16:03:38 (build-pythonapp-standalone) → Starting build-pythonapp-standalone...
16:03:38 (build-api) → Starting build-api...
16:03:38 (build-viteapp) → Starting build-viteapp...
...
16:03:43 (push-api) → Starting push-api...
16:03:43 (push-api) → Pushing api to container-registry
16:03:44 (push-api) i [INF] Docker tag for api -> docker.io/captainsafia/api:latest succeeded.
16:03:44 (push-pythonapp) i [INF] Docker tag for pythonapp:d5325602e04758397792c8332c5882846516b35c -> docker.io/captainsafia/pythonapp:latest succeeded.
16:03:48 (push-go-app) i [INF] Docker push for docker.io/captainsafia/go-app:latest succeeded.
16:03:48 (push-go-app) ✓ Successfully pushed go-app to docker.io/captainsafia/go-app:latest (5.1s)
16:03:48 (push-go-app) ✓ push-go-app completed successfully
16:03:48 (push-pythonapp-standalone) i [INF] Docker push for docker.io/captainsafia/pythonapp-standalone:latest succeeded.
16:03:48 (push-pythonapp-standalone) ✓ Successfully pushed pythonapp-standalone to docker.io/captainsafia/pythonapp-standalone:latest (5.4s)
16:03:48 (push-pythonapp-standalone) ✓ push-pythonapp-standalone completed successfully
16:03:49 (push-pythonapp) i [INF] Docker push for docker.io/captainsafia/pythonapp:latest succeeded.
16:03:49 (push-pythonapp) ✓ Successfully pushed pythonapp to docker.io/captainsafia/pythonapp:latest (5.7s)
16:03:49 (push-pythonapp) ✓ push-pythonapp completed successfully
16:04:05 (push-api) i [INF] Docker push for docker.io/captainsafia/api:latest succeeded.
16:04:05 (push-api) ✓ Successfully pushed api to docker.io/captainsafia/api:latest (21.3s)
16:04:05 (push-api) ✓ push-api completed successfully
16:04:05 (push) → Starting push...
16:04:05 (push) ✓ push completed successfully
16:04:05 (pipeline-execution) ✓ Completed successfully
------------------------------------------------------------
✓ 14/14 steps succeeded • Total time: 26.41s
```

### Explicit container registry support for Azure deployments

[Section titled “Explicit container registry support for Azure deployments”](#explicit-container-registry-support-for-azure-deployments)

Prior to Aspire 13.1, when deploying to Azure Container Apps using `AddAzureContainerAppEnvironment`, the Azure Container Registry (ACR) was provisioned implicitly as part of the environment. This automatic provisioning could cause deployment delays and made it difficult for developers to discover which registry was being used.

Aspire 13.1 addresses this by moving toward explicit container registry configuration, giving developers more control and visibility into where and when images are pushed. With the configuration below, the ACR associated with the “myenv” environment will be provisioned in parallel with the environment and image pushes will begin as soon as the registry has been successfully provisioned.

C# — Explicit Azure Container Registry

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var acr = builder.AddAzureContainerAppEnvironment("myenv");


var api = builder.AddProject<Projects.Api>("api")
    .WithContainerRegistry(acr);
```

For a deeper dive into container registry improvements and their impact on Azure deployments, check out [Safia Abdalla’s blog post on fixing Aspire’s image problem](https://blog.safia.rocks/2025/12/15/aspire-image-push/).

### Docker Compose improvements

[Section titled “Docker Compose improvements”](#docker-compose-improvements)

* Bind mount sources are now replaced with environment placeholders for portability.
* Resource endpoints are displayed after Docker Compose deployment.
* Fixed race condition in Dockerfile materialization during parallel pipeline execution.

For advanced scenarios, use `ConfigureEnvFile` to customize the generated `.env` file:

C# — Customize Docker Compose .env file

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddDockerComposeEnvironment("compose")
    .ConfigureEnvFile(env =>
    {
        env["CUSTOM_VAR"] = new CapturedEnvironmentVariable
        {
            Name = "CUSTOM_VAR",
            DefaultValue = "my-value"
        };
    });
```

Learn more about the [Docker Compose integration](/integrations/compute/docker/).

## 🌐 JavaScript and frontend support

[Section titled “🌐 JavaScript and frontend support”](#-javascript-and-frontend-support)

### JavaScript frontend starter template

[Section titled “JavaScript frontend starter template”](#javascript-frontend-starter-template)

A new `aspire-ts-cs-starter` template provides a ready-to-use JavaScript frontend setup:

Aspire CLI — Starter App ASP.NET Core/React

```bash
aspire new aspire-ts-cs-starter
```

The template includes:

* An ASP.NET Core minimal API backend named `Server`.
* A Vite-backed React client named `frontend`.
* An AppHost project to orchestrate both.

Note

The template uses `npm` by default. You can switch to `yarn` or `pnpm` after project creation.

Learn more about the [JavaScript frontend integration](/integrations/frameworks/javascript/).

### Vite HTTPS configuration

[Section titled “Vite HTTPS configuration”](#vite-https-configuration)

Aspire now supports dynamically augmenting existing Vite configurations to enable HTTPS endpoints at runtime, eliminating manual certificate configuration for development.

### Bug fixes

[Section titled “Bug fixes”](#bug-fixes-2)

* Fixed Dockerfile generation for projects using `pnpm` by properly enabling corepack. If you’re unfamiliar with corepack, see the [corepack documentation](https://nodejs.org/api/corepack.html), and it works [well with `pnpm`](https://pnpm.io/docker).

## 🔒 Certificates and security

[Section titled “🔒 Certificates and security”](#-certificates-and-security)

Configuring and trusting local development certificates is now more straightforward with Aspire 13.1. For more details, see [Certificate configuation](/app-host/certificate-configuration/).

### TLS termination support

[Section titled “TLS termination support”](#tls-termination-support)

Caution

These APIs are experimental and may change in future releases. Use diagnostic code `ASPIRECERTIFICATES001` to suppress the experimental warning. The diagnostic warning is detailed in [ASPIRECERTIFICATES001](/diagnostics/aspirecertificates001/).

New APIs allow configuring HTTPS certificates for resources that need to terminate TLS connections.

The following containers have built-in TLS termination support:

| Container         | Default |
| ----------------- | ------- |
| YARP              | Enabled |
| Redis             | Enabled |
| Keycloak          | Enabled |
| Uvicorn (Python)  | Enabled |
| Vite (JavaScript) | Opt-in  |

When TLS is enabled by default, the ASP.NET Core developer certificate is automatically used if available and trusted.

To explicitly enable the developer certificate on a resource (e.g., for Vite):

C# — Enable developer certificate

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddViteApp("frontend")
    .WithHttpsDeveloperCertificate();
```

To use a custom certificate:

C# — TLS termination with custom certificate

```csharp
var certificate = new X509Certificate2("path/to/certificate.pfx", "password");


builder.AddYarp("gateway")
    .WithHttpsCertificate(certificate);
```

For YARP, you can also explicitly set the HTTPS port:

C# — YARP with custom HTTPS port

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddYarp("gateway")
    .WithHostHttpsPort(8443);
```

To disable HTTPS certificate configuration for a resource:

C# — Disable HTTPS certificate

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddRedis("cache")
    .WithoutHttpsCertificate();
```

To configure TLS termination for a resource without built-in support, you can use a configuration callback to pass custom arguments and environment variables:

C# — TLS termination with configuration callback

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddContainer("my-service", "my-image")
    .WithHttpsCertificateConfiguration(ctx =>
    {
        // Pass the path to the cert in PFX format as an argument
        ctx.Arguments.Add("--https-certificate-path");
        ctx.Arguments.Add(ctx.PfxPath);


        // Set the public and private PEM format certificate paths as environment variables
        ctx.EnvironmentVariables["HTTPS_CERT"] = ctx.CertificatePath;
        ctx.EnvironmentVariables["HTTPS_CERT_KEY"] = ctx.KeyPath;


        return Task.CompletedTask;
    });
```

Learn more about [Certificate configuration](/app-host/certificate-configuration/).

## 🧩 App model updates

[Section titled “🧩 App model updates”](#-app-model-updates)

### Endpoint reference resolution

[Section titled “Endpoint reference resolution”](#endpoint-reference-resolution)

Endpoint references now properly wait for endpoint allocation when evaluating, fixing race conditions in complex orchestration scenarios.

### Container network context

[Section titled “Container network context”](#container-network-context)

Endpoint references now correctly honor their specific network context when resolving, ensuring proper networking in multi-network container deployments.

### System log formatting

[Section titled “System log formatting”](#system-log-formatting)

System-level logs from DCP now use a human-friendly format with a `[sys]` prefix instead of verbose JSON objects:

```plaintext
[sys] Starting process: Cmd = dotnet, Args = [run]
[sys] Failed to start Container: Error = container start failed (exit code 1)
```

This makes it easier to distinguish system logs from application output and improves readability in the console.

## 📦 Integration updates

[Section titled “📦 Integration updates”](#-integration-updates)

### DevTunnels stabilization

[Section titled “DevTunnels stabilization”](#devtunnels-stabilization)

The [📦 Aspire.Hosting.DevTunnels](https://www.nuget.org/packages/Aspire.Hosting.DevTunnels) package is now stable and no longer in preview. Use dev tunnels to expose your local Aspire applications to the internet for testing webhooks, mobile apps, and external integrations.

Learn more about the [Dev Tunnels integration](/integrations/devtools/dev-tunnels/).

### Endpoint proxy support stabilization

[Section titled “Endpoint proxy support stabilization”](#endpoint-proxy-support-stabilization)

The `WithEndpointProxySupport` API is now stable and no longer requires the experimental attribute.

### Keycloak improvements

[Section titled “Keycloak improvements”](#keycloak-improvements)

Keycloak containers can now export telemetry to your OTLP collector:

C# — Keycloak with OTLP export

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddKeycloak("keycloak")
    .WithOtlpExporter();
```

Learn more about the [Keycloak integration](/integrations/security/keycloak/).

### OpenTelemetry updates

[Section titled “OpenTelemetry updates”](#opentelemetry-updates)

OpenTelemetry dependencies have been updated to the latest stable versions across the codebase.

### Azure Functions

[Section titled “Azure Functions”](#azure-functions)

In Aspire 13.1, the Azure Functions integration is officially out of preview. Azure Functions now support a local development story with Aspire and deployments to ACA Native Functions with support for KEDA-based auto-scaling rules.

* Aspire dashboard will notify if the Azure Functions Core Tools are not installed on the local machine.
* New overload `AddAzureFunctionsProject(name, projectPath)` for adding Functions projects without a generic type parameter:

C# — Azure Functions without generic type

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureFunctionsProject("myfunc", "../MyFunctions/MyFunctions.csproj");
```

Learn more about the [Azure Functions integration](/integrations/cloud/azure/azure-functions/) or [how to use Azure Functions with Aspire](https://learn.microsoft.com/azure/azure-functions/dotnet-aspire-integration).

## 🏗️ Templates

[Section titled “🏗️ Templates”](#️-templates)

All Aspire templates have been updated for 13.1 with consistent patterns:

* Dropped support for previous Aspire versions.
* Unified project structure across starter templates.

Note

Template changes may require updating existing projects created from older templates.

## 🐛 Bug fixes

[Section titled “🐛 Bug fixes”](#-bug-fixes)

* Fixed `aspire mcp init` hanging in VS Code terminal on Windows.
* Fixed path normalization for AppHost paths on Windows.
* Fixed CLI tool detection on Windows with proper PATHEXT handling.
* Fixed saving parameters with custom config keys.
* Fixed container image builds for resources with dashes in names.
* Fixed relative endpoint URL handling.
* Fixed deployment state file case sensitivity on Linux.

## 🙏 Community contributions

[Section titled “🙏 Community contributions”](#-community-contributions)

Thank you to all community contributors who helped make Aspire 13.1 possible:

* Improved resource graph layout with adaptive force-directed positioning.
* Updated npm dependencies across playground apps.
* Documentation link updates.
* Various bug fixes and improvements.

We’re always excited to [see community contributions](/community/contributors/)! If you’d like to get involved, check out our [contributing guide](/community/contributor-guide/).

## ⚠️ Breaking changes

[Section titled “⚠️ Breaking changes”](#️-breaking-changes)

### Azure Redis API rename

[Section titled “Azure Redis API rename”](#azure-redis-api-rename)

| Change                            | Migration                                          |
| --------------------------------- | -------------------------------------------------- |
| `AddAzureRedisEnterprise` renamed | Use `AddAzureManagedRedis`                         |
| `AddAzureRedis` obsolete          | Migrate to `AddAzureManagedRedis` for new projects |

### Migration from Aspire 13.0 to 13.1

[Section titled “Migration from Aspire 13.0 to 13.1”](#migration-from-aspire-130-to-131)

1. **Update the CLI**: Run `aspire update --self`.
2. **Update your projects**: Run `aspire update` in your project directory.
3. **Rename Azure Redis**: Replace `AddAzureRedisEnterprise` with `AddAzureManagedRedis`.
4. **Review MCP configuration**: Run `aspire mcp init` to set up AI coding agent support.

### Connection Properties rename

[Section titled “Connection Properties rename”](#connection-properties-rename)

Some connection properties have been renamed for consistency across resources:

| Resource                  | Old property | New property   |
| ------------------------- | ------------ | -------------- |
| GitHub Models resource    | `Model`      | `ModelName`    |
| OpenAI model resource     | `Model`      | `ModelName`    |
| Milvus database resource  | `Database`   | `DatabaseName` |
| MongoDB database resource | `Database`   | `DatabaseName` |
| MySQL database resource   | `Database`   | `DatabaseName` |
| Oracle database resource  | `Database`   | `DatabaseName` |

***

If your client apps where using some of these properties, please update them to use the new names. For instance for a GitHub Models resource named `chat` the model name environment variable would change from `CHAT_MODEL` to `CHAT_MODELNAME`.

**Feedback and contributions**: We’d love to hear about your experience with Aspire 13.1! Share feedback on [GitHub](https://github.com/dotnet/aspire/issues) or join the conversation on [Discord](https://aka.ms/aspire-discord).

# Aspire 9.0

> Learn what's new in Aspire 9.0.

📢 Aspire 9.0 is the next major general availability (GA) release of Aspire; it supports *both*:

* .NET 8.0 Long Term Support (LTS) *or*
* .NET 9.0 Standard Term Support (STS).

Note

You’re able to use Aspire 9.0 with either .NET 8 or .NET 9!

This release addresses some of the most highly requested features and pain points from the community. The best features are community-driven! To join the community on, visit us on [Discord](https://discord.com/invite/h87kDAHQgJ) to chat with team members and collaborate with us on [GitHub](https://github.com/dotnet/aspire).

For more information on the official .NET version and Aspire version support, see:

* [.NET support policy](https://dotnet.microsoft.com/platform/support/policy): Definitions for LTS and STS.
* [Aspire support policy](https://dotnet.microsoft.com/platform/support/policy/aspire): Important unique product life cycle details.

## Upgrade to Aspire 9

[Section titled “Upgrade to Aspire 9”](#upgrade-to-aspire-9)

To upgrade from earlier versions of Aspire to Aspire 9, follow the instructions in the official upgrade guide. The guide provides detailed instructions on how to upgrade your existing Aspire solutions to Aspire 9. Regardless of you’re doing it manually, or using the Upgrade Assistant, the guide makes short work of the process.

### Tooling improvements

[Section titled “Tooling improvements”](#tooling-improvements)

Aspire 9 makes it simpler to configure your environment to develop Aspire applications. You no longer need a .NET workload. Instead, you install the new [Aspire SDK](/get-started/aspire-sdk/) into the AppHost project of your Aspire solutions. For more information, see [Aspire setup and tooling](/get-started/prerequisites/).

### Templates have moved

[Section titled “Templates have moved”](#templates-have-moved)

Aspire 9 is moving the contents that used to be installed via the workload into separate NuGet packages. This includes the templates for creating new Aspire projects and solutions. These templates are installed using the `dotnet new install` command. These can be installed by running the following command:

```bash
dotnet new install Aspire.ProjectTemplates::9.0.0
```

For more information, see [Aspire templates](/get-started/aspire-sdk-templates/).

## Dashboard UX enhancements and new interactivity features

[Section titled “Dashboard UX enhancements and new interactivity features”](#dashboard-ux-enhancements-and-new-interactivity-features)

The [Aspire dashboard](/dashboard/overview/) continues to improve with each release.

### Manage resource lifecycle

[Section titled “Manage resource lifecycle”](#manage-resource-lifecycle)

The most requested feature for the dashboard is to manage the lifecycles of your orchestrated named resources. Specifically, the ability to stop, start, and restart resources. This feature works for projects, containers, and executables. It enables restarting individual resources without having to restart the entire AppHost. For project resources, when the debugger is attached, it’s reattached on restart. For more information, see [Aspire dashboard: Stop or Start a resource](/dashboard/explore/#stop-or-start-a-resource).

### Mobile and responsive support

[Section titled “Mobile and responsive support”](#mobile-and-responsive-support)

The Aspire dashboard is now mobile-friendly, responsively adapting to a wide range of screen sizes and enabling on-the-go management of deployed Aspire applications. Other accessibility improvements were made, including the display of settings and content overflow on mobile.

### Sensitive properties, volumes, and health checks in resource details

[Section titled “Sensitive properties, volumes, and health checks in resource details”](#sensitive-properties-volumes-and-health-checks-in-resource-details)

The display of resource details contains several improvements:

* Properties can be marked as sensitive, automatically masking them in the dashboard UI. This security feature helps to avoid accidentally disclosing keys or passwords when screen sharing the dashboard with other people. For example, container arguments could pass sensitive information and so are masked by default.
* Configured container volumes are listed in resource details.
* Aspire 9 adds support for health checks. Detailed information about these checks can now be viewed in the resource details pane, showing why a resource might be marked as unhealthy or degraded. For more information, see [Resource health check](#resource-health-checks).

### Colorful console log

[Section titled “Colorful console log”](#colorful-console-log)

[ANSI escape codes](https://wikipedia.org/wiki/ANSI_escape_code) format text in terminals by controlling colors (foreground and background) and styles like bold, underline, and italics. Previously, the dashboard’s console logs page could only render one ANSI escape code at a time, failing when multiple codes were combined. For example, it could display red text, but not text that was both red and bold.

A community contribution from [@mangeg](https://github.com/mangeg) improved support for ANSI escape codes and removed this limitation.

![Colorful console logs](/_astro/console-logs-ansi-text-format.BSrCIQeX_1BpnDj.webp)

Another improvement to console logs is hiding unsupported escape codes. Codes that aren’t related to displaying text, such as positioning the cursor or communicating with the operating system don’t make sense in this UI, and are hidden.

## Telemetry user-centric additions

[Section titled “Telemetry user-centric additions”](#telemetry-user-centric-additions)

[Telemetry](/fundamentals/telemetry/) remains a vital aspect of Aspire. In Aspire 9, many new features were introduced to the Telemetry service.

### Improved telemetry filtering

[Section titled “Improved telemetry filtering”](#improved-telemetry-filtering)

Traces can be filtered with attribute values. For example, if you only want to view traces for one endpoint in your app, the `http.route` attribute on HTTP requests can be filtered to a specified value.

Telemetry filtering also supports autocomplete of existing values. The **Add filter** dialog provides a combo box for selecting from values that dashboard has available. This feature makes it much easier to filter to real data and helps avoid typos by entered a value yourself.

For more information, see [Aspire dashboard: Filter traces](/dashboard/explore/#filter-traces).

### Combine telemetry from multiple resources

[Section titled “Combine telemetry from multiple resources”](#combine-telemetry-from-multiple-resources)

When a resource has multiple replicas, you can now filter telemetry to view data from all instances at once. Select the parent resource, labeled `(application)`. For more information, see [Aspire dashboard: Combine telemetry from multiple resources](/dashboard/explore/#combine-telemetry-from-multiple-resources).

### Browser telemetry support

[Section titled “Browser telemetry support”](#browser-telemetry-support)

The dashboard supports OpenTelemetry Protocol (OTLP) over HTTP and cross-origin resource sharing (CORS). These features unlock the ability to send OpenTelemetry from browser apps to the Aspire dashboard.

For example, a browser-based single page app (SPA) can configure the [JavaScript OpenTelemetry SDK](https://opentelemetry.io/docs/languages/js/getting-started/browser/) to send structured logs, traces, and metrics created in the browser to the dashboard. Browser telemetry is displayed alongside server telemetry.

![Trace detail page with browser telemetry](/_astro/dashboard-browser-telemetry.De66OII2_Z2i2eUb.webp)

For more information on configuring browser telemetry, see [Enable browser telemetry](/dashboard/enable-browser-telemetry/) documentation.

## AppHost (Orchestration)

[Section titled “AppHost (Orchestration)”](#apphost-orchestration)

The [Aspire AppHost](/get-started/app-host/) is one of the **most important** features of Aspire. In Aspire 9, several new features were added specific to the AppHost.

### Waiting for dependencies

[Section titled “Waiting for dependencies”](#waiting-for-dependencies)

If you’ve been following along with Aspire, you already know that your AppHost project is where you define your app model. You create a distributed application builder, add and configure resources, and express their dependencies. Now, you can specify that a resource should *wait* for another resource before starting. This can help avoid connection errors during startup by only starting resources when their dependencies are “ready.”

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var rabbit = builder.AddRabbitMQ("rabbit");


builder.AddProject<Projects.WebApplication1>("api")
       .WithReference(rabbit)
       .WaitFor(rabbit); // Don't start "api" until "rabbit" is ready...


builder.Build().Run();
```

When the AppHost starts, it waits for the `rabbit` resource to be ready before starting the `api` resource.

There are two methods exposed to wait for a resource:

* `WaitFor`: Wait for a resource to be ready before starting another resource.
* `WaitForCompletion`: Wait for a resource to complete before starting another resource.

For more information, see [Aspire AppHost: Waiting for resources](/get-started/app-host/#adding-an-api-resource-and-declaring-a-dependency).

#### Resource health checks

[Section titled “Resource health checks”](#resource-health-checks)

The `WaitFor` API uses standard [.NET health checks](/fundamentals/health-checks/) to determine if a resource is ready. But what does “a resource being ready” mean? The best part is, that’s configurable by the consumer beyond their default values.

When a resource doesn’t expose any health checks (no health checks registered in the app), the AppHost waits for the resource to be in the running state before starting the dependent resource.

For resources that expose HTTP endpoints, you can easily add a health check that polls a specific path for an HTTP 200 response.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogApi = builder.AddContainer("catalog-api", "catalog-api")
                        .WithHttpEndpoint(targetPort: 8080)
                        .WithHttpHealthCheck("/health");


builder.AddProject<Projects.WebApplication1>("store")
       .WithReference(catalogApi.GetEndpoint("http"))
       .WaitFor(catalogApi);


builder.Build().Run();
```

The preceding example adds a health check to the `catalog-api` resource. The AppHost waits for the health check to return a healthy status before starting the `store` resource. It determines that the resource is ready when the `/health` endpoint returns an HTTP 200 status code.

While `store` is waiting for `catalog-api` to become healthy, the resources in the dashboard appear as:

![Waiting for an unhealthy resource before starting](/_astro/waiting-for-unhealthy-resource.BfH2GYKf_13RiUp.webp)

The AppHost’s health check mechanism builds upon the `IHealthChecksBuilder` implementation from the health checks namespace.

Health checks report data, which is displayed in the dashboard:

![Health check details in the dashboard's resource details view](/_astro/health-check-details.DyLMHd5c_F605w.webp)

Creating a custom health check is straightforward. Start by defining the health check, then associate its name with any resources it applies to.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var healthyAfter = DateTime.Now.AddSeconds(20);


builder.Services.AddHealthChecks().AddCheck(
    "delay20secs",
    () => DateTime.Now > healthyAfter
        ? HealthCheckResult.Healthy()
        : HealthCheckResult.Unhealthy()
    );


var cache = builder.AddRedis("cache")
                   .WithHealthCheck("delay20secs");


builder.AddProject<Projects.MyApp>("myapp")
       .WithReference(cache)
       .WaitFor(cache);
```

The preceding example adds a health check to the `cache` resource, which reports it as unhealthy for the first 20 seconds after the AppHost starts. So, the `myapp` resource waits for 20 seconds before starting, ensuring the `cache` resource is healthy.

The health check methods provide a simple mechanism to create health checks and associate them with specific resources.

### Persistent containers

[Section titled “Persistent containers”](#persistent-containers)

The AppHost now supports *persistent* containers. Persistent containers deviate from the typical container life cycle of Aspire orchestrated apps. While they’re *created* and *started* (when not already available) by the Aspire orchestrator, they’re not destroyed by Aspire.

This is useful when you want to keep the container running even after the AppHost has stopped.

Caution

To delete these containers, you must manually stop them using the container runtime.

To define an `IResourceBuilder<ContainerResource>` with a persistent lifetime, call the `WithLifetime` method and pass in persistent container lifetime:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var queue = builder.AddRabbitMQ("rabbit")
                   .WithLifetime(ContainerLifetime.Persistent);


builder.AddProject<Projects.WebApplication1>("api")
       .WithReference(queue)
       .WaitFor(queue);


builder.Build().Run();
```

The dashboard shows persistent containers with a pin icon:

![Persistent containers](/_astro/persistent-container.B3qvqKn7_ZNmkFU.webp)

After the AppHost is stopped, the container will continue to run:

![Docker desktop showing RabbitMQ](/_astro/persistent-container-docker-desktop.fBhTDXpR_MFVaN.webp)

The container persistence mechanism attempts to identify when you might wish to recreate the container. For example, if the environment for the container changes, then the container is restarted so that you don’t need to manually stop the container if the input configuration for the resource has changed.

### Resource commands

[Section titled “Resource commands”](#resource-commands)

The AppHost supports adding custom commands to resources. This is useful when you want to add custom functionality that is not natively supported by the AppHost. There’s likely many opportunities where exposing custom extension methods on resources will be useful. The [Aspire Community Toolkit](/integrations/overview/) might be a good place to share these extensions.

When you define a custom command, it’s available in the dashboard as a user experience feature.

Caution

These Aspire dashboard commands are only available when running the dashboard locally. They’re not available when running the dashboard in Azure Container Apps.

For more information on creating custom resource commands, see [How-to: Create custom resource commands in Aspire](/fundamentals/custom-resource-commands/).

### Container networking

[Section titled “Container networking”](#container-networking)

The AppHost now adds all containers to a common network named `default-aspire-network`. This is useful when you want to communicate between containers without going through the host network. This also makes it easier to migrate from docker compose to the AppHost, as containers can communicate with each other using the container name.

### Eventing model

[Section titled “Eventing model”](#eventing-model)

The eventing model allows developers to hook into the lifecycle of the application and resources. This is useful for running custom code at specific points in the application lifecycle. There are various ways to subscribe to events, including global events and per-resource events.

**Global events:**

* `BeforeStartEvent`: An event that is triggered before the application starts. This is the last place that changes to the app model are observed. This runs in both “Run” and “Publish” modes. This is a blocking event, meaning that the application doesn’t start until all handlers have completed.
* `AfterResourcesCreatedEvent`: An event that is triggered after the resources are created. This runs in Run mode only.
* `AfterEndpointsAllocatedEvent`: An event that is triggered after the endpoints are allocated for all resources. This runs in Run mode only.

The global events are analogous to the AppHost life cycle events. For more information, see [AppHost life cycles](/app-host/eventing/#apphost-eventing).

**Per-resource events:**

* `BeforeResourceStartedEvent`: An event that is triggered before a single resource starts. This runs in Run mode only. This is a blocking event, meaning that the resource doesn’t start until all handlers complete.
* `ConnectionStringAvailableEvent`: An event that is triggered when a connection string is available for a resource. This runs in Run mode only.
* `ResourceReadyEvent`: An event that is triggered when a resource is ready to be used. This runs in Run mode only.

For more information, see [Eventing in Aspire](/app-host/eventing/).

## Integrations

[Section titled “Integrations”](#integrations)

Aspire continues to add integrations that make it easy to get started with your favorite services and tools. For more information, see [Aspire integrations overview](/integrations/overview/).

### Redis Insight

[Section titled “Redis Insight”](#redis-insight)

Support for [Redis Insights](https://redis.io/insight/) is available on a Redis resource:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddRedis("redis")
       .WithRedisInsight(); // Starts a Redis Insight container image
                            // that is pre-configured to work with the
                            // Redis instance.
```

The `WithRedisInsight` extension method can be applied to multiple Redis resources and they’ll each be visible on the Redis Insight dashboard.

![Redis Insight dashboard showing multiple Redis instances](/_astro/redis-insight.oU6J_zOG_1lOJ9P.webp)

For more information, see [Add Redis resource with Redis Insights](/integrations/caching/redis/#add-redis-resource-with-redis-insights).

### OpenAI (Preview)

[Section titled “OpenAI (Preview)”](#openai-preview)

Starting with Aspire 9, an additional OpenAI integration is available which allows to use the latest official OpenAI dotnet library directly. The client integration registers the OpenAIClient as a singleton service in the service collection. The client can be used to interact with the OpenAI REST API.

* [📦 Aspire.OpenAI](https://www.nuget.org/packages/Aspire.OpenAI/9.0.0)

Moreover, the already available Aspire Azure OpenAI integration was improved to provide a flexible way to configure an `OpenAIClient` for either an Azure AI OpenAI service or a dedicated OpenAI REST API one with the new builder method. The following example detects if the connection string is for an Azure AI OpenAI service and registers the most appropriate `OpenAIClient` instance automatically.

```csharp
builder.AddOpenAIClientFromConfiguration("openai");
```

For instance, if the `openai` connection looked like `Endpoint=https://{account}.azure.com;Key={key};` it would guess it can register an Azure AI OpenAI client because of the domain name. Otherwise a common `OpenAIClient` would be used.

Read [Azure-agnostic client resolution](https://github.com/dotnet/aspire/blob/release/9.0/src/Components/Aspire.Azure.AI.OpenAI/README.md#azure-agnostic-client-resolution) for more details.

### MongoDB

[Section titled “MongoDB”](#mongodb)

Added support for specifying the MongoDB username and password when using the `AddMongoDB` extension method. If not specified, a random username and password is generated but can be manually specified using parameter resources.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var username = builder.AddParameter("mongousername");
var password = builder.AddParameter("mongopassword", secret: true);


var db = builder.AddMongo("db", username, password);
```

### Important Azure improvements

[Section titled “Important Azure improvements”](#important-azure-improvements)

The following sections describe Azure improvements added in Aspire 9. For a complete listing of all the breaking changes, see Breaking changes in Aspire 9.

#### Azure resource customization

[Section titled “Azure resource customization”](#azure-resource-customization)

In Aspire 8, customizing Azure resources were marked experimental because the underlying `Azure.Provisioning` libraries were new and gathering feedback before they could be marked stable. In Aspire 9 these APIs were updated and removes the experimental attribute.

**Azure Resource naming breaking change**

As part of the update to the provisioning libraries, the default naming scheme for Azure resources was updated with better support for various naming policies. However, this update resulted in a change to how resources are named. The new naming policy might result in the existing Azure resources being abandoned and new Azure resources being created, after updating your Aspire application from 8 to 9. To keep using the same naming policies from Aspire 8, you can add the following code to your AppHost *Program.cs*:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.Services.Configure<AzureProvisioningOptions>(options =>
{
    options.ProvisioningBuildOptions.InfrastructureResolvers.Insert(0, new AspireV8ResourceNamePropertyResolver());
});
```

#### Azure SQL, PostgreSQL, and Redis Update

[Section titled “Azure SQL, PostgreSQL, and Redis Update”](#azure-sql-postgresql-and-redis-update)

Azure SQL, PostgreSQL, and Redis resources are different than other Azure resources because there are local container resources for these technologies. In Aspire 8, in order to create these Azure resources you needed to start with a local container resource and then either “As” or “PublishAs” it to an Azure resource. This design introduced problems and didn’t fit with other APIs.

For example, you might have this code in Aspire 8:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddSqlServer("sql")
                 .PublishAsAzureSqlDatabase();


var pgsql = builder.AddPostgres("pgsql")
                   .PublishAsAzurePostgresFlexibleServer();


var cache = builder.AddRedis("cache")
                   .PublishAsAzureSqlDatabase();
```

In Aspire 9 these APIs were marked as obsolete and a new API pattern implemented:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var sql = builder.AddAzureSqlServer("sql")
                 .RunAsContainer();


var pgsql = builder.AddAzurePostgresFlexibleServer("pgsql")
                   .RunAsContainer();


var cache = builder.AddAzureRedis("cache")
                   .RunAsContainer();
```

##### Microsoft Entra ID by default

[Section titled “Microsoft Entra ID by default”](#microsoft-entra-id-by-default)

In order to make Aspire applications more secure, Azure Database for PostgreSQL and Azure Cache for Redis resources were updated to use Microsoft Entra ID by default. This requires changes to applications that need to connect to these resources. See the following for updating applications to use Microsoft Entra ID to connect to these resources:

* [Azure Database for PostgreSQL](https://devblogs.microsoft.com/dotnet/using-postgre-sql-with-dotnet-and-entra-id/)
* [Azure Cache for Redis](https://github.com/Azure/Microsoft.Azure.StackExchangeRedis)

The following examples demonstrate how to configure your application to connect to the Azure resources using Microsoft Entra ID:

* [Aspire: Azure PostgreSQL hosting integration](/integrations/cloud/azure/azure-postgresql/azure-postgresql-get-started/).
* [Aspire: Azure Redis hosting integration](/integrations/cloud/azure/azure-cache-redis/#hosting-integration).

If you need to use password or access key authentication (not recommended), you can opt-in with the following code:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var pgsql = builder.AddAzurePostgresFlexibleServer("pgsql")
                   .WithPasswordAuthentication();


var cache = builder.AddAzureRedis("cache")
                   .WithAccessKeyAuthentication();
```

#### Support for Azure Functions (Preview)

[Section titled “Support for Azure Functions (Preview)”](#support-for-azure-functions-preview)

Support for Azure Functions is one of the most widely requested features on the Aspire issue tracker and we’re excited to introduce preview support for it in this release. To demonstrate this support, let’s use Aspire to create and deploy a webhook.

To get started, create a new Azure Functions project using the **Visual Studio New Project** dialog. When prompted, select the **Enlist in Aspire orchestration** checkbox when creating the project.

![Create new Aspire Azure Functions project](/_astro/functions-step-1.CA_WB3AE_Zk8Wkn.webp)

In the AppHost project, observe that there’s a `PackageReference` to the new [📦 Aspire.Hosting.Azure.Functions](https://www.nuget.org/packages/Aspire.Hosting.Azure.Functions) NuGet package:

```xml
<ItemGroup>
    <PackageReference Include="Aspire.Hosting.AppHost" Version="9.0.0" />
    <PackageReference Include="Aspire.Hosting.Azure.Functions" Version="9.0.0" />
</ItemGroup>
```

This package provides an `AddAzureFunctionsProject` API that can be invoked in the AppHost to configure Azure Functions projects within an Aspire host:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureFunctionsProject<Projects.PigLatinApp>("piglatinapp");


builder.Build().Run();
```

In this example, the webhook is responsible for translating an input string into Pig Latin. Update the contents of our trigger with the following code:

```csharp
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
using System.Text;
using FromBodyAttribute = Microsoft.Azure.Functions.Worker.Http.FromBodyAttribute;


namespace PigLatinApp;


public class Function1(ILogger<Function1> logger)
{
    public record InputText(string Value);
    public record PigLatinText(string Value);


    [Function("Function1")]
    public IActionResult Run(
        [HttpTrigger(AuthorizationLevel.Anonymous, "post")] HttpRequest req,
        [FromBody] InputText inputText)
    {
        logger.LogInformation("C# HTTP trigger function processed a request.");


        var result = TranslateToPigLatin(inputText.Value);


        return new OkObjectResult(new PigLatinText(result));
    }


    private static string TranslateToPigLatin(string input)
    {
        if (string.IsNullOrEmpty(input))
        {
            return input;
        }


        var words = input.Split(' ');
        StringBuilder pigLatin = new();


        foreach (string word in words)
        {
            if (IsVowel(word[0]))
            {
                pigLatin.Append(word + "yay ");
            }
            else
            {
                int vowelIndex = FindFirstVowelIndex(word);
                if (vowelIndex is -1)
                {
                    pigLatin.Append(word + "ay ");
                }
                else
                {
                    pigLatin.Append(
                        word.Substring(vowelIndex) + word.Substring(0, vowelIndex) + "ay ");
                }
            }
        }


        return pigLatin.ToString().Trim();
    }


    private static int FindFirstVowelIndex(string word)
    {
        for (var i = 0; i < word.Length; i++)
        {
            if (IsVowel(word[i]))
            {
                return i;
            }
        }
        return -1;
    }


    private static bool IsVowel(char c) =>
        char.ToLower(c) is 'a' or 'e' or 'i' or 'o' or 'u';
}
```

Set a breakpoint on the first `logger.LogInformation` line of the `Run` method and press `F5` to start the Functions host. Once the Aspire dashboard launches, you observe the following:

![Screenshot of the Aspire running with an Azure Function app](/_astro/functions-dashboard-screenshot.DmcffsY8_Z1KtYsJ.webp)

Aspire has:

* Configured an emulated Azure Storage resource to be used for bookkeeping by the host.
* Launched the Functions host locally with the target as the Functions project registered.
* Wired the port defined in *launchSettings.json* of the functions project for listening.

Use your favorite HTTP client of choice to send a request to the trigger and observe the inputs bound from the request body in the debugger.

**Unix:**

```bash
curl --request POST \
  --url http://localhost:7282/api/Function1 \
  --header 'Content-Type: application/json' \
  --data '{
  "value": "Welcome to Azure Functions"
}'
```

**Windows:**

```powershell
curl --request POST `
  --url http://localhost:7282/api/Function1 `
  --header 'Content-Type: application/json' `
  --data '{
  "value": "Welcome to Azure Functions"
}'
```

![Screenshot of the Aspire dashboard: Debugging an Azure Function app](/_astro/functions-debug-screenshot.CfEA6Il9_ZM4kKX.webp)

Now you’re ready to deploy our application to Azure Container Apps (ACA). Deployment currently depends on preview builds of Azure Functions Worker and Worker SDK packages. If necessary, upgrade the versions referenced in the Functions project:

```xml
<ItemGroup>
    <PackageReference Include="Microsoft.Azure.Functions.Worker" Version="2.0.0-preview2" />
    <PackageReference Include="Microsoft.Azure.Functions.Worker.Sdk" Version="2.0.0-preview2" />
</ItemGroup>
```

You also need to expose a public endpoint for our Azure Functions project so that requests can be sent to our HTTP trigger:

```csharp
builder.AddAzureFunctionsProject<Projects.PigLatinApp>("piglatinapp")
       .WithExternalHttpEndpoints();
```

To deploy the application with the `azd` CLI, you need get the latest version first. To install the latest version, you see a warning if your version is out of date. Follow the instructions to update to the latest version.

After it’s installed, navigate to the folder containing the AppHost project and run `azd init`:

```bash
$ azd init


Initializing an app to run on Azure (azd init)


? How do you want to initialize your app? Use code in the current directory
  (✓) Done: Scanning app code in current directory


Detected services:


  .NET (Aspire)
  Detected in: ./PigLatinApp/PigLatinApp.AppHost/PigLatinApp.AppHost.csproj


azd will generate the files necessary to host your app on Azure using Azure Container Apps.


? Select an option Confirm and continue initializing my app
? Enter a new environment name: azfunc-piglatin


Generating files to run your app on Azure:


  (✓) Done: Generating ./azure.yaml
  (✓) Done: Generating ./next-steps.md


SUCCESS: Your app is ready for the cloud!
```

Then, deploy the application by running `azd up`:

```bash
$ azd up
? Select an Azure Subscription to use: 130. [redacted]
? Select an Azure location to use: 50. (US) West US 2 (westus2)


Packaging services (azd package)


Provisioning Azure resources (azd provision)
Provisioning Azure resources can take some time.


Subscription: [redacted]
Location: West US 2


  You can view detailed progress in the Azure Portal:
  [redacted]


  (✓) Done: Resource group: rg-azfunc-piglatin (967ms)
  (✓) Done: Container Registry: [redacted] (13.316s)
  (✓) Done: Log Analytics workspace: [redacted] (16.467s)
  (✓) Done: Container Apps Environment: [redacted] (1m35.531s)
  (✓) Done: Storage account: [redacted] (21.37s)


Deploying services (azd deploy)


  (✓) Done: Deploying service piglatinapp
  - Endpoint: {{endpoint-url}}


  Aspire Dashboard: {{dashboard-url}}
```

Finally, test your deployed Functions application using your favorite HTTP client:

**Unix:**

```bash
curl --request POST \
  --url {{endpoint-url}}/api/Function1 \
  --header 'Content-Type: application/json' \
  --data '{
  "value": "Welcome to Azure Functions"
}'
```

**Windows:**

```powershell
curl --request POST `
  --url {{endpoint-url}}/api/Function1 `
  --header 'Content-Type: application/json' `
  --data '{
  "value": "Welcome to Azure Functions"
}'
```

Support for Azure Functions in Aspire is still in preview with support for a limited set of triggers including:

* [HTTP triggers](https://learn.microsoft.com/azure/azure-functions/functions-triggers-bindings?pivots=programming-language-csharp#supported-bindings)
* [Azure Storage Queue triggers](https://learn.microsoft.com/azure/azure-functions/functions-bindings-storage-queue?pivots=programming-language-csharp)
* [Azure Storage Blob triggers](https://learn.microsoft.com/azure/azure-functions/functions-bindings-storage-blob?pivots=programming-language-csharp)
* [Azure Service Bus triggers](https://learn.microsoft.com/azure/azure-functions/functions-bindings-service-bus?pivots=programming-language-csharp)
* [Azure Event Hubs triggers](https://learn.microsoft.com/azure/azure-functions/functions-bindings-event-hubs?pivots=programming-language-csharp)

For more information, see the official [Aspire Azure Functions integration (Preview)](/integrations/cloud/azure/azure-functions/).

#### Customization of Azure Container Apps

[Section titled “Customization of Azure Container Apps”](#customization-of-azure-container-apps)

One of the most requested features is the ability to customize the Azure Container Apps that the AppHost creates without touching Bicep. This is possible by using the `PublishAsAzureContainerApp` APIs in the `Aspire.Hosting.Azure.AppContainers` namespace. These methods customizes the Azure Container App definition that the AppHost creates.

Add the package reference to your project file:

```xml
<ItemGroup>
  <PackageReference Include="Aspire.Hosting.Azure.AppContainers"
                    Version="9.0.0" />
</ItemGroup>
```

The following example demonstrates how to scale an Azure Container App to zero (`0`) replicas:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddAzurePostgresFlexibleServer("pg")
                .RunAsContainer()
                .AddDatabase("db");


// Type is for evaluation purposes only and is subject to change or removal in future updates. Suppress this diagnostic to proceed.
#pragma warning disable AZPROVISION001


builder.AddProject<Projects.WebApplication1>("api")
       .WithReference(db)
       .PublishAsAzureContainerApp((module, containerApp) =>
       {
           // Scale to 0
           containerApp.Template.Value!.Scale.Value!.MinReplicas = 0;
       });


#pragma warning restore AZPROVISION001


builder.Build().Run();
```

The preceding code example defers generation of the Azure Container App definition to the AppHost. This allows you to customize the Azure Container App definition without needing to run `azd infra synth` and unsafely modifying the generated bicep files.

# Aspire 9.1

> Learn what's new in Aspire 9.1.

📢 Aspire 9.1 is the next minor version release of Aspire; it supports *both*:

* .NET 8.0 Long Term Support (LTS) *or*
* .NET 9.0 Standard Term Support (STS).

Note

You’re able to use Aspire 9.1 with either .NET 8 or .NET 9!

As always, we focused on highly requested features and pain points from the community. Our theme for 9.1 was “polish, polish, polish”—so you see quality of life fixes throughout the whole platform. Some highlights from this release are resource relationships in the dashboard, support for working in GitHub Codespaces, and publishing resources as a Dockerfile.

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [GitHub](https://github.com/dotnet/aspire) or join us on [Discord](https://discord.com/invite/h87kDAHQgJ) to chat with team members.

Whether you’re new to Aspire or have been with us since the preview, it’s important to note that Aspire releases out-of-band from .NET releases. While major versions of Aspire align with .NET major versions, minor versions are released more frequently. For more details on .NET and Aspire version support, see:

* [.NET support policy](https://dotnet.microsoft.com/platform/support/policy): Definitions for LTS and STS.
* [Aspire support policy](https://dotnet.microsoft.com/platform/support/policy/aspire): Important unique product life cycle details.

## ⬆️ Upgrade to Aspire 9.1

[Section titled “⬆️ Upgrade to Aspire 9.1”](#️-upgrade-to-aspire-91)

Moving between minor releases of Aspire is simple:

1. In your AppHost project file (that is, *MyApp.AppHost.csproj*), update the [📦 Aspire.AppHost.Sdk](https://www.nuget.org/packages/Aspire.AppHost.Sdk) NuGet package to version `9.1.0`:

   ```xml
   <Project Sdk="Microsoft.NET.Sdk">


       <Sdk Name="Aspire.AppHost.Sdk" Version="9.1.0" />


       <!-- Omitted for brevity -->


   </Project>
   ```

   For more information, see [Aspire SDK](/get-started/aspire-sdk/).

2. Check for any NuGet package updates, either using the NuGet Package Manager in Visual Studio or the **Update NuGet Package** command in VS Code.

3. Update to the latest [Aspire templates](/get-started/aspire-sdk-templates/) by running the following .NET command line:

   ```bash
   dotnet new update
   ```

   Note

   The `dotnet new update` command updates all of your templates to the latest version.

If your AppHost project file doesn’t have the `Aspire.AppHost.Sdk` reference, you might still be using Aspire 8. To upgrade to 9.0, you can follow the documentation from last release.

## 🌱 Improved onboarding experience

[Section titled “🌱 Improved onboarding experience”](#-improved-onboarding-experience)

The onboarding experience for Aspire is improved with 9.1. The team worked on creating a GitHub Codespaces template that installs all the necessary dependencies for Aspire, making it easier to get started, including the templates and the ASP.NET Core developer certificate. Additionally, there’s support for Dev Containers. For more information, see:

* [Aspire and GitHub Codespaces](/get-started/github-codespaces/)
* [Aspire and Visual Studio Code Dev Containers](/get-started/dev-containers/)

## 🔧 Dashboard UX and customization

[Section titled “🔧 Dashboard UX and customization”](#-dashboard-ux-and-customization)

With every release of Aspire, the [dashboard](/dashboard/overview/) gets more powerful and customizable, this release is no exception. The following features were added to the dashboard in Aspire 9.1:

### 🧩 Resource relationships

[Section titled “🧩 Resource relationships”](#-resource-relationships)

The dashboard now supports “parent” and “child” resource relationships. For instance, when you create a Postgres instance with multiple databases, these databases are nested under the same instance on the **Resource** page.

![A screenshot of the Aspire dashboard showing the Postgres resource with a database nested underneath it](/_astro/dashboard-parentchild.BskzU4XP_ZboGeh.webp)

For more information, see [Explore the Aspire dashboard](/dashboard/explore/).

### 🔤 Localization overrides

[Section titled “🔤 Localization overrides”](#-localization-overrides)

The dashboard defaults to the language set in your browser. This release introduces the ability to override this setting and change the dashboard language independently from the browser language. Consider the following screen capture that demonstrates the addition of the language dropdown in the dashboard:

![A screenshot of the Aspire dashboard showing the new flyout menu to change language](/_astro/dashboard-language.C-mH-xqR_Z1mSztd.webp)

### 🗑️ Clear logs and telemetry from the dashboard

[Section titled “🗑️ Clear logs and telemetry from the dashboard”](#️-clear-logs-and-telemetry-from-the-dashboard)

New buttons were added to the **Console logs**, **Structured logs**, **Traces** and **Metrics** pages to clear data. There’s also a “Remove all” button in the settings popup to remove everything with one action.

Now you use this feature to reset the dashboard to a blank slate, test your app, view only the relevant logs and telemetry, and repeat.

![A screenshot of the Aspire dashboard showing the remove button on the structured logs page](/_astro/dashboard-remove-telemetry.mDXzVBZ7_rKTql.webp)

We 💜 love the developer community and thrive on its feedback, collaboration, and contributions. This feature is a community contribution from [@Daluur](https://github.com/Daluur). Join us in celebrating their contribution by using the feature!

Tip

If you’re interested in contributing to Aspire, look for issues labeled with [good first issue](https://github.com/dotnet/aspire/issues?q=is%3Aissue%20state%3Aopen%20label%3A%22good%20first%20issue%22) and follow the [contributor guide](https://github.com/dotnet/aspire/blob/main/docs/contributing.md).

### 🔢 New filtering

[Section titled “🔢 New filtering”](#-new-filtering)

You can now filter what you see in the **Resource** page by **Resource type**, **State**, and **Health state**. Consider the following screen capture, which demonstrates the addition of the filter options in the dashboard:

![A screenshot of the Aspire dashboard showing the new filter options](/_astro/dashboard-filter.CLfzcqCD_FbDwY.webp)

### 📝 More resource details

[Section titled “📝 More resource details”](#-more-resource-details)

When you select a resource in the dashboard, the details pane now displays new data points, including **References**, **Back references**, and **Volumes** with their mount types. This enhancement provides a clearer and more comprehensive view of your resources, improving the overall user experience by making relevant details more accessible.

![A screenshot of the Aspire dashboard with references and back references showing](/_astro/dashboard-resourcedetails.DkgK8ZwV_mw5G6.webp)

For more information, see [Aspire dashboard: Resources page](/dashboard/explore/#resources-page).

### 🛡️ CORS support for custom local domains

[Section titled “🛡️ CORS support for custom local domains”](#️-cors-support-for-custom-local-domains)

You can now set the `ASPIRE_DASHBOARD_CORS_ALLOWED_ORIGINS` environment variable to allow the dashboard to receive telemetry from other browser apps, such as if you have resources running on custom localhost domains.

For more information, see [Aspire AppHost: Dashboard configuration](/app-host/configuration/#dashboard).

### 🪵 Flexibility with console logs

[Section titled “🪵 Flexibility with console logs”](#-flexibility-with-console-logs)

The console log page has two new options. You’re now able to download your logs so you can view them in your own diagnostics tools. Plus, you can turn timestamps on or off to reduce visual clutter when needed.

![A screenshot of the console logs page with the download button, turn off timestamps button, and logs that don't show timestamps](/_astro/consolelogs-download.k9-sE6XM_Z22FLjY.webp)

For more information, see [Aspire dashboard: Console logs page](/dashboard/explore/#console-logs-page).

### 🎨 Various UX improvements

[Section titled “🎨 Various UX improvements”](#-various-ux-improvements)

Several new features in Aspire 9.1 enhance and streamline the following popular tasks:

* ▶️ Resource commands, such as **Start** and **Stop** buttons, are now available on the **Console logs** page.
* 🔍 Single selection to open in the *text visualizer*.
* 🔗 URLs within logs are now automatically clickable, with commas removed from endpoints.

Additionally, the 🖱️ scroll position resets when switching between different resources—this helps to visually reset the current resource view.

For more details on the latest dashboard enhancements, check out [James Newton-King on Bluesky](https://bsky.app/profile/james.newtonking.com), where he’s been sharing new features daily.

## ⚙️ Local development enhancements

[Section titled “⚙️ Local development enhancements”](#️-local-development-enhancements)

In Aspire 9.1, several improvements to streamline your local development experience were an emphasis. These enhancements are designed to provide greater flexibility, better integration with Docker, and more efficient resource management. Here are some of the key updates:

### ▶️ Start resources on demand

[Section titled “▶️ Start resources on demand”](#️-start-resources-on-demand)

You can now tell resources not to start with the rest of your app by using `WithExplicitStart` on the resource in your AppHost. Then, you can start it whenever you’re ready from inside the dashboard.

### 🐳 Better Docker integration

[Section titled “🐳 Better Docker integration”](#-better-docker-integration)

The `PublishAsDockerfile()` feature was introduced for all projects and executable resources. This enhancement allows for complete customization of the Docker container and Dockerfile used during the publish process.

While this API was available in previous versions, it couldn’t be used with project or executable resource types.

### 🧹 Cleaning up Docker networks

[Section titled “🧹 Cleaning up Docker networks”](#-cleaning-up-docker-networks)

In 9.1, we addressed a persistent issue where Docker networks created by Aspire would remain active even after the application was stopped. This bug, tracked in [Aspire GitHub issue #6504](https://github.com/dotnet/aspire/issues/6504), is resolved. Now, Docker networks are properly cleaned up, ensuring a more efficient and tidy development environment.

### ✅ Socket address issues fixed

[Section titled “✅ Socket address issues fixed”](#-socket-address-issues-fixed)

Several users reported issues ([#6693](https://github.com/dotnet/aspire/issues/6693), [#6704](https://github.com/dotnet/aspire/issues/6704), [#7095](https://github.com/dotnet/aspire/issues/7095)) with restarting the Aspire AppHost, including reconciliation errors and “address already in use” messages.

This release introduces a more robust approach to managing socket addresses, ensuring only one instance of each address is used at a time. Additionally, improvements were made to ensure proper project restarts and resource releases, preventing hanging issues. These changes enhance the stability and reliability of the AppHost, especially during development and testing.

## 🔌 Integration updates

[Section titled “🔌 Integration updates”](#-integration-updates)

Aspire continues to excel through its [integrations](/integrations/overview/) with various platforms. This release includes numerous updates to existing integrations and details about ownership migrations, enhancing the overall functionality and user experience.

### ☁️ Azure updates

[Section titled “☁️ Azure updates”](#️-azure-updates)

This release also focused on improving various [Azure integrations](/integrations/cloud/azure/overview/):

#### 🆕 New emulators

[Section titled “🆕 New emulators”](#-new-emulators)

We’re excited to bring new emulators for making local development easier. The following integrations got new emulators in this release:

* [Azure Service Bus](/integrations/cloud/azure/azure-service-bus/#add-azure-service-bus-emulator-resource)
* [Azure Cosmos DB Linux-based (preview)](/integrations/cloud/azure/azure-cosmos-db/#use-linux-based-emulator-preview)
* [Azure SignalR](/integrations/cloud/azure/azure-signalr/#add-an-azure-signalr-service-emulator-resource)

```csharp
var serviceBus = builder.AddAzureServiceBus("servicebus")
                        .RunAsEmulator();


#pragma warning disable ASPIRECOSMOSDB001
var cosmosDb = builder.AddAzureCosmosDB("cosmosdb")
                      .RunAsPreviewEmulator();


var signalr = builder.AddAzureSignalR("signalr", AzureSignalRServiceMode.Serverless)
                      .RunAsEmulator();
```

These new emulators work side-by-side with the existing emulators for:

* [Azure Storage](/integrations/cloud/azure/azure-storage-blobs/)
* [Azure Event Hubs](/integrations/cloud/azure/azure-event-hubs/#add-azure-event-hubs-emulator-resource)
* [Azure Cosmos DB](/integrations/cloud/azure/azure-cosmos-db/#add-azure-cosmos-db-emulator-resource)

#### 🌌 Cosmos DB

[Section titled “🌌 Cosmos DB”](#-cosmos-db)

Along with support for the new emulator, Cosmos DB added the following features.

##### 🔒 Support for Entra ID authentication by default

[Section titled “🔒 Support for Entra ID authentication by default”](#-support-for-entra-id-authentication-by-default)

Previously, the Cosmos DB integration used access keys and a Key Vault secret to connect to the service. Aspire 9.1 added support for using more secure authentication using managed identities by default. If you need to keep using access key authentication, you can get back to the previous behavior by calling `WithAccessKeyAuthentication`.

##### 💽 Support for modeling Database and Containers in the AppHost

[Section titled “💽 Support for modeling Database and Containers in the AppHost”](#-support-for-modeling-database-and-containers-in-the-apphost)

You can define a Cosmos DB database and containers in the AppHost and these resources are available when you run the application in both the emulator and in Azure. This allows you to define these resources up front and no longer need to create them from the application, which might not have permission to create them.

For example API usage to add database and containers, see the following related articles:

* [Aspire Azure Cosmos DB integration](/integrations/cloud/azure/azure-cosmos-db/#add-azure-cosmos-db-database-and-container-resources)
* [Aspire Cosmos DB Entity Framework Core integration](/integrations/cloud/azure/azure-cosmos-db/#add-azure-cosmos-db-database-and-container-resources)

##### ⚡ Support for Cosmos DB-based triggers in Azure Functions

[Section titled “⚡ Support for Cosmos DB-based triggers in Azure Functions”](#-support-for-cosmos-db-based-triggers-in-azure-functions)

The Azure Cosmos DB resource was modified to support consumption in Azure Functions applications that uses the Cosmos DB trigger. A Cosmos DB resource can be initialized and added as a reference to an Azure Functions resource with the following code:

```csharp
var cosmosDb = builder.AddAzureCosmosDB("cosmosdb")
                      .RunAsEmulator();
var database = cosmosDb.AddCosmosDatabase("mydatabase");
database.AddContainer("mycontainer", "/id");


var funcApp = builder.AddAzureFunctionsProject<Projects.AzureFunctionsEndToEnd_Functions>("funcapp")
       .WithReference(cosmosDb)
    .WaitFor(cosmosDb);
```

The resource can be used in the Azure Functions trigger as follows:

```csharp
public class MyCosmosDbTrigger(ILogger<MyCosmosDbTrigger> logger)
{
    [Function(nameof(MyCosmosDbTrigger))]
    public void Run([CosmosDBTrigger(
        databaseName: "mydatabase",
        containerName: "mycontainer",
        CreateLeaseContainerIfNotExists = true,
        Connection = "cosmosdb")] IReadOnlyList<Document> input)
    {
        logger.LogInformation(
            "C# cosmosdb trigger function processed: {Count} messages",
            input.Count);
    }
}
```

For more information using Azure Functions with Aspire, see [Aspire Azure Functions integration (Preview)](/integrations/cloud/azure/azure-functions/).

#### 🚚 Service Bus and Event Hubs

[Section titled “🚚 Service Bus and Event Hubs”](#-service-bus-and-event-hubs)

Similar to Cosmos DB, the Service Bus and Event Hubs integrations now allow you to define Azure Service Bus queues, topics, subscriptions, and Azure Event Hubs instances and consumer groups directly in your AppHost code. This enhancement simplifies your application logic by enabling the creation and management of these resources outside the application itself.

For more information, see the following updated articles:

* [Aspire Azure Service Bus integration](/integrations/cloud/azure/azure-service-bus/)
* [Aspire Azure Event Hubs integration](/integrations/cloud/azure/azure-event-hubs/)

#### ♻️ Working with existing resources

[Section titled “♻️ Working with existing resources”](#️-working-with-existing-resources)

There’s consistent feedback about making it easier to connect to existing Azure resources in Aspire. With 9.1, you can now easily connect to an existing Azure resource either directly by `string` name, or with [app model parameters](/fundamentals/external-parameters/) which can be changed at deployment time. For example to connect to an Azure Service Bus account, we can use the following code:

```csharp
var existingServiceBusName = builder.AddParameter("serviceBusName");
var existingServiceBusResourceGroup = builder.AddParameter("serviceBusResourceGroup");


var serviceBus = builder.AddAzureServiceBus("messaging")
                        .AsExisting(existingServiceBusName, existingServiceBusResourceGroup);
```

The preceding code reads the name and resource group from the parameters, and connects to the existing resource when the application is run or deployed. For more information, see [use existing Azure resources](/integrations/cloud/azure/overview/#use-existing-azure-resources).

#### 🌍 Azure Container Apps

[Section titled “🌍 Azure Container Apps”](#-azure-container-apps)

Experimental support for configuring custom domains in Azure Container Apps (ACA) was added. For example:

```csharp
#pragma warning disable ASPIREACADOMAINS001


var customDomain = builder.AddParameter("customDomain");
var certificateName = builder.AddParameter("certificateName");


builder.AddProject<Projects.AzureContainerApps_ApiService>("api")
       .WithExternalHttpEndpoints()
       .PublishAsAzureContainerApp((infra, app) =>
       {
           app.ConfigureCustomDomain(customDomain, certificateName);
       });
```

For more information, see [Aspire diagnostics overview](/diagnostics/overview/).

### ➕ Even more integration updates

[Section titled “➕ Even more integration updates”](#-even-more-integration-updates)

* OpenAI now supports the [📦 Microsoft.Extensions.AI](https://www.nuget.org/packages/Microsoft.Extensions.AI) NuGet package.

* RabbitMQ updated to version 7, and MongoDB to version 3. These updates introduced breaking changes, leading to the release of new packages with version-specific suffixes. The original packages continue to use the previous versions, while the new packages are as follows:

  * [📦 Aspire.RabbitMQ.Client.v7](https://www.nuget.org/packages/Aspire.RabbitMQ.Client.v7) NuGet package. For more information, see the [Aspire RabbitMQ client integration](/integrations/messaging/rabbitmq/#client-integration) documentation.
  * [📦 Aspire.MongoDB.Driver.v3](https://www.nuget.org/packages/Aspire.MongoDB.Driver.v3) NuGet package. For more information, see the [Aspire MongoDB client integration](/integrations/databases/mongodb/mongodb-client/) documentation.

* Dapr migrated to the [CommunityToolkit](https://github.com/CommunityToolkit/Aspire/tree/main/src/CommunityToolkit.Aspire.Hosting.Dapr) to facilitate faster innovation.

* Numerous other integrations received updates, fixes, and new features. For detailed information, refer to our [GitHub release notes](https://github.com/dotnet/aspire/releases).

The [📦 Aspire.Hosting.AWS](https://www.nuget.org/packages/Aspire.Hosting.AWS) NuGet package and source code migrated under [Amazon Web Services (AWS)) ownership](https://github.com/aws/integrations-on-dotnet-aspire-for-aws). This migration happened as part of Aspire 9.0, we’re just restating that change here.

## 🧪 Testing in Aspire

[Section titled “🧪 Testing in Aspire”](#-testing-in-aspire)

Aspire 9.1 simplifies writing cross-functional integration tests with a robust approach. The AppHost allows you to create, evaluate, and manage containerized environments seamlessly within a test run. This functionality supports popular testing frameworks like xUnit, NUnit, and MSTest, enhancing your testing capabilities and efficiency.

Now, you’re able to disable port randomization or enable the [dashboard](/dashboard/overview/). For more information, see [Aspire testing overview](/testing/overview/). Additionally, you can now [Pass arguments to your AppHost](/testing/manage-app-host/#pass-arguments-to-your-apphost).

Some of these enhancements were introduced as a result of stability issues that were reported, such as [Aspire GitHub issue #6678](https://github.com/dotnet/aspire/issues/6678)—where some resources failed to start do to “address in use” errors.

## 🚀 Deployment

[Section titled “🚀 Deployment”](#-deployment)

Significant improvements to the Azure Container Apps (ACA) deployment process are included in Aspire 9.1, enhancing both the `azd` CLI and AppHost options. One of the most requested features—support for deploying `npm` applications to ACA—is now implemented. This new capability allows `npm` apps to be deployed to ACA just like other resources, streamlining the deployment process and providing greater flexibility for developers.

We recognize there’s more work to be done in the area of deployment. Future releases will continue to address these opportunities for improvement. For more information on deploying Aspire to ACA, see [Deploy an Aspire project to Azure Container Apps](/deployment/azure/aca-deployment-aspire-cli/).

## ⚠️ Breaking changes

[Section titled “⚠️ Breaking changes”](#️-breaking-changes)

Aspire is moving quickly, and with that comes breaking changes. Breaking are categorized as either:

* **Binary incompatible**: The assembly version has changed, and you need to recompile your code.
* **Source incompatible**: The source code has changed, and you need to change your code.
* **Behavioral change**: The code behaves differently, and you need to change your code.

Typically APIs are decorated with the obsolete attribute giving you a warning when you compile, and an opportunity to adjust your code. For an overview of breaking changes in Aspire 9.1, see Breaking changes in Aspire 9.1.

## 🎯 Upgrade today

[Section titled “🎯 Upgrade today”](#-upgrade-today)

Follow the directions outlined in the [Upgrade to Aspire 9.1](#-upgrade-to-aspire-91) section to make the switch to 9.1 and take advantage of all these new features today! As always, we’re listening for your feedback on [GitHub](https://github.com/dotnet/aspire/issues)-and looking out for what you want to see in 9.2 ☺️.

For a complete list of issues addressed in this release, see [Aspire GitHub repository—9.1 milestone](https://github.com/dotnet/aspire/issues?q=is%3Aissue%20state%3Aclosed%20milestone%3A9.1%20).

# Aspire 9.2

> Learn what's new in the official general availability release of Aspire 9.2.

📢 Aspire 9.2 is the next minor version release of Aspire; it supports:

* .NET 8.0 Long Term Support (LTS)
* .NET 9.0 Standard Term Support (STS)

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [GitHub](https://github.com/dotnet/aspire) or join us on [Discord](https://discord.com/invite/h87kDAHQgJ) to chat with team members.

It’s important to note that Aspire releases out-of-band from .NET releases. While major versions of Aspire align with .NET major versions, minor versions are released more frequently. For more information on .NET and Aspire version support, see:

* [.NET support policy](https://dotnet.microsoft.com/platform/support/policy): Definitions for LTS and STS.
* [Aspire support policy](https://dotnet.microsoft.com/platform/support/policy/aspire): Important unique product life cycle details.

## ⬆️ Upgrade to Aspire 9.2

[Section titled “⬆️ Upgrade to Aspire 9.2”](#️-upgrade-to-aspire-92)

Caution

If you are using `azd` to deploy Azure PostgreSQL or Azure SQL Server, you now have to configure Azure Managed Identities. For more information, see [🛡️ Improved Managed Identity defaults](#improved-managed-identity-defaults).

Moving between minor releases of Aspire is simple:

1. In your AppHost project file (that is, *MyApp.AppHost.csproj*), update the [📦 Aspire.AppHost.Sdk](https://www.nuget.org/packages/Aspire.AppHost.Sdk) NuGet package to version `9.2.0`:

   ```diff
   <Project Sdk="Microsoft.NET.Sdk">


       <Sdk Name="Aspire.AppHost.Sdk" Version="9.2.0" />


       <PropertyGroup>
           <OutputType>Exe</OutputType>
           <TargetFramework>net9.0</TargetFramework>
          <IsAspireHost>true</IsAspireHost>
           <!-- Omitted for brevity -->
       </PropertyGroup>


       <ItemGroup>
           <PackageReference Include="Aspire.Hosting.AppHost" Version="9.2.0" />
       </ItemGroup>


       <!-- Omitted for brevity -->
   </Project>
   ```

   Caution

   The `IsAspireHost` property is no longer required in the project file. For more information, see [🚧 Project file changes](#project-file-changes).

   For more information, see [Aspire SDK](/get-started/aspire-sdk/).

2. Check for any NuGet package updates, either using the NuGet Package Manager in Visual Studio or the **Update NuGet Package** command in VS Code.

3. Update to the latest [Aspire templates](/get-started/aspire-sdk-templates/) by running the following .NET command line:

   ```bash
   dotnet new update
   ```

   Caution

   The `dotnet new update` command updates all of your templates to the latest version.

If your AppHost project file doesn’t have the `Aspire.AppHost.Sdk` reference, you might still be using Aspire 8. To upgrade to 9.0, follow [the upgrade guide](https://learn.microsoft.com/dotnet/aspire/get-started/upgrade-to-aspire-9).

## 🖥️ AppHost enhancements

[Section titled “🖥️ AppHost enhancements”](#️-apphost-enhancements)

The [AppHost](/get-started/app-host/) is the core of Aspire, providing the local hosting environment for your distributed applications. In Aspire 9.2, we’ve made several improvements to the AppHost:

### 🚧 Project file changes

[Section titled “🚧 Project file changes”](#-project-file-changes)

The Aspire AppHost project file no longer requires the `IsAspireHost` property. This property was moved to the `Aspire.AppHost.Sdk` SDK, therefore, you can remove it from your project file. For more information, see [dotnet/aspire issue #8144](https://github.com/dotnet/aspire/pull/8144).

### 🔗 Define custom resource URLs

[Section titled “🔗 Define custom resource URLs”](#-define-custom-resource-urls)

Resources can now define custom URLs. This makes it easier to build custom experiences for your resources. For example, you can define a custom URL for a database resource that points to the database management console. This makes it easier to access the management console directly from the dashboard, you can even give it a friendly name.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var catalogDb = builder.AddPostgres("postgres")
                       .WithDataVolume()
                       .WithPgAdmin(resource =>
                       {
                           resource.WithUrlForEndpoint("http", u => u.DisplayText = "PG Admin");
                       })
                       .AddDatabase("catalogdb");
```

The preceding code sets the display text for the `PG Admin` URL to `PG Admin`. This makes it easier to access the management console directly from the dashboard.

For more information, see [Define custom resource URLs](/fundamentals/custom-resource-urls/).

## 🔧 Dashboard user experience improvements

[Section titled “🔧 Dashboard user experience improvements”](#-dashboard-user-experience-improvements)

Aspire 9.2 adds new features to the [dashboard](/dashboard/overview/), making it a more powerful developer tool than ever. The following features were added to the dashboard in Aspire 9.2:

### 🧩 Resource graph

[Section titled “🧩 Resource graph”](#-resource-graph)

The resource graph is a new way to visualize the resources in your apps. It displays a graph of resources, linked by relationships. Click the ‘Graph’ tab on the Resources page to view the resource graph. See it in action on [James’s BlueSky](https://bsky.app/profile/james.newtonking.com/post/3lj7odu4re22p).

For more information, see [Aspire dashboard: Resources page](/dashboard/explore/#resources-page).

### 🎨 Resource icons

[Section titled “🎨 Resource icons”](#-resource-icons)

We’ve added resource icons to the resources page. The icon color matches the resource’s telemetry in structured logs and traces.

![Screenshot of dashboard resource's page showing the new resource icons.](/_astro/dashboard-resource-icons.BLIGGrPJ_1xCHIQ.webp)

### ⏯️ Pause and resume telemetry

[Section titled “⏯️ Pause and resume telemetry”](#️-pause-and-resume-telemetry)

New buttons were added to the **Console logs**, **Structured logs**, **Traces** and **Metrics** pages to pause collecting telemetry. Click the pause button again to resume collecting telemetry.

This feature allows you to pause telemetry in the dashboard while continuing to interact with your app.

![Screenshot of the dashboard showing the pause button.](/_astro/dashboard-pause-telemetry.DkHyRia1_ZSAdVG.webp)

### ❤️‍🩹 Metrics health warning

[Section titled “❤️‍🩹 Metrics health warning”](#️-metrics-health-warning)

The dashboard now warns you when a metric exceeds the configured cardinality limit. Once exceeded, the metric no longer provides accurate information.

![Screenshot of a metric with the cardinality limit warning.](/_astro/dashboard-cardinality-limit.DkiDd8rP_riXWX.webp)

### 🕰️ UTC Console logs option

[Section titled “🕰️ UTC Console logs option”](#️-utc-console-logs-option)

Console logs now supports UTC timestamps. The setting is accessible via the console logs options button.

![Screenshot of console logs page showing the UTC timestamps option.](/_astro/dashboard-console-logs-utc.Ys3ltSuZ_GSVa3.webp)

### 🔎 Trace details search text box

[Section titled “🔎 Trace details search text box”](#-trace-details-search-text-box)

We’ve added a search text box to trace details. Now you can quickly filter large traces to find the exact span you need. See it in action on [BluSky](https://bsky.app/profile/james.newtonking.com/post/3llunn7fc4s2p).

### 🌐 HTTP-based resource command functionality

[Section titled “🌐 HTTP-based resource command functionality”](#-http-based-resource-command-functionality)

[Custom resource commands](/fundamentals/custom-resource-commands/) now support HTTP-based functionality with the addition of the `WithHttpCommand` API, enabling you to define endpoints for tasks like database migrations or resets. These commands can be run directly from the Aspire dashboard.

Adds WithHttpCommand(), which lets you define a resource command that sends an HTTP request to your app during development. Useful for triggering endpoints like seed or reset from the dashboard.

```csharp
if (builder.Environment.IsDevelopment())
{
    var resetDbKey = Guid.NewGuid().ToString();


    catalogDbApp.WithEnvironment("DatabaseResetKey", resetDbKey)
                .WithHttpCommand("/reset-db", "Reset Database",
                    commandOptions: new()
                    {
                        Description = "Reset the catalog database to its initial state. This will delete and recreate the database.",
                        ConfirmationMessage = "Are you sure you want to reset the catalog database?",
                        IconName = "DatabaseLightning",
                        PrepareRequest = requestContext =>
                        {
                            requestContext.Request.Headers.Add("Authorization", $"Key {resetDbKey}");
                            return Task.CompletedTask;
                        }
                    });
}
```

For more information, see [Custom HTTP commands in Aspire](/fundamentals/http-commands/).

### 🗂️ Connection string resource type

[Section titled “🗂️ Connection string resource type”](#️-connection-string-resource-type)

We’ve introduced a new `ConnectionStringResource` type that makes it easier to build dynamic connection strings without defining a separate resource type. This makes it easier to work with and build dynamic parameterized connection strings.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiKey = builder.AddParameter("apiKey");
var cs = builder.AddConnectionString("openai",
    ReferenceExpression.Create($"Endpoint=https://api.openai.com/v1;AccessKey={apiKey};"));


var api = builder.AddProject<Projects.Api>("api")
                .WithReference(cs);
```

### 📥 Container resources can now specify an image pull policy

[Section titled “📥 Container resources can now specify an image pull policy”](#-container-resources-can-now-specify-an-image-pull-policy)

Container resources can now specify an `ImagePullPolicy` to control when the image is pulled. This is useful for resources that are updated frequently or that have a large image size. The following policies are supported:

* `Default`: Default behavior (which is the same as `Missing` in 9.2).
* `Always`: Always pull the image.
* `Missing`: Ensures the image is always pulled when the container starts.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cache = builder.AddRedis("cache")
                   .WithImageTag("latest")
                   .WithImagePullPolicy(ImagePullPolicy.Always)
                   .WithRedisInsight();
```

The `ImagePullPolicy` is set to `Always`, which means the image will always be pulled when the resource is created. This is useful for resources that are updated frequently.

### 📂 New container files API

[Section titled “📂 New container files API”](#-new-container-files-api)

In Aspire 9.2, we’ve added a new `WithContainerFiles` API, a way to create files and folders inside a container at runtime by defining them in code. Under the hood, it uses `docker cp` / `podman cp` to copy the files in. Supports setting contents, permissions, and ownership—no bind mounts or temp files needed.

## 🤝 Integrations updates

[Section titled “🤝 Integrations updates”](#-integrations-updates)

Integrations are a key part of Aspire, allowing you to easily add and configure services in your app. In Aspire 9.2, we’ve made several updates to integrations:

### 🔐 Redis/Valkey/Garnet: Password support enabled by default

[Section titled “🔐 Redis/Valkey/Garnet: Password support enabled by default”](#-redisvalkeygarnet-password-support-enabled-by-default)

The Redis, Valkey, and Garnet containers enable password authentication by default. This is part of our goal to be secure by default—protecting development environments with sensible defaults while still making them easy to configure. Passwords can be set explicitly or generated automatically if not provided.

### 💾 Automatic database creation support

[Section titled “💾 Automatic database creation support”](#-automatic-database-creation-support)

There’s [plenty of feedback and confusion](https://github.com/dotnet/aspire/issues/7101) around the `AddDatabase` API. The name implies that it adds a database, but it didn’t actually create the database. In Aspire 9.2, the `AddDatabase` API now creates a database for the following hosting integrations:

| Hosting integration                                                                      | API reference |
| ---------------------------------------------------------------------------------------- | ------------- |
| [📦 Aspire.Hosting.SqlServer](https://www.nuget.org/packages/Aspire.Hosting.SqlServer)   | `AddDatabase` |
| [📦 Aspire.Hosting.PostgreSql](https://www.nuget.org/packages/Aspire.Hosting.PostgreSql) | `AddDatabase` |

The Azure SQL and Azure PostgreSQL hosting integrations also expose `AddDatabase` APIs which work with their respective `RunAsContainer` methods. For more information, see [Understand Azure integration APIs](/integrations/cloud/azure/overview/#understand-azure-integration-apis).

By default, Aspire will create an empty database if it doesn’t exist. You can also optionally provide a custom script to run during creation for advanced setup or seeding.

Example using Postgres:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var postgres = builder.AddPostgres("pg1");


postgres.AddDatabase("todoapp")
    .WithCreationScript($$"""
        CREATE DATABASE {{databaseName}}
            ENCODING = 'UTF8';
        """);
```

For more information and examples of using the `AddDatabase` API, see:

* [Add PostgreSQL resource with database scripts](/integrations/databases/postgres/postgres-host/#add-postgresql-resource-with-database-scripts)
* [Add SQL Server resource with database scripts](/integrations/databases/sql-server/sql-server-host/#add-sql-server-resource-with-database-scripts)

The following hosting integrations don’t currently support database creation:

* [📦 Aspire.Hosting.MongoDb](https://www.nuget.org/packages/Aspire.Hosting.MongoDb)
* [📦 Aspire.Hosting.MySql](https://www.nuget.org/packages/Aspire.Hosting.MySql)
* [📦 Aspire.Hosting.Oracle](https://www.nuget.org/packages/Aspire.Hosting.Oracle)

## ☁️ Azure integration updates

[Section titled “☁️ Azure integration updates”](#️-azure-integration-updates)

In Aspire 9.2, we’ve made significant updates to Azure integrations, including:

### ⚙️ Configure Azure Container Apps environments

[Section titled “⚙️ Configure Azure Container Apps environments”](#️-configure-azure-container-apps-environments)

Aspire 9.2 introduces `AddAzureContainerAppEnvironment`, allowing you to define an Azure Container App environment directly in your app model. This adds an `AzureContainerAppsEnvironmentResource` that lets you configure the environment and its supporting infrastructure (like container registries and volume file shares) using C# and the Azure Provisioning APIs—without relying on `azd` for infrastructure generation.

Caution

This uses a different resource naming scheme than `azd`. If you’re upgrading an existing deployment, this may create duplicate resources. To avoid this, you can opt into `azd`’s naming convention:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureContainerAppEnvironment("my-env")
       .WithAzdResourceNaming();
```

For more information, see [Configure Azure Container Apps environments](/integrations/cloud/azure/configure-container-apps/).

### 🆕 New Client integrations: Azure PostgreSQL (Npgsql & EF Core)

[Section titled “🆕 New Client integrations: Azure PostgreSQL (Npgsql & EF Core)”](#-new-client-integrations-azure-postgresql-npgsql--ef-core)

Aspire 9.2 adds client integrations for working with **Azure Database for PostgreSQL**, supporting both local development and secure cloud deployment.

These integrations automatically use **Managed Identity (Entra ID)** in the cloud and during local development by default. They also support username/password, if configured in your AppHost. No application code changes are required to switch between authentication models.

* [📦 Aspire.Azure.Npgsql](https://www.nuget.org/packages/Aspire.Azure.Npgsql)
* [📦 Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL](https://www.nuget.org/packages/Aspire.Azure.Npgsql.EntityFrameworkCore.PostgreSQL)

**In AppHost:**

```csharp
var postgres = builder.AddAzurePostgresFlexibleServer("pg")
                      .AddDatabase("postgresdb");


builder.AddProject<Projects.MyService>()
       .WithReference(postgres);
```

**In MyService:**

```csharp
builder.AddAzureNpgsqlDbContext<MyDbContext>("postgresdb");
```

### 🖇️ Resource Deep Linking for Cosmos DB, Event Hubs, Service Bus, and OpenAI

[Section titled “🖇️ Resource Deep Linking for Cosmos DB, Event Hubs, Service Bus, and OpenAI”](#️-resource-deep-linking-for-cosmos-db-event-hubs-service-bus-and-openai)

CosmosDB databases and containers, EventHub hubs, ServiceBus queues/topics, and Azure OpenAI deployments now support **resource deep linking**. This allows connection information to target specific child resources—like a particular **Cosmos DB container**, **Event Hubs**, or **OpenAI deployment**—rather than just the top-level account or namespace.

Hosting integrations preserve the full resource hierarchy in connection strings, and client integrations can resolve and inject clients scoped to those specific resources.

**AppHost:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos")
                    .RunAsPreviewEmulator(e => e.WithDataExplorer());


var db = cosmos.AddCosmosDatabase("appdb");
db.AddContainer("todos", partitionKey: "/userId");
db.AddContainer("users", partitionKey: "/id");


builder.AddProject<Projects.TodoApi>("api")
       .WithReference(db);
```

**In the API project:**

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.AddAzureCosmosDatabase("appdb")
       .AddKeyedContainer("todos")
       .AddKeyedContainer("users");


app.MapPost("/todos", async ([FromKeyedServices("todos")] Container container, TodoItem todo) =>
{
    todo.Id = Guid.NewGuid().ToString();
    await container.CreateItemAsync(todo, new PartitionKey(todo.UserId));
    return Results.Created($"/todos/{todo.Id}", todo);
});
```

This makes it easy and convenient to use the SDKs to interact with specific resources directly—without extra wiring or manual configuration. It’s especially useful in apps that deal with multiple containers or Azure services.

### 🛡️ Improved Managed Identity defaults

[Section titled “🛡️ Improved Managed Identity defaults”](#️-improved-managed-identity-defaults)

Starting in **Aspire 9.2**, each Azure Container App now gets its **own dedicated managed identity** by default. This is a significant change from previous versions, where all apps shared a single, highly privileged identity.

This change strengthens Aspire’s *secure by default* posture:

* Each app only gets access to the Azure resources it needs.
* It enforces the principle of least privilege.
* It provides better isolation between apps in multi-service environments.

By assigning identities individually, Aspire can now scope role assignments more precisely—improving security, auditability, and alignment with Azure best practices.

This is a **behavioral breaking change** and may impact apps using:

* **Azure SQL Server** - Azure SQL only supports one Azure AD admin. With multiple identities, only the *last deployed app* will be granted admin access by default. Other apps will need explicit users and role assignments.
* **Azure PostgreSQL** - The app that creates the database becomes the owner. Other apps (like those running migrations or performing data operations) will need explicit `GRANT` permissions to access the database correctly.

See the [breaking changes](https://learn.microsoft.com/dotnet/aspire/whats-new/dotnet-aspire-9-2#breaking-changes) page for more details.

This new identity model is an important step toward more secure and maintainable applications in Aspire. While it introduces some setup considerations, especially for database integrations, it lays the groundwork for better default security across the board.

### 🔑 Least-privilege role assignment functionality

[Section titled “🔑 Least-privilege role assignment functionality”](#-least-privilege-role-assignment-functionality)

Aspire now supports APIs for modeling **least-privilege role assignments** when referencing Azure resources. This enables more secure defaults by allowing you to define exactly which roles each app needs for specific Azure resources.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage")
                     .RunAsEmulator(c => c.WithLifetime(ContainerLifetime.Persistent));


var blobs = storage.AddBlobs("blobs");


builder.AddProject<Projects.AzureContainerApps_ApiService>("api")
       .WithExternalHttpEndpoints()
       .WithReference(blobs)
       .WithRoleAssignments(storage, StorageBuiltInRole.StorageBlobDataContributor);
```

In this example, the API project is granted **Storage Blob Data Contributor** only for the referenced storage account. This avoids over-provisioning permissions and helps enforce the principle of least privilege.

Each container app automatically gets its own **managed identity**, and Aspire now generates the necessary role assignment infrastructure for both default and per-reference roles. When targeting existing Azure resources, role assignments are scoped correctly using separate Bicep resources.

### 1️⃣ First-class Azure Key Vault Secret support

[Section titled “1️⃣ First-class Azure Key Vault Secret support”](#1️⃣-first-class-azure-key-vault-secret-support)

Aspire now supports `IAzureKeyVaultSecretReference`, a new primitive for modeling secrets directly in the app model. This replaces `BicepSecretOutputReference` and gives finer grain control over Key Vault creation when using `AzureBicepResource`.

You can now:

* Add a shared Key Vault in C#
* Configure services that support keys (e.g., Redis, Cosmos DB) to store their secrets there
* Reference those secrets in your app as environment variables or via the Key Vault config provider

Use KeyVault directly in the “api” project:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var vault = builder.AddAzureKeyVault("kv");


var redis = builder.AddAzureRedis("redis")
                   .WithAccessKeyAuthentication(vault);


builder.AddProject<Projects.Api>("api")
       .WithReference(vault);
```

Let the compute environment handle the secret management for you:

```csharp
var redis = builder.AddAzureRedis("redis")
                   .WithAccessKeyAuthentication();


builder.AddProject<Projects.Api>("api")
       .WithReference(redis);
```

**Previous behavior:**

`azd` created and managed secret outputs using a key vault per resource, with no visibility in the app model. These Key Vault resources were handled implicitly and couldn’t be customized in C#.

**New behavior in 9.2:**

Calling `WithKeyAccessAuthentication` or `WithPasswordAuthentication` now creates an actual `AzureKeyVaultResource` (or accepts a reference to one), and stores connection strings there. Secret names follow the pattern `connectionstrings--{resourcename}` to prevent naming conflicts with other vault entries.

### 🔒 Improved default permissions for Azure Key Vault references

[Section titled “🔒 Improved default permissions for Azure Key Vault references”](#-improved-default-permissions-for-azure-key-vault-references)

When referencing a Key Vault, Aspire previously granted the broad **Key Vault Administrator** role by default. In 9.2, this has been changed to **Key Vault Secrets User**, which provides read-only access to secrets—suitable for most application scenarios.

This update continues the security-focused improvements in this release.

## 🚀 Deployment improvements

[Section titled “🚀 Deployment improvements”](#-deployment-improvements)

We’re excited to announce several new deployment features in Aspire 9.2, including:

### 📦 Publishers (Preview)

[Section titled “📦 Publishers (Preview)”](#-publishers-preview)

Publishers are a new extensibility point in Aspire that allow you to define how your distributed application gets transformed into deployable assets. Rather than relying on an [intermediate manifest format](/deployment/manifest-format/), publishers can now plug directly into the application model to generate Docker Compose files, Kubernetes manifests, Azure resources, or whatever else your environment needs.

When Aspire launched, it introduced a deployment manifest format—a serialized snapshot of the application model. While useful it burdened deployment tools with interpreting the manifest and resource authors with ensuring accurate serialization. This approach also complicated schema evolution and target-specific behaviors.

Publishers simplify this process by working directly with the full application model in-process, enabling richer, more flexible, and maintainable publishing experiences.

The following NuGet packages expose preview publishers:

* [📦 Aspire.Hosting.Azure](https://www.nuget.org/packages/Aspire.Hosting.Azure)
* [📦 Aspire.Hosting.Docker (Preview)](https://www.nuget.org/packages/Aspire.Hosting.Docker)
* [📦 Aspire.Hosting.Kubernetes (Preview)](https://www.nuget.org/packages/Aspire.Hosting.Kubernetes)

Caution

The Docker and Kubernetes publishers were contributed by community contributor, [Dave Sekula](https://github.com/Prom3theu5)—a great example of the community stepping up to extend the model. 💜 Thank you, Dave!

To use a publisher, add the corresponding NuGet package to your AppHost project file and then call the `Add[Name]Publisher()` method in your AppHost builder.

```csharp
builder.AddDockerComposePublisher();
```

Tip

Publisher registration methods follow the `Add[Name]Publisher()` convention.

You can also build your own publisher by implementing the publishing APIs and calling your custom registration method. Some publishers are still in preview, and the APIs are subject to change. The goal is to provide a more flexible and extensible way to publish distributed applications, making it easier to adapt to different deployment environments and scenarios.

### 🆕 Aspire CLI (Preview)

[Section titled “🆕 Aspire CLI (Preview)”](#-aspire-cli-preview)

Aspire 9.2 introduces the new **`aspire` CLI**, a tool for creating, running, and publishing Aspire applications from the command line. It provides a rich, interactive experience tailored for Aspire users.

The CLI is available as a .NET tool and can be installed with:

```bash
dotnet tool install --global aspire.cli --prerelease
```

#### Example usage:

[Section titled “Example usage:”](#example-usage)

```bash
aspire new
aspire run
aspire add redis
aspire publish --publisher docker-compose
```

#### Available commands:

[Section titled “Available commands:”](#available-commands)

* `new <template>` – Create a new Aspire sample project
* `run` – Run an Aspire AppHost in development mode
* `add <integration>` – Add an integration to your project
* `publish` – Generate deployment artifacts from your AppHost

🧪 The CLI is **preview**. We’re exploring how to make it a first-class experience for Aspire users—your feedback is welcome!

## 🧪 Testing template updates

[Section titled “🧪 Testing template updates”](#-testing-template-updates)

The xUnit testing project template now supports a version selector, allowing the user to select either:

* `v2`: The previous xUnit testing experience.
* `v3`: The new xUnit testing experience and template.
* `v3 with Microsoft Test Platform`: The next xUnit testing experience, template and uses the [Microsoft Testing Platform](https://learn.microsoft.com/dotnet/core/testing/microsoft-testing-platform-intro).

By default, to the `v3` experience. For more information, see:

* [What’s new in xUnit v.3](https://xunit.net/docs/getting-started/v3/whats-new)
* [Microsoft Testing Platform support in xUnit.net v3](https://xunit.net/docs/getting-started/v3/microsoft-testing-platform)

Note

Both `v3` versions are only supported with Aspire 9.2 or later.

## 💔 Breaking changes

[Section titled “💔 Breaking changes”](#-breaking-changes)

With every release, we strive to make Aspire better. However, some changes may break existing functionality. The following breaking changes are introduced in Aspire 9.2:

* [Breaking changes in Aspire 9.2](https://learn.microsoft.com/dotnet/aspire/whats-new/dotnet-aspire-9-2#breaking-changes)

# What's new in Aspire 9.3

> Learn what's new in the official general availability release of Aspire 9.3.

📢 Aspire 9.3 is the next minor version release of Aspire. It supports:

* .NET 8.0 Long Term Support (LTS)
* .NET 9.0 Standard Term Support (STS)

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [GitHub](https://github.com/dotnet/aspire) or join us on [Discord](https://aka.ms/dotnet-discord) to chat with team members.

It’s important to note that Aspire releases out-of-band from .NET releases. While major versions of Aspire align with major .NET versions, minor versions are released more frequently. For more information on .NET and Aspire version support, see:

* [.NET support policy](https://dotnet.microsoft.com/platform/support/policy): Definitions for LTS and STS.
* [Aspire support policy](https://dotnet.microsoft.com/platform/support/policy/aspire): Important unique product life cycle details.

## 🖥️ App model enhancements

[Section titled “🖥️ App model enhancements”](#️appmodel-enhancements)

### ✨ Zero-friction container configuration

[Section titled “✨ Zero-friction container configuration”](#-zero-friction-container-configuration)

Many container integrations now expose **first-class helpers** to set ports, usernames, and passwords without digging through internal properties. All three settings can be supplied **securely via parameters**, keeping secrets out of source:

```csharp
var pgPwd = builder.AddParameter("pg-pwd", secret: true);


builder.AddPostgres("pg")
       .WithHostPort(6045)          // choose the host-side port
       .WithPassword(pgPwd)         // reference a secret parameter
```

The new `WithHostPort`, `WithPassword`, and `WithUserName` (or equivalent per-service) extension methods are available on **PostgreSQL**, **SQL Server**, **Redis**, and several other container resources, giving you consistent, declarative control across the stack.

### 🔗 Streamlined custom URLs

[Section titled “🔗 Streamlined custom URLs”](#-streamlined-custom-urls)

9.3 makes resource links both **smarter** and **easier** to place:

* **Pick where a link appears** – each link now carries a `UrlDisplayLocation` (`SummaryAndDetails` or `DetailsOnly`), so you can keep diagnostic links out of the main grid yet still see them in the details pane.
* **Relative paths are auto-resolved** – hand the helper `"/health"` and Aspire rewrites it to the full host-qualified URL when the endpoint is allocated.
* **Multiple links per endpoint** – an overload of `WithUrlForEndpoint` lets you attach extra URLs (docs, admin UIs, probes) to the same endpoint without redefining it.
* **Endpoint helper inside callbacks** – `context.GetEndpoint("https")` fetches the fully-resolved endpoint so you can build custom links programmatically.
* **Custom URLs for any resource** – `WithUrl*` also works for custom resources.

```csharp
var frontend = builder.AddProject<Projects.Frontend>("frontend")


    // Hide the plain-HTTP link from the Resources grid
    .WithUrlForEndpoint("http",
        url => url.DisplayLocation = UrlDisplayLocation.DetailsOnly)


    // Add an extra link under the HTTPS endpoint that points to /health
    .WithUrlForEndpoint("https", ep => new()
    {
        Url            = "/health",                  // relative path supported
        DisplayText    = "Health",
        DisplayLocation = UrlDisplayLocation.DetailsOnly
    });
```

With these tweaks you can further customize your local dev stack by surfacing the right links in the right place.

### 🙈 Hide resources without “faking” their state

[Section titled “🙈 Hide resources without “faking” their state”](#-hide-resources-without-faking-their-state)

Historically the only way to keep a resource out of the Dashboard was to put it in the **`Hidden`** *state*—a hack that also made the resource look “terminal” to APIs such as `WaitForResourceAsync`. In 9.3 every snapshot now carries a **boolean `IsHidden` flag**, completely decoupling *visibility* from *lifecycle state*.

* **Cleaner defaults** – low-level helpers like `AddParameter` and `AddConnectionString` mark themselves hidden so they don’t clutter the UI:

  ```csharp
  var apiKey = builder.AddParameter("api-key", secret: true);   // IsHidden = true ✔
  ```

* **Accurate waits & health flows** – `WaitForResourceAsync` was updated to treat `IsHidden` as a separate predicate, so hidden resources can still be awaited or surfaced programmatically without special-casing states.

This small change removes ambiguity in the model while giving you precise control over what shows up in the Dashboard.

### 🔔 New lifecycle events

[Section titled “🔔 New lifecycle events”](#-new-lifecycle-events)

Aspire 9.3 introduces two new lifecycle events that make it easier to build custom resources with predictable behavior—without relying on hacks like `System.Threading.Tasks.Task.Run*?displayProperty=nameWithType` or polling:

#### `InitializeResourceEvent`

[Section titled “InitializeResourceEvent”](#initializeresourceevent)

This event fires **after a resource is added**, but **before endpoints are allocated**. It’s especially useful for custom resources that don’t have a built-in lifecycle (like containers or executables), giving you a clean place to kick off background logic, set default state, or wire up behavior.

For example, this minimal custom resource publishes a running state when initialized:

```csharp
var myCustom = new MyCustomResource("my-resource");


builder.AddResource(myCustom);
builder.Eventing.Subscribe<InitializeResourceEvent>(myCustom, async (e, ct) =>
{
    await e.Notifications.PublishUpdateAsync(e.Resource,
        s => s with { State = KnownResourceStates.Running });
});
```

This replaces awkward patterns like `Task.Run` inside constructors or `Configure()` methods. You can see a more complex version in the [TalkingClock sample](https://github.com/dotnet/aspire-samples/tree/3dee8cd7c7880fe421ea61ba167301eb1369000a/samples/CustomResources/CustomResources.AppHost) in the official Aspire samples repo.

#### `ResourceEndpointsAllocatedEvent`

[Section titled “ResourceEndpointsAllocatedEvent”](#resourceendpointsallocatedevent)

This event fires once a resource’s endpoints have been assigned (e.g., after port resolution or container allocation). It’s scoped per resource, so you can safely get an `Aspire.Hosting.ApplicationModel.EndpointReference` and build derived URLs or diagnostics.

```csharp
builder.Eventing.Subscribe<ResourceEndpointsAllocatedEvent>((e, ct) =>
{
    if (e.Resource is IResourceWithEndpoints resource)
    {
        var http = resource.GetEndpoint("http");


        Console.WriteLine($"Endpoint http - Allocated {http.IsAllocated}, Port: {http.Port}");
    }


    return Task.CompletedTask;
});
```

These events make resource authoring smoother, safer, and more deterministic—no lifecycle guesswork needed.

### 🌐 YARP Integration (Preview)

[Section titled “🌐 YARP Integration (Preview)”](#-yarp-integration-preview)

Aspire 9.3 introduces **preview support for [YARP](https://aka.ms/yarp)** (Yet Another Reverse Proxy)—a long-requested addition that brings reverse proxying into the Aspire application model.

This integration makes it easy to add a lightweight proxy container to your distributed app, powered by the official [YARP container image](https://yarp.dot.net). It currently supports **configuration-based routing only**, using a JSON file you supply.

#### Add a reverse proxy to your Aspire app:

[Section titled “Add a reverse proxy to your Aspire app:”](#add-a-reverse-proxy-to-your-aspire-app)

```csharp
builder.AddYarp("apigateway")
       .WithConfigFile("yarp.json")
       .WithReference(basketService)
       .WithReference(catalogService);
```

The config file is mounted into the container and used as the runtime YARP configuration.

#### Example *yarp.json*:

[Section titled “Example yarp.json:”](#example-yarpjson)

```json
{
  "ReverseProxy": {
    "Routes": {
      "catalog": {
        "ClusterId": "catalog",
        "Match": {
          "Path": "/catalog/{**catch-all}"
        }
      },
      "basket": {
        "ClusterId": "basket",
        "Match": {
          "Path": "/basket/{**catch-all}"
        }
      }
    },
    "Clusters": {
      "catalog": {
        "Destinations": {
          "catalog/d1": {
            "Address": "http://catalog/"
          }
        }
      },
      "basket": {
        "Destinations": {
          "basket/d1": {
            "Address": "http://basket/"
          }
        }
      }
    }
  }
}
```

The `.WithReference(...)` calls automatically ensure that the proxy container can resolve the referenced services by name (`catalog`, `basket`), using Aspire’s internal network graph.

#### ⚠️ Known limitations in this preview

[Section titled “⚠️ Known limitations in this preview”](#️-known-limitations-in-this-preview)

* **Only configuration-based routing is supported**. Code-based or programmatic route generation is not available yet.
* **The configuration file is not deployed** as part of publish operations—you must manage the file manually.
* **Routing from containers to projects will not work on Podman**, due to host-to-container networking limitations.

Tip

💡 Want to learn more about authoring YARP configs? See the official [YARP documentation](https://aka.ms/yarp). 🧪 This integration is in preview—APIs and behavior may evolve. Feedback welcome!

### 🐬 MySQL `AddDatabase` now creates the database

[Section titled “🐬 MySQL AddDatabase now creates the database”](#-mysql-adddatabase-now-creates-the-database)

In Aspire 9.3, the MySQL integration now supports **automatic database creation** via the `AddDatabase` API—matching the behavior already available for SQL Server and PostgreSQL.

Previously, calling `.AddDatabase("dbname")` on a MySQL resource only created a logical reference in Aspire’s app model—it did **not** create the database on the server. This mismatch caused confusion, especially when users expected Aspire to provision the database like it does for other integrations.

#### ✅ New behavior in 9.3:

[Section titled “✅ New behavior in 9.3:”](#-new-behavior-in-93)

```csharp
var mysql = builder.AddMySql("db");


mysql.AddDatabase("appdb");
```

At runtime, Aspire now executes a `CREATE DATABASE` command for `"appdb"` against the running MySQL container or server. If the database already exists, the command is skipped safely.

This brings MySQL in line with the broader Aspire database ecosystem:

| Integration | Automatically creates database?           |
| ----------- | ----------------------------------------- |
| SQL Server  | ✅ Yes                                     |
| PostgreSQL  | ✅ Yes                                     |
| **MySQL**   | ✅ **Yes (new in 9.3)**                    |
| MongoDB     | ❌ No (not needed; created on first write) |
| Oracle      | ❌ No (not supported yet)                  |

No additional configuration is required—the same `AddDatabase` call you already use now provisions the database for you behind the scenes.

## 📊 Dashboard delights

[Section titled “📊 Dashboard delights”](#dashboard-delights)

### ✨ GitHub Copilot in the dashboard

[Section titled “✨ GitHub Copilot in the dashboard”](#-github-copilot-in-the-dashboard)

Introducing GitHub Copilot in the Aspire dashboard! GitHub Copilot is your new AI debugging assistant.

GitHub Copilot supercharges the dashboard’s OpenTelemetry debugging and diagnostics experience. With AI, you can:

* Review hundreds of log messages with a single click
* Investigate the root cause of errors across multiple apps
* Highlight performance issues in traces
* Explain obscure error codes using AI’s huge knowledge repository

You’ll have access to Copilot in the dashboard when you launch your app from VS Code or Visual Studio.

![Screenshot of dashboard with GitHub Copilot chat open.](/_astro/dashboard-copilot.CbXhXLuE_Z1MwuoL.webp)

For more details on requirements and how to get started, see [GitHub Copilot in the Aspire dashboard](https://aspire.dev/dashboard/copilot/).

### 🧠 Remembers your filter settings

[Section titled “🧠 Remembers your filter settings”](#-remembers-your-filter-settings)

The Aspire dashboard now **remembers your resource filter settings** between sessions. Previously, if you filtered the Resources view (for example, to hide support services or highlight only frontend apps), those filters were reset on page reload.

As of 9.3, filter state is **persisted in local storage**, so your selections stick across refreshes and restarts. This small improvement makes it easier to focus on the parts of your app that matter most—especially in large graphs with many supporting services like Redis, SQL, or queues.

![Screenshot of dashboard resource's page showing the filter popup.](/_astro/dashboard-filter.CLfzcqCD_FbDwY.webp)

### 🧵 Uninstrumented resources now appear in Traces

[Section titled “🧵 Uninstrumented resources now appear in Traces”](#-uninstrumented-resources-now-appear-in-traces)

In 9.3, the dashboard can now **visualize outgoing calls to resources that don’t emit their own telemetry**—such as databases, caches, and other infrastructure components that lack built-in tracing.

Previously, these dependencies were invisible in the **Traces** view unless they were emitting OTLP traces. Now, if your app makes an HTTP, SQL, or Redis call to a **modeled Aspire resource** that doesn’t emit spans itself, Aspire still shows it as a **referenced peer** in the trace timeline.

This helps you:

* Understand the full chain of dependencies—even if some components are passive
* Debug latency or failures in calls to uninstrumented services
* Keep the trace UI consistent across infrastructure types

Caution

💡 This is especially useful for services like SQL Server, PostgreSQL, Redis, or blob storage where outgoing client telemetry exists, but the service itself doesn’t participate in distributed tracing.

🧪 No instrumentation changes are needed—Aspire infers the mapping based on resource references.

![Screenshot of dashboard traces's page showing added resources in results.](/_astro/dashboard-traces-uninstrumented-resources.H4OKeOKY_1p1zTm.webp)

### 🖱️ Resource context menus & quick-launch actions

[Section titled “🖱️ Resource context menus & quick-launch actions”](#️-resource-context-menus--quick-launch-actions)

Aspire 9.3 makes the dashboard more interactive and easier to navigate by introducing new **context menus** and enhancing how **resource URLs** are surfaced across views.

![Screenshot of dashboard resource graph view with a context menu.](/_astro/dashboard-context-menu.BFGGub_h_Z26VI1.webp)

#### 🧭 Right-click context menus in the graph

[Section titled “🧭 Right-click context menus in the graph”](#-right-click-context-menus-in-the-graph)

You can now **right-click any resource node** in the **Resource Graph** view to bring up a context menu with quick actions:

* Open structured logs, console logs, traces, or metrics for that resource
* Launch external URLs associated with the resource (like PGAdmin, Swagger, or Grafana)
* Jump directly to the resource’s detail pane

This reduces the number of clicks and lets you stay in the graph while investigating specific services.

#### 🔗 Resource URLs in console log actions

[Section titled “🔗 Resource URLs in console log actions”](#-resource-urls-in-console-log-actions)

Resource URLs defined via `WithUrlForEndpoint(...)` are now **more prominently integrated** into the dashboard UI. They appear:

* In the **console logs view** action bar
* In the new **right-click menus**
* On the **resource detail pane**, as before

This makes common destinations—like admin UIs, health checks, and docs—instantly accessible wherever you’re working.

Together, these improvements turn the Aspire dashboard into a true control plane for navigating your distributed app—**less friction, more focus.**

### ⏸️ Metrics pause warning

[Section titled “⏸️ Metrics pause warning”](#️-metrics-pause-warning)

The dashboard now shows a **warning banner** when metrics collection is paused. This makes it clear that data may be stale if you’ve temporarily halted telemetry.

![Screenshot of dashboard metrics page with a pause warning.](/_astro/dashboard-metrics-warning.L-Sd_u9P_22WsTL.webp)

### 📝 Friendly names in console logs

[Section titled “📝 Friendly names in console logs”](#-friendly-names-in-console-logs)

When a resource has only **one replica**, the Aspire dashboard now uses the **friendly resource name** (like `frontend`, `apigateway`, or `redis`) instead of the replica ID (like `frontend-0`) in the **console logs view**.

This small change makes logs easier to read and reduces visual noise—especially in common single-instance setups during development.

Note

In multi-replica scenarios, Aspire still uses full replica IDs so you can distinguish between instances.

## 🚀 Deployment & publish

[Section titled “🚀 Deployment & publish”](#deployment--publish)

### 🏗️ Improvements to in-preview publisher model & compute environment support

[Section titled “🏗️ Improvements to in-preview publisher model & compute environment support”](#️-improvements-to-in-preview-publisher-model--compute-environment-support)

In 9.2, we shipped our first iteration of “publishers”, a flexible way to configure deployments to any cloud in the AppHost. To ensure more flexibility, Aspire 9.3 includes a **new and improved** publisher model that distributes publishing behavior across your application graph instead of relying on a single top-level publisher.

Rather than selecting a target environment (like Docker or Azure) by calling `AddDockerComposePublisher()` or similar, Aspire now includes a **built-in publisher** that looks for a `PublishingCallbackAnnotation` on each resource. This annotation describes how that resource should be published—for example, as a Docker Compose service, Kubernetes manifest, or Azure Bicep module.

Tip

✅ This architectural shift lays the groundwork for **hybrid and heterogeneous deployments**, where different services within the same app can be deployed to different targets (cloud, edge, local).

#### Most apps only need one environment

[Section titled “Most apps only need one environment”](#most-apps-only-need-one-environment)

In typical apps, you only need to add a **single compute environment**, like:

```csharp
builder.AddAzureContainerAppEnvironment("env");
```

In this case, Aspire applies the correct publishing behavior to all compute resources in your app model—no extra configuration needed.

#### Multiple environments require disambiguation

[Section titled “Multiple environments require disambiguation”](#multiple-environments-require-disambiguation)

If you add **multiple compute environments**, Aspire needs to know which resource goes where. Compute environments apply their transformations to **all applicable compute resources** (projects, containers, executables). If more than one environment matches a given resource, Aspire throws an **ambiguous environment exception** at publish time.

You can resolve this by using `WithComputeEnvironment(...)`:

```csharp
var k8s = builder.AddKubernetesEnvironment("k8s-env");
var compose = builder.AddDockerComposeEnvironment("docker-env");


builder.AddProject<Projects.Api>("api")
       .WithComputeEnvironment(compose);


builder.AddProject<Projects.Frontend>("frontend")
       .WithComputeEnvironment(k8s);
```

This (contrived) example shows how you could explicitly map services to different compute targets—modeling, for example, a frontend in Kubernetes and a backend in Docker Compose.

Note

💡 Imagine a real-world case where your frontend is deployed to a CDN or GitHub Pages, and your backend runs in Azure Container Apps. This new model makes that future possible.

⚠️ All previous publisher registration APIs (like `AddDockerComposePublisher()`) have been removed in favor of this new model.

#### Supported compute environments

[Section titled “Supported compute environments”](#supported-compute-environments)

Aspire 9.3 has preview support for the following environment resources:

* `AddDockerComposeEnvironment(...)`
* `AddKubernetesEnvironment(...)`
* `AddAzureContainerAppEnvironment(...)`
* `AddAzureAppServiceEnvironment(...)` — [see new App Service support →](#-azure-app-service-preview-support)

These represent deployment targets that can transform and emit infrastructure-specific artifacts from your app model.

### 🐳 Docker Compose enhancements

[Section titled “🐳 Docker Compose enhancements”](#-docker-compose-enhancements)

Aspire 9.3 introduces powerful new capabilities for customizing Docker Compose output using strongly typed, C#-based configuration. You can now declaratively configure both the **global Compose file** and individual **services** directly from the Aspire app model—making your deployment output easy to reason about, customize, and automate.

#### 🛠️ Customize the Compose file and service definitions

[Section titled “🛠️ Customize the Compose file and service definitions”](#️-customize-the-compose-file-and-service-definitions)

You can now programmatically configure the top-level Compose file and the behavior of each individual service using two new APIs:

* `ConfigureComposeFile(...)` — customize the `docker-compose.yml` metadata
* `PublishAsDockerComposeService(...)` — modify the generated service for any compute resource (like a container or project)

```csharp
builder.AddDockerComposeEnvironment("env")
       .WithProperties(env =>
       {
           env.BuildContainerImages = false; // skip image build step
       })
       .ConfigureComposeFile(file =>
       {
           file.Name = "aspire-ai-chat"; // sets the file name
       });


// Add a container to the app
builder.AddContainer("service", "nginx")
       .WithEnvironment("ORIGINAL_ENV", "value")
       .PublishAsDockerComposeService((resource, service) =>
       {
           service.Labels["custom-label"] = "test-value";
           service.AddEnvironmentalVariable("CUSTOM_ENV", "custom-value");
           service.Restart = "always";
       });
```

These APIs give you a structured, strongly typed way to mutate the generated output—enabling richer CI automation, custom tooling, and environment-specific adjustments without editing YAML manually.

#### 🔗 Map parameters and expressions into Docker Compose

[Section titled “🔗 Map parameters and expressions into Docker Compose”](#-map-parameters-and-expressions-into-docker-compose)

Aspire now supports **binding values from the app model**—like parameters and references—into the Docker Compose definition via environment variable placeholders.

This makes it easy to flow dynamic configuration (e.g., from the CI pipeline or secret store) directly into the final output.

```csharp
builder.AddDockerComposeEnvironment("docker-compose");


var containerNameParam = builder.AddParameter("param-1", "default-name", publishValueAsDefault: true);


builder.AddContainer("service", "nginx")
       .WithEnvironment("ORIGINAL_ENV", "value")
       .PublishAsDockerComposeService((resource, service) =>
       {
           service.ContainerName = containerNameParam.AsEnvironmentPlaceholder(resource);
       });
```

The key API here is `.AsEnvironmentPlaceholder(...)`, which tells Aspire to emit a Compose variable like `${PARAM_1}` and register the mapping so the `.env` file is updated accordingly.

Tip

🧠 This tightly couples your infrastructure parameters with the Docker Compose model—without hardcoding values—unlocking composability across environments.

These enhancements make Docker Compose a **fully programmable publishing target**, ideal for local development, container-based CI workflows, and teams that need structured control without brittle YAML overlays.

### ☸️ Kubernetes manifest customization

[Section titled “☸️ Kubernetes manifest customization”](#️-kubernetes-manifest-customization)

Aspire 9.3 adds support for **programmatically customizing generated Kubernetes manifests** as part of the publish process. This gives you fine-grained control over the YAML artifacts Aspire emits—without writing raw manifest overlays or patches.

Like Docker Compose, Aspire now supports both **global environment-level settings** and **per-resource customization**.

#### 🛠️ Configure global and per-resource settings

[Section titled “🛠️ Configure global and per-resource settings”](#️-configure-global-and-per-resource-settings)

You can use the following APIs to configure Kubernetes output in C#:

* `WithProperties(...)` on the compute environment to set global behaviors
* `PublishAsKubernetesService(...)` on compute resources to modify their specific Kubernetes resources

```csharp
builder.AddKubernetesEnvironment("env")
       .WithProperties(env =>
       {
           env.DefaultImagePullPolicy = "Always"; // e.g., Always, IfNotPresent
       });


builder.AddContainer("service", "nginx")
       .WithEnvironment("ORIGINAL_ENV", "value")
       .PublishAsKubernetesService(resource =>
       {
           // Add custom deployment-level settings
           resource.Deployment!.Spec.RevisionHistoryLimit = 5;
       });
```

This gives you fully typed access to the Kubernetes object model, enabling powerful modifications like:

* Overriding container image pull policies
* Customizing replica counts or deployment strategies
* Injecting labels or annotations into Services, Deployments, or ConfigMaps

Caution

🧠 Aspire emits standard Kubernetes manifests under the hood—you can still use `kubectl`, `helm`, or GitOps workflows to deploy them, but now you can shape them directly from your app definition.

## 🖥️ Aspire CLI enhancements

[Section titled “🖥️ Aspire CLI enhancements”](#️-aspire-cli-enhancements)

🧪 The Aspire CLI is **still in preview** and under active development. Expect more features and polish in future releases.

📦 To install:

```bash
dotnet tool install --global aspire.cli --prerelease
```

Note

⚠️ **The Aspire 9.3 CLI is not compatible with Aspire 9.2 projects.** You must upgrade your project to Aspire 9.3+ in order to use the latest CLI features.

#### 🔍 Smarter AppHost discovery

[Section titled “🔍 Smarter AppHost discovery”](#-smarter-apphost-discovery)

The CLI now **walks upward** from your current directory, **recursively searching each level** for the AppHost project. Once located, it caches the result in a `.aspire` folder to speed up future commands.

You can now run commands like `aspire run`, `aspire add`, or `aspire publish` from **any directory within your solution**, and the CLI will resolve the AppHost automatically.

For example:

```bash
cd src/frontend
aspire run
```

#### ⏳ Health-aware dashboard launch

[Section titled “⏳ Health-aware dashboard launch”](#-health-aware-dashboard-launch)

The CLI now **waits for the dashboard to become responsive** before printing its URL to the terminal. This ensures the link works immediately when opened—no more blank pages or retry loops.

These updates make the Aspire CLI more reliable, script-friendly, and aligned with how developers move across folders and projects during daily development.

## ☁️ Azure goodies

[Section titled “☁️ Azure goodies”](#️azure-goodies)

### 🌐 Azure App Service (Preview support)

[Section titled “🌐 Azure App Service (Preview support)”](#-azure-app-service-preview-support)

Aspire 9.3 introduces **preview support for deploying .NET projects to Azure App Service**—one of the most requested features from developers using Aspire with existing Azure environments.

This integration lets you deploy your project as a **containerized Linux Web App**, modeled directly in your Aspire AppHost using a new `AddAzureAppServiceEnvironment(...)` API.

#### 🚧 Current limitations (Preview)

[Section titled “🚧 Current limitations (Preview)”](#-current-limitations-preview)

This first release is scoped to the most common use cases:

* Supports **.NET projects only** (via `AddProject(...)`)
* Each project must expose a **single public HTTP endpoint**
* **Projects are published as containers** to Azure Container Registry
* **Containers within the AppHost** are not supported
* **Existing App Service Plans are not supported**
* The Aspire **dashboard is not hosted** in App Service yet

Caution

📢 Hosted dashboard support is coming soon—we’re actively developing this. Feedback is welcome!

#### Example: Deploy to Azure App Service

[Section titled “Example: Deploy to Azure App Service”](#example-deploy-to-azure-app-service)

```csharp
builder.AddAzureAppServiceEnvironment("env");


builder.AddProject<Projects.Api>("api")
       .WithExternalHttpEndpoints()
       .PublishAsAzureAppServiceWebsite((infra, site) =>
       {
           site.SiteConfig.IsWebSocketsEnabled = true;
       });
```

In this example:

* Aspire provisions an App Service Plan and a Web App
* Your project is built as a container and published to **Azure Container Registry**
* The container is deployed to App Service with the configuration you provide

> 🧠 Use `PublishAsAzureAppServiceWebsite(...)` to customize settings like site config, authentication, or SKU.

💬 This feature is in **preview**—we’re looking for your feedback as we expand support!

### 📤 Use an existing Azure Container Registry (ACR)

[Section titled “📤 Use an existing Azure Container Registry (ACR)”](#-use-an-existing-azure-container-registry-acr)

Aspire 9.3 adds support for modeling an existing **Azure Container Registry (ACR)** using the new `AddAzureContainerRegistry(...)` API. This enables you to **push images to an ACR you already manage**—without Aspire provisioning a new one.

This is ideal for teams that:

* Share a centralized registry across environments
* Integrate with existing CI/CD pipelines and promotion workflows
* Require fine-grained control over image publishing

#### Example: associate ACR with an Azure Container Apps environment

[Section titled “Example: associate ACR with an Azure Container Apps environment”](#example-associate-acr-with-an-azure-container-apps-environment)

```csharp
var acr = builder.AddAzureContainerRegistry("my-acr");


builder.AddAzureContainerAppEnvironment("env")
       .WithAzureContainerRegistry(acr);


builder.AddProject<Projects.Api>("api")
       .WithExternalHttpEndpoints();
```

In this example:

* The ACR is modeled in Aspire and used by the container apps environment
* Aspire publishes the built image to `my-acr` and configures Azure Container Apps to pull from it

#### ACR works with multiple compute environments

[Section titled “ACR works with multiple compute environments”](#acr-works-with-multiple-compute-environments)

You can associate an `AzureContainerRegistryResource` with:

* `AddAzureContainerAppEnvironment(...)`
* `AddAzureAppServiceEnvironment(...)`

This gives you consistent control over where images are published, even across different compute targets.

> 💡 Use `.RunAsExisting()` or `.PublishAsExisting()` on the ACR resource to reference an existing registry without provisioning one.

### 🖇️ Resource Deep Linking for Blob Containers

[Section titled “🖇️ Resource Deep Linking for Blob Containers”](#️-resource-deep-linking-for-blob-containers)

Aspire 9.3 expands **resource deep linking** to include **Azure Blob Storage containers**, building on the model already used for Cosmos DB, Event Hubs, Service Bus, and Azure OpenAI.

You can now model individual blob containers directly in your AppHost, then inject scoped `BlobContainerClient` instances into your services—making it easy to read or write blobs without manually configuring connection strings or access.

**AppHost:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Azure Storage Emulator
var storage = builder.AddAzureStorage("storage").RunAsEmulator();


// Add a blob group and a container
var blobs = storage.AddBlobs("blobs");
var container = blobs.AddBlobContainer("images", blobContainerName: "image-uploads");


// Add the API project and reference the container
builder.AddProject<Projects.my94app_ApiService>("api")
       .WithExternalHttpEndpoints()
       .WithReference(container);


builder.Build().Run();
```

**In the API project:**

```csharp
using Azure.Storage.Blobs;


var builder = WebApplication.CreateBuilder(args);


// Register the blob container client
builder.AddAzureBlobContainerClient("images");


var app = builder.Build();


// Minimal POST endpoint for image upload
app.MapPost("/upload", async (
    IFormFile file,
    BlobContainerClient container) =>
{
    await container.CreateIfNotExistsAsync();


    var blob = container.GetBlobClient(file.FileName);
    using var stream = file.OpenReadStream();
    await blob.UploadAsync(stream, overwrite: true);


    return Results.Ok(new { Url = blob.Uri });
});


app.Run();
```

This pattern provides clean separation of concerns, secure container scoping, and minimal ceremony—ideal for microservices that interact with specific blob containers.

### 🔐 Expanded Azure Key Vault client integrations

[Section titled “🔐 Expanded Azure Key Vault client integrations”](#-expanded-azure-key-vault-client-integrations)

Aspire 9.3 expands Azure Key Vault support with new client integration APIs for **keys** and **certificates**, allowing you to inject typed Azure SDK clients directly into your services:

* `AddAzureKeyVaultKeyClient(...)`
* `AddAzureKeyVaultCertificateClient(...)`
* `AddKeyedAzureKeyVaultKeyClient(...)`
* `AddKeyedAzureKeyVaultCertificateClient(...)`

These APIs complement the existing `AddAzureKeyVaultClient(...)` and provide easy access to `KeyClient` and `CertificateClient` from the Azure SDK for .NET.

```csharp
var builder = WebApplication.CreateBuilder(args);


// Register default clients
builder.AddAzureKeyVaultKeyClient("kv");
builder.AddAzureKeyVaultCertificateClient("kv");


// Register named (keyed) clients
builder.AddKeyedAzureKeyVaultCertificateClient("kv", "signing-cert");
```

The **keyed overloads** allow you to register multiple clients scoped to the same Key Vault resource—useful when accessing multiple certificates or keys by purpose.

> 🙌 This feature was contributed by [@james-gould](https://github.com/james-gould). Thank you!

### 🔑 Use Key Vault secrets in environment variables

[Section titled “🔑 Use Key Vault secrets in environment variables”](#-use-key-vault-secrets-in-environment-variables)

Aspire 9.3 adds support for wiring **Key Vault secrets directly into environment variables** using a new overload of `WithEnvironment(...)` that accepts an `IAzureKeyVaultSecretReference`.

This makes it easy to securely reference secrets from a modeled Key Vault without hardcoding secret values—and ensures those references flow correctly into deployment outputs like Azure Bicep.

```csharp
var kv = builder.AddAzureKeyVault("myKeyVault");


var secretRef = kv.Resource.GetSecret("mySecret");


builder.AddContainer("myContainer", "nginx")
       .WithEnvironment("MY_SECRET", secretRef);
```

#### 🧩 Reference secrets from existing Key Vaults

[Section titled “🧩 Reference secrets from existing Key Vaults”](#-reference-secrets-from-existing-key-vaults)

You can also use this with **existing Azure Key Vaults** by marking the resource with `AsExisting(...)`, `RunAsExisting(...)`, or `PublishAsExisting(...)`. This lets you consume secrets from **already-provisioned vaults**—perfect for shared environments or team-managed infrastructure.

```csharp
var keyVaultNameParam = builder.AddParameter("key-vault-name");
var keyVaultResourceGroupParam = builder.AddParameter("key-vault-rg");


var existingVault = builder.AddAzureKeyVault("sharedVault")
                           .AsExisting(keyVaultNameParam, keyVaultResourceGroupParam);


var apiKey = existingVault.Resource.GetSecret("stripe-api-key");


builder.AddContainer("billing", "mycompany/billing")
       .WithEnvironment("STRIPE_API_KEY", apiKey);
```

This pattern ensures Aspire:

* Doesn’t attempt to re-provision the Key Vault
* Emits references to the correct existing resources in publish mode
* Still enables secret injection and secure scoping via environment variables

📖 See also: [Use existing Azure resources](https://aspire.dev/integrations/cloud/azure/overview/#use-existing-azure-resources).

### 🧠 Azure AI Inference client integration (Preview)

[Section titled “🧠 Azure AI Inference client integration (Preview)”](#-azure-ai-inference-client-integration-preview)

Aspire 9.3 adds **client-only support for Azure-hosted Chat Completions endpoints** using the `Azure.AI.Inference` library and the `Microsoft.Extensions.AI` abstractions.

This integration simplifies calling Azure OpenAI or Azure AI Inference services from your application—whether you prefer working directly with the SDK or using abstraction-friendly interfaces.

#### Use `ChatCompletionsClient` with the Azure SDK

[Section titled “Use ChatCompletionsClient with the Azure SDK”](#use-chatcompletionsclient-with-the-azure-sdk)

```csharp
builder.AddAzureChatCompletionsClient("connectionName");


app.MapPost("/chat-raw", (
    ChatCompletionsClient client,
    ChatRequest message) =>
{
    // Use the client
});
```

#### Use `IChatClient` via `Microsoft.Extensions.AI`

[Section titled “Use IChatClient via Microsoft.Extensions.AI”](#use-ichatclient-via-microsoftextensionsai)

```csharp
builder.AddAzureChatCompletionsClient("inference")
       .AddChatClient();
```

Once registered, you can inject `Microsoft.Extensions.AI.IChatClient` using standard dependency injection:

```csharp
app.MapPost("/chat", async (
    IChatClient chatClient,
    ChatRequest message) =>
{
    var result = await chatClient.GetResponseAsync(message.Input);
    return result;
});
```

This setup integrates seamlessly with frameworks like [Semantic Kernel](https://github.com/microsoft/semantic-kernel), and works well in modular or pluggable AI systems.

🔗 Learn more about [Microsoft.Extensions.AI](https://learn.microsoft.com/dotnet/ai/microsoft-extensions-ai) and [ChatCompletionsClient](https://learn.microsoft.com/dotnet/api/azure.ai.inference.chatcompletionsclient).

### ⚙️ Azure App Configuration client integration

[Section titled “⚙️ Azure App Configuration client integration”](#️-azure-app-configuration-client-integration)

Aspire 9.3 adds support for **Azure App Configuration** via a new client integration, [📦 Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration](https://www.nuget.org/packages/Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration) NuGet package.

This makes it easy to connect to centralized configuration using the official Azure SDK and the `Microsoft.Extensions.Configuration.AzureAppConfiguration` provider—no manual setup required.

```csharp
builder.AddAzureAppConfiguration("appconfig");
```

Once registered, Aspire automatically wires Azure App Configuration into your application’s configuration pipeline.

#### Example: bind Azure App Configuration to app settings

[Section titled “Example: bind Azure App Configuration to app settings”](#example-bind-azure-app-configuration-to-app-settings)

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.AddAzureAppConfiguration("appconfig");


var app = builder.Build();


app.MapGet("/feature", (IConfiguration config) =>
{
    var isEnabled = config.GetValue<bool>("FeatureFlag:Enabled");
    return Results.Ok(new { Enabled = isEnabled });
});


app.Run();
```

This enables:

* Dynamic feature flag evaluation
* Centralized configuration management across environments
* Secure integration into the Aspire hosting model

> 🔐 Like all Azure integrations in Aspire, the App Configuration client defaults to using **Managed Identity** for secure access—no connection strings required.

📦 NuGet package: [`Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration`](https://www.nuget.org/packages/Aspire.Microsoft.Extensions.Configuration.AzureAppConfiguration) 🔗 Learn more about [Azure App Configuration](https://learn.microsoft.com/azure/azure-app-configuration/overview)

### 🛡️ Secure multi-app access to Azure SQL (Breaking change)

[Section titled “🛡️ Secure multi-app access to Azure SQL (Breaking change)”](#️-secure-multi-app-access-to-azure-sql-breaking-change)

In Aspire 9.2, using **multiple projects with the same Azure SQL Server** inside an **Azure Container Apps environment** could silently break your app’s identity model.

Each app was assigned its own **managed identity**, but Aspire granted **admin access** to the last app deployed—overwriting access for any previously deployed apps. This led to confusing failures where only one app could talk to the database at a time.

#### ✅ New behavior in 9.3

[Section titled “✅ New behavior in 9.3”](#-new-behavior-in-93-1)

Aspire 9.3 fixes this by:

1. Assigning **one identity** as the **SQL Server administrator**

2. Emitting a **SQL script** that:

   * Creates a **user** for each additional managed identity
   * Assigns each user the **`db_owner`** role on the target database

This ensures every app that references the database gets **full access** without conflicting with other apps.

#### Why this matters

[Section titled “Why this matters”](#why-this-matters)

* Supports **multiple apps accessing the same SQL Server** securely
* Preserves **least-privilege separation** across app identities
* Avoids the brittle “last one wins” admin behavior from earlier releases
* Enables richer deployment scenarios in cloud-native environments like Azure Container Apps

#### ⚠️ Breaking change

[Section titled “⚠️ Breaking change”](#️-breaking-change)

If your deployment relied on Aspire setting the managed identity as the SQL Server **admin**, you’ll need to review your access model. Apps now receive **explicit role-based access (`db_owner`)** instead of broad admin rights.

📖 Related: [dotnet/aspire#8381](https://github.com/dotnet/aspire/issues/8381) and [dotnet/aspire#8389](https://github.com/dotnet/aspire/issues/8389)

### 💸 Default Azure SQL SKU now uses the Free Offer (Breaking change)

[Section titled “💸 Default Azure SQL SKU now uses the Free Offer (Breaking change)”](#-default-azure-sql-sku-now-uses-the-free-offer-breaking-change)

Aspire 9.3 changes the default SKU used when provisioning **Azure SQL databases** to the **GP\_S\_Gen5\_2** (General Purpose Serverless) tier with the [**Free Offer**](https://learn.microsoft.com/azure/azure-sql/database/free-offer?view=azuresql\&preserve-view=true). This helps reduce unexpected costs during development and experimentation.

Previously, Aspire defaulted to the **General Purpose (GP)** tier *without* the Free Offer, which could incur charges even for small or test apps.

#### What’s new

[Section titled “What’s new”](#whats-new)

When you provision a SQL database like this:

```csharp
var sql = builder.AddAzureSqlServer("sqlserver");


sql.AddDatabase("appdb");
```

Aspire now automatically uses the **Free Offer** for `appdb`, which will deploy a **GP\_S\_Gen5\_2** (General Purpose Serverless), unless you override it.

#### How to restore the previous behavior

[Section titled “How to restore the previous behavior”](#how-to-restore-the-previous-behavior)

If your app requires the performance or features of the General Purpose paid tier, you can opt out of the new default using:

```csharp
sql.AddDatabase("appdb")
   .WithDefaultAzureSku(); // Uses the previous (General Purpose) default
```

If you want to specify what SKU to use, you the `ConfigureInfrastructure` method as explained here: [Setting a specific SKU](https://github.com/dotnet/aspire/tree/main/src/Aspire.Hosting.Azure.Sql#setting-a-specific-sku).

#### ⚠️ Breaking change

[Section titled “⚠️ Breaking change”](#️-breaking-change-1)

This change affects cost, performance, and available features in new deployments. If your app depends on higher-tier capabilities, be sure to configure the SKU accordingly.

🔧 Use `.WithDefaultAzureSku()` on the **database** to revert to the old behavior

## 🚀 AZD: Major Improvements to CI/CD for Aspire Apps

[Section titled “🚀 AZD: Major Improvements to CI/CD for Aspire Apps”](#-azd-major-improvements-to-cicd-for-aspire-apps)

We’ve dramatically improved how `azd` configures CI/CD pipelines for Aspire-based applications. These updates directly address one of the most frustrating pain points reported by the community: managing environment parameters and secrets securely and predictably across environments.

Aspire apps are increasingly parameter-driven — using infrastructure-defined settings like connection strings, runtime versions, API keys, and feature flags. Getting those values safely and consistently into CI pipelines like GitHub Actions has historically been difficult. This release fixes that.

### 🧠 Smarter Parameter Handling — No More `AZD_INITIAL_ENVIRONMENT_CONFIG`

[Section titled “🧠 Smarter Parameter Handling — No More AZD\_INITIAL\_ENVIRONMENT\_CONFIG”](#-smarter-parameter-handling--no-more-azd_initial_environment_config)

Previously, Aspire apps that required infrastructure parameters relied on a hidden environment variable called `AZD_INITIAL_ENVIRONMENT_CONFIG`. This variable was a large JSON blob containing all local environment configuration. It had to be passed manually into CI pipelines, was difficult to inspect, and introduced friction when sharing or updating environments.

**Now:** `azd` extracts Aspire parameters directly from your infrastructure definitions and exposes them as named environment variables or secrets in your pipeline — **securely and explicitly**.

For example:

```bicep
param openaiKey string
param dbPassword string
```

become:

```yaml
AZURE_OPENAI_KEY: ${{ secrets.AZURE_OPENAI_KEY }}
AZURE_DB_PASSWORD: ${{ secrets.AZURE_DB_PASSWORD }}
```

This means no more bundling, no more fragile config hacks, and no more guessing how your environment is configured in CI.

### 🔤 Consistent, Predictable Parameter Naming

[Section titled “🔤 Consistent, Predictable Parameter Naming”](#-consistent-predictable-parameter-naming)

Aspire parameters are mapped to environment variable names using a clear rule:

1. Convert `camelCase` to `SNAKE_CASE`
2. Replace dashes (`-`) with underscores (`_`)
3. Uppercase everything
4. Prefix with `AZURE_`

| Parameter name         | Env var vame                 |
| ---------------------- | ---------------------------- |
| `openaiKey`            | `AZURE_OPENAI_KEY`           |
| `dbPassword`           | `AZURE_DB_PASSWORD`          |
| `storage-account-name` | `AZURE_STORAGE_ACCOUNT_NAME` |

This naming consistency means Aspire deployment targets like Azure Container Apps can resolve configuration without custom mappings — locally or in the cloud.

### 📦 Aspire Parameters Automatically Exported to CI

[Section titled “📦 Aspire Parameters Automatically Exported to CI”](#-aspire-parameters-automatically-exported-to-ci)

Aspire apps often define required parameters in Bicep or infrastructure modules — including things like API keys, credentials, or runtime configuration. These are now automatically exported to your pipeline configuration using the naming rules above.

You no longer need to:

* Manually configure these in *.azure/env-name/config.json*
* Inject them into CI via complex JSON blobs
* Worry about missing or mismatched configuration between local and cloud

Secure parameters (like `openaiKey` or `dbPassword`) are automatically treated as CI secrets, while others are injected as variables — all handled by `azd`.

### 🧼 Interactive Secret Management in GitHub Actions

[Section titled “🧼 Interactive Secret Management in GitHub Actions”](#-interactive-secret-management-in-github-actions)

When you run `azd pipeline config`, `azd` will now detect and prompt you if a secret already exists in your GitHub repo or if a secret is no longer used:

#### Existing Secret Prompt:

[Section titled “Existing Secret Prompt:”](#existing-secret-prompt)

```plaintext
The secret AZURE_OPENAI_KEY already exists. What would you like to do?
  [1] Keep it
  [2] Keep ALL existing secrets
  [3] Overwrite it
  [4] Overwrite ALL secrets
```

#### Unused Secret Prompt:

[Section titled “Unused Secret Prompt:”](#unused-secret-prompt)

```plaintext
The secret AZURE_OLD_SECRET is no longer used. What would you like to do?
  [1] Keep it
  [2] Keep ALL unused secrets
  [3] Delete it
  [4] Delete ALL unused secrets
```

This ensures:

* You’re never surprised by secret overwrites
* You can keep your repo clean of stale configuration
* CI reflects your actual infrastructure setup

### 🔄 End-to-End, Repeatable Aspire Deployment

[Section titled “🔄 End-to-End, Repeatable Aspire Deployment”](#-end-to-end-repeatable-aspire-deployment)

With these changes, the local-to-cloud workflow for Aspire apps is now consistent and automated:

1. You define infrastructure parameters as part of your Aspire app.
2. `azd` captures them during provisioning.
3. `azd pipeline config` maps them into your GitHub Actions or Azure DevOps pipeline.
4. Your pipeline runs securely with all the same inputs as your local environment — no manual steps required.

No more `AZD_INITIAL_ENVIRONMENT_CONFIG`. No more brittle overrides. Just clear, secure, parameterized deployment.

These changes unlock a smoother, safer CI/CD experience for Aspire projects — reducing manual configuration, improving security, and aligning your local development setup with your production pipeline.

## 💔 Breaking changes

[Section titled “💔 Breaking changes”](#-breaking-changes)

With every release, we strive to make Aspire better. However, some changes may break existing functionality.

# What's new in Aspire 9.4

> Learn what's new in the official general availability release of Aspire 9.4.

📢 Aspire 9.4 is the next minor version release of Aspire. It supports:

* .NET 8.0 Long Term Support (LTS)
* .NET 9.0 Standard Term Support (STS)
* .NET 10.0 Preview 6

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [GitHub](https://github.com/dotnet/aspire) or join us on our new [Discord](https://aka.ms/aspire-discord) to chat with the team and other community members.

It’s important to note that Aspire releases out-of-band from .NET releases. While major versions of Aspire align with major .NET versions, minor versions are released more frequently. For more information on .NET and Aspire version support, see:

* [.NET support policy](https://dotnet.microsoft.com/platform/support/policy): Definitions for LTS and STS.
* [Aspire support policy](https://dotnet.microsoft.com/platform/support/policy/aspire): Important unique product lifecycle details.

## ⬆️ Upgrade to Aspire 9.4

[Section titled “⬆️ Upgrade to Aspire 9.4”](#️-upgrade-to-aspire-94)

Moving between minor releases of Aspire is simple:

1. In your AppHost project file (that is, *MyApp.AppHost.csproj*), update the [📦 Aspire.AppHost.Sdk](https://www.nuget.org/packages/Aspire.AppHost.Sdk) NuGet package to version `9.4.0`:

   ```xml
   <Sdk Name="Aspire.AppHost.Sdk" Version="9.4.0" />
   ```

   For more information, see [Aspire SDK](%60dotnet/aspire/sdk%60).

2. Check for any NuGet package updates, either using the NuGet Package Manager in Visual Studio or the **Update NuGet Package** command from C# Dev Kit in VS Code.

3. Update to the latest [Aspire templates](fundamentals/aspire-sdk-templates/) by running the following .NET command line:

   .NET CLI

   ```bash
   dotnet new install Aspire.ProjectTemplates
   ```

   > The `dotnet new install` command will update existing Aspire templates to the latest version if they are already installed.

## 🛠️ Aspire CLI is generally available

[Section titled “🛠️ Aspire CLI is generally available”](#️-aspire-cli-is-generally-available)

With the release of Aspire 9.4, the Aspire CLI is generally available. To install the Aspire CLI as an AOT compiled binary, use the following helper scripts:

```bash
# Bash
curl -sSL https://aspire.dev/install.sh | bash


# PowerShell
iex "& { $(irm https://aspire.dev/install.ps1) }"
```

This will install the CLI and put it on your PATH (the binaries are placed in the `$HOME/.aspire/bin` path). If you choose you can also install the CLI as a non-AOT .NET global tool using:

.NET CLI

```bash
dotnet tool install -g Aspire.Cli
```

For more information, see [Install Aspire CLI](https://aspire.dev/reference/cli/overview/) and [aspire-install script reference](https://aspire.dev/reference/cli/overview/).

Note

⚠️ **The Aspire 9.4 CLI is not compatible with Aspire 9.3 projects.** You must upgrade your project to Aspire 9.4+ in order to use the latest CLI features.

### 🎯 CLI Commands

[Section titled “🎯 CLI Commands”](#-cli-commands)

The Aspire CLI has the following [commands](cli-reference/aspire/):

* `aspire new`: Creates a new Aspire project from templates.
* `aspire run`: Finds and runs the existing apphost from anywhere in the repo.
* `aspire add`: Adds a hosting integration package to the apphost.
* `aspire config [get|set|delete|list]`: Configures Aspire settings and feature flags.
* `aspire publish` (Preview): Generates deployment artifacts based on the apphost.

In addition to these core commands, we have two beta commands behind [feature flags](cli-reference/aspire-config/):

* `aspire exec`: Invokes an arbitrary command in the context of an executable resource defined in the apphost (ie, inheriting its environment variables).
* `aspire deploy`: Extends the capabilities of `aspire publish` to actively deploy to a target environment.

#### `aspire exec`

[Section titled “aspire exec”](#aspire-exec)

The new `exec` command allows you to execute commands within the context of your Aspire application environment:

```bash
# Execute commands, like migrations, with environment variables from your app model
aspire exec --resource my-api -- dotnet ef database update


# Run scripts with access to application context
aspire exec --start-resource my-worker -- npm run build


# The exec command automatically provides environment variables
# from your Aspire application resources to the executed command
```

**Key capabilities**:

* **Environment variable injection** from your app model resources
* **Resource targeting** with `--resource` or `--start-resource` options
* **Command execution** in the context of your Aspirified application

\[!INCLUDE [aspire exec feature flag note](cli/includes/exec-feature-flag-note/)]

#### `aspire deploy`

[Section titled “aspire deploy”](#aspire-deploy)

The `aspire deploy` command supports extensible deployment workflows through the new [`DeployingCallbackAnnotation`](https://aspire.dev/fundamentals/annotations-overview/), enabling custom pre/post-deploy logic and richer integration with external systems during deployment operations.

**Key capabilities:**

* **Custom deployment hooks** using `Aspire.Hosting.ApplicationModel.DeployingCallbackAnnotation` to execute custom logic during the `aspire deploy` command
* **Workflow activity reporting** via the `Aspire.Hosting.Publishing.IPublishingActivityReporter` to support progress notifications and prompting in commmands
* **Integration with publish** - `aspire deploy` runs `Aspire.Hosting.Publishing.PublishingCallbackAnnotations` to support deploying artifacts emitted by publish steps, if applicable

The example below demonstrates using the `DeployingCallbackAnnotation` to register custom deployment behavior and showcases [CLI-based prompting](#-enhanced-publish-and-deploy-output) and progress notifications.

```csharp
#pragma warning disable ASPIREPUBLISHERS001
#pragma warning disable ASPIREINTERACTION001


using Aspire.Hosting.Publishing;
using Microsoft.Extensions.DependencyInjection;


var builder = DistributedApplication.CreateBuilder(args);


// Custom deployment step defined below
builder.AddDataSeedJob("SeedInitialData", seedDataPath: "data/seeds");


builder.Build().Run();


internal class DataSeedJobResource(string name, string seedDataPath)
    : Resource(name)
{
    public string SeedDataPath { get; } = seedDataPath;
}


internal static class DataSeedJobBuilderExtensions
{
    public static IResourceBuilder<DataSeedJobResource> AddDataSeedJob(
        this IDistributedApplicationBuilder builder,
        string name,
        string seedDataPath = "data/seeds")
    {
        var job = new DataSeedJobResource(name, seedDataPath);
        var resourceBuilder = builder.AddResource(job);


        // Attach a DeployingCallbackAnnotation that will be invoked on `aspire deploy`
        job.Annotations.Add(new DeployingCallbackAnnotation(async ctx =>
        {
            CancellationToken ct = ctx.CancellationToken;


            // Prompt the user for a confirmation using the interaction service
            var interactionService = ctx.Services.GetRequiredService<IInteractionService>();


            var envResult = await interactionService.PromptInputAsync(
                "Environment Configuration",
                "Please enter the target environment name:",
                new InteractionInput
                {
                    Label = "Environment Name",
                    InputType = InputType.Text,
                    Required = true,
                    Placeholder = "dev, staging, prod"
                },
                cancellationToken: ct);




            // Use the ActivityReporter to report progress on the seeding process
            var reporter = ctx.ActivityReporter;


            var step = await reporter.CreateStepAsync("Seeding data", ct);
            var task = await step.CreateTaskAsync($"Loading seed data from {seedDataPath}", ct);


            try
            {
                // Do some work here
                await Task.Delay(3000);


                await task.SucceedAsync("Seed data loaded", ct);
                await step.SucceedAsync("Data seeding completed", ct);
            }
            catch (Exception ex)
            {
                await task.FailAsync(ex.Message, ct);
                await step.FailAsync("Data seeding failed", ct);
                throw;
            }
        }));


        return resourceBuilder;
    }
}
```

This custom deployment logic executes as follows from the `aspire deploy` command.

![aspire-deploy-whats-new](https://github.com/user-attachments/assets/15c6730d-8154-496a-be70-c67257ce5523)

Now, integration owners can create sophisticated `aspire deploy` workflows. This work also provides a foundation for advanced deployment automation scenarios.

Note

While the `Aspire.Hosting.ApplicationModel.DeployingCallbackAnnotation` API is available in Aspire 9.4, there are currently no built-in resources that natively support deployment callbacks. Built-in resource support for deployment callbacks will be added in the next version of Aspire.

Caution

🧪 **Feature Flag**: The `aspire deploy` command is behind a feature flag and **disabled by default** in this release. It must be explicitly enabled for use with `aspire config set features.deployCommandEnabled true`

### 📃 Enhanced publish and deploy output

[Section titled “📃 Enhanced publish and deploy output”](#-enhanced-publish-and-deploy-output)

Aspire 9.4 significantly improves the feedback and progress reporting during publish and deploy operations, providing clearer visibility into what’s happening during deployment processes.

**Key improvements:**

* **Enhanced progress reporting** with detailed step-by-step feedback during publishing
* **Cleaner output formatting** that makes it easier to follow deployment progress
* **Better error messaging** with more descriptive information when deployments fail
* **Improved publishing context** that tracks and reports on resource deployment status
* **Container build logs** provide clear status updates during container operations

These improvements make it much easier to understand what’s happening during `aspire deploy` and `aspire publish` operations, helping developers debug issues more effectively and gain confidence in their deployment processes.

The enhanced output is particularly valuable for:

* **CI/CD pipelines** where clear logging is essential for troubleshooting
* **Complex deployments** with multiple resources and dependencies
* **Container-based deployments** where build and push operations need clear status reporting
* **Team environments** where deployment logs need to be easily interpreted by different team members

For more information about publishing and deploying Aspire apps, see [aspire deploy](cli-reference/aspire-deploy/).

## 🖥️ App model enhancements

[Section titled “🖥️ App model enhancements”](#️-app-model-enhancements)

### 🎛️ Interaction service

[Section titled “🎛️ Interaction service”](#️-interaction-service)

Aspire 9.4 introduces the [interaction service](https://aspire.dev/extensibility/interaction-service/), a general service that allows developers to build rich experiences at runtime by extending the dashboard UX and at publish and deploy time using the Aspire CLI. It allows you to build complex interactions where input is required from the user.

Caution

🧪 This feature is experimental and may change in future releases.

![Recording of using the interaction service in the dashboard.](/_astro/dashboard-interaction-service.B113z4vR_ZhHQLL.webp)

The interaction system supports:

* Confirmation prompts for destructive operations
* Input collection with validation
* Multi-step workflows
* Dashboard interactions during run mode
* CLI interactions during deploy and publish operations

```csharp
// Example usage of IInteractionService APIs
public class DeploymentService
{
    private readonly IInteractionService _interactionService;


    public DeploymentService(IInteractionService interactionService)
    {
        _interactionService = interactionService;
    }


    public async Task DeployAsync()
    {
        // Prompt for confirmation before destructive operations
        var confirmResult = await _interactionService.PromptConfirmationAsync(
            "Confirm Deployment",
            "This will overwrite the existing deployment. Continue?");


        if (confirmResult.Canceled || !confirmResult.Data)
        {
            return;
        }


        // Collect multiple inputs with validation
        var regionInput = new InteractionInput { Label = "Region", InputType = InputType.Text, Required = true };
        var instanceCountInput = new InteractionInput { Label = "Instance Count", InputType = InputType.Number, Required = true };
        var enableMonitoringInput =  new InteractionInput { Label = "Enable Monitoring", InputType = InputType.Boolean };


        var multiInputResult = await _interactionService.PromptInputsAsync(
            "Advanced Configuration",
            "Configure deployment settings:",
            [regionInput, instanceCountInput, enableMonitoringInput],
            new InputsDialogInteractionOptions
            {
                ValidationCallback = async context =>
                {
                    if (!IsValidRegion(regionInput.Value))
                    {
                        context.AddValidationError(regionInput, "Invalid region specified");
                    }
                }
            });


        if (multiInputResult.Canceled)
        {
            return;
        }


        await RunDeploymentAsync(
            region: regionInput.Value,
            instanceCount: instanceCountInput.Value,
            enableMonitoring: enableMonitoringInput.Value);


        // Show progress notifications
        await _interactionService.PromptNotificationAsync(
            "Deployment Status",
            "Deployment completed successfully!",
            new NotificationInteractionOptions
            {
                Intent = MessageIntent.Success,
                LinkText = "View Dashboard",
                LinkUrl = "https://portal.azure.com"
            });
    }


    private bool IsValidRegion(string? region)
    {
        // Validation logic here
        return !string.IsNullOrEmpty(region);
    }
}
```

**Input types supported:**

* `Text` - Standard text input
* `SecretText` - Password/secret input (masked)
* `Choice` - Dropdown selection
* `Boolean` - Checkbox input
* `Number` - Numeric input

**Advanced features:**

* **Validation callbacks** for complex input validation
* **Markdown support** for rich text descriptions
* **Custom button text** and dialog options
* **Intent-based styling** for different message types
* **Link support** in notifications

These interactions work seamlessly whether you’re running your application through the [Aspire dashboard](#-dashboard-improvements) or deploying via the CLI with `aspire deploy` and `aspire publish` commands.

### 🔄 Interactive parameter prompting during run mode

[Section titled “🔄 Interactive parameter prompting during run mode”](#-interactive-parameter-prompting-during-run-mode)

Aspire 9.4 introduces interactive parameter prompting, automatically collecting missing parameter values in the dashboard during application startup through the new [interaction service](#-interaction-service).

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Parameters without default values will trigger prompts
var apiKey = builder.AddParameter("api-key", secret: true);
var dbPassword = builder.AddParameter("db-password", secret: true);


// This also works for values that could be defined in appsettings.json
var environment = builder.AddParameterFromConfiguration("environment", "ENVIRONMENT_VARIABLE");


// Application will prompt for these values if not provided
var database = builder.AddPostgres("postgres", password: dbPassword);
var api = builder.AddProject<Projects.Api>("api")
    .WithEnvironment("API_KEY", apiKey)
    .WithEnvironment("ENVIRONMENT", environment)
    .WithReference(database);


builder.Build().Run();
```

**Interactive experience:**

* **Automatically detects parameters** that are missing so there aren’t startup failures
* **Dashboard prompts** with interactive forms and Markdown-enabled parameter descriptions
* **Validation support** for enforcing rules (required, length, casing, etc)
* **Secret masking** so sensitive input isn’t shown while being entered
* **Save to user secrets** for persistent per-project value storage outside of source control

This feature eliminates the need to pre-configure all parameters in appsettings.json or .env files before running your Aspirified application, so you can clone, run, and be guided through what values are needed to run the full stack.

#### 📝 Enhanced parameter descriptions and custom input rendering

[Section titled “📝 Enhanced parameter descriptions and custom input rendering”](#-enhanced-parameter-descriptions-and-custom-input-rendering)

Building on the interactive parameter prompting capabilities and the new [interaction service](#-interaction-service), Aspire 9.4 introduces rich parameter descriptions and custom input rendering to provide better user guidance and specialized input controls during parameter collection.

* **Aspire.Hosting.ParameterResourceBuilderExtensions.WithDescription** - Add helpful descriptions to guide users during parameter input
* **Markdown support** - Rich text descriptions with links, formatting, and lists using `enableMarkdown: true`
* **Aspire.Hosting.ParameterResourceBuilderExtensions.WithCustomInput** - Create specialized input controls for specific parameter types

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Parameters with descriptions provide better user guidance
var apiKey = builder.AddParameter("api-key", secret: true)
    .WithDescription("API key for external service authentication");


var environment = builder.AddParameter("environment")
    .WithDescription("Target deployment environment (dev, staging, prod)");


// Parameters with rich markdown descriptions
var configValue = builder.AddParameter("config-value")
    .WithDescription("""
        Configuration value with detailed instructions:


        - Use **development** for local testing
        - Use **staging** for pre-production validation
        - Use **production** for live deployments


        See [configuration guide](https://docs.company.com/config) for details.
        """, enableMarkdown: true);


// Custom input rendering for specialized scenarios
var workerCount = builder.AddParameter("worker-count")
    .WithDescription("Number of background worker processes")
    .WithCustomInput(p => new InteractionInput
    {
        InputType = InputType.Number,
        Label = "Worker Count",
        Placeholder = "Enter number (1-10)",
        Description = p.Description
    });


var deploymentRegion = builder.AddParameter("region")
    .WithDescription("Azure region for deployment")
    .WithCustomInput(p => new InteractionInput
    {
        InputType = InputType.Choice,
        Label = "Deployment Region",
        Description = p.Description,
        Options = new[]
        {
            KeyValuePair.Create("eastus", "East US"),
            KeyValuePair.Create("westus", "West US"),
            KeyValuePair.Create("northeurope", "North Europe"),
            KeyValuePair.Create("southeastasia", "Southeast Asia")
        }
    });


var api = builder.AddProject<Projects.Api>("api")
    .WithEnvironment("API_KEY", apiKey)
    .WithEnvironment("ENVIRONMENT", environment)
    .WithEnvironment("CONFIG_VALUE", configValue)
    .WithEnvironment("WORKER_COUNT", workerCount)
    .WithEnvironment("REGION", deploymentRegion);


builder.Build().Run();
```

For more information, including supported input types, see the [Interaction Service section](#-interaction-service) below or the full [interaction service docs](https://aspire.dev/extensibility/interaction-service/).

### 🌐 External service modeling

[Section titled “🌐 External service modeling”](#-external-service-modeling)

Modern applications frequently need to integrate with external APIs, third-party services, or existing infrastructure that isn’t managed by Aspire. Aspire 9.4 introduces first-class support for [modeling external services](fundamentals/orchestrate-resources.md#express-external-service-resources) as resources in your application graph.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Reference an external service by URL
var externalApi = builder.AddExternalService("external-api", "https://api.company.com");


// Or use a parameter for dynamic configuration
var apiUrl = builder.AddParameter("api-url");
var externalDb = builder.AddExternalService("external-db", apiUrl)
    .WithHttpHealthCheck("/health");


var myService = builder.AddProject<Projects.MyService>("my-service")
    .WithReference(externalApi)
    .WithReference(externalDb);


builder.Build().Run();
```

External services appear in the Aspire dashboard with health status, can be referenced like any other resource, and support the same configuration patterns as internal resources.

### 🔗 Enhanced endpoint URL support

[Section titled “🔗 Enhanced endpoint URL support”](#-enhanced-endpoint-url-support)

Aspire 9.4 introduces support for [non-localhost URLs](https://aspire.dev/fundamentals/networking-overview/), making it easier to work with custom domains and network configurations. This includes support for `*.localhost` subdomains and automatic generation of multiple URL variants for endpoints listening on multiple addresses.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Endpoints targeting all addresses automatically get multiple URL variants
var api = builder.AddProject<Projects.Api>("api")
    .WithEndpoint("https", e => e.TargetHost = "0.0.0.0");


// Machine name URLs for external access
var publicService = builder.AddProject<Projects.PublicService>("public")
    .WithEndpoint("https", e => e.TargetHost = "0.0.0.0");


builder.Build().Run();
```

**Key capabilities:**

* **Custom `*.localhost` subdomain support** that maintains localhost behavior
* **Automatic endpoint URL generation** for endpoints listening on multiple addresses, with both localhost and machine name URLs (such as Codespaces)
* **All URL variants** appear in the Aspire dashboard for easy access
* **Network flexibility** for development scenarios requiring specific network configurations
* **Launch profile configuration support** so custom URLs can also be configured via launch profiles in `launchSettings.json`:

```json
{
  "profiles": {
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://*:7001;http://*:5001",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

This simplifies development workflows where custom domains or external network access is needed while maintaining the familiar localhost development experience. A popular example includes SaaS solutions which use custom domains per-tenant.

### 🐳 Enhanced persistent container support

[Section titled “🐳 Enhanced persistent container support”](#-enhanced-persistent-container-support)

Aspire 9.4 improves support for [persistent containers](https://aspire.dev/app-host/persistent-containers/) with better lifecycle management and networking capabilities, ensuring containers can persist across application restarts while maintaining proper connectivity.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Persistent containers with improved lifecycle support
var database = builder.AddPostgres("postgres")
    .WithLifetime(ContainerLifetime.Persistent)
    .WithExplicitStart(); // Better support for explicit start with persistent containers


// Persistent containers automatically also get persistent networking
var redis = builder.AddRedis("redis")
    .WithLifetime(ContainerLifetime.Persistent);


var api = builder.AddProject<Projects.Api>("api")
    .WithReference(database)
    .WithReference(redis);


builder.Build().Run();
```

**Enhanced capabilities:**

* **Improved lifecycle coordination** between `Aspire.Hosting.ResourceBuilderExtensions.WithExplicitStart*` and `ContainerLifetime.Persistent`
* **Automatic persistent networking** spun up when persistent containers are detected
* **Container delay start** for more reliable startup sequencing
* **Network isolation** between persistent and session-scoped containers, which now use separate networks for better resource management

This will greatly improve your experience while building stateful services that persist beyond individual application runs.

### 🎛️ Resource command service

[Section titled “🎛️ Resource command service”](#️-resource-command-service)

Aspire 9.4 introduces `Aspire.Hosting.ApplicationModel.ResourceCommandService`, an API for executing commands against resources. You can now easily execute the commands that appear in the dashboard programmatically. For example, when writing unit tests for commands, or having other integrations in Aspire execute commands.

The example below uses `ResourceCommandService` to have a command execute other commands.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var database = builder.AddPostgres("postgres")
    .WithHttpCommand("admin-restart", "Restart Database",
        commandName: "db-restart",
        commandOptions: new HttpCommandOptions
        {
            Method = HttpMethod.Post,
            Description = "Restart the PostgreSQL database"
        });


var cache = builder.AddRedis("cache")
    .WithHttpCommand("admin-flush", "Flush Cache",
        commandName: "cache-flush",
        commandOptions: new HttpCommandOptions
        {
            Method = HttpMethod.Delete,
            Description = "Clear all cached data"
        });


// Add a composite command that coordinates multiple operations
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(database)
    .WithReference(cache)
    .WithCommand("reset-all", "Reset Everything", async (context, ct) =>
    {
        var logger = context.ServiceProvider.GetRequiredService<ILogger<Program>>();
        var commandService = context.ServiceProvider.GetRequiredService<ResourceCommandService>();


        logger.LogInformation("Starting full system reset...");


        try
        {
            var flushResult = await commandService.ExecuteCommandAsync(cache.Resource, "cache-flush", ct);
            var restartResult = await commandService.ExecuteCommandAsync(database.Resource, "db-restart", ct);
            if (!restartResult.Success || !flushResult.Success)
            {
                return CommandResults.Failure($"System reset failed");
            }


            logger.LogInformation("System reset completed successfully");
            return CommandResults.Success();
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "System reset failed");
            return CommandResults.Failure(ex);
        }
    },
    displayDescription: "Reset cache and restart database in coordinated sequence",
    iconName: "ArrowClockwise");


builder.Build().Run();
```

`ResourceCommandService` can also be used in unit tests:

```csharp
[Fact]
public async Task Should_ResetCache_WhenTestStarts()
{
    var builder = DistributedApplication.CreateBuilder();


    // Add cache with reset command for testing
    var cache = builder.AddRedis("test-cache")
        .WithHttpCommand("reset", "Reset Cache",
            commandName: "reset-cache",
            commandOptions: new HttpCommandOptions
            {
                Method = HttpMethod.Delete,
                Description = "Clear all cached test data"
            });


    var api = builder.AddProject<Projects.TestApi>("test-api")
        .WithReference(cache);


    await using var app = builder.Build();
    await app.StartAsync();


    // Reset cache before running test
    var result = await app.ResourceCommands.ExecuteCommandAsync(
        cache.Resource,
        "reset-cache",
        CancellationToken.None);


    Assert.True(result.Success, $"Failed to reset cache: {result.ErrorMessage}");
}
```

### 🔄 Resource lifecycle events

[Section titled “🔄 Resource lifecycle events”](#-resource-lifecycle-events)

Aspire 9.4 introduces convenient extension methods on `Aspire.Hosting.ApplicationModel.IResourceBuilder`1\` that make it much easier to subscribe to [lifecycle events](https://aspire.dev/app-host/eventing/#apphost-life-cycle-events) directly on resources, providing a cleaner and more intuitive API.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var database = builder.AddPostgres("postgres")
                .AddDatabase("mydb")
                .OnConnectionStringAvailable(async (resource, evt, cancellationToken) =>
                {
                    // Log when connection strings are resolved
                    var logger = evt.Services.GetRequiredService<ILogger<Program>>();
                    logger.LogInformation("Connection string available for {Name}", resource.Name);
                });


var api = builder.AddProject<Projects.Api>("api")
                .WithReference(database)
                .OnInitializeResource(async (resource, evt, cancellationToken) =>
                {
                    // Early resource initialization
                    var logger = evt.Services.GetRequiredService<ILogger<Program>>();
                    logger.LogInformation("Initializing resource {Name}", resource.Name);
                })
                .OnBeforeResourceStarted(async (resource, evt, cancellationToken) =>
                {
                    // Pre-startup validation or configuration
                    var serviceProvider = evt.Services;
                    // Additional validation logic here
                })
                .OnResourceEndpointsAllocated(async (resource, evt, cancellationToken) =>
                {
                    // React to endpoint allocation
                    var logger = evt.Services.GetRequiredService<ILogger<Program>>();
                    logger.LogInformation("Endpoints allocated for {Name}", resource.Name);
                })
                .OnResourceReady(async (resource, evt, cancellationToken) =>
                {
                    // Resource is fully ready
                    var logger = evt.Services.GetRequiredService<ILogger<Program>>();
                    logger.LogInformation("Resource {Name} is ready", resource.Name);
                });


// Example: Database seeding using OnResourceReady
var db = builder.AddMongoDB("mongo")
    .WithMongoExpress()
    .AddDatabase("db")
    .OnResourceReady(async (db, evt, ct) =>
    {
        // Seed the database with initial data
        var connectionString = await db.ConnectionStringExpression.GetValueAsync(ct);
        using var client = new MongoClient(connectionString);


        var myDb = client.GetDatabase("db");
        await myDb.CreateCollectionAsync("entries", cancellationToken: ct);


        // Insert sample data
        for (int i = 0; i < 10; i++)
        {
            await myDb.GetCollection<Entry>("entries").InsertOneAsync(new Entry(), cancellationToken: ct);
        }
    });


builder.Build().Run();
```

**Available lifecycle events:**

* `Aspire.Hosting.DistributedApplicationEventingExtensions.OnInitializeResource*` - Called during early resource initialization
* `Aspire.Hosting.DistributedApplicationEventingExtensions.OnBeforeResourceStarted*` - Called before the resource starts
* `Aspire.Hosting.DistributedApplicationEventingExtensions.OnConnectionStringAvailable*` - Called when connection strings are resolved (requires `IResourceWithConnectionString`)
* `Aspire.Hosting.DistributedApplicationEventingExtensions.OnResourceEndpointsAllocated*` - Called when resource endpoints are allocated (requires `IResourceWithEndpoints`)
* `Aspire.Hosting.DistributedApplicationEventingExtensions.OnResourceReady*` - Called when the resource is fully ready

The new chainable fluent API, strongly-typed callbacks, and simplified syntax make it intuitive to hook into your resource lifecycles for interactions, commands, custom scripts, and more.

**Migration from manual eventing:**

```csharp
// ❌ Before (manual eventing subscription):
builder.Eventing.Subscribe<ResourceReadyEvent>(db.Resource, async (evt, ct) =>
{
    // Manual event handling with no type safety
    var cs = await db.Resource.ConnectionStringExpression.GetValueAsync(ct);
    // Process event...
});


// ✅ After (fluent extension methods):
var db = builder.AddMongoDB("mongo")
    .AddDatabase("db")
    .OnResourceReady(async (db, evt, ct) =>
    {
        // Direct access to strongly-typed resource
        var cs = await db.ConnectionStringExpression.GetValueAsync(ct);
        // Process event...
    });
```

The new extension methods make it much easier to implement common patterns like database seeding, configuration validation, and resource health checks. Note that the old mechanism is not being deprecated, the new methods simply provide a more natural programming model when using the builder pattern.

### 📁 Enhanced container file mounting

[Section titled “📁 Enhanced container file mounting”](#-enhanced-container-file-mounting)

Configuring container file systems often requires understanding complex Docker volume syntax and managing file permissions manually. Aspire 9.4 introduces enhanced file mounting APIs that handle common scenarios with sensible defaults.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Simple file copying from local source to container
var myContainer = builder.AddContainer("myapp", "myapp:latest")
    .WithContainerFiles("/app/config", "./config-files")
    .WithContainerFiles("/app/data", "./data", defaultOwner: 1000, defaultGroup: 1000)
    .WithContainerFiles("/app/scripts", "./scripts", umask: UnixFileMode.UserRead | UnixFileMode.UserWrite);


// You can also use the callback approach for dynamic file generation
var dynamicContainer = builder.AddContainer("worker", "worker:latest")
    .WithContainerFiles("/app/runtime-config", async (context, ct) =>
    {
        // Generate configuration files dynamically
        var configFile = new ContainerFileSystemItem
        {
            Name = "app.json",
            Contents = JsonSerializer.SerializeToUtf8Bytes(new { Environment = "Production" })
        };


        return new[] { configFile };
    });


builder.Build().Run();
```

The [enhanced APIs](https://aspire.dev/fundamentals/persist-data-volumes/) handle file permissions, ownership, and provide both static and dynamic file mounting capabilities while maintaining the flexibility to customize when needed.

### ✨ Advanced YARP routing with transform APIs (Preview)

[Section titled “✨ Advanced YARP routing with transform APIs (Preview)”](#-advanced-yarp-routing-with-transform-apis-preview)

Note

The [YARP integration](https://aspire.dev/integrations/reverse-proxies/yarp/) is currently in preview and APIs may change in future releases.

Building sophisticated reverse proxy configurations has traditionally required deep knowledge of YARP’s transform system and manual JSON configuration. Aspire 9.4 introduces a comprehensive set of fluent APIs that make advanced routing transformations accessible through strongly-typed C# code.

**Breaking change in 9.4:** The `WithConfigFile()` method has been removed and replaced with a code-based configuration model. This new approach works seamlessly with deployment scenarios as the strongly-typed configuration methods translate directly into the appropriate environment variables.

You can now programmatically configure request/response transformations, header manipulation, path rewriting, and query string handling directly from your app model—no more wrestling with complex configuration files.

**Example 1: Simple path-based routing with path prefix removal**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var apiV1 = builder.AddProject<Projects.ApiV1>("api-v1");
var apiV2 = builder.AddProject<Projects.ApiV2>("api-v2");


var yarp = builder.AddYarp("gateway")
    .WithConfiguration(yarpBuilder =>
    {
        // Route /v1/* requests to api-v1, removing the /v1 prefix
        yarpBuilder.AddRoute("/v1/{**catch-all}", apiV1)
            .WithTransformPathRemovePrefix("/v1");


        // Route /v2/* requests to api-v2, removing the /v2 prefix
        yarpBuilder.AddRoute("/v2/{**catch-all}", apiV2)
            .WithTransformPathRemovePrefix("/v2");
    });


builder.Build().Run();
```

**Example 2: Host-based routing**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var adminApi = builder.AddProject<Projects.AdminApi>("admin-api");
var publicApi = builder.AddProject<Projects.PublicApi>("public-api");


var yarp = builder.AddYarp("gateway")
    .WithConfiguration(yarpBuilder =>
    {
        // Route admin.example.com to admin API
        yarpBuilder.AddRoute(adminApi)
            .WithMatchHosts("admin.example.com");


        // Route api.example.com to public API
        yarpBuilder.AddRoute(publicApi)
            .WithMatchHosts("api.example.com");


        // Default route for any other host
        yarpBuilder.AddRoute("/{**catch-all}", publicApi);
    });


builder.Build().Run();
```

**Example 3: Advanced routing with comprehensive transforms**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var backendApi = builder.AddProject<Projects.BackendApi>("backend-api");
var identityService = builder.AddProject<Projects.Identity>("identity-service");


var yarp = builder.AddYarp("gateway")
    .WithConfiguration(yarpBuilder =>
    {
        // Configure sophisticated routing with transforms
        yarpBuilder.AddRoute("/api/v1/{**catch-all}", backendApi)
            .WithTransformPathPrefix("/v2")  // Rewrite /api/v1/* to /v2/*
            .WithTransformRequestHeader("X-API-Version", "2.0")
            .WithTransformForwarded(useHost: true, useProto: true)
            .WithTransformResponseHeader("X-Powered-By", "Aspire Gateway");


        // Advanced header and query manipulation
        yarpBuilder.AddRoute("/auth/{**catch-all}", identityService)
            .WithTransformClientCertHeader("X-Client-Cert")
            .WithTransformQueryValue("client_id", "aspire-app")
            .WithTransformRequestHeadersAllowed("Authorization", "Content-Type")
            .WithTransformUseOriginalHostHeader(false);
    });


builder.Build().Run();
```

#### Migration from YARP 9.3 to 9.4

[Section titled “Migration from YARP 9.3 to 9.4”](#migration-from-yarp-93-to-94)

If you were using `WithConfigFile()` in Aspire 9.3, you’ll need to migrate to the new code-based configuration model shown above. The strongly-typed APIs provide better IntelliSense support and work seamlessly with deployment scenarios.

Note

We are working on a more general-purpose solution for file-based configuration during deployment. File-based configuration support will return in a future version of Aspire.

This eliminates the need for complex YARP configuration files while providing complete access to YARP’s powerful transformation pipeline through a fluent API.

### 🔒 Enhanced Docker Compose deployment security

[Section titled “🔒 Enhanced Docker Compose deployment security”](#-enhanced-docker-compose-deployment-security)

Aspire 9.4 improves [Docker Compose publish](https://aspire.dev/deployment/overview/) security with smart port mapping - only external endpoints are exposed to the host while internal services use Docker’s internal networking.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var compose = builder.AddDockerComposeEnvironment("production");


// Add a service with both internal and external endpoints
var webService = builder.AddContainer("webservice", "nginx")
    .WithEndpoint(scheme: "http", port: 8080, name: "internal")       // Internal endpoint
    .WithEndpoint(scheme: "http", port: 8081, name: "api", isExternal: true); // External endpoint


builder.Build().Run();
```

**Generated Docker Compose output:**

```yaml
services:
  webservice:
    image: "nginx:latest"
    ports:
      - "8081:8001"    # Only external endpoints get port mappings (host:container)
    expose:
      - "8000"         # Internal endpoints use expose (container port only)
    networks:
      - "aspire"
```

Now, only `isExternal: true` endpoints are exposed to host, and internal endpoints use Docker’s `expose` for container-to-container communication.

## 🎨 Dashboard improvements

[Section titled “🎨 Dashboard improvements”](#-dashboard-improvements)

Tip

For a bite sized look at many of the 9.4 dashboard changes, James Newton-King has kept up his tradition of posting one new dashboard feature a day leading up to an Aspire release on his [BlueSky](https://bsky.app/profile/james.newtonking.com)!

### 🔔 Automatic upgrade check notifications

[Section titled “🔔 Automatic upgrade check notifications”](#-automatic-upgrade-check-notifications)

Aspire 9.4 includes an update notification system that automatically checks for newer versions and notifies developers when updates are available, making sure you stay current with the latest improvements and security updates.

When a newer version is detected, a friendly notification appears in the Aspire dashboard:

![Screenshot of dashboard showing an update notification.](/_astro/dashboard-update-notification.CbuDufvf_Z2mm2cn.webp)

Aspire only shows notifications when a newer version is available, and the checks happen in the background without impacting application startup or performance. The upgrade check system can be disabled by setting the `ASPIRE_VERSION_CHECK_DISABLED` environment variable to `true`. For more information, see [Aspire version update notifications](https://aspire.dev/app-host/configuration/#aspire-version-update-notifications).

### 📋 Parameters and connection strings visible in dashboard

[Section titled “📋 Parameters and connection strings visible in dashboard”](#-parameters-and-connection-strings-visible-in-dashboard)

Aspire 9.4 makes parameters and connection strings visible in the Aspire dashboard, providing better visibility into your application’s configuration and connectivity status during development.

Connection strings:

* Appear in the **resource details** panel for any resource that implements `Aspire.Hosting.ApplicationModel.IResourceWithConnectionString`
* Values are marked as **sensitive** and can be toggled for visibility in the dashboard
* Supports all resource types including databases, message brokers, and custom resources

![Screenshot of dashboard showing connection string.](/_astro/dashboard-connection-strings.Cl0PzzIP_1udGQa.webp)

External parameters are no longer hidden. The parameter state and value is visible in the dashboard.

![Screenshot of dashboard showing parameters.](/_astro/dashboard-parameters.BOYyVwzb_1ypxSm.webp)

For more information, see [external parameters](https://learn.microsoft.com/dotnet/aspire/fundamentals/external-parameters).

### 🔗 Enhanced dashboard peer visualization for uninstrumented resources

[Section titled “🔗 Enhanced dashboard peer visualization for uninstrumented resources”](#-enhanced-dashboard-peer-visualization-for-uninstrumented-resources)

Aspire 9.4 lets you observe connections between resources even when they aren’t instrumented with telemetry.

For example, the screenshot below shows a call to a GitHub model resolving to the model resource in Aspire:

![Screenshot of a span linked to a GitHub model resource defined in Aspire.](/_astro/dashboard-tracing-peers.B_MifMg3_Z1e5fAA.webp)

OpenTelemetry spans can now resolve to peers that are defined by parameters, connection strings, GitHub Models, and external services:

* **Connection string parsing** supports SQL Server, PostgreSQL, MySQL, MongoDB, Redis, and many other connection string formats
* **Visualize parameters** with URLs or connection strings and how they connect to services
* **GitHub Models integration** for GitHub-hosted AI models with proper state management
* **External service mapping** between your services and external dependencies

### 📋 Console logs text wrapping control

[Section titled “📋 Console logs text wrapping control”](#-console-logs-text-wrapping-control)

Aspire 9.4 introduces a new toggle option in the dashboard console logs to control text wrapping behavior, giving you better control over how long log lines are displayed.

![Recording of toggling line wrapping on console logs page.](/_astro/dashboard-console-logs-wrapping.CGls-NOj_2eCpRU.webp)

Some Aspire users have run into trouble with viewing large console logs, which is tracked in this GitHub issue: [Console logs not showing, plus browser window size affecting displayed logs #7969](https://github.com/dotnet/aspire/issues/7969). If you’re having trouble with logs please try experimenting with disabling wrapping and see whether it improves your user experience. Feedback on this issue would be very helpful.

### 👁️ Show/hide hidden resources in dashboard

[Section titled “👁️ Show/hide hidden resources in dashboard”](#️-showhide-hidden-resources-in-dashboard)

Aspire 9.4 introduces the ability to show or hide hidden resources in the dashboard, giving you complete visibility into your application’s infrastructure components and internal resources that are normally hidden from view.

![Dashboard resources page with the show/hide hidden resources UI visible.](/_astro/dashboard-hidden-resources.CwZCw6vv_2nAfHO.webp)

If there are no hidden resources in your Aspire app then the show/hide UI is disabled.

### 🏗️ Enhanced dashboard infrastructure with proxied endpoints

[Section titled “🏗️ Enhanced dashboard infrastructure with proxied endpoints”](#️-enhanced-dashboard-infrastructure-with-proxied-endpoints)

Aspire 9.4 introduces significant infrastructure improvements to the dashboard system, implementing proxied endpoints that make dashboard launching more reliable and avoiding port reuse problems. This architectural enhancement resolves issues with dashboard connectivity during application startup and shutdown scenarios. The UI when the dashboard is attempting to reconnect has also been updated to be more reliable and with a new cohesive look and animation.

### 🐳 Docker Compose with integrated Aspire Dashboard

[Section titled “🐳 Docker Compose with integrated Aspire Dashboard”](#-docker-compose-with-integrated-aspire-dashboard)

Managing observability in Docker Compose environments often requires running separate monitoring tools or losing the rich insights that Aspire provides during development. Aspire 9.4 introduces native Aspire Dashboard integration for Docker Compose environments.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var compose = builder.AddDockerComposeEnvironment("production")
                    .WithDashboard(dashboard => dashboard.WithHostPort(8080)); // Configure dashboard with specific port


// Add services that will automatically report to the dashboard
builder.AddProject<Projects.Frontend>("frontend");
builder.AddProject<Projects.Api>("api");


builder.Build().Run();
```

## 🔗 Updated integrations

[Section titled “🔗 Updated integrations”](#-updated-integrations)

### 🐙 GitHub Models integration

[Section titled “🐙 GitHub Models integration”](#-github-models-integration)

Aspire 9.4 introduces support for [GitHub Models](https://docs.github.com/en/github-models), enabling easy integration with AI models hosted on GitHub’s platform. This provides a simple way to incorporate AI capabilities into your applications using GitHub’s model hosting service.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add GitHub Model - API key parameter is automatically created
var model = builder.AddGitHubModel("chat-model", "gpt-4o-mini");


// You can also specify an API key explicitly if needed
var apiKey = builder.AddParameter("github-api-key", secret: true);
var explicitModel = builder.AddGitHubModel("explicit-chat", "gpt-4o-mini")
    .WithApiKey(apiKey);


// Use the model in your services
var chatService = builder.AddProject<Projects.ChatService>("chat")
    .WithReference(model);


builder.Build().Run();
```

The [GitHub Models integration](https://aspire.dev/integrations/ai/github-models/) provides:

* **Simple model integration** with GitHub’s hosted AI models
* **Automatic API key parameter creation** with the pattern `{name}-gh-apikey`
* **Explicit API key support** using `WithApiKey()` for custom scenarios
* **GITHUB\_TOKEN fallback** when no explicit API key is provided
* **Built-in health checks** for model availability

### 🤖 Azure AI Foundry integration

[Section titled “🤖 Azure AI Foundry integration”](#-azure-ai-foundry-integration)

Aspire 9.4 introduces comprehensive [Azure AI Foundry](https://ai.azure.com/) support, bringing enterprise AI capabilities directly into your distributed applications. This integration simplifies working with AI models and deployments through the Azure AI platform, supporting both Azure-hosted deployments and local development with [Foundry Local](https://github.com/microsoft/Foundry-Local).

#### Hosting configuration

[Section titled “Hosting configuration”](#hosting-configuration)

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Azure AI Foundry project
var foundry = builder.AddAzureAIFoundry("foundry");


// Add specific model deployments
var chat = foundry.AddDeployment("chat", "qwen2.5-0.5b", "1", "Microsoft");
var embedding = foundry.AddDeployment("embedding", "text-embedding-ada-002", "2", "OpenAI");


// Connect your services to AI capabilities
var webService = builder.AddProject<Projects.WebService>("webservice")
    .WithReference(chat)
    .WaitFor(chat);


builder.Build().Run();
```

##### Azure AI Foundry Local support

[Section titled “Azure AI Foundry Local support”](#azure-ai-foundry-local-support)

[Azure AI Foundry Local](https://learn.microsoft.com/azure/ai-foundry/foundry-local/) is an on-device AI inference solution that runs models locally on your hardware, providing performance, privacy, and cost advantages without requiring an Azure subscription. It’s ideal for scenarios requiring data privacy, offline operation, cost reduction, or low-latency responses.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// For local development, run with Foundry Local
var localFoundry = builder.AddAzureAIFoundry("foundry")
    .RunAsFoundryLocal()
    .AddDeployment("chat", "phi-3.5-mini", "1", "Microsoft");


var webService = builder.AddProject<Projects.WebService>("webservice")
    .WithReference(localFoundry)
    .WaitFor(localFoundry);


builder.Build().Run();
```

#### Client integration

[Section titled “Client integration”](#client-integration)

Once you’ve configured the [Azure AI Foundry resource](https://aspire.dev/integrations/cloud/azure/azure-ai-foundry/) in your AppHost, consume it in your services using the [Azure AI Inference SDK](https://aspire.dev/integrations/cloud/azure/azure-ai-inference/) or [OpenAI SDK](https://aspire.dev/integrations/cloud/azure/azure-openai/) for compatible models:

**Using Azure AI Inference SDK:**

```csharp
// In Program.cs
var builder = WebApplication.CreateBuilder(args);


builder.AddAzureChatCompletionsClient("chat")
       .AddChatClient();


var app = builder.Build();


// Minimal API endpoint for chat completion
app.MapPost("/generate", async (IChatClient chatClient, ChatRequest request) =>
{
    var messages = new List<ChatMessage>
    {
        new(ChatRole.System, "You are a helpful assistant."),
        new(ChatRole.User, request.Prompt)
    };


    var response = await chatClient.GetResponseAsync(messages);
    return Results.Ok(new { Response = response.Text });
});


app.Run();


public record ChatRequest(string Prompt);
```

**Using OpenAI SDK (for compatible models):**

```csharp
// In Program.cs
var builder = WebApplication.CreateBuilder(args);


builder.AddOpenAIClient("chat")
       .AddChatClient();


// Usage is identical to the Azure AI Inference SDK example above
```

**Key differences between Azure AI Foundry and Foundry Local:**

* **Azure AI Foundry** - Cloud-hosted models with enterprise-grade scaling, supports all Azure AI model deployments
* **Foundry Local** - On-device inference with different model selection optimized for local hardware, no Azure subscription required

The `RunAsFoundryLocal()` method enables local development scenarios using [Azure AI Foundry Local](https://learn.microsoft.com/azure/ai-foundry/foundry-local/), allowing you to test AI capabilities without requiring cloud resources during development. This supports automatic model downloading, loading, and management through the integrated Foundry Local runtime.

### 🗄️ Database hosting improvements

[Section titled “🗄️ Database hosting improvements”](#️-database-hosting-improvements)

Several database integrations have been updated with **improved initialization patterns**:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// MongoDB - new WithInitFiles method (replaces WithInitBindMount)
var mongo = builder.AddMongoDB("mongo")
    .WithInitFiles("./mongo-init");  // Initialize with scripts


// MySQL - improved initialization with better file handling
var mysql = builder.AddMySql("mysql", password: builder.AddParameter("mysql-password"))
    .WithInitFiles("./mysql-init");  // Initialize with SQL scripts


// Oracle - enhanced setup capabilities with consistent API
var oracle = builder.AddOracle("oracle")
    .WithInitFiles("./oracle-init");  // Initialize with Oracle scripts


builder.Build().Run();
```

All database providers now support `WithInitFiles()` method, replacing the more complex `WithInitBindMount()` method and enabling better error handling.

## ☁️ Azure goodies

[Section titled “☁️ Azure goodies”](#️-azure-goodies)

### 🏷️ Consistent resource name exposure

[Section titled “🏷️ Consistent resource name exposure”](#️-consistent-resource-name-exposure)

Aspire 9.4 now consistently exposes the actual names of all Azure resources through the `NameOutputReference` property. This enables applications to access the real Azure resource names that get generated during deployment, which is essential for scenarios requiring direct Azure resource coordination. This is particularly valuable for external automation scripts and monitoring and alerting systems that reference resources by their actual names.

### 🗄️ Azure Cosmos DB

[Section titled “🗄️ Azure Cosmos DB”](#️-azure-cosmos-db)

#### Hierarchical partition keys

[Section titled “Hierarchical partition keys”](#hierarchical-partition-keys)

Aspire 9.4 introduces support for **hierarchical partition keys** (subpartitioning) in Azure Cosmos DB, enabling multi-level partitioning for better data distribution and query performance.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var cosmos = builder.AddAzureCosmosDB("cosmos");
var database = cosmos.AddCosmosDatabase("ecommerce");


// Traditional single partition key
var ordersContainer = database.AddContainer("orders", "/customerId");


// New hierarchical partition keys (up to 3 levels)
var productsContainer = database.AddContainer("products",
    ["/category", "/subcategory", "/brand"]);


// Multi-tenant scenario
var eventsContainer = database.AddContainer("events",
    ["/tenantId", "/userId", "/sessionId"]);


builder.Build().Run();
```

**Key benefits:**

* **Scale beyond 20GB per logical partition** through multi-level distribution
* **Improved query performance** with efficient routing to relevant partitions
* **Better data distribution** for multi-dimensional datasets
* **Enhanced scalability** up to 10,000+ RU/s per logical partition prefix

For detailed guidance on design patterns and best practices, see the [Azure Cosmos DB hierarchical partition keys documentation](https://learn.microsoft.com/azure/cosmos-db/hierarchical-partition-keys).

#### Serverless support

[Section titled “Serverless support”](#serverless-support)

Azure Cosmos DB accounts now default to serverless mode for cost optimization with consumption-based billing.

```csharp
// Default behavior: Creates serverless account (new in 9.4)
var cosmos = builder.AddAzureCosmosDB("cosmos");


// Explicitly enable provisioned throughput mode
var provisionedCosmos = builder.AddAzureCosmosDB("cosmos")
    .WithDefaultAzureSku(); // Uses provisioned throughput instead of serverless
```

**Serverless benefits:**

* **Pay-per-use** - Only charged for consumed Request Units and storage
* **No minimum costs** - Ideal for intermittent or unpredictable workloads
* **Automatic scaling** - No capacity planning required
* **Perfect for development/testing** environments

**Use serverless for:** Variable workloads, development/testing, applications with low average-to-peak traffic ratios.\
**Use provisioned throughput for:** Sustained traffic requiring predictable performance guarantees.

For detailed comparison and limits, see [Azure Cosmos DB serverless documentation](https://learn.microsoft.com/azure/cosmos-db/serverless).

### 🆔 Consistent user-assigned managed identity support

[Section titled “🆔 Consistent user-assigned managed identity support”](#-consistent-user-assigned-managed-identity-support)

Aspire 9.4 introduces comprehensive support for Azure user-assigned managed identities, providing enhanced security and consistent identity management across your Azure infrastructure:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Create a user-assigned managed identity
var appIdentity = builder.AddAzureUserAssignedIdentity("app-identity");


// Create the container app environment
var containerEnv = builder.AddAzureContainerAppEnvironment("container-env");


// Apply the identity to compute resources
var functionApp = builder.AddAzureFunctionsProject<Projects.Functions>("functions")
    .WithAzureUserAssignedIdentity(appIdentity);


// The identity can be shared across multiple resources
var webApp = builder.AddProject<Projects.WebApp>("webapp")
    .WithAzureUserAssignedIdentity(appIdentity);


// Use the same identity for accessing Azure services
var keyVault = builder.AddAzureKeyVault("secrets");
var storage = builder.AddAzureStorage("storage");


// Services using the shared identity can access resources securely
var processor = builder.AddProject<Projects.DataProcessor>("processor")
    .WithAzureUserAssignedIdentity(appIdentity)
    .WithReference(keyVault)
    .WithReference(storage);


builder.Build().Run();
```

This approach provides:

* **Flexible identity control** - Override Aspire’s secure defaults when you need specific identity configurations
* **Consistent identity management** across all compute resources

#### 🔐 Disabled local authentication to enforce managed identity

[Section titled “🔐 Disabled local authentication to enforce managed identity”](#-disabled-local-authentication-to-enforce-managed-identity)

Aspire 9.4 automatically disables local authentication for [Azure EventHubs](https://aspire.dev/integrations/cloud/azure/azure-event-hubs/) and [Azure Web PubSub](https://aspire.dev/integrations/cloud/azure/azure-web-pubsub/) resources, enforcing managed identity authentication by default.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Azure EventHubs with automatic local auth disabled
var eventHubs = builder.AddAzureEventHubs("eventhubs");
var hub = eventHubs.AddEventHub("orders");


// Azure Web PubSub with automatic local auth disabled
var webPubSub = builder.AddAzureWebPubSub("webpubsub");


// Services connect using managed identity automatically
var processor = builder.AddProject<Projects.EventProcessor>("processor")
    .WithReference(hub)
    .WithReference(webPubSub);


builder.Build().Run();
```

This change automatically applies to all Azure EventHubs and Web PubSub resources, ensuring secure-by-default behavior.

### 🔐 Azure Key Vault enhancements

[Section titled “🔐 Azure Key Vault enhancements”](#-azure-key-vault-enhancements)

Aspire 9.4 introduces significant improvements to the [Azure Key Vault integration](https://aspire.dev/integrations/cloud/azure/azure-key-vault/) with new secret management APIs that provide strongly typed access to secrets:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var secrets = builder.AddAzureKeyVault("secrets");


// Add a secret from a parameter
var connectionStringParam = builder.AddParameter("connectionString", secret: true);
var connectionString = secrets.AddSecret("connection-string", connectionStringParam);


// Add a secret with custom secret name in Key Vault
var apiKeyParam = builder.AddParameter("api-key", secret: true);
var apiKey = secrets.AddSecret("api-key", "ApiKey", apiKeyParam);


// Get a secret reference for consumption (for existing secrets)
var existingSecret = secrets.GetSecret("ExistingSecret");


// Use in your services
var webApi = builder.AddProject<Projects.WebAPI>("webapi")
    .WithEnvironment("CONNECTION_STRING", connectionString)
    .WithEnvironment("API_KEY", apiKey)
    .WithEnvironment("EXISTING_SECRET", existingSecret);
```

**Key features**:

* `Aspire.Hosting.AzureKeyVaultResourceExtensions.AddSecret*` method for adding new secrets to Key Vault from parameters or expressions
* `Aspire.Hosting.Azure.AzureKeyVaultResource.GetSecret*` method for referencing existing secrets in Key Vault
* **Strongly-typed secret references** that can be used with `WithEnvironment()` for environment variables
* **Custom secret naming** support with optional `secretName` parameter

#### 📥Resource Deep Linking for Azure Storage Queues

[Section titled “📥Resource Deep Linking for Azure Storage Queues”](#resource-deep-linking-for-azure-storage-queues)

Aspire 9.4 expands resource deep linking to include Azure Queue Storage queues, building on the model already used for Azure Blob Storage, Cosmos DB, etc.

You can now model individual storage queues directly in your AppHost, then inject scoped QueueClient instances into your services—making it easy to interact with queues without manually configuring connection strings or access.

**AppHost:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var storage = builder.AddAzureStorage("storage");


// Model individual queues as first-class resources
var orderQueue = storage.AddQueue("orders", "order-processing");
var notificationQueue = storage.AddQueue("notifications", "user-notifications");


// Services get scoped access to specific queues
builder.AddProject<Projects.OrderProcessor>("order-processor")
       .WithReference(orderQueue);  // Only has access to order-processing queue


builder.AddProject<Projects.NotificationService>("notifications")
       .WithReference(notificationQueue);  // Only has access to user-notifications queue


builder.Build().Run();
```

**In the OrderProcessor project:**

```csharp
using Azure.Storage.Queues;


var builder = WebApplication.CreateBuilder(args);


// Register the queue client
builder.AddAzureQueue("orders");


var app = builder.Build();


// Minimal POST endpoint for image upload
app.MapPost("/process-order", async (QueueClient ordersQueue) =>
{
    // read a message for the queue
    var message = await ordersQueue.ReceiveMessageAsync();
    ProcessMessage(message);


    return Results.Ok();
});


app.Run();
```

This approach provides clean separation of concerns, secure container scoping, and minimal ceremony—ideal for microservices that interact with specific storage queues.

### 📡 OpenTelemetry tracing support for Azure App Configuration

[Section titled “📡 OpenTelemetry tracing support for Azure App Configuration”](#-opentelemetry-tracing-support-for-azure-app-configuration)

Aspire 9.4 introduces **OpenTelemetry tracing support** for [Azure App Configuration](https://aspire.dev/integrations/cloud/azure/azure-app-configuration/), completing the observability story for this integration. The Azure App Configuration integration now automatically instruments configuration retrieval operations and refresh operations with distributed tracing.

```csharp
var builder = WebApplication.CreateBuilder(args);


// Azure App Configuration now includes automatic tracing
builder.AddAzureAppConfiguration("config", settings =>
{
    settings.Endpoint = new Uri("https://myconfig.azconfig.io");
    // Tracing is enabled by default - traces configuration operations
});


// Optionally disable tracing for specific scenarios
builder.AddAzureAppConfiguration("sensitive-config", settings =>
{
    settings.DisableTracing = true; // Disable OpenTelemetry tracing
});


var app = builder.Build();
```

**What gets traced:**

* **Configuration retrieval operations** - When configuration values are loaded from Azure App Configuration
* **Configuration refresh operations** - When the configuration is refreshed in the background
* **Activity source**: `Microsoft.Extensions.Configuration.AzureAppConfiguration` - for filtering and correlation

Tracing can be disabled using `DisableTracing = true` for sensitive scenarios.

This enhancement brings Azure App Configuration in line with other Azure components that support comprehensive observability, providing developers with better insights into configuration-related performance and behavior.

### ⚙️ Enhanced Azure provisioning interaction

[Section titled “⚙️ Enhanced Azure provisioning interaction”](#️-enhanced-azure-provisioning-interaction)

Aspire 9.4 significantly improves the Azure provisioning experience by leveraging the interaction services to streamline Azure subscription and resource group configuration during deployment workflows.

The enhanced Azure provisioning system:

* **Automatically prompts for missing Azure configuration** during deploy operations
* **Saves configuration to user secrets** for future deployments
* **Provides smart defaults** like auto-generated resource group names
* **Includes validation callbacks** for Azure-specific inputs like subscription IDs and locations
* **Supports rich HTML prompts** with links to create free Azure accounts

This enhancement makes Azure deployment significantly more user-friendly, especially for developers new to Azure or setting up projects for the first time. The interaction system ensures that all necessary Azure configuration is collected interactively and stored securely for subsequent deployments.

### 🐳 Azure App Service container support

[Section titled “🐳 Azure App Service container support”](#-azure-app-service-container-support)

Aspire 9.4 introduces support for deploying containerized applications with Dockerfiles to Azure App Service environments. This enables a seamless transition from local container development to Azure App Service deployment.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Create an Azure App Service environment
builder.AddAzureAppServiceEnvironment("app-service-env");


// Add a containerized project with Dockerfile
var containerApp = builder.AddContainer("my-app", "my-app:latest")
    .WithDockerfile("./Dockerfile");


// Or add a project that builds to a container
var webApp = builder.AddProject<Projects.WebApp>("webapp");


builder.Build().Run();
```

This feature bridges the gap between container development and Azure App Service deployment, allowing developers to use the same container-based workflows they use locally in production Azure environments.

### 🏗️ Improvements to the Azure Container Apps integration

[Section titled “🏗️ Improvements to the Azure Container Apps integration”](#️-improvements-to-the-azure-container-apps-integration)

Managing complex Azure Container Apps environments often requires integrating with existing Azure resources like Log Analytics workspaces. Aspire 9.4 enhances the [Container Apps integration](https://aspire.dev/integrations/cloud/azure/configure-container-apps/) with support for existing Azure resources and improved configuration.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Reference existing Log Analytics workspace
var workspaceName = builder.AddParameter("workspace-name");
var workspaceRg = builder.AddParameter("workspace-rg");


var logWorkspace = builder.AddAzureLogAnalyticsWorkspace("workspace")
                          .AsExisting(workspaceName, workspaceRg);


var containerEnv = builder.AddAzureContainerAppEnvironment("production")
                          .WithAzureLogAnalyticsWorkspace(logWorkspace);


builder.AddProject<Projects.Api>("api")
       .WithComputeEnvironment(containerEnv);


builder.Build().Run();
```

This also helps manage cost control by reusing existing resources like Log Analytics.

#### 🛡️ Automatic DataProtection configuration for .NET on ACA

[Section titled “🛡️ Automatic DataProtection configuration for .NET on ACA”](#️-automatic-dataprotection-configuration-for-net-on-aca)

Aspire 9.4 automatically configures DataProtection for .NET projects deployed to Azure Container Apps, ensuring applications work correctly when scaling beyond a single instance.

When ASP.NET Core applications scale to multiple instances, they need shared DataProtection keys to decrypt cookies, authentication tokens, and other protected data across all instances. Without proper configuration, users experience authentication issues and data corruption when load balancers route requests to different container instances.

Aspire now automatically enables `autoConfigureDataProtection` for all .NET projects deployed to Azure Container Apps:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureContainerAppEnvironment("production");


// DataProtection is automatically configured for scaling
var api = builder.AddProject<Projects.WebApi>("api");


var frontend = builder.AddProject<Projects.BlazorApp>("frontend");


builder.Build().Run();
```

This enhancement aligns Aspire-generated deployments with Azure Developer CLI (`azd`) behavior and resolves common production scaling issues without requiring manual DataProtection configuration.

### ⚡ Azure Functions Container Apps integration

[Section titled “⚡ Azure Functions Container Apps integration”](#-azure-functions-container-apps-integration)

Aspire 9.4 improves Azure Functions deployment to Azure Container Apps by automatically setting the correct function app kind. This ensures Azure Functions are properly recognized and managed within the Azure Container Apps environment.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


builder.AddAzureContainerAppEnvironment("functions-env");


// Azure Functions project deployed to Container Apps
var functionsApp = builder.AddAzureFunctionsProject<Projects.MyFunctions>("functions");


builder.Build().Run();
```

This change resolves issues where Azure Functions deployed to Container Apps weren’t properly recognized by Azure tooling and monitoring systems, providing a more seamless serverless experience.

## 📋 Project template improvements

[Section titled “📋 Project template improvements”](#-project-template-improvements)

Aspire 9.4 introduces enhancements to project templates, including .NET 10 support and improved file naming conventions.

### 🚀 .NET 10 framework support

[Section titled “🚀 .NET 10 framework support”](#-net-10-framework-support)

All Aspire project templates now support .NET 10 with framework selection. .NET 9.0 remains the default target framework.

```bash
# Create a new Aspire project targeting .NET 10
dotnet new aspire --framework net10.0


# Create an AppHost project targeting .NET 10
dotnet new aspire-apphost --framework net10.0
```

### 📝 Improved file naming convention

[Section titled “📝 Improved file naming convention”](#-improved-file-naming-convention)

The `aspire-apphost` template now uses a more descriptive file naming convention making it easier to distinguish AppHost files in multi-project solutions. Instead of `Program.cs`, the main program file is now named `AppHost.cs`.

The content and functionality remain unchanged — only the filename has been updated to be more descriptive.

## 💔 Breaking changes

[Section titled “💔 Breaking changes”](#-breaking-changes)

### 🔑 Azure Key Vault secret reference changes

[Section titled “🔑 Azure Key Vault secret reference changes”](#-azure-key-vault-secret-reference-changes)

Azure Key Vault secret handling has been updated with improved APIs that provide better type safety and consistency:

```csharp
// ❌ Before (obsolete):
var keyVault = builder.AddAzureKeyVault("secrets");
var secretOutput = keyVault.GetSecretOutput("ApiKey");           // Obsolete
var secretRef = new BicepSecretOutputReference(secretOutput);    // Obsolete - class removed


// ✅ After (recommended):
var keyVault = builder.AddAzureKeyVault("secrets");
var secretRef = keyVault.GetSecret("ApiKey");                    // New strongly-typed API


// For environment variables:
// ❌ Before (obsolete):
builder.AddProject<Projects.Api>("api")
       .WithEnvironment("API_KEY", secretRef);  // Using BicepSecretOutputReference


// ✅ After (recommended):
builder.AddProject<Projects.Api>("api")
       .WithEnvironment("API_KEY", secretRef);  // Using IAzureKeyVaultSecretReference
```

**Migration impact**: Replace `GetSecretOutput()` and `BicepSecretOutputReference` usage with the new `GetSecret()` method that returns `IAzureKeyVaultSecretReference`.

### 📦 Azure Storage blob container creation changes

[Section titled “📦 Azure Storage blob container creation changes”](#-azure-storage-blob-container-creation-changes)

Azure Storage blob container creation has been moved from specialized blob storage resources to the main storage resource for better consistency:

```csharp
// ❌ Before (obsolete):
var storage = builder.AddAzureStorage("storage");
var blobs = storage.AddBlobs("blobs");
var container = blobs.AddBlobContainer("images");     // Obsolete


// ✅ After (recommended):
var storage = builder.AddAzureStorage("storage");
var container = storage.AddBlobContainer("images");   // Direct on storage resource
```

**Migration impact**: Use `AddBlobContainer()` directly on `AzureStorageResource` instead of on specialized blob storage resources.

### 🔐 Keycloak realm import simplification

[Section titled “🔐 Keycloak realm import simplification”](#-keycloak-realm-import-simplification)

The `WithRealmImport` method signature has been **simplified by removing the confusing `isReadOnly` parameter**:

```csharp
// ❌ Before (deprecated):
var keycloak = builder.AddKeycloak("keycloak")
    .WithRealmImport("./realm.json", isReadOnly: false);  // Confusing parameter


// ✅ After (recommended):
var keycloak = builder.AddKeycloak("keycloak")
    .WithRealmImport("./realm.json");  // Clean, simple API


// If you need explicit read-only control:
var keycloak = builder.AddKeycloak("keycloak")
    .WithRealmImport("./realm.json", isReadOnly: true);  // Still available as overload
```

**Migration impact**: Remove the `isReadOnly` parameter from single-parameter `WithRealmImport()` calls - the method now defaults to appropriate behavior. Use the two-parameter overload if explicit control is needed.

### 🔧 Milvus configuration method updates

[Section titled “🔧 Milvus configuration method updates”](#-milvus-configuration-method-updates)

Milvus configuration has been updated with more descriptive method names:

```csharp
// ❌ Before (deprecated):
var milvus = builder.AddMilvus("milvus")
    .WithConfigurationBindMount("./milvus.yaml");  // Old method name


// ✅ After (recommended):
var milvus = builder.AddMilvus("milvus")
    .WithConfigurationFile("./milvus.yaml");  // Method renamed for clarity
```

**Migration impact**: Update method calls to use `WithConfigurationFile` instead of `WithConfigurationBindMount` for Milvus configuration.

### 🔄 Azure Storage client registration updates

[Section titled “🔄 Azure Storage client registration updates”](#-azure-storage-client-registration-updates)

Client registration methods for Azure Storage have been standardized with new naming conventions:

```csharp
// ❌ Before (obsolete):
builder.AddAzureTableClient("tables");         // Obsolete
builder.AddKeyedAzureTableClient("tables");    // Obsolete
builder.AddAzureBlobClient("blobs");            // Obsolete
builder.AddKeyedAzureBlobClient("blobs");       // Obsolete
builder.AddAzureQueueClient("queues");          // Obsolete
builder.AddKeyedAzureQueueClient("queues");     // Obsolete


// ✅ After (recommended):
builder.AddAzureTableServiceClient("tables");         // Standardized naming
builder.AddKeyedAzureTableServiceClient("tables");    // Standardized naming
builder.AddAzureBlobServiceClient("blobs");           // Standardized naming
builder.AddKeyedAzureBlobServiceClient("blobs");      // Standardized naming
builder.AddAzureQueueServiceClient("queues");         // Standardized naming
builder.AddKeyedAzureQueueServiceClient("queues");    // Standardized naming
```

**Migration impact**: Update all client registration calls to use the new `*ServiceClient` naming convention.

### 🗄️ Database initialization method changes

[Section titled “🗄️ Database initialization method changes”](#️-database-initialization-method-changes)

Several database resources have **deprecated `WithInitBindMount` in favor of the more consistent `WithInitFiles`**:

```csharp
// ❌ Before (deprecated):
var mongo = builder.AddMongoDB("mongo")
    .WithInitBindMount("./init", isReadOnly: true);  // Complex parameters


var mysql = builder.AddMySql("mysql")
    .WithInitBindMount("./mysql-scripts", isReadOnly: false);


var oracle = builder.AddOracle("oracle")
    .WithInitBindMount("./oracle-init", isReadOnly: true);


var postgres = builder.AddPostgres("postgres")
    .WithInitBindMount("./postgres-init", isReadOnly: true);


// ✅ After (recommended):
var mongo = builder.AddMongoDB("mongo")
    .WithInitFiles("./init");  // Simplified, consistent API


var mysql = builder.AddMySql("mysql")
    .WithInitFiles("./mysql-scripts");  // Same pattern across all providers


var oracle = builder.AddOracle("oracle")
    .WithInitFiles("./oracle-init");  // Unified approach


var postgres = builder.AddPostgres("postgres")
    .WithInitFiles("./postgres-init");  // Consistent across all databases
```

**Affected database providers**: MongoDB, MySQL, Oracle, and PostgreSQL

**Migration impact**: Replace `WithInitBindMount()` calls with `WithInitFiles()` - the new method handles read-only mounting automatically and provides better error handling.

### Resource lifecycle event updates

[Section titled “Resource lifecycle event updates”](#resource-lifecycle-event-updates)

The generic `AfterEndpointsAllocatedEvent` has been deprecated in favor of more specific, type-safe events:

```csharp
// ❌ Before (deprecated):
builder.Services.AddSingleton<IDistributedApplicationLifecycleHook, MyLifecycleHook>();


public class MyLifecycleHook : IDistributedApplicationLifecycleHook
{
    public Task AfterEndpointsAllocatedAsync(DistributedApplicationModel appModel, CancellationToken cancellationToken)
    {
        // Generic event handling - deprecated
        return Task.CompletedTask;
    }
}


// ✅ After (recommended):
var api = builder.AddProject<Projects.Api>("api")
    .OnBeforeResourceStarted(async (resource, evt, cancellationToken) =>
    {
        // Resource-specific event handling
    })
    .OnResourceEndpointsAllocated(async (resource, evt, cancellationToken) =>
    {
        // Endpoint-specific event handling
    });
```

**Migration impact**: Replace usage of `AfterEndpointsAllocatedEvent` with resource-specific lifecycle events like `OnBeforeResourceStarted` or `OnResourceEndpointsAllocated` for better type safety and clarity.

### 🧊 Azure Container Apps hybrid mode removal

[Section titled “🧊 Azure Container Apps hybrid mode removal”](#-azure-container-apps-hybrid-mode-removal)

Azure Container Apps hybrid mode support has been **removed** to simplify the deployment model and improve consistency. Previously, `PublishAsAzureContainerApp` would automatically create Azure infrastructure, but this behavior has been streamlined.

```csharp
// ❌ Before (hybrid mode - no longer supported):
// In hybrid mode, this would automatically add Azure Container Apps infrastructure
var api = builder.AddProject<Projects.Api>("api")
    .PublishAsAzureContainerApp((infrastructure, containerApp) =>
    {
        app.Template.Scale.MinReplicas = 0;
    });


// The hybrid approach mixed azd-generated environments with Aspire-managed infrastructure
// This caused confusion and maintenance complexity


// ✅ After (required approach):
// Explicitly add Azure Container App Environment first
var containerAppEnvironment = builder.AddAzureContainerAppEnvironment("cae");


// When coming from hybrid mode, the names of the resources will change
// WithAzdResourceNaming will keep the older naming convention that azd uses
// while making this transition to aspire owned infrastructure.
containerAppEnvironment.WithAzdResourceNaming();


// Then use PublishAsAzureContainerApp for customization only (same API)
var api = builder.AddProject<Projects.Api>("api")
    .PublishAsAzureContainerApp((infrastructure, containerApp) =>
    {
        app.Template.Scale.MinReplicas = 0;
    });
```

**Key changes:**

* `PublishAsAzureContainerApp()` **no longer automatically creates infrastructure** - it only adds customization annotations
* **BicepSecretOutput APIs have been removed** from the Azure Container Apps logic for simplified secret handling

**Migration impact:**

1. **Add explicit Azure Container App Environment**: Use `builder.AddAzureContainerAppEnvironment("name")` before calling `PublishAsAzureContainerApp()`
2. **Update secret references**: Replace any `BicepSecretOutputReference` usage with proper Azure Key Vault resources using `IAzureKeyVaultSecretReference`
3. **Review infrastructure setup**: Ensure your Bicep templates or infrastructure setup properly creates the Container App Environment that your apps will deploy to

This change provides **clearer separation** between infrastructure provisioning (handled by explicit resource creation) and application deployment configuration (handled by `PublishAsAzureContainerApp`), making the deployment process more predictable and easier to understand.

### ⚠️ Known parameter deprecations

[Section titled “⚠️ Known parameter deprecations”](#️-known-parameter-deprecations)

Several auto-injected known parameters have been deprecated and removed from Azure resources in favor of explicit resource modeling:

**Deprecated parameters:**

* `AzureBicepResource.KnownParameters.KeyVaultName`
* `AzureBicepResource.KnownParameters.LogAnalyticsWorkspaceId`

#### KeyVaultName parameter deprecation

[Section titled “KeyVaultName parameter deprecation”](#keyvaultname-parameter-deprecation)

The `AzureBicepResource.KnownParameters.KeyVaultName` parameter is now obsolete. Previously, this parameter was automatically injected into Azure resources to reference Key Vault instances for storing secrets.

```csharp
// ❌ Before (deprecated):
var customResource = builder.AddAzureInfrastructure("custom", infra =>
{
    // Custom Bicep template that expected keyVaultName parameter to be auto-filled
    var kvNameParam = new ProvisioningParameter(AzureBicepResource.KnownParameters.KeyVaultName, typeof(string));
    infra.Add(kvNameParam);


    var keyVault = KeyVaultService.FromExisting("keyVault");
    keyVault.Name = kvNameParam;  // This was auto-populated by Aspire
    infra.Add(keyVault);


    // Store secrets in the auto-injected Key Vault
    var secret = new KeyVaultSecret("mySecret", keyVault)
    {
        Properties = { Value = "sensitive-value" }
    };
    infra.Add(secret);
});


// ✅ After (recommended):
var keyVault = builder.AddAzureKeyVault("secrets");
var customResource = builder.AddAzureInfrastructure("custom", infra =>
{
    // Use explicit Key Vault resource reference
    var existingKeyVault = (KeyVaultService)keyVault.Resource.AddAsExistingResource(infra);


    var secret = new KeyVaultSecret("mySecret", existingKeyVault)
    {
        Properties = { Value = "sensitive-value" }
    };
    infra.Add(secret);
});
```

#### LogAnalyticsWorkspaceId parameter deprecation

[Section titled “LogAnalyticsWorkspaceId parameter deprecation”](#loganalyticsworkspaceid-parameter-deprecation)

The `AzureBicepResource.KnownParameters.LogAnalyticsWorkspaceId` parameter is now obsolete. Application Insights resources will now automatically create their own Log Analytics workspace or use explicitly provided ones.

```csharp
// ❌ Before (deprecated):
var appInsights = builder.AddAzureApplicationInsights("ai")
    .WithParameter(AzureBicepResource.KnownParameters.LogAnalyticsWorkspaceId, workspaceId);


// ✅ After (recommended):
// Option 1: Auto-generated workspace (default behavior)
var appInsights = builder.AddAzureApplicationInsights("ai");


// Option 2: Explicit workspace resource
var workspace = builder.AddAzureLogAnalyticsWorkspace("workspace");
var appInsights = builder.AddAzureApplicationInsights("ai")
    .WithLogAnalyticsWorkspace(workspace);


// Option 3: Reference existing workspace from another resource
var env = builder.AddAzureContainerAppEnvironment("env");
var appInsights = builder.AddAzureApplicationInsights("ai")
    .WithLogAnalyticsWorkspace(env.GetOutput("AZURE_LOG_ANALYTICS_WORKSPACE_ID"));
```

#### Container App Environment parameter changes

[Section titled “Container App Environment parameter changes”](#container-app-environment-parameter-changes)

Previously, container app environment properties (managed identity, workspace ID) were automatically injected into other Azure resources. These are no longer auto-injected as Aspire now supports multiple compute environments.

```csharp
// ❌ Before (auto-injection):
// These properties were automatically available in other resources:
// - MANAGED_IDENTITY_NAME
// - MANAGED_IDENTITY_PRINCIPAL_ID
// - logAnalyticsWorkspaceId


// ✅ After (explicit references):
var env = builder.AddAzureContainerAppEnvironment("env");
var resource = builder.AddAzureInfrastructure("custom", infra =>
{
    // Use explicit references when needed
    var managedEnv = (ContainerAppManagedEnvironment)env.Resource.AddAsExistingResource(infra);
    // Access properties through the bicep resource directly
});
```

**Migration impact**: Replace auto-injected parameters with explicit resource modeling for better resource graph representation and support for multiple Azure compute environments. See [Azure resource customization docs](https://learn.microsoft.com/dotnet/aspire/azure/customize-azure-resources) for more details.

### 🔧 ParameterResource.Value synchronous behavior change

[Section titled “🔧 ParameterResource.Value synchronous behavior change”](#-parameterresourcevalue-synchronous-behavior-change)

The `ParameterResource.Value` property now blocks synchronously when waiting for parameter value resolution, which can potentially cause deadlocks in async contexts. The new `GetValueAsync()` method should be used instead for proper async handling.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Parameters that need resolution
var apiKey = builder.AddParameter("api-key", secret: true);
var connectionString = builder.AddParameter("connection-string", secret: true);


// ❌ Before (can cause deadlocks in async contexts):
builder.AddProject<Projects.Api>("api")
    .WithEnvironment("API_KEY", apiKey.Resource.Value)  // Blocks synchronously - can deadlock
    .WithEnvironment("CONNECTION_STRING", connectionString.Resource.Value);


// ✅ After (recommended for async contexts):
// Use the parameter resources directly with WithEnvironment - they handle async resolution internally
builder.AddProject<Projects.Api>("api")
    .WithEnvironment("API_KEY", apiKey)  // Let Aspire handle async resolution
    .WithEnvironment("CONNECTION_STRING", connectionString);


// Or if you need the actual value in custom code with WithEnvironment callback:
builder.AddProject<Projects.Api>("api")
    .WithEnvironment("API_KEY", async (context, cancellationToken) =>
    {
        return await apiKey.Resource.GetValueAsync(cancellationToken);  // Proper async handling
    })
    .WithEnvironment("CONNECTION_STRING", async (context, cancellationToken) =>
    {
        return await connectionString.Resource.GetValueAsync(cancellationToken);
    });


// For non-async contexts where blocking is acceptable:
var syncValue = apiKey.Resource.Value;  // Still works but may block
```

**Migration impact**: When working with `ParameterResource` values in async contexts, use the new `GetValueAsync()` method instead of the `Value` property to avoid potential deadlocks. For `WithEnvironment()` calls, prefer passing the parameter resource directly rather than accessing `.Value` synchronously.

With every release, we strive to make Aspire better. However, some changes may break existing functionality.

## 🎯 Upgrade today

[Section titled “🎯 Upgrade today”](#-upgrade-today)

Follow the directions outlined in the [Upgrade to Aspire 9.4](#-upgrade-to-aspire-94) section to make the switch to 9.4 and take advantage of all these new features today! As always, we’re listening for your feedback on [GitHub](https://github.com/dotnet/aspire/issues)—and looking out for what you want to see in 9.5 ☺️.

For a complete list of issues addressed in this release, see [Aspire GitHub repository—9.4 milestone](https://github.com/dotnet/aspire/issues?q=is%3Aissue%20state%3Aclosed%20milestone%3A9.4%20).

# What's new in Aspire 9.5

> Learn what's new in Aspire 9.5.

📢 Aspire 9.5 is the next minor version release of Aspire. It supports:

* .NET 8.0 Long Term Support (LTS).
* .NET 9.0 Standard Term Support (STS).
* .NET 10.0 Release Candidate (RC) 1.

If you have feedback, questions, or want to contribute to Aspire, collaborate with us on [GitHub](https://github.com/dotnet/aspire) or join us on [Discord](https://aka.ms/aspire-discord) to chat with the team and other community members.

It’s important to note that Aspire releases are out-of-band from .NET releases. While major versions of Aspire align with major .NET versions, minor versions are released more frequently. For more information on .NET and Aspire version support, see:

* [.NET support policy](https://dotnet.microsoft.com/platform/support/policy): Definitions for LTS and STS.
* [Aspire support policy](https://dotnet.microsoft.com/platform/support/policy/aspire): Important unique product lifecycle details.

## ⬆️ Upgrade to Aspire 9.5

[Section titled “⬆️ Upgrade to Aspire 9.5”](#️-upgrade-to-aspire-95)

Note

Try out `aspire update`! Aspire 9.5 brings a new preview CLI command - [aspire update](#new-aspire-update-command-preview) - that can update your AppHost and its packages for you. Get the latest CLI if you want to try to give us feedback about it on [GitHub](https://github.com/dotnet/aspire/issues)!

Moving between minor releases of Aspire is simple:

1. Get the latest release of the Aspire CLI:

   ```bash
   curl -sSL https://aspire.dev/install.sh | bash
   ```

   ```powershell
   iex "& { $(irm https://aspire.dev/install.ps1) }"
   ```

2. In your AppHost project file (that is, *MyApp.AppHost.csproj*), update the [📦 Aspire.AppHost.Sdk](https://www.nuget.org/packages/Aspire.AppHost.Sdk) package to version `9.5.2`:

   ```xml
   <Sdk Name="Aspire.AppHost.Sdk" Version="9.5.2" />
   ```

   For more information, see [Aspire SDK](%60dotnet/aspire/sdk%60).

3. Check for any NuGet package updates, either using the NuGet Package Manager in Visual Studio or the **Update NuGet Package** command from C# Dev Kit in Visual Studio (VS) Code.

4. Update to the latest [Aspire templates](fundamentals/aspire-sdk-templates/) by running the following .NET command line:

   .NET CLI

   ```bash
   dotnet new install Aspire.ProjectTemplates
   ```

Note

The `dotnet new install` command updates existing Aspire templates to the latest version if they’re already installed.

## 🛠️ CLI and tooling

[Section titled “🛠️ CLI and tooling”](#️-cli-and-tooling)

Aspire 9.5 adds targeted CLI and tooling updates that speed up setup and maintenance.

**Key improvements:**

* Channel-aware package selection in `aspire add` so you can choose stable, daily, or custom builds.
* Preview `aspire update` command that scans your AppHost, validates versions, and applies safe upgrades.
* Experimental single-file AppHost (`apphost.cs`) behind a feature flag.
* SSH Remote port forwarding support in VS Code, matching Dev Container and Codespaces behavior.
* Enhanced `aspire exec` with `--workdir`, clearer help, and early argument validation.
* Performance refinements: package search disk cache, cleaner debug output, clearer status messages, and faster repeat package resolution.

Run `aspire update` to upgrade, enable the single-file AppHost to experiment with a minimal setup, and use `aspire exec` to script tasks with inherited environment context.

### Channel-aware `aspire add` and templating

[Section titled “Channel-aware aspire add and templating”](#channel-aware-aspire-add-and-templating)

You can now pick packages from different channels or versions during `aspire add`. Additionally, friendly name generation is now more flexible for searching packages. When adding packages, you should use versions that are aligned to the `Aspire.Hosting.AppHost` package that you’re using. To update your entire AppHost and its referenced project, you can use the `aspire update` command as described in the following section.

### New `aspire update` command (preview)

[Section titled “New aspire update command (preview)”](#new-aspire-update-command-preview)

The new `aspire update` command helps you keep your Aspire projects current by automatically detecting and updating outdated packages and templates.

Aspire CLI

```bash
# Analyze and update out-of-date Aspire packages & templates
aspire update
```

![Recording of aspire update running on eShop sample.](/_astro/aspire-update.DKyL5FJg_17AEAG.webp)

This command updates your SDK, AppHost packages, and any Aspire client integrations used in the app. It validates package compatibility and asks for confirmation before applying changes. Like `add`, `update` is channel aware, so you can choose to update to stable, daily, or your own configuration of builds.

Caution

🧪 **Preview feature**: The `aspire update` command is in preview and might change before general availability. The `aspire update` command makes changes to project files, central package management, and NuGet.config files. We recommend using version control and inspecting changes after `aspire update` is run to verify the changes.

### File-based AppHost support (preview)

[Section titled “File-based AppHost support (preview)”](#file-based-apphost-support-preview)

Aspire 9.5 introduces infrastructure for .NET 10’s new file-based apps feature, meaning you only need one file — and no project file — for your Aspire Apphost. The new capabilities are currently behind a feature flag that elevates the minimum .NET SDK requirement to prepare for upcoming file-based app execution scenarios.

Aspire CLI

```bash
# Enable file-based AppHost ("apphost.cs") support
aspire config set features.singlefileAppHostEnabled true
# Disable the minimum SDK version check
aspire config set features.minimumSdkCheckEnabled false
```

For more information, see [aspire config set command](cli-reference/aspire-config-set/).

**SDK version requirements:**

* **Feature enabled**: Requires .NET SDK 10.0.100 RC1 or later
* **Override support**: Manual SDK version overrides continue to work with highest precedence

You can use `aspire new` to create a new, blank file-based AppHost. Select the *Single-file AppHost (experimental)* option from the project template list:

```csharp
#:sdk Aspire.AppHost.Sdk@9.5.2


var builder = DistributedApplication.CreateBuilder(args);


builder.Build().Run();
```

Then add some resources, use `aspire add` the same as you would with a project-based Apphost, and `aspire run` to start!

### SSH Remote support for port forwarding in VS Code

[Section titled “SSH Remote support for port forwarding in VS Code”](#ssh-remote-support-for-port-forwarding-in-vs-code)

Aspire 9.5 adds SSH Remote support in VS Code. Ports forward automatically in SSH Remote sessions the same way they do in Dev Containers and GitHub Codespaces.

### `aspire exec` command (preview) enhancements

[Section titled “aspire exec command (preview) enhancements”](#aspire-exec-command-preview-enhancements)

The `aspire exec` command allows you to execute commands within the context of your Aspire application environment, inheriting environment variables, and configuration from your app model resources.

Aspire 9.5 builds on the 9.4 preview and adds several key improvements:

* `--workdir` (`-w`) flag to run commands inside a specific working directory.
* Fail-fast argument validation with clearer error messages.
* Improved help and usage text for better developer experience.

For more information, see [aspire exec command](cli-reference/aspire-exec/) reference.

#### Basic usage examples

[Section titled “Basic usage examples”](#basic-usage-examples)

Aspire CLI

```bash
# Execute database migrations with environment variables from your app model
aspire exec --resource my-api -- dotnet ef database update


# Run commands in a specific working directory
aspire exec --resource worker --workdir /app/tools -- dotnet run


# Wait for resource to start before executing command
aspire exec --start-resource my-worker -- npm run build
```

#### Command syntax

[Section titled “Command syntax”](#command-syntax)

* Use `--resource` to execute immediately when AppHost starts.
* Use `--start-resource` to wait for the resource to be running first.
* Use `--workdir` to specify the working directory for the command.
* Use `--` to separate `aspire` options from the command to execute.

Note

This command is disabled by default. To use it, turn on the feature toggle by running:

Aspire CLI

```bash
aspire config set features.execCommandEnabled true
```

For more information, see [aspire config command](cli-reference/aspire-config/).

### Other tweaks

[Section titled “Other tweaks”](#other-tweaks)

* Relative path included in AppHost status messages.
* Clean CLI debug logging with reduced noise.
* Directory safety check for `aspire new` and consistent template inputs.
* Refactored NuGet prefetch architecture reducing UI lag during `aspire new`.
* Package search disk cache to speed up `aspire new | add | update` commands.
* Context-sensitive completion messages for publish/deploy.

## 📊 Dashboard enhancements

[Section titled “📊 Dashboard enhancements”](#-dashboard-enhancements)

### Generative AI visualizer

[Section titled “Generative AI visualizer”](#generative-ai-visualizer)

Aspire 9.5 introduces the GenAI visualizer, which collates, summarizes, and visualizes LLM-centric calls within your app:

* 🗃️ Explore input and output messages.
* 🚀 JSON/XML payloads highlighted and indented.
* 🖼️ Preview Markdown and multimodal content (for example, images).

If GenAI-specific telemetry is found in an OpenTelemetry (OTEL) span, a sparkle (✨) icon appears next to its name in the Traces view. Clicking the icon launches the visualizer dialog.

The [GenAI telemetry semantic conventions](https://opentelemetry.io/docs/specs/semconv/gen-ai/) are evolving rapidly. The visualizer supports multiple versions of the telemetry, and we update it as the conventions move toward a stable release.

![Recording of the GenAI visualizer.](/_astro/dashboard-geni-visualizer.DhKO2e8H_Z1KGm3W.webp)

### Rich property grid content

[Section titled “Rich property grid content”](#rich-property-grid-content)

In the Aspire 9.5 Dashboard, there are icons and clickable buttons in property grids in resource details, log entry details, and span details.

* **Icons** improve visual clarity. For example, quickly see that a resource isn’t in a healthy state if the icon is red or yellow.
* **Clickable buttons** improve navigation. For example, select a resource name or telemetry ID to navigate to a different page for more information.

![Screenshot of property grid with icons.](/_astro/dashboard-rich-property-grid.DogNBefT_DXSGT.webp)

### Multi-resource console logs

[Section titled “Multi-resource console logs”](#multi-resource-console-logs)

A new “All” option in the console logs view streams logs from every running resource simultaneously.

* **Unified log stream**: See logs from all resources in chronological order.
* **Color-coded prefixes**: Each resource gets a deterministic color for easy identification.

![Screenshot of the console logs page displaying (All) logs.](/_astro/console-logs-all.C9o6WIKO_Z15UY7p.webp)

### Custom resource icons

[Section titled “Custom resource icons”](#custom-resource-icons)

Resources can now specify custom icons and their variant (Filled, which is the default, or Regular) using `WithIconName()` for better visual identification in dashboard views. Any [Fluent UI system icons](https://github.com/microsoft/fluentui-system-icons/blob/main/icons_filled.md) can be used.

```csharp
var postgres = builder.AddPostgres("database")
    .WithIconName("database");


var redis = builder.AddRedis("cache")
    .WithIconName("memory");


var api = builder.AddProject<Projects.Api>("api")
    .WithIconName("webAsset", ApplicationModel.IconVariant.Regular);
```

This iconography helps teams quickly identify different types of resources in complex applications with many services. Custom resource icons now also apply to project and container resources through unified annotation, providing consistent visual identification across all resource types.

### Reverse proxy support

[Section titled “Reverse proxy support”](#reverse-proxy-support)

The dashboard now properly handles reverse proxy scenarios with explicit forwarded header mapping when enabled. This fixes common issues with authentication redirects and URL generation behind proxies like YARP.

```bash
# Enable forwarded headers processing
export ASPIRE_DASHBOARD_FORWARDEDHEADERS_ENABLED=true
```

This is useful for deployment scenarios where the dashboard is accessed through a load balancer or reverse proxy.

### Container runtime notifications

[Section titled “Container runtime notifications”](#container-runtime-notifications)

Notifications now appear when Docker or Podman is installed but unhealthy, with automatic dismissal when the runtime recovers. This provides immediate feedback when your container runtime needs attention, helping diagnose startup issues faster.

![Screenshot of the dashboard showing the container runtime warning.](/_astro/dashboard-container-warning.DD_3Gu66_1SsjEx.webp)

### Trace filtering

[Section titled “Trace filtering”](#trace-filtering)

The Traces page now has a type filter, a quick way to find traces and spans for the selected operation type.

For example, choose Messaging 📬 to see only traces from your app that interact with RabbitMQ, Azure Service Bus, etc.

![Screenshot of the traces page showing the type filter.](/_astro/dashboard-trace-type.BELTqPIQ_Z1IVGiL.webp)

### Trace detail improvements

[Section titled “Trace detail improvements”](#trace-detail-improvements)

The trace detail page includes several quality-of-life improvements:

🏷️ Span names are clearer, with resources split into their own column 🪵 Logs are now shown in the waterfall chart—hover for a tooltip, or select for full details ↕️ New “Expand all” and “Collapse all” buttons

![Screenshot of trace details showing the new resources column and log tooltips.](/_astro/dashboard-trace-detail-logs.DQDXfGES_1BL9F5.webp)

### Other improvements

[Section titled “Other improvements”](#other-improvements)

* Resource action menus now use submenus to prevent overflow on complex apps.
* Projects show their associated launch profiles.
* Error spans use consistent error styling.
* Better default icons for parameters and services.
* Enhanced port parsing.
* Message truncation for long log entries.
* Optional log line wrapping.
* Improved text visualizer dialog.
* Comprehensive dashboard localization improvements including localized Launch Profile names.
* Embedded log entries within trace spans.
* Better span timing calculations.
* Accessibility improvements with better toolbar/menu overflow handling, improved keyboard navigation, semantic headings, and mobile navigation scroll fixes.

## 📦 Integration changes and additions

[Section titled “📦 Integration changes and additions”](#-integration-changes-and-additions)

### OpenAI hosting integration

[Section titled “OpenAI hosting integration”](#openai-hosting-integration)

The new `AddOpenAI` integration provides first-class support for modeling OpenAI endpoints and their associated models within your Aspire application model. For more information, see [Aspire OpenAI integration (Preview)](https://aspire.dev/integrations/ai/openai/).

**Features:**

* **Single OpenAI endpoint** resource with child model resources using `AddModel`.
* **Resource referencing** so other projects automatically receive connection information.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var openai = builder.AddOpenAI("openai");


var chatModel = openai.AddModel("chat", "gpt-4o-mini");


var api = builder.AddProject<Projects.Api>("api")
    .WithReference(chatModel);


builder.Build().Run();
```

**Local development scenario:**

```csharp
// Use with local OpenAI-compatible services
var localOpenAI = builder.AddOpenAI("local-openai")
    .WithApiKey(builder.AddParameter("local-api-key"))
    .WithEndpoint("http://localhost:11434"); // Ollama or similar


var localModel = localOpenAI.AddModel("local-chat", "llama3.2");
```

### GitHub Models and Azure AI Foundry typed catalogs

[Section titled “GitHub Models and Azure AI Foundry typed catalogs”](#github-models-and-azure-ai-foundry-typed-catalogs)

Aspire 9.5 introduces a typed catalog for GitHub and Azure-hosted models, providing IntelliSense support and refactoring safety when working with AI models. This brings type safety and IntelliSense support for the ever-increasing AI model catalog, and takes the guesswork out of version and “format” strings. The catalog is updated daily.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Before: String-based approach (error-prone)
var model = builder.AddGitHubModel("chat", "gpt-4o-mini"); // Typos not caught


// After: Typed catalog approach
var chatModel = builder.AddGitHubModel("chat", GitHubModel.OpenAI.OpenAIGPT4oMini);


// IntelliSense shows all available models grouped by provider
var embeddingModel = builder.AddGitHubModel("embeddings", GitHubModel.OpenAI.OpenAITextEmbedding3Large);
```

For more information, see:

* [Aspire GitHub Models integration (Preview)](https://aspire.dev/integrations/ai/github-models/).
* [Aspire Azure AI Foundry integration (Preview)](https://aspire.dev/integrations/cloud/azure/azure-ai-foundry/).

### Dev Tunnels hosting integration

[Section titled “Dev Tunnels hosting integration”](#dev-tunnels-hosting-integration)

Aspire 9.5 introduces first-class support for Dev Tunnels, enabling seamless integration of secure public tunnels for your applications during development and testing scenarios.

**Features:**

* **Secure public tunnels**: Create public HTTPS endpoints for applications running locally.
* **Automatic tunnel management**: Tunnels are created, configured, and cleaned up automatically.
* **Private and anonymous tunnels**: Support for both authenticated private tunnels and public anonymous access.
* **Development workflow integration**: Perfect for webhook testing, mobile app development, and external service integration.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add a basic Dev Tunnel resource (default: private access)
var tunnel = builder.AddDevTunnel("dev-tunnel");


// Add your web application
var webApp = builder.AddProject<Projects.WebApp>("webapp");


// Connect the tunnel to the web application endpoint
tunnel.WithReference(webApp);


builder.Build().Run();
```

The Dev Tunnels integration automatically handles Azure authentication, tunnel lifecycle management, and provides public or private URLs (depending on configuration) to connected resources, making it easy to expose local development services securely to external consumers. Dev Tunnels also improves support for mobile dev, such as .NET MAUI, making it easy to launch both your backend and mobile app at once without complex dev-time config. For more information, see [Aspire Dev Tunnels integration (Preview)](/integrations/devtools/dev-tunnels/).

### YARP static files support

[Section titled “YARP static files support”](#yarp-static-files-support)

Aspire 9.5 adds comprehensive static file serving capabilities to the YARP integration, enabling you to serve static assets directly from YARP alongside reverse proxy functionality. This is perfect for single-page applications, frontend assets, and hybrid scenarios where you need both static content and API proxying.

**Features:**

* **Direct static file serving**: Serve HTML, CSS, JS, and other static assets from YARP.
* **Flexible source options**: Bind mount local directories or use Docker multi-stage builds.
* **Automatic configuration**: Simple API enables static files with minimal setup.
* **Production ready**: Works in both development and publish scenarios.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Enable static file serving (serves from wwwroot folder)
var yarp = builder.AddYarp("gateway")
    .WithStaticFiles();


builder.Build().Run();
```

**Docker multi-stage build scenario:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Use Dockerfile to build and copy static assets
var frontend = builder.AddYarp("frontend")
    .WithStaticFiles()
    .WithDockerFile("../react-app");


builder.Build().Run();
```

For more information, see [Multi-stage Docker builds](https://aspire.dev/integrations/reverse-proxies/yarp/#multi-stage-docker-builds).

**Hybrid static + API gateway:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var backendApi = builder.AddProject<Projects.Api>("api");
var authService = builder.AddProject<Projects.Auth>("auth");


// YARP serves static files AND proxies API requests
var gateway = builder.AddYarp("app-gateway")
    .WithStaticFiles("./frontend/dist")
    .WithConfiguration(yarp =>
    {
        // API routes
        yarp.AddRoute("/api/{**catch-all}", backendApi)
            .WithTransformPathRemovePrefix("/api");


        // Auth routes
        yarp.AddRoute("/auth/{**catch-all}", authService)
            .WithTransformPathRemovePrefix("/auth");


        // Static files are served for all other routes
    });


builder.Build().Run();
```

This feature enables modern web application architectures where YARP acts as both a reverse proxy for backend services and a static file server for frontend assets, providing a unified entry point for your distributed application.

For more information, see [Aspire YARP integration](https://aspire.dev/integrations/reverse-proxies/yarp/).

### Azure Kusto / Azure Data Explorer

[Section titled “Azure Kusto / Azure Data Explorer”](#azure-kusto--azure-data-explorer)

A new **preview** package `Aspire.Hosting.Azure.Kusto` has been added. Once the package has been added to the AppHost, it’s possible to start a Kusto emulator with just a few lines of code:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var db = builder.AddAzureKustoCluster("kusto")
    .RunAsEmulator()
    .AddReadWriteDatabase("sensorreadings");


builder.Build().Run();
```

### RabbitMQ auto activation

[Section titled “RabbitMQ auto activation”](#rabbitmq-auto-activation)

RabbitMQ client connections now support auto activation to prevent startup deadlocks and improve application reliability. Auto activation is disabled by default in 9.5, but planned to be enabled by default in a future release.

```csharp
var builder = WebApplication.CreateBuilder(args);


// Auto activation is disabled by default for RabbitMQ, enable using DisableAutoActivation=false
builder.AddRabbitMQClient("messaging", o => o.DisableAutoActivation = false);
```

### Redis integration improvements

[Section titled “Redis integration improvements”](#redis-integration-improvements)

#### Auto activation

[Section titled “Auto activation”](#auto-activation)

Redis client connections also now support auto activation, and are also disabled by default, but planned to be enabled by default in a future release.

```csharp
var builder = WebApplication.CreateBuilder(args);


// Auto activation is disabled by default for Redis, enable using DisableAutoActivation=false
var redisClient = builder.AddRedisClient("redis", c => c.DisableAutoActivation = false);
```

#### Client builder pattern

[Section titled “Client builder pattern”](#client-builder-pattern)

Aspire 9.5 introduces a new Redis client builder pattern that provides a fluent, type-safe approach to configuring Redis clients with integrated support for distributed caching, output caching, and Azure authentication.

Basic usage:

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.AddRedisClientBuilder("redis")
  .WithDistributedCache(options =>
  {
    options.InstanceName = "MyApp";
  });
```

To enable Azure authentication, add a reference to the new `Aspire.Microsoft.Azure.StackExchangeRedis` package, and chain a call to `.WithAzureAuthentication()`:

```csharp
builder.AddRedisClientBuilder("redis")
  .WithAzureAuthentication()
  .WithDistributedCache(options =>
  {
    options.InstanceName = "MyApp";
  });
```

### Azure Redis Enterprise support

[Section titled “Azure Redis Enterprise support”](#azure-redis-enterprise-support)

Aspire 9.5 introduces first-class support for [Azure Redis Enterprise](https://learn.microsoft.com/azure/redis/overview), providing a high-performance, fully managed Redis service with enterprise-grade features. Azure Redis Enterprise provides advanced caching capabilities with clustering, high availability, and enterprise security features while maintaining compatibility with the standard Redis APIs.

The new `AddAzureRedisEnterprise` extension method enables Redis Enterprise resource modeling:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add Azure Redis Enterprise resource
var redisEnterprise = builder.AddAzureRedisEnterprise("redis-enterprise");


// Use in your applications
var api = builder.AddProject<Projects.Api>("api")
    .WithReference(redisEnterprise);


builder.Build().Run();
```

**Local development with container emulation:**

```csharp
var redisEnterprise = builder.AddAzureRedisEnterprise("redis-enterprise")
    .RunAsContainer(container => container
        .WithHostPort(6379));
```

**Authentication options:**

Like other Azure integrations, Azure Redis Enterprise uses Microsoft Entra ID authentication by default. This is the recommended authentication strategy since secrets aren’t used. To enable access key authentication, you can use the following:

```csharp
// With access key authentication (default)
var redisEnterprise = builder.AddAzureRedisEnterprise("redis-enterprise")
    .WithAccessKeyAuthentication();


// With Key Vault integration for access keys
var keyVault = builder.AddAzureKeyVault("keyvault");
var redisEnterprise = builder.AddAzureRedisEnterprise("redis-enterprise")
    .WithAccessKeyAuthentication(keyVault);
```

For more information, see [Aspire Azure Managed Redis integration](https://aspire.dev/integrations/cloud/azure/azure-cache-redis/).

### Azure App Configuration emulator (preview)

[Section titled “Azure App Configuration emulator (preview)”](#azure-app-configuration-emulator-preview)

Aspire 9.5 adds preview support for running an Azure App Configuration emulator as part of your distributed application model. The emulator lets you develop locally with full feature parity for key/value configuration data—without provisioning a live Azure resource.

Container image (preview): `mcr.microsoft.com/azure-app-configuration/app-configuration-emulator:1.0.0-preview`

You can use this container **with or without Aspire**—it’s just a normal container image. Aspire adds first-class resource modeling, lifecycle management, environment wiring, and (optionally) persistent storage.

**Features:**

* Local development parity for Azure App Configuration scenarios.
* Built-in browser UI for CRUD (create, read, update, delete) of configuration entries.
* Persistent data via a mounted volume (optional).
* Seamless integration with other Aspire resources via `WithReference`.
* Supports inner-loop testing without network latency or secrets in Azure.

**Add emulator via Aspire:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var appConfig = builder.AddAzureAppConfiguration("config")
  .RunAsEmulator(emulator => emulator
    .WithDataVolume()); // Persists configuration across restarts


var api = builder.AddProject<Projects.Api>("api")
    .WithReference(appConfig);


builder.Build().Run();
```

**Accessing the UI:**

When running under Aspire, the emulator dashboard (configuration explorer) is exposed as a normal endpoint. Open it from the Aspire Dashboard resource details panel to manage key-values interactively.

**Standalone (without Aspire):**

```bash
docker run --rm -p 8080:8080 \
  mcr.microsoft.com/azure-app-configuration/app-configuration-emulator:1.0.0-preview
```

Then browse to `http://localhost:8080` to launch the UI and manage configuration entries.

Caution

The Azure App Configuration emulator is in **preview**. Behavior, image tags, and API surface may change before general availability.

**Typical project configuration usage:**

```csharp
var builder = WebApplication.CreateBuilder(args);


builder.AddAzureAppConfiguration("config");


var app = builder.Build();


app.MapGet("/message", (IConfiguration config) =>
{
    var message = config["Message"];
    return new { Message = message };
});
app.Run();
```

This enables fast local iteration with a real UI and no external dependencies, while keeping deployment parity with Azure-hosted configuration.

### Azure Storage emulator improvements

[Section titled “Azure Storage emulator improvements”](#azure-storage-emulator-improvements)

Aspire now pulls Azurite version 3.35.0 by default, resolving health check issues that previously returned HTTP 400 responses. This improves the reliability of Azure Storage emulator health checks during development.

### MySQL password improvements

[Section titled “MySQL password improvements”](#mysql-password-improvements)

The MySQL integration added support for specifying a password parameter:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Secure password parameter
var password = builder.AddParameter("mysql-password", secret: true);


var mysql = builder.AddMySql("mysql")
    .WithPassword(password);




builder.Build().Run();
```

### Other improvements

[Section titled “Other improvements”](#other-improvements-1)

* New reference properties have been added to Azure PostgreSQL and Redis resources for custom connection string composition and individual component access.
* OpenTelemetry Protocols (OTLP) support now has protocol selection capabilities, allowing you to choose between gRPC and HTTP protobuf transports for telemetry data.

## 🧩 App model enhancements

[Section titled “🧩 App model enhancements”](#-app-model-enhancements)

### Resource lifecycle events

[Section titled “Resource lifecycle events”](#resource-lifecycle-events)

Aspire 9.5 introduces new resource lifecycle event APIs that allow you to register callbacks for when resources stop, providing better control over cleanup and coordination during application shutdown.

The new `OnResourceStopped` extension method allows you to register callbacks that execute when a resource enters the stopped state:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var invoicing = builder.AddPostgres("postgres", "mypostgres").AddDatabase("invoicing");


var api = builder.AddProject<Projects.Api>("api")
    .OnResourceStopped(async (resource, stoppedEvent, cancellationToken) =>
    {
        // Use events to clean up the system to allow rapid
        // inner loop debugging.


        await ResetSystemState();
    })
    .WithReference(invoicing);


builder.Build().Run();
```

**Resource stopped event details:**

The `ResourceStoppedEvent` provides information about the stopping event:

```csharp
// Register detailed stopped event handler
var redis = builder.AddRedis("cache")
    .OnResourceStopped(async (resource, stoppedEvent, cancellationToken) =>
    {
        // Access event details
        Console.WriteLine($"Resource: {resource.Name}");
        Console.WriteLine($"Event timestamp: {stoppedEvent.Snapshot.StopTimeStamp}");
        Console.WriteLine($"Exit code: {stoppedEvent.Snapshot.ExitCode}");


        // Perform async cleanup with cancellation support
        await CleanupCacheConnections(cancellationToken);
    });
```

### Context-based endpoint resolution

[Section titled “Context-based endpoint resolution”](#context-based-endpoint-resolution)

**Breaking change**: Endpoint resolution in `WithEnvironment` callbacks now correctly resolves container hostnames instead of always using “localhost.”

```csharp
var redis = builder.AddRedis("redis");


// Another container getting endpoint info from Redis container
var rabbitmq = builder.AddContainer("myapp", "mycontainerapp")
    .WithEnvironment(context =>
    {
        var endpoint = redis.GetEndpoint("tcp");
        var redisHost = endpoint.Property(EndpointProperty.Host);
        var redisPort = endpoint.Property(EndpointProperty.Port);


        // Previously: redisHost would always resolve to "localhost"
        // Now: redisHost correctly resolves to "redis" (container name)
        context.EnvironmentVariables["REDIS_HOST"] = redisHost;
        context.EnvironmentVariables["REDIS_PORT"] = redisPort;
    })
    .WithReference(redis);
```

**What you need to review:**

* **Container deployments**: Your apps will now receive correct container hostnames.
* **Local development**: Localhost behavior is preserved for noncontainerized scenarios.
* **Connection strings**: Automatic connection strings continue to work as expected.
* **Manual environment**: Review custom `WithEnvironment` calls that assume localhost.

### HTTP health probes for resources

[Section titled “HTTP health probes for resources”](#http-health-probes-for-resources)

Aspire 9.5 introduces comprehensive HTTP health probe support that allows you to configure startup, readiness, and liveness probes for your resources, providing better health monitoring and deployment coordination.

**Features:**

* **Multiple probe types**: Configure startup, readiness, and liveness probes independently.
* **Flexible endpoint targeting**: Probe any HTTP endpoint with custom paths and configurations.
* **Configurable timing**: Control probe intervals, timeouts, and failure thresholds.
* **Kubernetes alignment**: Probe semantics align with Kubernetes health check concepts.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Add readiness probe to ensure service is ready before routing traffic
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpProbe(ProbeType.Readiness, "/health/ready");


// Add liveness probe to detect if service needs restart
var worker = builder.AddProject<Projects.Worker>("worker")
    .WithHttpProbe(ProbeType.Liveness, "/health/live");


builder.Build().Run();
```

**Advanced probe configuration:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Comprehensive probe setup with custom timing
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpProbe(
        type: ProbeType.Startup,
        path: "/health/startup",
        initialDelaySeconds: 30,    // Wait 30s before first probe
        periodSeconds: 10,          // Probe every 10 seconds
        timeoutSeconds: 5,          // 5 second timeout per probe
        failureThreshold: 5,        // Consider failed after 5 failures
        successThreshold: 1         // Consider healthy after 1 success
    );


builder.Build().Run();
```

**Integration with resource dependencies:**

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var database = builder.AddPostgres("postgres");
var cache = builder.AddRedis("redis");


// API with probes that check dependencies
var api = builder.AddProject<Projects.Api>("api")
    .WithHttpProbe(ProbeType.Readiness, "/health/ready") // Checks DB & Redis connectivity
    .WaitFor(database)  // Wait for database startup
    .WaitFor(cache)     // Wait for cache startup
    .WithReference(database)
    .WithReference(cache);


// Frontend waits for API to be ready (not just started)
var frontend = builder.AddProject<Projects.Frontend>("frontend")
    .WaitFor(api)  // Waits for API readiness probe to pass
    .WithReference(api);


builder.Build().Run();
```

This feature enhances deployment reliability by providing fine-grained health monitoring that integrates seamlessly with Aspire’s resource orchestration and dependency management.

### Enhanced resource waiting patterns

[Section titled “Enhanced resource waiting patterns”](#enhanced-resource-waiting-patterns)

New `WaitForStart` method provides granular control over startup ordering, complementing existing `WaitFor` semantics. It also pairs with improved `ExternalService` health honoring which ensures dependents truly wait for external resources to be healthy.

**Understanding wait behaviors:**

* **`WaitFor`**: Waits for dependency to be Running AND pass all health checks.
* **`WaitForStart`**: Waits only for dependency to reach Running (ignores health checks).
* **`WaitForCompletion`**: Waits for dependency to reach a terminal state.

```csharp
var postgres = builder.AddPostgres("postgres");
var redis = builder.AddRedis("redis");


var api = builder.AddProject<Projects.Api>("api")
    .WaitForStart(postgres)  // New: startup only
    .WaitFor(redis)          // Healthy state
    .WithReference(postgres)
    .WithReference(redis);
```

**ExternalService health integration:**

`WaitFor` now honors `ExternalService` health checks. Previously a dependent could start even if the external target failed its readiness probe.

```csharp
var externalApi = builder.AddExternalService("backend-api", "http://api.company.com")
    .WithHttpHealthCheck("/health/ready");


var frontend = builder.AddProject<Projects.Frontend>("frontend")
    .WaitFor(externalApi)    // Now waits for healthy external API
    .WithReference(externalApi);
```

If you need the old (lenient) behavior:

```csharp
// Do not wait for health
var frontend = builder.AddProject<Projects.Frontend>("frontend")
    .WithReference(externalApi);


// Or only wait for startup
var frontend2 = builder.AddProject<Projects.Frontend>("frontend2")
    .WaitForStart(externalApi)
    .WithReference(externalApi);
```

### Enhanced resource lifetime support

[Section titled “Enhanced resource lifetime support”](#enhanced-resource-lifetime-support)

**Breaking change**: Resources like `ParameterResource`, `ConnectionStringResource`, and GitHub Model resources now participate in lifecycle operations and support `WaitFor`.

```csharp
var builder = DistributedApplication.CreateBuilder(args);


var connectionString = builder.AddConnectionString("database");
var apiKey = builder.AddParameter("api-key", secret: true);


var api = builder.AddProject<Projects.Api>("api")
    .WaitFor(connectionString)
    .WaitFor(apiKey)
    .WithEnvironment("DB_CONNECTION", connectionString)
    .WithEnvironment("API_KEY", apiKey);


var github = builder.AddGitHubModels("github");
var model = github.AddModel("gpt4", GitHubModel.OpenAI.Gpt4o);


var aiService = builder.AddProject<Projects.AIService>("ai-service")
    .WaitFor(model)
    .WithReference(model);


builder.Build().Run();
```

These resources no longer implement `IResourceWithoutLifetime`; they surface as Running and can be waited on just like services.

## ☁️ Publishing and deployment

[Section titled “☁️ Publishing and deployment”](#️-publishing-and-deployment)

### Azure Container App Jobs support

[Section titled “Azure Container App Jobs support”](#azure-container-app-jobs-support)

Aspire 9.5 introduces comprehensive support for Azure Container App Jobs, allowing you to deploy both project and container resources as background job workloads that can run on schedules, in response to events, or be triggered manually. For more information, see [Azure Container App Jobs](https://aspire.dev/integrations/cloud/azure/container-app-jobs/)

Container App Jobs complement the existing Container Apps functionality by providing a dedicated way to run finite workloads like data processing, ETL operations, batch jobs, and scheduled maintenance tasks.

#### Publishing resources as Container App Jobs

[Section titled “Publishing resources as Container App Jobs”](#publishing-resources-as-container-app-jobs)

Use the new `PublishAsAzureContainerAppJob` extension method to publish resources as jobs:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Publish a project as a Container App Job
var dataProcessor = builder.AddProject<Projects.DataProcessor>("data-processor")
    .PublishAsAzureContainerAppJob(); // Deploys as a job which must be manually started.


builder.Build().Run();
```

Or use the `PublishAsScheduledAzureContainerAppJob` extension method to publish a resource as a job that runs on a schedule:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Publish a project as a Container App Job
var dataProcessor = builder.AddProject<Projects.DataProcessor>("data-processor")
    .PublishAsScheduledAzureContainerAppJob("0 0 * * *"); // Every day at midnight


builder.Build().Run();
```

#### Job customization and configuration

[Section titled “Job customization and configuration”](#job-customization-and-configuration)

Use the callback on the `PublishAsAzureContainerAppJob(...)` method to customize the job:

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Publish a project as a Container App Job
var dataProcessor = builder.AddProject<Projects.DataProcessor>("data-processor")
    .PublishAsAzureContainerAppJob((infrastructure, job) => {
        job.Configuration.ReplicaTimeout = 3600; // 1 hour
    });


builder.Build().Run();
```

### Built-in Azure deployment with Aspire CLI

[Section titled “Built-in Azure deployment with Aspire CLI”](#built-in-azure-deployment-with-aspire-cli)

Aspire 9.5 delivers the first iteration of a unified Azure provisioning and deployment pipeline through the `aspire deploy` command. The deployment experience features graph-based dependency planning through `ResourceDeploymentGraph` for correct resource provisioning order and maximum parallelism, support for interactive prompting to gather values required for deployment, and enhanced error reporting for identifying issues during deployment. The AppHost integrates Azure provisioning prompts into the standard interaction system for consistent UX, providing deployment-time flexibility with automatic infrastructure provisioning, container image building and registry pushing, and compute resource deployment to Azure Container Apps—all orchestrated through a single command with real-time progress monitoring and comprehensive error reporting.

For more information on deploying to Azure with the Aspire CLI, read [the official documentation](https://aspire.dev/deployment/azure/aca-deployment-aspire-cli/).

### Executable resource configuration APIs

[Section titled “Executable resource configuration APIs”](#executable-resource-configuration-apis)

Enhanced APIs for configuring executable resources with command and working directory specifications.

#### WithCommand and WithWorkingDirectory APIs

[Section titled “WithCommand and WithWorkingDirectory APIs”](#withcommand-and-withworkingdirectory-apis)

New extension methods enable fluent, mutable configuration of executable resources, allowing you to modify command and working directory after initial setup:

```csharp
// Configure executable with custom command and working directory
var processor = builder.AddExecutable("data-processor", "python", "/app/data-processing")
    .WithCommand("main.py --batch-size 100")
    .WithArgs("--config", "production.json");


// Change working directory after initial configuration
var buildTool = builder.AddExecutable("build-tool", "npm", ".")
    .WithCommand("run build:production")
    .WithWorkingDirectory("./frontend");
```

#### Enhanced CommandLineArgsCallbackContext

[Section titled “Enhanced CommandLineArgsCallbackContext”](#enhanced-commandlineargscallbackcontext)

The `CommandLineArgsCallbackContext` now includes resource information for context-aware argument building:

```csharp
var worker = builder.AddExecutable("worker", "dotnet", ".")
    .WithArgs(context =>
    {
        // Access to the resource instance for dynamic configuration
        var resourceName = context.Resource.Name;
        var environment = context.ExecutionContext.IsRunMode ? "Development" : "Production";


        context.Args.Add("--resource-name");
        context.Args.Add(resourceName);
        context.Args.Add("--environment");
        context.Args.Add(environment);
    });
```

These APIs provide fine-grained control over executable resource configuration, enabling complex deployment scenarios and dynamic argument construction based on execution context.

#### InteractionInputCollection enhancements

[Section titled “InteractionInputCollection enhancements”](#interactioninputcollection-enhancements)

Enhanced parameter input handling with the new `InteractionInputCollection` type:

```csharp
// Enhanced interaction service with typed input collection
public async Task<InteractionResult<InteractionInputCollection>> ProcessParametersAsync()
{
    var inputs = new List<InteractionInput>
    {
        new() { Name = "username", Label = "Username", InputType = InputType.Text },
        new() { Name = "password", Label = "Password", InputType = InputType.Password },
        new() { Name = "environment", Label = "Environment", InputType = InputType.Select,
                Options = new[] { ("dev", "Development"), ("prod", "Production") } }
    };


    var result = await interactionService.PromptInputsAsync(
        "Configure Parameters",
        "Enter application configuration:",
        inputs);


    if (result.Success)
    {
        // Access inputs by name with type safety
        var username = result.Value["username"].Value;
        var password = result.Value["password"].Value;
        var environment = result.Value["environment"].Value;
    }


    return result;
}
```

The `InteractionInputCollection` provides indexed access by name and improved type safety for parameter processing workflows.

### Docker Compose Aspire Dashboard forwarding headers

[Section titled “Docker Compose Aspire Dashboard forwarding headers”](#docker-compose-aspire-dashboard-forwarding-headers)

`AddDockerComposeEnvironment(...).WithDashboard()` gained `WithForwardedHeaders()` to enable forwarded `Host` and `Proto` handling for dashboard scenarios behind reverse proxies or compose networks. This mirrors the standalone dashboard forwarded header support and fixes auth redirect edge cases.

```csharp
builder.AddDockerComposeEnvironment("env")
  .WithDashboard(d => d.WithForwardedHeaders());
```

### Container build customization

[Section titled “Container build customization”](#container-build-customization)

`ContainerBuildOptions` support enables customizing the underlying `dotnet publish` invocation when Aspire builds project-sourced container images (for example to change configuration, trimming, or pass other MSBuild properties). Use the new options hook on the project container image configuration to set MSBuild properties instead of maintaining a custom Dockerfile. (Exact API surface is intentionally summarized here to avoid drift; see API docs for `ContainerBuildOptions` in the hosting namespace for usage.)

### Deployment image tag callbacks

[Section titled “Deployment image tag callbacks”](#deployment-image-tag-callbacks)

Aspire 9.5 introduces powerful deployment image tag callback APIs that allow dynamic generation of container image tags at deployment time, supporting both synchronous and asynchronous scenarios.

#### Deployment tag callback features

[Section titled “Deployment tag callback features”](#deployment-tag-callback-features)

* **Dynamic tag generation**: Calculate image tags based on deployment context, git commits, build numbers, or timestamps.
* **Async callback support**: Perform asynchronous operations like API calls or file system access during tag generation.
* **Deployment context access**: Access the deployment environment, resource information, and configuration.
* **Flexible callback types**: Support simple lambdas, context-aware callbacks, and async operations.

#### Basic deployment tag examples

[Section titled “Basic deployment tag examples”](#basic-deployment-tag-examples)

```csharp
var builder = DistributedApplication.CreateBuilder(args);


// Simple static tag callback
var api = builder.AddProject<Projects.Api>("api")
    .WithDeploymentImageTag(() => "v1.2.3-stable");


// Dynamic tag with timestamp
var worker = builder.AddProject<Projects.Worker>("worker")
    .WithDeploymentImageTag(() => $"build-{DateTime.UtcNow:yyyyMMdd-HHmm}");


builder.Build().Run();
```

#### Context-aware deployment tags

[Section titled “Context-aware deployment tags”](#context-aware-deployment-tags)

```csharp
// Access deployment context for dynamic tag generation
var api = builder.AddProject<Projects.Api>("api")
    .WithDeploymentImageTag(context =>
    {
        // Access resource information
        var resourceName = context.Resource.Name;
        var environment = context.Environment;


        return $"{resourceName}-{environment}-{GetBuildNumber()}";
    });


// Git-based tagging
var frontend = builder.AddProject<Projects.Frontend>("frontend")
    .WithDeploymentImageTag(context =>
    {
        var gitCommit = GetGitCommitHash();
        var branch = GetCurrentBranch();
        return $"{branch}-{gitCommit[..8]}";
    });
```

#### Async deployment tag callbacks

[Section titled “Async deployment tag callbacks”](#async-deployment-tag-callbacks)

```csharp
// Async callback for complex tag generation
var database = builder.AddProject<Projects.Database>("database")
    .WithDeploymentImageTag(async context =>
    {
        // Perform async operations during deployment
        var buildInfo = await GetBuildInfoFromApi();
        var version = await ReadVersionFromFile();


        return $"db-{version}-build{buildInfo.Number}";
    });


// API-based version lookup
var api = builder.AddProject<Projects.Api>("api")
    .WithDeploymentImageTag(async context =>
    {
        using var client = new HttpClient();
        var latestTag = await client.GetStringAsync("https://api.company.com/latest-tag");
        return $"api-{latestTag.Trim()}";
    });
```

#### Advanced deployment scenarios

[Section titled “Advanced deployment scenarios”](#advanced-deployment-scenarios)

```csharp
// Environment-specific tagging
var service = builder.AddProject<Projects.Service>("service")
    .WithDeploymentImageTag(context =>
    {
        return context.Environment switch
        {
            "Production" => $"prod-{GetReleaseVersion()}",
            "Staging" => $"staging-{GetBuildNumber()}",
            "Development" => $"dev-{DateTime.UtcNow:yyyyMMdd}",
            _ => "latest"
        };
    });


// Multi-resource coordination
var sharedVersion = await GetSharedVersionAsync();


var frontend = builder.AddProject<Projects.Frontend>("frontend")
    .WithDeploymentImageTag(() => $"frontend-{sharedVersion}");


var backend = builder.AddProject<Projects.Backend>("backend")
    .WithDeploymentImageTag(() => $"backend-{sharedVersion}");
```

## 💔 Breaking changes

[Section titled “💔 Breaking changes”](#-breaking-changes)

### InteractionInput API requires Name property

[Section titled “InteractionInput API requires Name property”](#interactioninput-api-requires-name-property)

**Breaking change**: `InteractionInput` now requires a `Name` property, while `Label` becomes optional ([#10835](https://github.com/dotnet/aspire/pull/10835)).

#### Migration example

[Section titled “Migration example”](#migration-example)

```csharp
// Before (9.4 and earlier)
var input = new InteractionInput
{
    Label = "Database Password",
    InputType = InputType.SecretText,
    Required = true
};


// After (9.5+)
var input = new InteractionInput
{
    Name = "database_password", // Required field identifier
    Label = "Database Password", // Optional (defaults to Name)
    InputType = InputType.SecretText,
    Required = true
};
```

This change enables better form serialization and integration with interactive parameter processing.

### Notification terminology renamed from MessageBar

[Section titled “Notification terminology renamed from MessageBar”](#notification-terminology-renamed-from-messagebar)

**Breaking change**: Notification terminology has been updated, with MessageBar renamed to use new notification terminology ([#10449](https://github.com/dotnet/aspire/pull/10449)).

This change affects APIs and terminology used in the notification system, requiring updates to code that references the old MessageBar naming conventions.

# Upgrade Aspire

> Learn how to upgrade your Aspire projects to the latest version.

Upgrading Aspire involves updating the **Aspire CLI** itself, the **Aspire SDK**, and all related **packages** in your solution. The `aspire update` command handles most of this for you, but you may also need to review breaking changes and update tooling extensions.

Note

If you’re new to Aspire, there’s no reason to upgrade anything. See [prerequisites](/get-started/prerequisites/) and [install Aspire CLI](/get-started/install-cli/) to get started.

## Upgrade with the Aspire CLI

[Section titled “Upgrade with the Aspire CLI”](#upgrade-with-the-aspire-cli)

1. **Update the Aspire CLI** to the latest version:

   Update the Aspire CLI

   ```bash
   aspire update --self
   ```

2. **Update your Aspire solution** by running:

   Update your Aspire solution

   ```bash
   aspire update
   ```

   This command automatically:

   * Updates the [`Aspire.AppHost.Sdk` version](/get-started/aspire-sdk/)
   * Updates all Aspire NuGet packages to the latest version
   * Supports both regular projects and Central Package Management (CPM)

For more information, see [`aspire update` command reference](/reference/cli/commands/aspire-update/).

## Update the VS Code extension (optional)

[Section titled “Update the VS Code extension (optional)”](#update-the-vs-code-extension-optional)

If you have the Aspire extension installed, you can update it to get the latest tooling support:

1. Open VS Code
2. Go to **Extensions** ( Command + Shift + X `CmdShiftX` Control + Shift + X `CtrlShiftX` Control + Shift + X `CtrlShiftX` )
3. Search for **Aspire**
4. Click **Update** if an update is available

For more information, see [Aspire extension for VS Code](/get-started/aspire-vscode-extension/).

## Remove the legacy workload (Aspire 8 only)

[Section titled “Remove the legacy workload (Aspire 8 only)”](#remove-the-legacy-workload-aspire-8-only)

Still rocking the Aspire workload? No judgment here—we’ve all been there. 🕰️ Time to let it go and join us in the future!

Tip

This step is only needed if you’re upgrading from Aspire 8. If you’re already on Aspire 9 or later, you’re good.

Please remove the **aspire workload** with the following command:

```bash
dotnet workload uninstall aspire
```

## Verify the upgrade

[Section titled “Verify the upgrade”](#verify-the-upgrade)

After upgrading, run your application to ensure everything works as expected:

Run the Aspire application

```bash
aspire run
```

## Need help?

[Section titled “Need help?”](#need-help)

* 🆘 Stuck? [Join the Discord community](https://discord.com/invite/raNPcaaSj8) for real-time support
* 🐛 Found a bug? [File a GitHub issue](https://github.com/dotnet/aspire/issues/new/choose)